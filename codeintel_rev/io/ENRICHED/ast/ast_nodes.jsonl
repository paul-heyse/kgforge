{
  "path": "__init__.py",
  "module": "",
  "qualname": null,
  "name": null,
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "CodeIntel MCP package exposing server, indexing, and retrieval APIs.",
  "is_public": true
}
{
  "path": "_lazy_imports.py",
  "module": "_lazy_imports",
  "qualname": "_lazy_imports",
  "name": "_lazy_imports",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Helpers for lazily importing heavy optional dependencies.",
  "is_public": true
}
{
  "path": "_lazy_imports.py",
  "module": "_lazy_imports",
  "qualname": "LazyModule",
  "name": "LazyModule",
  "node_type": "ClassDef",
  "lineno": 11,
  "col": 0,
  "end_lineno": 42,
  "end_col": 43,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Proxy object that imports a module only when accessed.",
  "is_public": true
}
{
  "path": "_lazy_imports.py",
  "module": "_lazy_imports",
  "qualname": "LazyModule.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 16,
  "col": 4,
  "end_lineno": 19,
  "end_col": 46,
  "parent_qualname": "LazyModule",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "_lazy_imports.py",
  "module": "_lazy_imports",
  "qualname": "LazyModule.module",
  "name": "module",
  "node_type": "FunctionDef",
  "lineno": 21,
  "col": 4,
  "end_lineno": 32,
  "end_col": 27,
  "parent_qualname": "LazyModule",
  "decorators": [],
  "bases": [],
  "docstring": "Return the concrete module, importing it on first access.\n\nReturns\n-------\nModuleType\n    Imported module referenced by this proxy.",
  "is_public": true
}
{
  "path": "_lazy_imports.py",
  "module": "_lazy_imports",
  "qualname": "LazyModule.__getattr__",
  "name": "__getattr__",
  "node_type": "FunctionDef",
  "lineno": 34,
  "col": 4,
  "end_lineno": 35,
  "end_col": 43,
  "parent_qualname": "LazyModule",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "_lazy_imports.py",
  "module": "_lazy_imports",
  "qualname": "LazyModule.__setattr__",
  "name": "__setattr__",
  "node_type": "FunctionDef",
  "lineno": 37,
  "col": 4,
  "end_lineno": 42,
  "end_col": 43,
  "parent_qualname": "LazyModule",
  "decorators": [],
  "bases": [],
  "docstring": "Allow monkeypatching proxied modules in tests.",
  "is_public": false
}
{
  "path": "app/__init__.py",
  "module": "app",
  "qualname": "app",
  "name": "app",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "FastAPI application wiring for the CodeIntel MCP server.",
  "is_public": true
}
{
  "path": "app/capabilities.py",
  "module": "app.capabilities",
  "qualname": "app.capabilities",
  "name": "app.capabilities",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Capability snapshot helpers for conditional tool registration and /capz.",
  "is_public": true
}
{
  "path": "app/capabilities.py",
  "module": "app.capabilities",
  "qualname": "_build_capability_gauge",
  "name": "_build_capability_gauge",
  "node_type": "FunctionDef",
  "lineno": 28,
  "col": 0,
  "end_lineno": 30,
  "end_col": 48,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "app/capabilities.py",
  "module": "app.capabilities",
  "qualname": "_import_optional",
  "name": "_import_optional",
  "node_type": "FunctionDef",
  "lineno": 90,
  "col": 0,
  "end_lineno": 122,
  "end_col": 19,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return imported module when available, otherwise ``None``.\n\nParameters\n----------\nmodule_name : str\n    Name of the module to import (e.g., \"faiss\", \"duckdb\").\n\nReturns\n-------\nModuleType | None\n    Imported module instance or ``None`` when unavailable (module not found\n    or import error occurred). Import errors are logged at debug level.\n\nNotes\n-----\nThis helper safely imports optional dependencies without raising exceptions.\nUsed for capability detection to determine which features are available\nat runtime. Time complexity: O(1) for cached imports, O(module_load_time)\nfor first-time imports.",
  "is_public": false
}
{
  "path": "app/capabilities.py",
  "module": "app.capabilities",
  "qualname": "_probe_faiss_gpu",
  "name": "_probe_faiss_gpu",
  "node_type": "FunctionDef",
  "lineno": 125,
  "col": 0,
  "end_lineno": 159,
  "end_col": 34,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return FAISS GPU availability and optional reason for failure.\n\nParameters\n----------\nmodule : ModuleType | None\n    FAISS module instance. If None, returns (False, \"faiss-missing\").\n\nReturns\n-------\ntuple[bool, str | None]\n    Availability flag and optional reason string. Returns (True, None) if GPU\n    is available, (False, reason) otherwise. Reason codes include:\n    \"faiss-missing\", \"gpu-symbols-missing\", \"no-gpu-visible\", \"gpu-probe-error:<class>\".\n\nNotes\n-----\nThis helper probes FAISS GPU support by checking for required GPU symbols\n(StandardGpuResources, GpuClonerOptions, index_cpu_to_gpu) and attempting\nto query GPU count. Handles various failure modes gracefully without raising.",
  "is_public": false
}
{
  "path": "app/capabilities.py",
  "module": "app.capabilities",
  "qualname": "_path_exists",
  "name": "_path_exists",
  "node_type": "FunctionDef",
  "lineno": 162,
  "col": 0,
  "end_lineno": 181,
  "end_col": 39,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return True when ``path`` is populated and exists on the filesystem.\n\nParameters\n----------\npath : Path | None\n    Filesystem path to check. If None, returns False.\n\nReturns\n-------\nbool\n    ``True`` when the path exists, otherwise ``False``. Returns False if\n    path is None or if the path does not exist on the filesystem.\n\nNotes\n-----\nThis helper safely checks path existence without raising exceptions.\nUsed for capability detection to verify index files and other resources.",
  "is_public": false
}
{
  "path": "app/capabilities.py",
  "module": "app.capabilities",
  "qualname": "_record_metrics",
  "name": "_record_metrics",
  "node_type": "FunctionDef",
  "lineno": 184,
  "col": 0,
  "end_lineno": 187,
  "end_col": 51,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Update Prometheus gauges with the latest capability snapshot.",
  "is_public": false
}
{
  "path": "app/capabilities.py",
  "module": "app.capabilities",
  "qualname": "Capabilities",
  "name": "Capabilities",
  "node_type": "ClassDef",
  "lineno": 191,
  "col": 0,
  "end_lineno": 381,
  "end_col": 23,
  "parent_qualname": null,
  "decorators": [
    "dataclass(frozen=True, slots=True)"
  ],
  "bases": [],
  "docstring": "Capability snapshot used for MCP tool gating and the /capz endpoint.",
  "is_public": true
}
{
  "path": "app/capabilities.py",
  "module": "app.capabilities",
  "qualname": "Capabilities.has_semantic",
  "name": "has_semantic",
  "node_type": "FunctionDef",
  "lineno": 213,
  "col": 4,
  "end_lineno": 221,
  "end_col": 68,
  "parent_qualname": "Capabilities",
  "decorators": [
    "property"
  ],
  "bases": [],
  "docstring": "Return ``True`` when semantic MCP tools can be registered safely.\n\nReturns\n-------\nbool\n    Semantic capability flag.",
  "is_public": true
}
{
  "path": "app/capabilities.py",
  "module": "app.capabilities",
  "qualname": "Capabilities.has_symbols",
  "name": "has_symbols",
  "node_type": "FunctionDef",
  "lineno": 224,
  "col": 4,
  "end_lineno": 232,
  "end_col": 46,
  "parent_qualname": "Capabilities",
  "decorators": [
    "property"
  ],
  "bases": [],
  "docstring": "Return ``True`` when symbol MCP tools can be registered safely.\n\nReturns\n-------\nbool\n    Symbol capability flag.",
  "is_public": true
}
{
  "path": "app/capabilities.py",
  "module": "app.capabilities",
  "qualname": "Capabilities.has_reranker",
  "name": "has_reranker",
  "node_type": "FunctionDef",
  "lineno": 235,
  "col": 4,
  "end_lineno": 237,
  "end_col": 63,
  "parent_qualname": "Capabilities",
  "decorators": [
    "property"
  ],
  "bases": [],
  "docstring": "Return ``True`` when XTR reranking is available.",
  "is_public": true
}
{
  "path": "app/capabilities.py",
  "module": "app.capabilities",
  "qualname": "Capabilities.model_dump",
  "name": "model_dump",
  "node_type": "FunctionDef",
  "lineno": 239,
  "col": 4,
  "end_lineno": 277,
  "end_col": 22,
  "parent_qualname": "Capabilities",
  "decorators": [],
  "bases": [],
  "docstring": "Return a JSON-serializable payload suitable for `/capz` responses.\n\nReturns\n-------\ndict[str, object]\n    Structured capability payload.",
  "is_public": true
}
{
  "path": "app/capabilities.py",
  "module": "app.capabilities",
  "qualname": "Capabilities.stamp",
  "name": "stamp",
  "node_type": "FunctionDef",
  "lineno": 279,
  "col": 4,
  "end_lineno": 302,
  "end_col": 66,
  "parent_qualname": "Capabilities",
  "decorators": [],
  "bases": [],
  "docstring": "Return a stable hash representing the current capability snapshot.\n\nParameters\n----------\npayload : dict[str, object] | None, optional\n    Capability payload to hash. If None, uses `self.model_dump()`.\n\nReturns\n-------\nstr\n    Hex-encoded SHA-256 digest of the capability payload. The hash is\n    deterministic and stable for identical capability configurations.\n\nNotes\n-----\nThis method computes a stable hash of the capability snapshot for\nversioning and change detection. The payload is JSON-serialized with\nsorted keys to ensure deterministic hashing. Time complexity: O(n) where\nn is the size of the serialized payload.",
  "is_public": true
}
{
  "path": "app/capabilities.py",
  "module": "app.capabilities",
  "qualname": "Capabilities.from_context",
  "name": "from_context",
  "node_type": "FunctionDef",
  "lineno": 305,
  "col": 4,
  "end_lineno": 381,
  "end_col": 23,
  "parent_qualname": "Capabilities",
  "decorators": [
    "classmethod"
  ],
  "bases": [],
  "docstring": "Build a capability snapshot from the provided application context.\n\nParameters\n----------\ncontext : ApplicationContext\n    Application context containing paths, clients, and managers used\n    to detect available capabilities.\n\nReturns\n-------\nCapabilities\n    Snapshot computed from the context, including detected features\n    (FAISS index, DuckDB, SCIP index, vLLM client, GPU support, etc.)\n    and optional hints for missing capabilities.\n\nNotes\n-----\nThis class method probes the application context to determine which\nfeatures are available. It checks for index files, optional module\nimports, GPU availability, and index version information. The resulting\nsnapshot is used for MCP tool gating and the /capz endpoint. Time\ncomplexity: O(1) for most checks, O(module_load_time) for optional imports.",
  "is_public": true
}
{
  "path": "app/config_context.py",
  "module": "app.config_context",
  "qualname": "app.config_context",
  "name": "app.config_context",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Application-level configuration context manager.\n\nThis module provides centralized configuration lifecycle management for the\nCodeIntel MCP application. Instead of loading settings repeatedly from environment\nvariables on each request, configuration is loaded exactly once during FastAPI\napplication startup and shared across all request handlers via explicit dependency\ninjection.\n\nKey Components\n--------------\nResolvedPaths : dataclass\n    Canonicalized absolute filesystem paths for all application resources.\nApplicationContext : dataclass\n    Application-wide context holding configuration and long-lived clients.\nresolve_application_paths : function\n    Validates and resolves all configured paths relative to repository root.\n\nDesign Principles\n-----------------\n- **Load Once**: Configuration parsed from environment exactly once at startup\n- **Explicit Injection**: Context passed as parameter (no global state)\n- **Fail-Fast**: Invalid configuration prevents application startup\n- **Immutable**: Settings frozen after creation (thread-safe)\n- **RFC 9457**: All errors use Problem Details format\n\nExample Usage\n-------------\nDuring FastAPI application startup:\n\n>>> # In lifespan() function\n>>> context = ApplicationContext.create()\n>>> app.state.context = context\n\nIn request handlers:\n\n>>> # In MCP tool wrapper\n>>> context = request.app.state.context\n>>> files_adapter.list_paths(context, path=\"src\")\n\nSee Also\n--------\ncodeintel_rev.app.readiness : Readiness probe system for health checks\ncodeintel_rev.config.settings : Settings dataclasses and environment loading",
  "is_public": true
}
{
  "path": "app/config_context.py",
  "module": "app.config_context",
  "qualname": "_RetrievalMetrics",
  "name": "_RetrievalMetrics",
  "node_type": "ClassDef",
  "lineno": 101,
  "col": 0,
  "end_lineno": 133,
  "end_col": 11,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "Protocol"
  ],
  "docstring": "Protocol defining the interface for retrieval metrics collection.\n\nThis protocol describes the methods that retrieval metrics implementations\nmust provide for tracking index version information. Used for type checking\nand dependency injection in application context initialization.",
  "is_public": false
}
{
  "path": "app/config_context.py",
  "module": "app.config_context",
  "qualname": "_RetrievalMetrics.set_index_version",
  "name": "set_index_version",
  "node_type": "FunctionDef",
  "lineno": 109,
  "col": 4,
  "end_lineno": 133,
  "end_col": 11,
  "parent_qualname": "_RetrievalMetrics",
  "decorators": [],
  "bases": [],
  "docstring": "Set the active version for a named index.\n\nThis method records the active version of an index (FAISS, DuckDB, etc.)\nfor metrics and observability purposes. The version information is used\nto track index lifecycle changes and correlate metrics with specific\nindex versions.\n\nParameters\n----------\nname : str\n    Name of the index (e.g., \"faiss\", \"duckdb\", \"splade\"). Used to\n    identify which index the version applies to.\nversion : str | None\n    Version identifier for the index (e.g., \"v1.2.3\", \"2024-01-15\").\n    If None, indicates that the index version is unknown or not available.\n\nNotes\n-----\nThis method is called during application context initialization when\nindexes are loaded. The version information is stored in metrics for\nlater querying and analysis. Time complexity: O(1) for setting the\nversion. The method performs no I/O operations and should be thread-safe.",
  "is_public": true
}
{
  "path": "app/config_context.py",
  "module": "app.config_context",
  "qualname": "_infer_index_root",
  "name": "_infer_index_root",
  "node_type": "FunctionDef",
  "lineno": 141,
  "col": 0,
  "end_lineno": 168,
  "end_col": 23,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return the directory that stores versioned index assets.\n\nParameters\n----------\npaths : ResolvedPaths\n    Resolved application paths containing FAISS index location.\n\nReturns\n-------\nPath\n    Directory containing the lifecycle manifest and versions. If\n    `CODEINTEL_INDEXES_DIR` environment variable is set, uses that path.\n    Otherwise infers from `paths.faiss_index` parent directory structure.\n\nNotes\n-----\nThis helper determines the index root directory for versioned index lifecycle\nmanagement. The root contains subdirectories for each version and a manifest\ntracking published/active versions.",
  "is_public": false
}
{
  "path": "app/config_context.py",
  "module": "app.config_context",
  "qualname": "_build_factory_adjuster",
  "name": "_build_factory_adjuster",
  "node_type": "FunctionDef",
  "lineno": 171,
  "col": 0,
  "end_lineno": 201,
  "end_col": 36,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return a DefaultFactoryAdjuster derived from settings.\n\nParameters\n----------\nsettings : Settings\n    Application settings containing index configuration defaults.\n\nReturns\n-------\nFactoryAdjuster\n    Adjuster informed by ``settings.index`` defaults. If settings are invalid\n    or missing required attributes, returns `NoopFactoryAdjuster()` as fallback.\n\nNotes\n-----\nThis helper extracts FAISS and hybrid search tuning parameters from settings\nand constructs a factory adjuster that applies these defaults when creating\nruntime cells. Defensively handles missing or malformed settings by falling\nback to a no-op adjuster.",
  "is_public": false
}
{
  "path": "app/config_context.py",
  "module": "app.config_context",
  "qualname": "_build_faiss_manager",
  "name": "_build_faiss_manager",
  "node_type": "FunctionDef",
  "lineno": 204,
  "col": 0,
  "end_lineno": 244,
  "end_col": 18,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Construct and log the FAISS manager for the main index.\n\nParameters\n----------\nsettings : Settings\n    Application settings containing index configuration.\npaths : ResolvedPaths\n    Resolved filesystem paths including FAISS index path.\n\nReturns\n-------\nmanager : FAISSManager\n    Configured FAISS manager instance.\n\nRaises\n------\nConfigurationError\n    If IndexConfig.nlist is None during context creation.",
  "is_public": false
}
{
  "path": "app/config_context.py",
  "module": "app.config_context",
  "qualname": "_build_scope_store",
  "name": "_build_scope_store",
  "node_type": "FunctionDef",
  "lineno": 247,
  "col": 0,
  "end_lineno": 270,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return the session scope store backed by redis.asyncio.\n\nParameters\n----------\nsettings : Settings\n    Application settings containing Redis configuration.\n\nReturns\n-------\nstore : ScopeStore\n    Configured scope store instance.",
  "is_public": false
}
{
  "path": "app/config_context.py",
  "module": "app.config_context",
  "qualname": "_build_git_clients",
  "name": "_build_git_clients",
  "node_type": "FunctionDef",
  "lineno": 273,
  "col": 0,
  "end_lineno": 292,
  "end_col": 39,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Initialize Git clients for blame and history operations.\n\nParameters\n----------\npaths : ResolvedPaths\n    Resolved filesystem paths including repository root.\n\nReturns\n-------\nclients : tuple[GitClient, AsyncGitClient]\n    Pair of synchronous and asynchronous Git clients.",
  "is_public": false
}
{
  "path": "app/config_context.py",
  "module": "app.config_context",
  "qualname": "_assign_frozen",
  "name": "_assign_frozen",
  "node_type": "FunctionDef",
  "lineno": 298,
  "col": 0,
  "end_lineno": 300,
  "end_col": 42,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Assign attribute on a frozen dataclass instance.",
  "is_public": false
}
{
  "path": "app/config_context.py",
  "module": "app.config_context",
  "qualname": "_faiss_module",
  "name": "_faiss_module",
  "node_type": "FunctionDef",
  "lineno": 303,
  "col": 0,
  "end_lineno": 316,
  "end_col": 17,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return the cached FAISS manager module.\n\nReturns\n-------\nModuleType\n    Imported FAISS manager module.",
  "is_public": false
}
{
  "path": "app/config_context.py",
  "module": "app.config_context",
  "qualname": "_import_faiss_manager_cls",
  "name": "_import_faiss_manager_cls",
  "node_type": "FunctionDef",
  "lineno": 319,
  "col": 0,
  "end_lineno": 328,
  "end_col": 58,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Import ``FAISSManager`` lazily to keep module import costs low.\n\nReturns\n-------\ntype[FAISSManager]\n    Resolved manager class.",
  "is_public": false
}
{
  "path": "app/config_context.py",
  "module": "app.config_context",
  "qualname": "_import_faiss_runtime_opts_cls",
  "name": "_import_faiss_runtime_opts_cls",
  "node_type": "FunctionDef",
  "lineno": 331,
  "col": 0,
  "end_lineno": 340,
  "end_col": 37,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return the FAISS runtime options dataclass.\n\nReturns\n-------\ntype\n    Runtime options dataclass exported by ``codeintel_rev.io.faiss_manager``.",
  "is_public": false
}
{
  "path": "app/config_context.py",
  "module": "app.config_context",
  "qualname": "_faiss_runtime_options_from_index",
  "name": "_faiss_runtime_options_from_index",
  "node_type": "FunctionDef",
  "lineno": 343,
  "col": 0,
  "end_lineno": 381,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Materialize FAISS runtime options from the structured index config.\n\nParameters\n----------\nindex_cfg : IndexConfig\n    Structured index configuration containing FAISS parameters (family, PQ\n    settings, HNSW parameters, GPU options, etc.).\n\nReturns\n-------\nFAISSRuntimeOptions\n    Instance of ``FAISSRuntimeOptions`` matching ``index_cfg`` parameters.\n    The returned object is used to configure FAISS manager runtime behavior.\n\nNotes\n-----\nThis helper converts structured `IndexConfig` (from settings or index manifest)\ninto FAISS-specific runtime options. It dynamically imports the FAISS runtime\noptions class and instantiates it with values from the config.",
  "is_public": false
}
{
  "path": "app/config_context.py",
  "module": "app.config_context",
  "qualname": "_import_hybrid_engine_cls",
  "name": "_import_hybrid_engine_cls",
  "node_type": "FunctionDef",
  "lineno": 384,
  "col": 0,
  "end_lineno": 398,
  "end_col": 21,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Import ``HybridSearchEngine`` lazily for runtime cell initialization.\n\nReturns\n-------\ntype[HybridSearchEngine]\n    Hybrid search engine class.",
  "is_public": false
}
{
  "path": "app/config_context.py",
  "module": "app.config_context",
  "qualname": "_import_xtr_index_cls",
  "name": "_import_xtr_index_cls",
  "node_type": "FunctionDef",
  "lineno": 401,
  "col": 0,
  "end_lineno": 415,
  "end_col": 20,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Import ``XTRIndex`` lazily to avoid eager heavy dependencies.\n\nReturns\n-------\ntype[XTRIndex]\n    XTR index class.",
  "is_public": false
}
{
  "path": "app/config_context.py",
  "module": "app.config_context",
  "qualname": "_require_dependency",
  "name": "_require_dependency",
  "node_type": "FunctionDef",
  "lineno": 418,
  "col": 0,
  "end_lineno": 474,
  "end_col": 18,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Ensure a heavy dependency is available, raising RuntimeUnavailableError.\n\nExtended Summary\n----------------\nValidates that an optional runtime dependency can be imported before\nconstructing runtime components. This function gates access to heavy\ndependencies (e.g., FAISS, CUDA libraries) that may not be installed\nin all deployment environments. Used during ApplicationContext\ninitialization to fail-fast when required runtimes are unavailable.\n\nParameters\n----------\nmodule : str\n    Python module name to import (e.g., \"faiss\", \"cupy\").\n    Must be importable via `importlib.import_module()`.\nruntime : str\n    Human-readable runtime identifier for error messages\n    (e.g., \"coderank-faiss\", \"xtr-index\").\npurpose : str\n    Brief description of why this dependency is needed,\n    included in error messages for diagnostics.\n\nRaises\n------\nRuntimeUnavailableError\n    If ``module`` cannot be imported. The error includes the\n    runtime identifier, purpose, and underlying ImportError detail.\n\nNotes\n-----\nUses `gate_import()` from `kgfoundry_common.typing` to safely\nattempt the import. Time O(1); no I/O or state mutations.\nThis is a fail-fast validation helper, not a lazy loader.\n\nExamples\n--------\n>>> # doctest: +SKIP\n>>> # Example requires faiss to be installed\n>>> _require_dependency(\"faiss\", runtime=\"test\", purpose=\"vector search\")\n>>> # If module is not installed:\n>>> _require_dependency(\"nonexistent_module_xyz\", runtime=\"test\", purpose=\"demo\")\nTraceback (most recent call last):\n    ...\nRuntimeUnavailableError: ...test runtime unavailable: demo...",
  "is_public": false
}
{
  "path": "app/config_context.py",
  "module": "app.config_context",
  "qualname": "_ensure_path_exists",
  "name": "_ensure_path_exists",
  "node_type": "FunctionDef",
  "lineno": 477,
  "col": 0,
  "end_lineno": 533,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Validate that a filesystem path exists for a given runtime.\n\nExtended Summary\n----------------\nChecks filesystem existence of a required resource path (index files,\ndata directories, etc.) before constructing runtime components.\nUsed during ApplicationContext initialization to fail-fast when\nconfigured resources are missing. This prevents runtime errors\nduring request handling by catching missing resources at startup.\n\nParameters\n----------\npath : Path\n    Filesystem path to validate. Must be absolute or relative\n    to the repository root. Resolved via `pathlib.Path.resolve()`.\nruntime : str\n    Human-readable runtime identifier for error messages\n    (e.g., \"coderank-faiss\", \"xtr-index\").\ndescription : str\n    Brief description of what the path represents,\n    included in error messages (e.g., \"CodeRank FAISS index\").\n\nRaises\n------\nRuntimeUnavailableError\n    If ``path`` does not exist. The error includes the runtime\n    identifier, description, and the absolute path string.\n\nNotes\n-----\nTime O(1) filesystem stat; no I/O beyond existence check.\nThis is a fail-fast validation helper, not a lazy loader.\nPaths are expected to be pre-resolved by `resolve_application_paths()`.\n\nExamples\n--------\n>>> from pathlib import Path\n>>> import tempfile\n>>> # doctest: +SKIP\n>>> # Example with existing path (requires temp directory)\n>>> with tempfile.TemporaryDirectory() as tmpdir:\n...     _ensure_path_exists(Path(tmpdir), runtime=\"test\", description=\"temp\")\n>>> # Missing path raises error:\n>>> _ensure_path_exists(Path(\"/nonexistent/path/xyz\"), runtime=\"test\", description=\"index\")\nTraceback (most recent call last):\n    ...\nRuntimeUnavailableError: ...index not found...",
  "is_public": false
}
{
  "path": "app/config_context.py",
  "module": "app.config_context",
  "qualname": "ResolvedPaths",
  "name": "ResolvedPaths",
  "node_type": "ClassDef",
  "lineno": 537,
  "col": 0,
  "end_lineno": 593,
  "end_col": 17,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Canonicalized filesystem paths for runtime operations.\n\nAll paths are absolute and resolved relative to repo_root. This eliminates\nambiguity and ensures consistent path handling throughout the application.\nPath resolution is performed once at application startup rather than on\neach request.\n\nAttributes\n----------\nrepo_root : Path\n    Absolute path to repository root directory. This is the base directory\n    for all source code and must exist before application startup.\ndata_dir : Path\n    Absolute path to base data directory containing indexes and databases.\nvectors_dir : Path\n    Absolute path to directory containing Parquet files with vector embeddings.\nfaiss_index : Path\n    Absolute path to FAISS IVF-PQ index file (CPU version).\nfaiss_idmap_path : Path\n    Absolute path to the FAISS ID map Parquet sidecar used for chunk hydration.\nduckdb_path : Path\n    Absolute path to DuckDB catalog database file.\nscip_index : Path\n    Absolute path to SCIP index file (JSON or protobuf format).\ncoderank_vectors_dir : Path\n    Directory storing CodeRank chunk embeddings or shards.\ncoderank_faiss_index : Path\n    Path to the CodeRank FAISS index used for Stage-A retrieval.\nwarp_index_dir : Path\n    Directory containing WARP/XTR index artifacts.\nxtr_dir : Path\n    Directory containing XTR token-level artifacts (memmaps + metadata).\n\nExamples\n--------\nPaths are created during application startup:\n\n>>> settings = load_settings()\n>>> paths = resolve_application_paths(settings)\n>>> paths.repo_root\nPosixPath('/home/user/kgfoundry')\n>>> paths.faiss_index\nPosixPath('/home/user/kgfoundry/data/faiss/code.ivfpq.faiss')",
  "is_public": true
}
{
  "path": "app/config_context.py",
  "module": "app.config_context",
  "qualname": "resolve_application_paths",
  "name": "resolve_application_paths",
  "node_type": "FunctionDef",
  "lineno": 596,
  "col": 0,
  "end_lineno": 708,
  "end_col": 16,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Resolve all configured paths to absolute paths.\n\nConverts relative paths to absolute paths relative to repo_root, validates\nthat repo_root exists and is a directory, and returns a frozen dataclass\ncontaining all resolved paths.\n\nThis function is called once during application startup. Path resolution\nfailures cause ConfigurationError to be raised, which prevents the\napplication from starting.\n\nParameters\n----------\nsettings : Settings\n    Application settings containing path configuration loaded from\n    environment variables.\n\nReturns\n-------\nResolvedPaths\n    Fully resolved absolute paths for all application resources.\n\nRaises\n------\nConfigurationError\n    If repo_root does not exist, is not a directory, or cannot be accessed.\n    Error includes RFC 9457 Problem Details with context fields for\n    debugging (repo_root value, source environment variable).\n\nExamples\n--------\n>>> settings = Settings(\n...     paths=PathsConfig(\n...         repo_root=\"/home/user/kgfoundry\",\n...         data_dir=\"data\",\n...         faiss_index=\"data/faiss/code.ivfpq.faiss\",\n...     ),\n...     # ... other settings\n... )\n>>> paths = resolve_application_paths(settings)\n>>> paths.data_dir.is_absolute()\nTrue\n>>> paths.data_dir.parent == paths.repo_root\nTrue",
  "is_public": true
}
{
  "path": "app/config_context.py",
  "module": "app.config_context",
  "qualname": "resolve_application_paths._resolve",
  "name": "_resolve",
  "node_type": "FunctionDef",
  "lineno": 657,
  "col": 4,
  "end_lineno": 673,
  "end_col": 43,
  "parent_qualname": "resolve_application_paths",
  "decorators": [],
  "bases": [],
  "docstring": "Resolve a path string relative to repo_root.\n\nParameters\n----------\npath_str : str\n    Path string that may be relative or absolute.\n\nReturns\n-------\nPath\n    Absolute resolved path.",
  "is_public": false
}
{
  "path": "app/config_context.py",
  "module": "app.config_context",
  "qualname": "_FaissRuntimeState",
  "name": "_FaissRuntimeState",
  "node_type": "ClassDef",
  "lineno": 714,
  "col": 0,
  "end_lineno": 722,
  "end_col": 34,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Runtime bookkeeping for FAISS initialization.",
  "is_public": false
}
{
  "path": "app/config_context.py",
  "module": "app.config_context",
  "qualname": "_FaissRuntimeState.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 719,
  "col": 4,
  "end_lineno": 722,
  "end_col": 34,
  "parent_qualname": "_FaissRuntimeState",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "app/config_context.py",
  "module": "app.config_context",
  "qualname": "_ContextRuntimeState",
  "name": "_ContextRuntimeState",
  "node_type": "ClassDef",
  "lineno": 726,
  "col": 0,
  "end_lineno": 762,
  "end_col": 9,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Mutable runtime state backing the frozen ApplicationContext.",
  "is_public": false
}
{
  "path": "app/config_context.py",
  "module": "app.config_context",
  "qualname": "_ContextRuntimeState.attach_observer",
  "name": "attach_observer",
  "node_type": "FunctionDef",
  "lineno": 738,
  "col": 4,
  "end_lineno": 742,
  "end_col": 45,
  "parent_qualname": "_ContextRuntimeState",
  "decorators": [],
  "bases": [],
  "docstring": "Attach observer to each runtime cell.",
  "is_public": true
}
{
  "path": "app/config_context.py",
  "module": "app.config_context",
  "qualname": "_ContextRuntimeState.attach_adjuster",
  "name": "attach_adjuster",
  "node_type": "FunctionDef",
  "lineno": 744,
  "col": 4,
  "end_lineno": 748,
  "end_col": 45,
  "parent_qualname": "_ContextRuntimeState",
  "decorators": [],
  "bases": [],
  "docstring": "Attach a factory adjuster to each runtime cell.",
  "is_public": true
}
{
  "path": "app/config_context.py",
  "module": "app.config_context",
  "qualname": "_ContextRuntimeState.iter_cells",
  "name": "iter_cells",
  "node_type": "FunctionDef",
  "lineno": 750,
  "col": 4,
  "end_lineno": 762,
  "end_col": 9,
  "parent_qualname": "_ContextRuntimeState",
  "decorators": [],
  "bases": [],
  "docstring": "Return ordered tuples of runtime cell names and instances.\n\nReturns\n-------\ntuple[tuple[str, RuntimeCell[Any]], ...]\n    Ordered collection of runtime cell name/value pairs.",
  "is_public": true
}
{
  "path": "app/config_context.py",
  "module": "app.config_context",
  "qualname": "ApplicationContext",
  "name": "ApplicationContext",
  "node_type": "ClassDef",
  "lineno": 766,
  "col": 0,
  "end_lineno": 1582,
  "end_col": 47,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Application-wide context holding all configuration and long-lived clients.\n\nThis is the single source of truth for configuration throughout the application.\nIt's initialized once during FastAPI startup (in lifespan() function) and\ninjected into request handlers via app.state.\n\nThe context is NOT a global singleton - it's explicitly passed as a parameter\nto all functions that need it. This makes dependencies explicit and testing\nstraightforward.\n\nAttributes\n----------\nsettings : Settings\n    Immutable application settings loaded from environment variables. Frozen\n    after creation to ensure thread-safe access.\npaths : ResolvedPaths\n    Canonicalized filesystem paths for all resources (repo root, indexes, etc.).\n    All paths are absolute.\nvllm_client : VLLMClient\n    vLLM embedding service client with persistent HTTP connection pool.\n    Shared across all requests for efficiency.\nfaiss_manager : FAISSManager\n    FAISS index manager that handles CPU and GPU indexes. GPU resources are\n    lazily initialized on first search or optionally pre-loaded at startup.\nscope_store : ScopeStore\n    Redis-backed scope store for session-scoped query filters with L1/L2 caching.\nduckdb_manager : DuckDBManager\n    DuckDB manager for managing the DuckDB catalog database.\ngit_client : GitClient\n    Typed Git operations client using GitPython. Provides structured APIs for\n    blame and history operations without subprocess overhead. Lazy-initializes\n    Git repository on first access.\nasync_git_client : AsyncGitClient\n    Async wrapper around git_client for non-blocking Git operations. Runs\n    synchronous GitPython operations in threadpool via asyncio.to_thread.\nruntime_observer : RuntimeCellObserver\n    Observer instance that receives lifecycle callbacks from runtime cells\n    (hybrid engine, FAISS manager, XTR index). Defaults to NullRuntimeCellObserver\n    when not provided. Used for instrumentation, monitoring, and diagnostics.\nfactory_adjuster : FactoryAdjuster\n    Adjuster applied to runtime cell factories to inject tuning parameters\n    (e.g., FAISS nprobe, hybrid RRF weights). Defaults to NoopFactoryAdjuster\n    if not provided. Can be updated at runtime via `apply_factory_adjuster()`.\nindex_manager : IndexLifecycleManager\n    Manager for versioned index lifecycle operations (stage, publish, rollback).\n    Initialized during context setup with index root inferred from paths.\n    Provides APIs for managing index versions and manifests.\n\nExamples\n--------\nCreate context during application startup:\n\n>>> context = ApplicationContext.create()\n>>> context.settings.paths.repo_root\n'/home/user/kgfoundry'\n\nUse context in adapter functions:\n\n>>> def list_paths(context: ApplicationContext, ...) -> dict:\n...     repo_root = context.paths.repo_root\n...     # ... use repo_root for file operations\n\nAccess from FastAPI request handler:\n\n>>> @app.get(\"/api/endpoint\")\n>>> async def handler(request: Request):\n...     context = request.app.state.context\n...     # ... use context\n\nNotes\n-----\nThe context is designed to be immutable after creation (settings and paths\nare frozen dataclasses). The FAISS manager and vLLM client maintain internal\nstate (connection pools, loaded indexes) but their configuration cannot be\nchanged after initialization.\n\nSee Also\n--------\nresolve_application_paths : Creates ResolvedPaths from Settings\nApplicationContext.create : Factory method for creating context",
  "is_public": true
}
{
  "path": "app/config_context.py",
  "module": "app.config_context",
  "qualname": "ApplicationContext.__post_init__",
  "name": "__post_init__",
  "node_type": "FunctionDef",
  "lineno": 867,
  "col": 4,
  "end_lineno": 877,
  "end_col": 44,
  "parent_qualname": "ApplicationContext",
  "decorators": [],
  "bases": [],
  "docstring": "Attach the configured observer to all runtime cells.",
  "is_public": false
}
{
  "path": "app/config_context.py",
  "module": "app.config_context",
  "qualname": "ApplicationContext.create",
  "name": "create",
  "node_type": "FunctionDef",
  "lineno": 880,
  "col": 4,
  "end_lineno": 983,
  "end_col": 9,
  "parent_qualname": "ApplicationContext",
  "decorators": [
    "classmethod"
  ],
  "bases": [],
  "docstring": "Create application context from environment variables.\n\nExtended Summary\n----------------\nThis is the primary way to create an ApplicationContext. It loads settings\nfrom environment variables, resolves and validates all filesystem paths,\ncreates long-lived HTTP and index manager clients, and logs successful\ninitialization with key configuration values. The method is designed to\nbe called exactly once during application startup (typically in the FastAPI\nlifespan() function). Configuration errors cause ConfigurationError to be\nraised by resolve_application_paths(), preventing application startup with\nclear error messages including RFC 9457 Problem Details.\n\nParameters\n----------\nruntime_observer : RuntimeCellObserver | None, optional\n    Observer instance that receives lifecycle callbacks from runtime cells\n    (hybrid engine, FAISS manager, XTR index). Used for instrumentation,\n    monitoring, and diagnostics. If None (default), uses NullRuntimeCellObserver\n    which suppresses all callbacks. Defaults to None.\nfactory_adjuster : FactoryAdjuster | None, optional\n    Optional adjuster applied to runtime factories. When ``None``, a default\n    adjuster derived from ``settings.index`` is used.\n\nReturns\n-------\nApplicationContext\n    Initialized context with all clients and configuration ready. The context\n    is frozen after creation and thread-safe for concurrent access.\n\nExamples\n--------\n>>> # In FastAPI lifespan() function\n>>> @asynccontextmanager\n>>> async def lifespan(app: FastAPI):\n...     context = ApplicationContext.create()\n...     app.state.context = context\n...     yield\n\n>>> # With custom observer for instrumentation\n>>> observer = MyCustomObserver()\n>>> context = ApplicationContext.create(runtime_observer=observer)\n\nNotes\n-----\nTime complexity O(1) for context creation; I/O occurs during path resolution\nand client initialization. The method performs filesystem operations to validate\npaths and may establish network connections for HTTP clients. Thread-safe after\ncreation due to frozen dataclass design. The method is idempotent in the sense\nthat calling it multiple times creates independent contexts, but it should only\nbe called once per application lifecycle.\n\nThis method may propagate ConfigurationError from resolve_application_paths()\nif paths cannot be resolved or validated. The exception includes RFC 9457 Problem\nDetails with context fields for debugging (repo_root value, source environment\nvariable) and causes application startup to fail.\n\nSee Also\n--------\nload_settings : Loads Settings from environment variables\nresolve_application_paths : Validates and resolves paths",
  "is_public": true
}
{
  "path": "app/config_context.py",
  "module": "app.config_context",
  "qualname": "ApplicationContext._iter_runtime_cells",
  "name": "_iter_runtime_cells",
  "node_type": "FunctionDef",
  "lineno": 985,
  "col": 4,
  "end_lineno": 993,
  "end_col": 41,
  "parent_qualname": "ApplicationContext",
  "decorators": [],
  "bases": [],
  "docstring": "Return managed runtime cells for diagnostics and cleanup.\n\nReturns\n-------\ntuple[tuple[str, RuntimeCell[Any]], ...]\n    Tuple of runtime cell name/value pairs.",
  "is_public": false
}
{
  "path": "app/config_context.py",
  "module": "app.config_context",
  "qualname": "ApplicationContext.reload_indices",
  "name": "reload_indices",
  "node_type": "FunctionDef",
  "lineno": 995,
  "col": 4,
  "end_lineno": 1011,
  "end_col": 44,
  "parent_qualname": "ApplicationContext",
  "decorators": [],
  "bases": [],
  "docstring": "Close runtime cells so they reopen against the active index version.",
  "is_public": true
}
{
  "path": "app/config_context.py",
  "module": "app.config_context",
  "qualname": "ApplicationContext._update_index_version_metrics",
  "name": "_update_index_version_metrics",
  "node_type": "FunctionDef",
  "lineno": 1013,
  "col": 4,
  "end_lineno": 1020,
  "end_col": 62,
  "parent_qualname": "ApplicationContext",
  "decorators": [],
  "bases": [],
  "docstring": "Expose the active index version via Prometheus gauges.",
  "is_public": false
}
{
  "path": "app/config_context.py",
  "module": "app.config_context",
  "qualname": "ApplicationContext._autotune_if_requested",
  "name": "_autotune_if_requested",
  "node_type": "FunctionDef",
  "lineno": 1022,
  "col": 4,
  "end_lineno": 1061,
  "end_col": 9,
  "parent_qualname": "ApplicationContext",
  "decorators": [],
  "bases": [],
  "docstring": "Run a quick ParameterSpace sweep when enabled and no profile exists.",
  "is_public": false
}
{
  "path": "app/config_context.py",
  "module": "app.config_context",
  "qualname": "ApplicationContext.apply_factory_adjuster",
  "name": "apply_factory_adjuster",
  "node_type": "FunctionDef",
  "lineno": 1063,
  "col": 4,
  "end_lineno": 1072,
  "end_col": 100,
  "parent_qualname": "ApplicationContext",
  "decorators": [],
  "bases": [],
  "docstring": "Update runtime tuning knobs and reset cells to pick up changes.",
  "is_public": true
}
{
  "path": "app/config_context.py",
  "module": "app.config_context",
  "qualname": "ApplicationContext.get_hybrid_engine",
  "name": "get_hybrid_engine",
  "node_type": "FunctionDef",
  "lineno": 1074,
  "col": 4,
  "end_lineno": 1095,
  "end_col": 21,
  "parent_qualname": "ApplicationContext",
  "decorators": [],
  "bases": [],
  "docstring": "Return the hybrid search engine, instantiating it lazily.\n\nReturns\n-------\nHybridSearchEngine\n    Shared hybrid retrieval engine configured for the current settings.\n\nRaises\n------\nRuntimeError\n    If the engine fails to initialize.",
  "is_public": true
}
{
  "path": "app/config_context.py",
  "module": "app.config_context",
  "qualname": "ApplicationContext.get_hybrid_engine._factory",
  "name": "_factory",
  "node_type": "FunctionDef",
  "lineno": 1088,
  "col": 8,
  "end_lineno": 1089,
  "end_col": 46,
  "parent_qualname": "ApplicationContext.get_hybrid_engine",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "app/config_context.py",
  "module": "app.config_context",
  "qualname": "ApplicationContext.get_offline_recall_evaluator",
  "name": "get_offline_recall_evaluator",
  "node_type": "FunctionDef",
  "lineno": 1097,
  "col": 4,
  "end_lineno": 1126,
  "end_col": 24,
  "parent_qualname": "ApplicationContext",
  "decorators": [],
  "bases": [],
  "docstring": "Return the offline recall evaluator for diagnostic runs.\n\nReturns\n-------\nOfflineRecallEvaluator\n    Evaluator bound to the current FAISS manager and catalog paths.\n\nRaises\n------\nRuntimeError\n    If offline evaluation has been disabled via configuration.",
  "is_public": true
}
{
  "path": "app/config_context.py",
  "module": "app.config_context",
  "qualname": "ApplicationContext.get_coderank_faiss_manager",
  "name": "get_coderank_faiss_manager",
  "node_type": "FunctionDef",
  "lineno": 1128,
  "col": 4,
  "end_lineno": 1172,
  "end_col": 22,
  "parent_qualname": "ApplicationContext",
  "decorators": [],
  "bases": [],
  "docstring": "Return a lazily loaded FAISS manager for CodeRank search.\n\nParameters\n----------\nvec_dim : int\n    Expected embedding dimension for the CodeRank index.\n\nReturns\n-------\nFAISSManager\n    Configured FAISS manager instance pointing to the CodeRank index.\n\nRaises\n------\nValueError\n    If ``vec_dim`` is non-positive or mismatched with the cached index.",
  "is_public": true
}
{
  "path": "app/config_context.py",
  "module": "app.config_context",
  "qualname": "ApplicationContext.get_coderank_faiss_manager._factory",
  "name": "_factory",
  "node_type": "FunctionDef",
  "lineno": 1161,
  "col": 8,
  "end_lineno": 1162,
  "end_col": 70,
  "parent_qualname": "ApplicationContext.get_coderank_faiss_manager",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "app/config_context.py",
  "module": "app.config_context",
  "qualname": "ApplicationContext.get_xtr_index",
  "name": "get_xtr_index",
  "node_type": "FunctionDef",
  "lineno": 1174,
  "col": 4,
  "end_lineno": 1219,
  "end_col": 19,
  "parent_qualname": "ApplicationContext",
  "decorators": [],
  "bases": [],
  "docstring": "Return the lazily initialized XTR token index when enabled.\n\nReturns\n-------\nXTRIndex | None\n    Ready XTR index instance or ``None`` when disabled/unavailable.\n\nRaises\n------\nRuntimeUnavailableError\n    If configuration enables XTR but artifacts or dependencies are missing.",
  "is_public": true
}
{
  "path": "app/config_context.py",
  "module": "app.config_context",
  "qualname": "ApplicationContext.get_xtr_index._factory",
  "name": "_factory",
  "node_type": "FunctionDef",
  "lineno": 1196,
  "col": 8,
  "end_lineno": 1197,
  "end_col": 42,
  "parent_qualname": "ApplicationContext.get_xtr_index",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "app/config_context.py",
  "module": "app.config_context",
  "qualname": "ApplicationContext._build_coderank_faiss_manager",
  "name": "_build_coderank_faiss_manager",
  "node_type": "FunctionDef",
  "lineno": 1221,
  "col": 4,
  "end_lineno": 1297,
  "end_col": 22,
  "parent_qualname": "ApplicationContext",
  "decorators": [],
  "bases": [],
  "docstring": "Construct the CodeRank FAISS manager with dependency gates.\n\nExtended Summary\n----------------\nBuilds a FAISSManager instance for CodeRank vector search by\nvalidating the index path exists, ensuring FAISS is importable,\nand loading the pre-built index from disk. This method gates\naccess to the CodeRank runtime, failing fast if dependencies\nor resources are missing. The manager is configured with\napplication settings (nlist, cuvs preference) and loaded\ninto CPU memory for immediate use.\n\nParameters\n----------\nvec_dim : int\n    Vector dimensionality expected by the CodeRank index.\n    Must match the dimension used when the index was built.\n    Typically 768 or 1536 for transformer-based embeddings.\n\nReturns\n-------\nFAISSManager\n    Ready-to-use FAISS manager configured for the CodeRank index.\n    The index is loaded into CPU memory and ready for search queries.\n    GPU support is enabled if `use_cuvs` is True and CUDA is available.\n\nNotes\n-----\nTime O(1) for validation; index loading time depends on index size.\nThe manager loads the index synchronously; no lazy loading.\nGPU support (cuvs) is determined by application settings and\nruntime availability. This method is called during ApplicationContext\ninitialization, not per-request.\n\nMay propagate `RuntimeUnavailableError` from `_ensure_path_exists()`\nif the index path does not exist, or from `_require_dependency()`\nif the FAISS library cannot be imported.\n\nRaises\n------\nConfigurationError\n    Raised when index configuration is invalid (e.g., ``nlist`` is None).\n    The exception includes context about the missing configuration value.\n\nSee Also\n--------\nApplicationContext._build_xtr_index : Similar pattern for XTR index\ncodeintel_rev.io.faiss_manager.FAISSManager : Manager implementation",
  "is_public": false
}
{
  "path": "app/config_context.py",
  "module": "app.config_context",
  "qualname": "ApplicationContext._build_xtr_index",
  "name": "_build_xtr_index",
  "node_type": "FunctionDef",
  "lineno": 1299,
  "col": 4,
  "end_lineno": 1333,
  "end_col": 20,
  "parent_qualname": "ApplicationContext",
  "decorators": [],
  "bases": [],
  "docstring": "Construct the XTR index runtime with artifact and dependency gates.\n\nReturns\n-------\nXTRIndex\n    Ready XTR index instance.\n\nRaises\n------\nRuntimeUnavailableError\n    If configuration disables XTR or required artifacts/dependencies are missing.",
  "is_public": false
}
{
  "path": "app/config_context.py",
  "module": "app.config_context",
  "qualname": "ApplicationContext._build_hybrid_engine",
  "name": "_build_hybrid_engine",
  "node_type": "FunctionDef",
  "lineno": 1335,
  "col": 4,
  "end_lineno": 1354,
  "end_col": 9,
  "parent_qualname": "ApplicationContext",
  "decorators": [],
  "bases": [],
  "docstring": "Construct the hybrid search engine with dependency gates per channel.\n\nReturns\n-------\nHybridSearchEngine\n    Configured hybrid search engine instance.",
  "is_public": false
}
{
  "path": "app/config_context.py",
  "module": "app.config_context",
  "qualname": "ApplicationContext.ensure_faiss_ready",
  "name": "ensure_faiss_ready",
  "node_type": "FunctionDef",
  "lineno": 1356,
  "col": 4,
  "end_lineno": 1431,
  "end_col": 33,
  "parent_qualname": "ApplicationContext",
  "decorators": [],
  "bases": [],
  "docstring": "Load FAISS index (once) and attempt GPU clone.\n\nThis method is thread-safe and idempotent. On first call, it loads the\nCPU index from disk. On subsequent calls, it returns cached state.\nGPU cloning is attempted once (if not already done during pre-loading).\n\nThe method is typically called from semantic search adapter on first\nsearch request (lazy loading) or optionally during application startup\n(eager loading controlled by FAISS_PRELOAD environment variable).\n\nReturns\n-------\ntuple[bool, list[str], str | None]\n    Three-element tuple:\n    - ready (bool): True if FAISS index is available for searching\n    - limits (list[str]): Warning messages about degraded mode (e.g.,\n      \"GPU unavailable\", \"Index not found\"). Empty list if fully ready.\n    - error (str | None): Error message if index loading failed, None\n      if successful or already loaded.\n\nExamples\n--------\n>>> context = ApplicationContext.create()\n>>> ready, limits, error = context.ensure_faiss_ready()\n>>> if ready:\n...     # Proceed with search\n...     results = context.faiss_manager.search(query_vector, k=20)\n... else:\n...     # Handle error (return error response to client)\n...     print(f\"FAISS unavailable: {error}\")\n\nNotes\n-----\nThe method uses a threading.Lock to ensure only one thread loads the\nindex even under concurrent requests. Subsequent calls skip loading\nand immediately return the cached state.\n\nGPU initialization failures are non-fatal - the method returns ready=True\nwith a warning in the limits list. Semantic search will fall back to\nCPU index automatically.",
  "is_public": true
}
{
  "path": "app/config_context.py",
  "module": "app.config_context",
  "qualname": "ApplicationContext.open_catalog",
  "name": "open_catalog",
  "node_type": "FunctionDef",
  "lineno": 1434,
  "col": 4,
  "end_lineno": 1480,
  "end_col": 27,
  "parent_qualname": "ApplicationContext",
  "decorators": [
    "contextmanager"
  ],
  "bases": [],
  "docstring": "Yield a DuckDB catalog context manager.\n\nOpens a connection to the DuckDB catalog containing chunk metadata,\nyields the catalog instance for querying, and ensures the connection\nis closed even if an exception occurs.\n\nThe catalog provides SQL access to chunk metadata (URIs, line numbers,\npreview text) stored in Parquet files. It's used to hydrate FAISS\nsearch results with full chunk information.\n\nYields\n------\nDuckDBCatalog\n    Catalog instance with active database connection. Supports querying\n    by chunk IDs, URIs, and other metadata fields.\n\nExamples\n--------\n>>> with context.open_catalog() as catalog:\n...     chunks = catalog.query_by_ids([1, 2, 3])\n...     for chunk in chunks:\n...         print(chunk[\"uri\"], chunk[\"preview\"])\n\nNotes\n-----\nThe catalog connection is automatically closed when the context manager\nexits, even if an exception is raised. This ensures no connection leaks.\n\nSee Also\n--------\ncodeintel_rev.io.duckdb_catalog.DuckDBCatalog : Catalog implementation",
  "is_public": true
}
{
  "path": "app/config_context.py",
  "module": "app.config_context",
  "qualname": "ApplicationContext.with_overrides",
  "name": "with_overrides",
  "node_type": "FunctionDef",
  "lineno": 1482,
  "col": 4,
  "end_lineno": 1562,
  "end_col": 9,
  "parent_qualname": "ApplicationContext",
  "decorators": [],
  "bases": [],
  "docstring": "Return a new context with the provided overrides.\n\nExtended Summary\n----------------\nThis method creates a new ApplicationContext instance with selective overrides\nto the current context's dependencies. It is used for testing, dependency injection,\nand creating specialized contexts (e.g., with mocked components or different\nconfiguration). The method preserves all non-overridden dependencies from the\ncurrent context, allowing incremental customization without full reinitialization.\nThis is particularly useful in test fixtures where specific components need to\nbe replaced while keeping the rest of the context intact.\n\nParameters\n----------\nsettings : Settings | None, optional\n    Application settings to override. If None, uses the current context's\n    settings. Defaults to None.\npaths : ResolvedPaths | None, optional\n    Resolved file system paths to override. If None, uses the current context's\n    paths. Defaults to None.\n**components : object\n    Keyword arguments for component overrides. Accepted keys are:\n    ``vllm_client``, ``faiss_manager``, ``scope_store``, ``duckdb_manager``,\n    ``git_client``, ``async_git_client``. Each override replaces the corresponding\n    component in the new context. Unsupported keys raise ValueError.\n\nReturns\n-------\nApplicationContext\n    Fresh context instance sharing the existing dependencies unless\n    overridden via keyword arguments. The new context is independent of the\n    original and can be modified without affecting it.\n\nRaises\n------\nValueError\n    If unsupported override keys are supplied in **components. Only the\n    accepted component names listed in Parameters are allowed.\n\nNotes\n-----\nTime complexity O(1) for context creation. Space complexity O(1) aside from\nthe new context object and any overridden components. The method performs no\nI/O and has no side effects. Thread-safe if all components are thread-safe.\nOverrides are shallow; nested component dependencies are not automatically\nupdated to match overridden components.",
  "is_public": true
}
{
  "path": "app/config_context.py",
  "module": "app.config_context",
  "qualname": "ApplicationContext.with_overrides._component_value",
  "name": "_component_value",
  "node_type": "FunctionDef",
  "lineno": 1549,
  "col": 8,
  "end_lineno": 1550,
  "end_col": 67,
  "parent_qualname": "ApplicationContext.with_overrides",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "app/config_context.py",
  "module": "app.config_context",
  "qualname": "ApplicationContext.close_all_runtimes",
  "name": "close_all_runtimes",
  "node_type": "FunctionDef",
  "lineno": 1564,
  "col": 4,
  "end_lineno": 1582,
  "end_col": 47,
  "parent_qualname": "ApplicationContext",
  "decorators": [],
  "bases": [],
  "docstring": "Best-effort shutdown for mutable runtimes.",
  "is_public": true
}
{
  "path": "app/gpu_warmup.py",
  "module": "app.gpu_warmup",
  "qualname": "app.gpu_warmup",
  "name": "app.gpu_warmup",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "GPU warmup and initialization sequence.\n\nPerforms comprehensive GPU availability checks and warmup operations to ensure\nGPU is reachable and functional before expensive operations begin.",
  "is_public": true
}
{
  "path": "app/gpu_warmup.py",
  "module": "app.gpu_warmup",
  "qualname": "_check_cuda_availability",
  "name": "_check_cuda_availability",
  "node_type": "FunctionDef",
  "lineno": 28,
  "col": 0,
  "end_lineno": 61,
  "end_col": 63,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Check CUDA availability via PyTorch.\n\nReturns\n-------\ntuple[bool, str]\n    (is_available, status_message)",
  "is_public": false
}
{
  "path": "app/gpu_warmup.py",
  "module": "app.gpu_warmup",
  "qualname": "_check_faiss_gpu_support",
  "name": "_check_faiss_gpu_support",
  "node_type": "FunctionDef",
  "lineno": 64,
  "col": 0,
  "end_lineno": 94,
  "end_col": 50,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Check FAISS GPU support.\n\nReturns\n-------\ntuple[bool, str]\n    (is_available, status_message)",
  "is_public": false
}
{
  "path": "app/gpu_warmup.py",
  "module": "app.gpu_warmup",
  "qualname": "_test_torch_gpu_operations",
  "name": "_test_torch_gpu_operations",
  "node_type": "FunctionDef",
  "lineno": 97,
  "col": 0,
  "end_lineno": 120,
  "end_col": 55,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Test basic GPU tensor operations using PyTorch.\n\nReturns\n-------\ntuple[bool, str]\n    (test_passed, status_message)",
  "is_public": false
}
{
  "path": "app/gpu_warmup.py",
  "module": "app.gpu_warmup",
  "qualname": "_test_faiss_gpu_resources",
  "name": "_test_faiss_gpu_resources",
  "node_type": "FunctionDef",
  "lineno": 123,
  "col": 0,
  "end_lineno": 151,
  "end_col": 83,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Test FAISS GPU resource initialization.\n\nReturns\n-------\ntuple[bool, str, int | None]\n    Tuple of (test_passed, status_message, scratch_bytes).",
  "is_public": false
}
{
  "path": "app/gpu_warmup.py",
  "module": "app.gpu_warmup",
  "qualname": "warmup_gpu",
  "name": "warmup_gpu",
  "node_type": "FunctionDef",
  "lineno": 155,
  "col": 0,
  "end_lineno": 254,
  "end_col": 18,
  "parent_qualname": null,
  "decorators": [
    "lru_cache(maxsize=1)"
  ],
  "bases": [],
  "docstring": "Perform GPU warmup sequence to verify GPU availability and functionality.\n\nResults are cached after the first run; call ``warmup_gpu.cache_clear()`` in tests\nto force a re-run.\n\nChecks:\n1. CUDA availability via PyTorch\n2. FAISS GPU support (+ cuVS/CAGRA symbol presence)\n3. Basic GPU tensor operations (torch)\n4. FAISS GPU resource initialization\n\nReturns\n-------\ndict[str, bool | str]\n    Dictionary with warmup results:\n    - ``cuda_available``: True if CUDA is available via PyTorch\n    - ``faiss_gpu_available``: True if FAISS GPU symbols are available\n    - ``faiss_cuvs_available``: True if FAISS exposes cuVS/CAGRA bindings\n    - ``torch_gpu_test``: True if basic torch GPU operations succeed\n    - ``faiss_gpu_test``: True if FAISS GPU resource initialization succeeds\n    - ``overall_status``: \"ready\" if all checks pass, \"degraded\" if some fail,\n      \"unavailable\" if all fail\n    - ``details``: Human-readable status message\n\nExamples\n--------\n>>> result = warmup_gpu()\n>>> if result[\"overall_status\"] == \"ready\":\n...     print(\"GPU is ready for use\")\n... else:\n...     print(f\"GPU status: {result['details']}\")",
  "is_public": true
}
{
  "path": "app/main.py",
  "module": "app.main",
  "qualname": "app.main",
  "name": "app.main",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "FastAPI application with MCP server mount.\n\nProvides health/readiness endpoints, CORS, and streaming support.",
  "is_public": true
}
{
  "path": "app/main.py",
  "module": "app.main",
  "qualname": "_sse_keepalive_interval",
  "name": "_sse_keepalive_interval",
  "node_type": "FunctionDef",
  "lineno": 76,
  "col": 0,
  "end_lineno": 91,
  "end_col": 29,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return the configured SSE keep-alive interval (seconds).\n\nReturns\n-------\nfloat\n    Keep-alive interval in seconds, clamped to a minimum of 5.0 seconds.\n    Defaults to ``_DEFAULT_SSE_KEEPALIVE_SECONDS`` if environment variable\n    is unset or invalid.",
  "is_public": false
}
{
  "path": "app/main.py",
  "module": "app.main",
  "qualname": "_sse_keepalive_budget",
  "name": "_sse_keepalive_budget",
  "node_type": "FunctionDef",
  "lineno": 94,
  "col": 0,
  "end_lineno": 111,
  "end_col": 41,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return optional cap on keep-alive frames for long-lived SSE streams.\n\nReturns\n-------\nint | None\n    Maximum number of keep-alive frames to emit after the initial payload.\n    ``None`` indicates infinite keep-alives (default). Intended for tests to\n    keep the stream finite by setting ``SSE_MAX_KEEPALIVES``.",
  "is_public": false
}
{
  "path": "app/main.py",
  "module": "app.main",
  "qualname": "_client_address",
  "name": "_client_address",
  "node_type": "FunctionDef",
  "lineno": 114,
  "col": 0,
  "end_lineno": 133,
  "end_col": 57,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return a printable representation of the originating client address.\n\nParameters\n----------\nrequest : Request\n    FastAPI request object containing client connection information.\n\nReturns\n-------\nstr\n    Client address string in \"host:port\" format, or \"host\" if port is None,\n    or \"unknown\" if client information is unavailable.",
  "is_public": false
}
{
  "path": "app/main.py",
  "module": "app.main",
  "qualname": "_log_request_summary",
  "name": "_log_request_summary",
  "node_type": "FunctionDef",
  "lineno": 136,
  "col": 0,
  "end_lineno": 149,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Emit a structured log describing a completed HTTP request.",
  "is_public": false
}
{
  "path": "app/main.py",
  "module": "app.main",
  "qualname": "_stream_log_extra",
  "name": "_stream_log_extra",
  "node_type": "FunctionDef",
  "lineno": 152,
  "col": 0,
  "end_lineno": 188,
  "end_col": 19,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return structured logging metadata for streaming lifecycle events.\n\nParameters\n----------\nrequest : Request\n    FastAPI request object containing request state and URL path.\nstream_name : str\n    Name identifier for the stream being logged.\nstage : str\n    Lifecycle stage identifier (e.g., \"open\", \"flush\", \"closed\").\nchunk_bytes : int | None\n    Optional byte count for the chunk being processed. Defaults to None.\n\nReturns\n-------\ndict[str, object]\n    Dictionary containing request_id, path, stream name, stage, and optional\n    chunk_bytes for structured logging.",
  "is_public": false
}
{
  "path": "app/main.py",
  "module": "app.main",
  "qualname": "_preload_faiss_index",
  "name": "_preload_faiss_index",
  "node_type": "FunctionDef",
  "lineno": 191,
  "col": 0,
  "end_lineno": 219,
  "end_col": 19,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Pre-load FAISS index during startup to avoid first-request latency.\n\nParameters\n----------\ncontext : ApplicationContext\n    Application context containing FAISS manager.\n\nReturns\n-------\nbool\n    True if index loaded successfully, False otherwise.",
  "is_public": false
}
{
  "path": "app/main.py",
  "module": "app.main",
  "qualname": "_env_flag",
  "name": "_env_flag",
  "node_type": "FunctionDef",
  "lineno": 222,
  "col": 0,
  "end_lineno": 236,
  "end_col": 62,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return ``True`` when an environment flag is explicitly enabled.\n\nParameters\n----------\nname : str\n    Environment variable name to inspect.\n\nReturns\n-------\nbool\n    ``True`` if the variable is set to a truthy value.",
  "is_public": false
}
{
  "path": "app/main.py",
  "module": "app.main",
  "qualname": "_resolve_proxy_trusted_hops",
  "name": "_resolve_proxy_trusted_hops",
  "node_type": "FunctionDef",
  "lineno": 239,
  "col": 0,
  "end_lineno": 258,
  "end_col": 23,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return ProxyFix trusted hop count with PROXY_TRUSTED_HOPS override.\n\nReturns\n-------\nint\n    Number of upstream proxy hops to trust when applying ProxyFix.",
  "is_public": false
}
{
  "path": "app/main.py",
  "module": "app.main",
  "qualname": "_log_gpu_warmup",
  "name": "_log_gpu_warmup",
  "node_type": "FunctionDef",
  "lineno": 261,
  "col": 0,
  "end_lineno": 279,
  "end_col": 91,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Log the GPU warmup status summary.\n\nParameters\n----------\nstatus : Mapping[str, object]\n    Warmup status payload emitted by :func:`warmup_gpu`.",
  "is_public": false
}
{
  "path": "app/main.py",
  "module": "app.main",
  "qualname": "_preload_faiss_if_configured",
  "name": "_preload_faiss_if_configured",
  "node_type": "AsyncFunctionDef",
  "lineno": 282,
  "col": 0,
  "end_lineno": 289,
  "end_col": 85,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Preload FAISS indexes when configured to do so.",
  "is_public": false
}
{
  "path": "app/main.py",
  "module": "app.main",
  "qualname": "_preload_xtr_if_configured",
  "name": "_preload_xtr_if_configured",
  "node_type": "FunctionDef",
  "lineno": 292,
  "col": 0,
  "end_lineno": 303,
  "end_col": 69,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Preload XTR runtime when toggle is enabled.",
  "is_public": false
}
{
  "path": "app/main.py",
  "module": "app.main",
  "qualname": "_preload_hybrid_if_configured",
  "name": "_preload_hybrid_if_configured",
  "node_type": "FunctionDef",
  "lineno": 306,
  "col": 0,
  "end_lineno": 314,
  "end_col": 81,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Preload HybridSearchEngine when toggle is enabled.",
  "is_public": false
}
{
  "path": "app/main.py",
  "module": "app.main",
  "qualname": "_initialize_context",
  "name": "_initialize_context",
  "node_type": "AsyncFunctionDef",
  "lineno": 317,
  "col": 0,
  "end_lineno": 402,
  "end_col": 29,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Initialize application context, readiness probe, and optional runtimes.\n\nExtended Summary\n----------------\nThis function orchestrates the application startup sequence by creating the\nApplicationContext, performing GPU warmup, initializing the readiness probe,\nand optionally pre-loading FAISS, XTR, and hybrid search runtimes. It stores\nthe context and readiness probe in the FastAPI app.state for access by request\nhandlers. This function is called once during application startup from the\nlifespan() context manager.\n\nParameters\n----------\napp : FastAPI\n    FastAPI application instance. Used to store application context and\n    readiness probe in app.state for access by request handlers.\nruntime_observer : RuntimeCellObserver | None, optional\n    Observer attached to runtime cells for instrumentation. Defaults to a\n    no-op observer when not provided.\n\nReturns\n-------\ntuple[ApplicationContext, ReadinessProbe]\n    Pair containing the initialized context and readiness probe. The context\n    contains all configuration and long-lived clients. The readiness probe\n    monitors the health of dependent services and resources.\n\nRaises\n------\nTypeError\n    Raised when `ApplicationContext.create` does not accept the\n    ``runtime_observer`` parameter (older interface).\n\nNotes\n-----\nTime complexity depends on runtime pre-loading configuration. GPU warmup and\noptional pre-loading operations may take several seconds. The function performs\nI/O operations (filesystem access, network requests for readiness checks) and\nmay allocate GPU resources. Thread-safe if called from a single async context\nduring startup. The function is not idempotent - it should only be called once\nper application lifecycle.\n\nThis function may propagate ConfigurationError from ApplicationContext.create()\nif application configuration is invalid or required resources are missing. The\nexception propagates to lifespan(), causing FastAPI startup to fail.\n\nExamples\n--------\n>>> # Called from lifespan() context manager\n>>> context, readiness = await _initialize_context(app)\n>>> assert context is not None\n>>> assert readiness is not None",
  "is_public": false
}
{
  "path": "app/main.py",
  "module": "app.main",
  "qualname": "_shutdown_context",
  "name": "_shutdown_context",
  "node_type": "AsyncFunctionDef",
  "lineno": 405,
  "col": 0,
  "end_lineno": 424,
  "end_col": 48,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Shut down mutable runtimes and readiness probes.",
  "is_public": false
}
{
  "path": "app/main.py",
  "module": "app.main",
  "qualname": "lifespan",
  "name": "lifespan",
  "node_type": "AsyncFunctionDef",
  "lineno": 428,
  "col": 0,
  "end_lineno": 520,
  "end_col": 51,
  "parent_qualname": null,
  "decorators": [
    "asynccontextmanager"
  ],
  "bases": [],
  "docstring": "Application lifespan manager with explicit configuration initialization.\n\nThis function runs during FastAPI startup and shutdown, managing the\nconfiguration lifecycle explicitly rather than relying on lazy loading.\n\nParameters\n----------\napp : FastAPI\n    FastAPI application instance. Used to store application context and\n    readiness probe in app.state.\n\nYields\n------\nNone\n    Control to the FastAPI application after successful initialization.\n\nRaises\n------\nConfigurationError\n    If configuration is invalid or required resources are missing.\n    FastAPI will fail to start, preventing broken deployment. The exception\n    includes RFC 9457 Problem Details with context fields for debugging.\n\nNotes\n-----\nStartup sequence:\n1. Load configuration from environment (fail fast if invalid)\n2. Perform GPU warmup sequence (verify CUDA/torch/FAISS GPU availability)\n3. Initialize long-lived clients (vLLM, FAISS manager)\n4. Initialize scope registry for session-scoped query constraints\n5. Run readiness checks (verify indexes exist, vLLM reachable)\n6. Optionally pre-load FAISS index (controlled by FAISS_PRELOAD env var)\n7. Start background pruning task for expired sessions\n\nShutdown sequence:\n1. Cancel background pruning task\n2. Clear readiness state\n3. Explicitly close any open resources",
  "is_public": true
}
{
  "path": "app/main.py",
  "module": "app.main",
  "qualname": "lifespan._handle_hup",
  "name": "_handle_hup",
  "node_type": "FunctionDef",
  "lineno": 489,
  "col": 12,
  "end_lineno": 500,
  "end_col": 77,
  "parent_qualname": "lifespan",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "app/main.py",
  "module": "app.main",
  "qualname": "observability_run_report",
  "name": "observability_run_report",
  "node_type": "AsyncFunctionDef",
  "lineno": 557,
  "col": 0,
  "end_lineno": 590,
  "end_col": 41,
  "parent_qualname": null,
  "decorators": [
    "app.get('/observability/run_report')"
  ],
  "bases": [],
  "docstring": "Return RunReport V2 for observability dashboards.\n\nParameters\n----------\nsession_id : str\n    Session identifier to inspect.\nrun_id : str | None\n    Specific run identifier; when omitted the latest run is returned.\nresponse_format : str | None\n    Optional format selector (``\"md\"`` or ``\"markdown\"`` for plaintext).\n\nReturns\n-------\nResponse\n    JSON response by default or plaintext Markdown when requested.\n\nRaises\n------\nHTTPException\n    Raised when the application context is missing or the run cannot be found.",
  "is_public": true
}
{
  "path": "app/main.py",
  "module": "app.main",
  "qualname": "get_run_report",
  "name": "get_run_report",
  "node_type": "AsyncFunctionDef",
  "lineno": 594,
  "col": 0,
  "end_lineno": 632,
  "end_col": 33,
  "parent_qualname": null,
  "decorators": [
    "app.get('/reports/{session_id}')"
  ],
  "bases": [],
  "docstring": "Return JSON run report for the session/run identifier.\n\nThis endpoint retrieves a run report for the specified session and optional\nrun identifier. The report contains telemetry data, metrics, and execution\ndetails for the requested run. If no run_id is provided, returns the most\nrecent run for the session.\n\nParameters\n----------\nsession_id : str\n    Session identifier extracted from the URL path. Used to identify the\n    telemetry session containing the run report.\nrun_id : str | None, optional\n    Optional run identifier to retrieve a specific run report. If None\n    (default), returns the most recent run for the session. Used to\n    retrieve historical run reports within a session.\n\nReturns\n-------\ndict[str, Any]\n    Run report payload serialisable to JSON containing telemetry data,\n    metrics, timing information, and execution details for the requested run.\n    The payload structure matches the RunReport schema.\n\nRaises\n------\nHTTPException\n    Raised in the following cases:\n    - Status 503: Application context is not initialized (missing from app.state)\n    - Status 404: Run not found for the specified session_id and run_id",
  "is_public": true
}
{
  "path": "app/main.py",
  "module": "app.main",
  "qualname": "get_run_report_markdown",
  "name": "get_run_report_markdown",
  "node_type": "AsyncFunctionDef",
  "lineno": 636,
  "col": 0,
  "end_lineno": 675,
  "end_col": 53,
  "parent_qualname": null,
  "decorators": [
    "app.get('/reports/{session_id}.md', response_class=PlainTextResponse)"
  ],
  "bases": [],
  "docstring": "Return Markdown run report for the session/run identifier.\n\nThis endpoint retrieves a run report for the specified session and optional\nrun identifier, formatted as Markdown. The report contains telemetry data,\nmetrics, and execution details rendered in human-readable Markdown format.\nIf no run_id is provided, returns the most recent run for the session.\n\nParameters\n----------\nsession_id : str\n    Session identifier extracted from the URL path. Used to identify the\n    telemetry session containing the run report.\nrun_id : str | None, optional\n    Optional run identifier to retrieve a specific run report. If None\n    (default), returns the most recent run for the session. Used to\n    retrieve historical run reports within a session.\n\nReturns\n-------\nPlainTextResponse\n    FastAPI PlainTextResponse containing Markdown-formatted run report body.\n    The response includes telemetry data, metrics, timing information, and\n    execution details rendered in Markdown format suitable for display in\n    documentation or web interfaces.\n\nRaises\n------\nHTTPException\n    Raised in the following cases:\n    - Status 503: Application context is not initialized (missing from app.state)\n    - Status 404: Run not found for the specified session_id and run_id",
  "is_public": true
}
{
  "path": "app/main.py",
  "module": "app.main",
  "qualname": "get_run_report_mermaid",
  "name": "get_run_report_mermaid",
  "node_type": "AsyncFunctionDef",
  "lineno": 679,
  "col": 0,
  "end_lineno": 707,
  "end_col": 52,
  "parent_qualname": null,
  "decorators": [
    "app.get('/reports/{session_id}.mmd', response_class=PlainTextResponse)"
  ],
  "bases": [],
  "docstring": "Return a Mermaid representation of the run.\n\nParameters\n----------\nsession_id : str\n    Session identifier to retrieve the run report for.\nrun_id : str | None\n    Optional run identifier when multiple runs share a session. If None,\n    returns the latest run for the session.\n\nReturns\n-------\nPlainTextResponse\n    Mermaid `graph TD` body describing the run.\n\nRaises\n------\nHTTPException\n    Raised when the application context is not initialized or the run cannot\n    be found.",
  "is_public": true
}
{
  "path": "app/main.py",
  "module": "app.main",
  "qualname": "get_run_report_v2",
  "name": "get_run_report_v2",
  "node_type": "AsyncFunctionDef",
  "lineno": 711,
  "col": 0,
  "end_lineno": 727,
  "end_col": 51,
  "parent_qualname": null,
  "decorators": [
    "app.get('/runs/{session_id}/report')"
  ],
  "bases": [],
  "docstring": "Alias for `/reports/{session_id}` retaining backwards compatibility.\n\nParameters\n----------\nsession_id : str\n    Session identifier to retrieve the run report for.\nrun_id : str | None\n    Optional run identifier when multiple runs share a session. If None,\n    returns the latest run for the session.\n\nReturns\n-------\ndict[str, Any]\n    JSON run report payload.",
  "is_public": true
}
{
  "path": "app/main.py",
  "module": "app.main",
  "qualname": "get_run_report_markdown_v2",
  "name": "get_run_report_markdown_v2",
  "node_type": "AsyncFunctionDef",
  "lineno": 731,
  "col": 0,
  "end_lineno": 749,
  "end_col": 60,
  "parent_qualname": null,
  "decorators": [
    "app.get('/runs/{session_id}/report.md', response_class=PlainTextResponse)"
  ],
  "bases": [],
  "docstring": "Alias for `/reports/{session_id}.md`.\n\nParameters\n----------\nsession_id : str\n    Session identifier to retrieve the run report for.\nrun_id : str | None\n    Optional run identifier when multiple runs share a session. If None,\n    returns the latest run for the session.\n\nReturns\n-------\nPlainTextResponse\n    Markdown run report body.",
  "is_public": true
}
{
  "path": "app/main.py",
  "module": "app.main",
  "qualname": "get_run_report_mermaid_v2",
  "name": "get_run_report_mermaid_v2",
  "node_type": "AsyncFunctionDef",
  "lineno": 753,
  "col": 0,
  "end_lineno": 771,
  "end_col": 59,
  "parent_qualname": null,
  "decorators": [
    "app.get('/runs/{session_id}/report.mmd', response_class=PlainTextResponse)"
  ],
  "bases": [],
  "docstring": "Alias for `/reports/{session_id}.mmd`.\n\nParameters\n----------\nsession_id : str\n    Session identifier to retrieve the run report for.\nrun_id : str | None\n    Optional run identifier when multiple runs share a session. If None,\n    returns the latest run for the session.\n\nReturns\n-------\nPlainTextResponse\n    Mermaid graph for the run.",
  "is_public": true
}
{
  "path": "app/main.py",
  "module": "app.main",
  "qualname": "inject_request_id",
  "name": "inject_request_id",
  "node_type": "AsyncFunctionDef",
  "lineno": 775,
  "col": 0,
  "end_lineno": 798,
  "end_col": 19,
  "parent_qualname": null,
  "decorators": [
    "app.middleware('http')"
  ],
  "bases": [],
  "docstring": "Ensure every request carries a stable request identifier.\n\nParameters\n----------\nrequest : Request\n    Incoming HTTP request to process.\ncall_next : Callable[[Request], Awaitable[Response]]\n    Next middleware or route handler in the chain.\n\nReturns\n-------\nResponse\n    Response with X-Request-Id header set to the request identifier.",
  "is_public": true
}
{
  "path": "app/main.py",
  "module": "app.main",
  "qualname": "set_mcp_context",
  "name": "set_mcp_context",
  "node_type": "AsyncFunctionDef",
  "lineno": 802,
  "col": 0,
  "end_lineno": 877,
  "end_col": 19,
  "parent_qualname": null,
  "decorators": [
    "app.middleware('http')"
  ],
  "bases": [],
  "docstring": "Set ApplicationContext in context variable for MCP tool handlers.\n\nThis middleware sets the ApplicationContext in a context variable that\ncan be accessed by FastMCP tool handlers. FastMCP doesn't support Request\ninjection directly, so we use contextvars to pass the context.\n\nParameters\n----------\nrequest : Request\n    Incoming HTTP request from FastAPI/Starlette.\ncall_next : Callable[[Request], Awaitable[Response]]\n    Next middleware or route handler in the chain.\n\nReturns\n-------\nResponse\n    Response from the next handler.\n\nRaises\n------\nException\n    Propagated from `call_next()` if the downstream handler raises any\n    exception. Also propagates exceptions from timeline event recording.\n\nNotes\n-----\nThis middleware extracts the ApplicationContext from `request.app.state`\nand sets it in a context variable (`app_context`) for MCP tool handlers.\nIt also records timeline events for request processing. Time complexity:\nO(1) for context variable operations, plus downstream handler time.",
  "is_public": true
}
{
  "path": "app/main.py",
  "module": "app.main",
  "qualname": "disable_nginx_buffering",
  "name": "disable_nginx_buffering",
  "node_type": "AsyncFunctionDef",
  "lineno": 881,
  "col": 0,
  "end_lineno": 913,
  "end_col": 19,
  "parent_qualname": null,
  "decorators": [
    "app.middleware('http')"
  ],
  "bases": [],
  "docstring": "Disable NGINX buffering for streaming responses.\n\nThis middleware sets the X-Accel-Buffering header to \"no\" on all responses,\nwhich instructs NGINX to disable buffering and enable streaming. This is\ncritical for Server-Sent Events (SSE) and other streaming protocols where\nbackpressure and real-time delivery are important.\n\nThe middleware runs after the request handler executes, modifying the\nresponse headers before it's sent to the client. This ensures that NGINX\nwill stream the response directly to the client rather than buffering it\nin memory, which is essential for long-running streams and prevents memory\nissues with large responses.\n\nParameters\n----------\nrequest : Request\n    Incoming HTTP request from FastAPI/Starlette.\ncall_next : Callable[[Request], Awaitable[Response]]\n    Next middleware or route handler in the chain. This is an async callable\n    that takes a Request and returns an awaitable Response.\n\nReturns\n-------\nResponse\n    Response object with X-Accel-Buffering header set to \"no\". The response\n    is the same as returned by call_next, but with the streaming header added.",
  "is_public": true
}
{
  "path": "app/main.py",
  "module": "app.main",
  "qualname": "healthz",
  "name": "healthz",
  "node_type": "AsyncFunctionDef",
  "lineno": 917,
  "col": 0,
  "end_lineno": 925,
  "end_col": 41,
  "parent_qualname": null,
  "decorators": [
    "app.get('/healthz')"
  ],
  "bases": [],
  "docstring": "Health check endpoint (network-only).\n\nReturns\n-------\nJSONResponse\n    Health status.",
  "is_public": true
}
{
  "path": "app/main.py",
  "module": "app.main",
  "qualname": "readyz",
  "name": "readyz",
  "node_type": "AsyncFunctionDef",
  "lineno": 929,
  "col": 0,
  "end_lineno": 960,
  "end_col": 41,
  "parent_qualname": null,
  "decorators": [
    "app.get('/readyz')"
  ],
  "bases": [],
  "docstring": "Readiness check endpoint.\n\nVerifies that dependent services are available. This endpoint always returns\nHTTP 200, but the payload indicates whether all resources are healthy. Kubernetes\nreadiness probes should check the \"ready\" field in the response.\n\nParameters\n----------\nrequest : Request\n    FastAPI request object.\n\nReturns\n-------\nJSONResponse\n    Readiness status with detailed check results.",
  "is_public": true
}
{
  "path": "app/main.py",
  "module": "app.main",
  "qualname": "capz",
  "name": "capz",
  "node_type": "AsyncFunctionDef",
  "lineno": 964,
  "col": 0,
  "end_lineno": 1003,
  "end_col": 32,
  "parent_qualname": null,
  "decorators": [
    "app.get('/capz')"
  ],
  "bases": [],
  "docstring": "Return a cached capability snapshot (refreshable via query flag).\n\nParameters\n----------\nrequest : Request\n    Incoming HTTP request from FastAPI/Starlette.\nrefresh : bool, optional\n    If True, forces refresh of the capability snapshot. Otherwise returns\n    cached snapshot if available (default: False).\n\nReturns\n-------\nJSONResponse\n    Capability payload with keys: capability flags (faiss_index, duckdb,\n    etc.), optional hints, and stamp (SHA-256 hash). Returns 503 status\n    if application context is not initialized.\n\nNotes\n-----\nThis endpoint provides capability detection for MCP tool gating and\nmonitoring. The snapshot is cached in `request.app.state.capabilities`\nand refreshed on demand or when missing. Time complexity: O(1) for cached\nresponses, O(module_probe_time) for refresh.",
  "is_public": true
}
{
  "path": "app/main.py",
  "module": "app.main",
  "qualname": "_stream_with_logging",
  "name": "_stream_with_logging",
  "node_type": "AsyncFunctionDef",
  "lineno": 1006,
  "col": 0,
  "end_lineno": 1064,
  "end_col": 9,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Wrap a streaming iterator and emit lifecycle logs for observability.\n\nParameters\n----------\nsource : AsyncIterator[bytes]\n    Source iterator to wrap and log.\nrequest : Request\n    FastAPI request object for logging context.\nstream_name : str\n    Name identifier for the stream being logged.\n\nYields\n------\nbytes\n    Chunks from the source iterator, passed through unchanged.\n\nRaises\n------\nasyncio.CancelledError\n    Re-raised if the source iterator is cancelled, after logging cancellation.",
  "is_public": false
}
{
  "path": "app/main.py",
  "module": "app.main",
  "qualname": "sse_demo",
  "name": "sse_demo",
  "node_type": "AsyncFunctionDef",
  "lineno": 1068,
  "col": 0,
  "end_lineno": 1117,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [
    "app.get('/sse')"
  ],
  "bases": [],
  "docstring": "SSE streaming demo endpoint with keep-alive comments.\n\nParameters\n----------\nrequest : Request\n    FastAPI request object for logging context.\n\nReturns\n-------\nStreamingResponse\n    SSE stream containing ready event, 5 data events, and recurring keep-alive\n    comments.",
  "is_public": true
}
{
  "path": "app/main.py",
  "module": "app.main",
  "qualname": "sse_demo.event_generator",
  "name": "event_generator",
  "node_type": "AsyncFunctionDef",
  "lineno": 1085,
  "col": 4,
  "end_lineno": 1112,
  "end_col": 32,
  "parent_qualname": "sse_demo",
  "decorators": [],
  "bases": [],
  "docstring": "Generate Server-Sent Events (SSE) stream for demo purposes.\n\nThis generator function produces a simple SSE stream containing a ready\nevent followed by 5 data events with incremental counters. Each data\nevent is sent with a 0.5 second delay to demonstrate streaming behavior.\nAfter the initial payload burst, the generator emits keep-alive comments\nevery ``SSE_KEEPALIVE_SECONDS`` so intermediaries keep the connection\nopen for long-lived sessions.\n\nYields\n------\nbytes\n    SSE-formatted event chunks. Each chunk is a complete SSE message\n    terminated with double newlines. The first chunk is a ready event,\n    followed by 5 data events containing incremental counters (0-4),\n    and then recurring keep-alive comments until the client disconnects.",
  "is_public": true
}
{
  "path": "app/main.py",
  "module": "app.main",
  "qualname": "http_exception_handler_with_request_id",
  "name": "http_exception_handler_with_request_id",
  "node_type": "FunctionDef",
  "lineno": 1121,
  "col": 0,
  "end_lineno": 1149,
  "end_col": 86,
  "parent_qualname": null,
  "decorators": [
    "app.exception_handler(HTTPException)"
  ],
  "bases": [],
  "docstring": "Return HTTPException responses with structured payloads and request IDs.\n\nParameters\n----------\nrequest : Request\n    FastAPI request object containing request state.\nexc : HTTPException\n    HTTP exception to handle and format.\n\nReturns\n-------\nJSONResponse\n    JSON response with error payload and X-Request-Id header if available.",
  "is_public": true
}
{
  "path": "app/main.py",
  "module": "app.main",
  "qualname": "unhandled_exception_handler",
  "name": "unhandled_exception_handler",
  "node_type": "FunctionDef",
  "lineno": 1153,
  "col": 0,
  "end_lineno": 1190,
  "end_col": 74,
  "parent_qualname": null,
  "decorators": [
    "app.exception_handler(Exception)"
  ],
  "bases": [],
  "docstring": "Wrap unhandled exceptions in a debuggable envelope.\n\nParameters\n----------\nrequest : Request\n    FastAPI request object containing request state.\nexc : Exception\n    Unhandled exception to wrap and log.\n\nReturns\n-------\nJSONResponse\n    JSON response with error payload (status 500) and X-Request-Id header\n    if available.",
  "is_public": true
}
{
  "path": "app/middleware.py",
  "module": "app.middleware",
  "qualname": "app.middleware",
  "name": "app.middleware",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Session management middleware for CodeIntel MCP.\n\nThis module provides FastAPI middleware for extracting or generating session IDs\nand storing them in thread-local context variables for access by MCP tool adapters.\n\nKey Components\n--------------\nSessionScopeMiddleware : class\n    Middleware that processes X-Session-ID header and populates ContextVar.\nsession_id_var : ContextVar[str | None]\n    Thread-local storage for current request's session ID.\nget_session_id : function\n    Helper to retrieve session ID from ContextVar (raises if not set).\n\nDesign Principles\n-----------------\n- **Thread-Local Isolation**: ContextVar ensures session IDs don't leak across threads\n- **Fail-Safe Defaults**: Auto-generates UUID if client doesn't provide session ID\n- **FastMCP Compatibility**: Works around FastMCP's lack of Request injection in tools\n- **Explicit Dependencies**: No global state; session ID accessed via explicit get_session_id()\n\nMiddleware Flow\n---------------\n1. Extract X-Session-ID header from request\n2. Generate UUID if header absent\n3. Store in request.state.session_id (FastAPI convention)\n4. Store in session_id_var (ContextVar for thread-local access)\n5. Invoke next middleware/handler\n6. Return response (no header modificationFastMCP limitation)\n\nExample Usage\n-------------\nRegister middleware in FastAPI application:\n\n>>> from codeintel_rev.app.middleware import SessionScopeMiddleware\n>>> app.add_middleware(SessionScopeMiddleware)\n\nAccess session ID in adapter:\n\n>>> from codeintel_rev.app.middleware import get_session_id\n>>> async def my_adapter(context: ApplicationContext, ...) -> dict:\n...     session_id = get_session_id()\n...     scope = await context.scope_store.get(session_id)\n...     # ... use scope\n\nSee Also\n--------\ncodeintel_rev.app.scope_store : ScopeStore for storing session scopes\ncodeintel_rev.mcp_server.scope_utils : Utilities for retrieving and merging scopes",
  "is_public": true
}
{
  "path": "app/middleware.py",
  "module": "app.middleware",
  "qualname": "get_session_id",
  "name": "get_session_id",
  "node_type": "FunctionDef",
  "lineno": 82,
  "col": 0,
  "end_lineno": 130,
  "end_col": 21,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Retrieve session ID from thread-local context.\n\nThis helper is called by adapters to access the session ID set by\nSessionScopeMiddleware. It should only be called within request handlers\ncalling it outside a request context raises RuntimeError.\n\nReturns\n-------\nstr\n    Session ID for the current request (UUID format).\n\nRaises\n------\nRuntimeError\n    If called outside request context (session ID not set by middleware).\n    This indicates middleware is not registered or adapter is called\n    directly without going through FastAPI request handling.\n\nExamples\n--------\nIn an adapter function:\n\n>>> async def my_adapter(context: ApplicationContext) -> dict:\n...     session_id = get_session_id()  # Retrieves from ContextVar\n...     scope = await context.scope_store.get(session_id)\n...     # ... process with scope\n\nOutside request context (error case):\n\n>>> get_session_id()  # doctest: +SKIP\nTraceback (most recent call last):\n    ...\nRuntimeError: Session ID not initializedensure SessionScopeMiddleware is registered\n\nNotes\n-----\nContextVar provides thread-local storage that is automatically copied to\nchild tasks in asyncio, ensuring session ID propagates correctly through\nawait calls and background tasks spawned from the request handler.",
  "is_public": true
}
{
  "path": "app/middleware.py",
  "module": "app.middleware",
  "qualname": "get_capability_stamp",
  "name": "get_capability_stamp",
  "node_type": "FunctionDef",
  "lineno": 133,
  "col": 0,
  "end_lineno": 142,
  "end_col": 37,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return the capability stamp associated with the current request.\n\nReturns\n-------\nstr | None\n    Stable capability hash when initialized, otherwise ``None`` if the\n    stamp has not been stored in the current context.",
  "is_public": true
}
{
  "path": "app/middleware.py",
  "module": "app.middleware",
  "qualname": "SessionScopeMiddleware",
  "name": "SessionScopeMiddleware",
  "node_type": "ClassDef",
  "lineno": 145,
  "col": 0,
  "end_lineno": 322,
  "end_col": 23,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "BaseHTTPMiddleware"
  ],
  "docstring": "Middleware for session ID extraction and context storage.\n\nProcesses every request to extract or generate a session ID, then stores\nit in both request.state (FastAPI convention) and a ContextVar (for\nFastMCP tool access). Session IDs enable stateful scope management across\nmultiple MCP tool calls within the same session.\n\nThis middleware is stateless and does not maintain any instance attributes.\n\nParameters\n----------\napp : ASGIApp\n    ASGI application to wrap with middleware.\ndispatch : DispatchFunction | None, optional\n    Optional custom dispatch function for the middleware. If None, uses the\n    default dispatch from BaseHTTPMiddleware. Defaults to None.\n\nNotes\n-----\nMiddleware Order:\n- SessionScopeMiddleware should be registered early in the middleware stack\n  (before tool handlers) to ensure session ID is available.\n- If other middleware needs session ID, register it after SessionScope.\n\nSession ID Generation:\n- UUIDs are generated using uuid.uuid4() (random, 122 bits of entropy).\n- Collision probability is negligible for practical session counts (<2^61).\n\nWhy Not Response Header:\n- FastMCP doesn't provide a way to customize response headers from tool\n  handlers, so we return session_id in the response body instead.\n- Future: If FastMCP adds response customization, add X-Session-ID header.\n\nExamples\n--------\nRegister middleware in application:\n\n>>> from fastapi import FastAPI\n>>> from codeintel_rev.app.middleware import SessionScopeMiddleware\n>>> app = FastAPI()\n>>> app.add_middleware(SessionScopeMiddleware)\n\nSend request with session ID:\n\n>>> import httpx\n>>> headers = {\"X-Session-ID\": \"my-custom-session-123\"}\n>>> response = httpx.post(\"/mcp/tools/set_scope\", headers=headers, ...)\n\nSend request without session ID (auto-generated):\n\n>>> response = httpx.post(\"/mcp/tools/set_scope\", ...)\n>>> session_id = response.json()[\"session_id\"]  # Use for subsequent requests",
  "is_public": true
}
{
  "path": "app/middleware.py",
  "module": "app.middleware",
  "qualname": "SessionScopeMiddleware.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 200,
  "col": 4,
  "end_lineno": 202,
  "end_col": 29,
  "parent_qualname": "SessionScopeMiddleware",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "app/middleware.py",
  "module": "app.middleware",
  "qualname": "SessionScopeMiddleware.dispatch",
  "name": "dispatch",
  "node_type": "AsyncFunctionDef",
  "lineno": 204,
  "col": 4,
  "end_lineno": 322,
  "end_col": 23,
  "parent_qualname": "SessionScopeMiddleware",
  "decorators": [],
  "bases": [],
  "docstring": "Process request and inject session ID.\n\nExtracts X-Session-ID header or generates UUID, stores in request.state\nand ContextVar, then invokes next middleware/handler.\n\nParameters\n----------\nrequest : Request\n    Starlette Request object with headers and state.\ncall_next : Callable[[Request], Awaitable[Response]]\n    Next middleware or route handler in the chain. Must be an async\n    callable that accepts a Request and returns an awaitable Response.\n\nReturns\n-------\nResponse\n    Response from downstream handler (unmodified).\n\nNotes\n-----\nThe middleware is async to support FastAPI's async route handlers.\nEven if adapters are sync functions, FastAPI wraps them in asyncio.to_thread.",
  "is_public": true
}
{
  "path": "app/readiness.py",
  "module": "app.readiness",
  "qualname": "app.readiness",
  "name": "app.readiness",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Application readiness checks for Kubernetes health probes.\n\nThis module provides comprehensive readiness checks for all critical application\nresources including filesystem paths, FAISS indexes, DuckDB catalogs, and\nexternal services (vLLM). The ReadinessProbe class manages these checks and\nexposes results via the /readyz endpoint for Kubernetes integration.\n\nKey Components\n--------------\nCheckResult : dataclass\n    Immutable result of a single readiness check with healthy status and detail.\nReadinessProbe : class\n    Manages readiness checks across all dependencies with async refresh.\n\nDesign Principles\n-----------------\n- **Comprehensive**: Checks all critical resources (files, directories, services)\n- **Non-blocking**: HTTP checks use short timeouts to prevent blocking\n- **Graceful Degradation**: Optional resources (SCIP index) don't fail readiness\n- **Structured Results**: CheckResult provides JSON-serializable payloads\n\nExample Usage\n-------------\nDuring application startup:\n\n>>> # In lifespan() function\n>>> readiness = ReadinessProbe(context)\n>>> await readiness.initialize()\n>>> app.state.readiness = readiness\n\nIn readiness endpoint:\n\n>>> # In /readyz handler\n>>> results = await readiness.refresh()\n>>> return {\"ready\": all(r.healthy for r in results.values()), \"checks\": results}\n\nSee Also\n--------\ncodeintel_rev.app.config_context : ApplicationContext with configuration\ncodeintel_rev.app.main : FastAPI application with /readyz endpoint",
  "is_public": true
}
{
  "path": "app/readiness.py",
  "module": "app.readiness",
  "qualname": "CheckResult",
  "name": "CheckResult",
  "node_type": "ClassDef",
  "lineno": 73,
  "col": 0,
  "end_lineno": 108,
  "end_col": 22,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Outcome of a single readiness check.\n\nAttributes\n----------\nhealthy : bool\n    Whether the resource is ready for use.\ndetail : str | None\n    Diagnostic detail when unhealthy or degraded. None when healthy.\n\nExamples\n--------\n>>> result = CheckResult(healthy=True)\n>>> result.as_payload()\n{'healthy': True}\n\n>>> result = CheckResult(healthy=False, detail=\"FAISS index not found\")\n>>> result.as_payload()\n{'healthy': False, 'detail': 'FAISS index not found'}",
  "is_public": true
}
{
  "path": "app/readiness.py",
  "module": "app.readiness",
  "qualname": "CheckResult.as_payload",
  "name": "as_payload",
  "node_type": "FunctionDef",
  "lineno": 97,
  "col": 4,
  "end_lineno": 108,
  "end_col": 22,
  "parent_qualname": "CheckResult",
  "decorators": [],
  "bases": [],
  "docstring": "Convert to JSON-serializable dictionary.\n\nReturns\n-------\ndict[str, Any]\n    Dictionary with \"healthy\" boolean and optional \"detail\" string.",
  "is_public": true
}
{
  "path": "app/readiness.py",
  "module": "app.readiness",
  "qualname": "ReadinessProbe",
  "name": "ReadinessProbe",
  "node_type": "ClassDef",
  "lineno": 111,
  "col": 0,
  "end_lineno": 641,
  "end_col": 13,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Manages readiness checks across core dependencies.\n\nThis class performs comprehensive health checks on all critical application\nresources including filesystem paths, indexes, databases, and external\nservices. Checks are performed synchronously in a thread pool to avoid\nblocking the event loop.\n\nParameters\n----------\ncontext : ApplicationContext\n    Application context containing configuration and clients.\n\nExamples\n--------\nInitialize during application startup:\n\n>>> readiness = ReadinessProbe(context)\n>>> await readiness.initialize()\n\nRefresh checks on demand:\n\n>>> results = await readiness.refresh()\n>>> all_healthy = all(r.healthy for r in results.values())\n\nGet cached snapshot:\n\n>>> snapshot = readiness.snapshot()\n>>> faiss_status = snapshot[\"faiss_index\"]\n\nNotes\n-----\nThe probe maintains a cache of check results to avoid recomputing on every\nrequest. The cache is updated atomically via async lock during refresh().\n\nInternal attributes (not part of public API):\n- ``_context``: Application context with configuration and paths\n- ``_lock``: Lock protecting _last_checks cache during concurrent refresh calls\n- ``_last_checks``: Cache of most recent check results keyed by resource name",
  "is_public": true
}
{
  "path": "app/readiness.py",
  "module": "app.readiness",
  "qualname": "ReadinessProbe.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 152,
  "col": 4,
  "end_lineno": 155,
  "end_col": 54,
  "parent_qualname": "ReadinessProbe",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "app/readiness.py",
  "module": "app.readiness",
  "qualname": "ReadinessProbe.initialize",
  "name": "initialize",
  "node_type": "AsyncFunctionDef",
  "lineno": 157,
  "col": 4,
  "end_lineno": 168,
  "end_col": 28,
  "parent_qualname": "ReadinessProbe",
  "decorators": [],
  "bases": [],
  "docstring": "Prime readiness state on application startup.\n\nPerforms initial readiness checks and caches results. This should be\ncalled once during application startup before serving requests.\n\nExamples\n--------\n>>> readiness = ReadinessProbe(context)\n>>> await readiness.initialize()",
  "is_public": true
}
{
  "path": "app/readiness.py",
  "module": "app.readiness",
  "qualname": "ReadinessProbe.refresh",
  "name": "refresh",
  "node_type": "AsyncFunctionDef",
  "lineno": 170,
  "col": 4,
  "end_lineno": 197,
  "end_col": 42,
  "parent_qualname": "ReadinessProbe",
  "decorators": [],
  "bases": [],
  "docstring": "Recompute readiness checks asynchronously.\n\nRuns all checks in a thread pool to avoid blocking the event loop.\nUpdates the internal cache atomically and returns the latest results.\n\nReturns\n-------\nMapping[str, CheckResult]\n    Latest readiness results keyed by resource name. Keys include:\n    - \"repo_root\": Repository root directory check\n    - \"data_dir\": Data directory check (created if missing)\n    - \"vectors_dir\": Vectors directory check (created if missing)\n    - \"faiss_index\": FAISS index file check\n    - \"duckdb_catalog\": DuckDB catalog file check\n    - \"scip_index\": SCIP index file check (optional)\n    - \"vllm_service\": vLLM service connectivity check\n\nExamples\n--------\n>>> results = await readiness.refresh()\n>>> faiss_healthy = results[\"faiss_index\"].healthy",
  "is_public": true
}
{
  "path": "app/readiness.py",
  "module": "app.readiness",
  "qualname": "ReadinessProbe.shutdown",
  "name": "shutdown",
  "node_type": "AsyncFunctionDef",
  "lineno": 199,
  "col": 4,
  "end_lineno": 210,
  "end_col": 37,
  "parent_qualname": "ReadinessProbe",
  "decorators": [],
  "bases": [],
  "docstring": "Clear readiness state on shutdown.\n\nClears the internal cache of check results. Should be called during\napplication shutdown to free resources.\n\nExamples\n--------\n>>> await readiness.shutdown()",
  "is_public": true
}
{
  "path": "app/readiness.py",
  "module": "app.readiness",
  "qualname": "ReadinessProbe.snapshot",
  "name": "snapshot",
  "node_type": "FunctionDef",
  "lineno": 212,
  "col": 4,
  "end_lineno": 238,
  "end_col": 38,
  "parent_qualname": "ReadinessProbe",
  "decorators": [],
  "bases": [],
  "docstring": "Return the latest readiness snapshot.\n\nReturns the cached check results without performing new checks. Use\nrefresh() to update the cache with fresh results.\n\nReturns\n-------\nMapping[str, CheckResult]\n    Most recent readiness results from the last refresh() call.\n\nRaises\n------\nRuntimeError\n    If the probe has not been initialized yet (no refresh() called).\n\nExamples\n--------\n>>> snapshot = readiness.snapshot()\n>>> if snapshot[\"faiss_index\"].healthy:\n...     # FAISS is ready\n...     pass",
  "is_public": true
}
{
  "path": "app/readiness.py",
  "module": "app.readiness",
  "qualname": "ReadinessProbe._run_checks",
  "name": "_run_checks",
  "node_type": "FunctionDef",
  "lineno": 240,
  "col": 4,
  "end_lineno": 306,
  "end_col": 22,
  "parent_qualname": "ReadinessProbe",
  "decorators": [],
  "bases": [],
  "docstring": "Execute all readiness checks synchronously.\n\nPerforms checks on all critical resources including filesystem paths,\nindex files, and external services. This method runs in a thread pool\nto avoid blocking the event loop.\n\nReturns\n-------\ndict[str, CheckResult]\n    Check results keyed by resource name.",
  "is_public": false
}
{
  "path": "app/readiness.py",
  "module": "app.readiness",
  "qualname": "ReadinessProbe._record_check",
  "name": "_record_check",
  "node_type": "FunctionDef",
  "lineno": 309,
  "col": 4,
  "end_lineno": 322,
  "end_col": 25,
  "parent_qualname": "ReadinessProbe",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "app/readiness.py",
  "module": "app.readiness",
  "qualname": "ReadinessProbe.check_directory",
  "name": "check_directory",
  "node_type": "FunctionDef",
  "lineno": 325,
  "col": 4,
  "end_lineno": 360,
  "end_col": 40,
  "parent_qualname": "ReadinessProbe",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": "Ensure a directory exists (creating it if requested).\n\nParameters\n----------\npath : Path\n    Directory path to validate.\ncreate : bool, optional\n    When True, create the directory hierarchy if it is missing.\n    Defaults to False.\n\nReturns\n-------\nCheckResult\n    Healthy status and diagnostic detail when unavailable.\n\nExamples\n--------\n>>> result = ReadinessProbe.check_directory(Path(\"/tmp/test\"))\n>>> result.healthy\nTrue\n\n>>> result = ReadinessProbe.check_directory(Path(\"/nonexistent\"), create=True)\n>>> result.healthy\nTrue  # Directory was created",
  "is_public": true
}
{
  "path": "app/readiness.py",
  "module": "app.readiness",
  "qualname": "ReadinessProbe.check_file",
  "name": "check_file",
  "node_type": "FunctionDef",
  "lineno": 363,
  "col": 4,
  "end_lineno": 411,
  "end_col": 56,
  "parent_qualname": "ReadinessProbe",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": "Validate existence of a filesystem resource.\n\nParameters\n----------\npath : Path\n    Target filesystem path.\ndescription : str\n    Human-readable resource description for diagnostics.\noptional : bool, optional\n    When True, missing resources mark the check as healthy but include\n    detail. Defaults to False (missing resources fail the check).\n\nReturns\n-------\nCheckResult\n    Healthy status and contextual detail.\n\nExamples\n--------\n>>> result = ReadinessProbe.check_file(\n...     Path(\"/tmp/test.txt\"), description=\"test file\", optional=False\n... )\n>>> result.healthy\nFalse  # File doesn't exist\n\n>>> result = ReadinessProbe.check_file(\n...     Path(\"/tmp/test.txt\"), description=\"test file\", optional=True\n... )\n>>> result.healthy\nTrue  # Optional file missing is OK\n>>> result.detail\n'test file not found at /tmp/test.txt'",
  "is_public": true
}
{
  "path": "app/readiness.py",
  "module": "app.readiness",
  "qualname": "ReadinessProbe._check_duckdb_catalog",
  "name": "_check_duckdb_catalog",
  "node_type": "FunctionDef",
  "lineno": 413,
  "col": 4,
  "end_lineno": 457,
  "end_col": 40,
  "parent_qualname": "ReadinessProbe",
  "decorators": [],
  "bases": [],
  "docstring": "Validate DuckDB catalog presence and optional materialization state.\n\nParameters\n----------\npath : Path\n    Path to the DuckDB catalog file.\n\nReturns\n-------\nCheckResult\n    Healthy status and diagnostic detail when validation fails.",
  "is_public": false
}
{
  "path": "app/readiness.py",
  "module": "app.readiness",
  "qualname": "ReadinessProbe._check_xtr_artifacts",
  "name": "_check_xtr_artifacts",
  "node_type": "FunctionDef",
  "lineno": 459,
  "col": 4,
  "end_lineno": 479,
  "end_col": 55,
  "parent_qualname": "ReadinessProbe",
  "decorators": [],
  "bases": [],
  "docstring": "Verify that XTR token artifacts are present when enabled.\n\nReturns\n-------\nCheckResult\n    Healthy status describing artifact availability.",
  "is_public": false
}
{
  "path": "app/readiness.py",
  "module": "app.readiness",
  "qualname": "ReadinessProbe._duckdb_table_exists",
  "name": "_duckdb_table_exists",
  "node_type": "FunctionDef",
  "lineno": 482,
  "col": 4,
  "end_lineno": 503,
  "end_col": 35,
  "parent_qualname": "ReadinessProbe",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": "Return True when `chunks_materialized` table exists.\n\nParameters\n----------\nconn : duckdb.DuckDBPyConnection\n    DuckDB database connection.\n\nReturns\n-------\nbool\n    ``True`` when the materialized table exists, ``False`` otherwise.",
  "is_public": false
}
{
  "path": "app/readiness.py",
  "module": "app.readiness",
  "qualname": "ReadinessProbe._duckdb_index_exists",
  "name": "_duckdb_index_exists",
  "node_type": "FunctionDef",
  "lineno": 506,
  "col": 4,
  "end_lineno": 526,
  "end_col": 35,
  "parent_qualname": "ReadinessProbe",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": "Return True when `idx_chunks_materialized_uri` index exists.\n\nParameters\n----------\nconn : duckdb.DuckDBPyConnection\n    DuckDB database connection.\n\nReturns\n-------\nbool\n    ``True`` when the index exists, ``False`` otherwise.",
  "is_public": false
}
{
  "path": "app/readiness.py",
  "module": "app.readiness",
  "qualname": "ReadinessProbe._check_search_tools",
  "name": "_check_search_tools",
  "node_type": "FunctionDef",
  "lineno": 529,
  "col": 4,
  "end_lineno": 550,
  "end_col": 9,
  "parent_qualname": "ReadinessProbe",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": "Ensure either ripgrep or grep is available for text search.\n\nReturns\n-------\nCheckResult\n    Healthy status if ripgrep or grep is available, otherwise error detail.",
  "is_public": false
}
{
  "path": "app/readiness.py",
  "module": "app.readiness",
  "qualname": "ReadinessProbe.check_vllm_connection",
  "name": "check_vllm_connection",
  "node_type": "FunctionDef",
  "lineno": 552,
  "col": 4,
  "end_lineno": 563,
  "end_col": 43,
  "parent_qualname": "ReadinessProbe",
  "decorators": [],
  "bases": [],
  "docstring": "Verify vLLM availability for the configured execution mode.\n\nReturns\n-------\nCheckResult\n    Result of the probe indicating health and optional detail.",
  "is_public": true
}
{
  "path": "app/readiness.py",
  "module": "app.readiness",
  "qualname": "ReadinessProbe._check_vllm_inprocess",
  "name": "_check_vllm_inprocess",
  "node_type": "FunctionDef",
  "lineno": 565,
  "col": 4,
  "end_lineno": 587,
  "end_col": 40,
  "parent_qualname": "ReadinessProbe",
  "decorators": [],
  "bases": [],
  "docstring": "Perform an embedding smoke test when running vLLM in-process.\n\nReturns\n-------\nCheckResult\n    Healthy status along with diagnostic detail when failures occur.",
  "is_public": false
}
{
  "path": "app/readiness.py",
  "module": "app.readiness",
  "qualname": "ReadinessProbe._check_vllm_http",
  "name": "_check_vllm_http",
  "node_type": "FunctionDef",
  "lineno": 590,
  "col": 4,
  "end_lineno": 641,
  "end_col": 13,
  "parent_qualname": "ReadinessProbe",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": "Validate HTTP vLLM endpoint reachability.\n\nExtended Summary\n----------------\nThis static method performs a health check on a remote vLLM HTTP endpoint\nby sending a GET request to the /health endpoint. It validates the URL format,\nchecks connectivity, and verifies that the endpoint returns a successful HTTP\nstatus code. This is used by the readiness probe to determine if the vLLM\nservice is available and responding correctly when running in HTTP mode.\n\nParameters\n----------\nbase_url : str\n    Base URL of the vLLM HTTP service (e.g., \"http://localhost:8001/v1\").\n    Must be a valid HTTP or HTTPS URL with a netloc component. Invalid URLs\n    result in an unhealthy CheckResult.\n\nReturns\n-------\nCheckResult\n    Status representing endpoint availability. healthy=True if the endpoint\n    responds successfully, healthy=False with detail message if the endpoint\n    is unreachable, returns an error status, or the URL is invalid.\n\nNotes\n-----\nTime complexity O(1) plus network latency. Space complexity O(1) aside from\nHTTP response buffers. The method performs network I/O with a timeout defined\nby HTTP_HEALTH_TIMEOUT_S. Thread-safe as it's a static method with no shared\nstate. Network errors are caught and converted to unhealthy CheckResult.",
  "is_public": false
}
{
  "path": "app/routers/__init__.py",
  "module": "app.routers",
  "qualname": "app.routers",
  "name": "app.routers",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "FastAPI router modules for CodeIntel administrative endpoints.",
  "is_public": true
}
{
  "path": "app/routers/index_admin.py",
  "module": "app.routers.index_admin",
  "qualname": "app.routers.index_admin",
  "name": "app.routers.index_admin",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Admin endpoints for staging, publishing, and rolling back index versions.",
  "is_public": true
}
{
  "path": "app/routers/index_admin.py",
  "module": "app.routers.index_admin",
  "qualname": "_require_admin",
  "name": "_require_admin",
  "node_type": "FunctionDef",
  "lineno": 28,
  "col": 0,
  "end_lineno": 31,
  "end_col": 69,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "app/routers/index_admin.py",
  "module": "app.routers.index_admin",
  "qualname": "_context",
  "name": "_context",
  "node_type": "FunctionDef",
  "lineno": 34,
  "col": 0,
  "end_lineno": 38,
  "end_col": 18,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "app/routers/index_admin.py",
  "module": "app.routers.index_admin",
  "qualname": "_find_ledger_path",
  "name": "_find_ledger_path",
  "node_type": "FunctionDef",
  "lineno": 41,
  "col": 0,
  "end_lineno": 50,
  "end_col": 58,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "app/routers/index_admin.py",
  "module": "app.routers.index_admin",
  "qualname": "get_run_report",
  "name": "get_run_report",
  "node_type": "AsyncFunctionDef",
  "lineno": 54,
  "col": 0,
  "end_lineno": 79,
  "end_col": 40,
  "parent_qualname": null,
  "decorators": [
    "router.get('/observability/run/{run_id}/report')"
  ],
  "bases": [],
  "docstring": "Return structured run report derived from the on-disk ledger.\n\nParameters\n----------\nrun_id : str\n    Run identifier to look up in the ledger directory.\nrequest : Request\n    FastAPI request object used to extract application context.\n\nReturns\n-------\nJSONResponse\n    JSON response containing the structured run report dictionary.\n\nRaises\n------\nHTTPException\n    Raised with status code 404 when the run ledger file is not found.",
  "is_public": true
}
{
  "path": "app/routers/index_admin.py",
  "module": "app.routers.index_admin",
  "qualname": "_persist_session_tuning",
  "name": "_persist_session_tuning",
  "node_type": "AsyncFunctionDef",
  "lineno": 82,
  "col": 0,
  "end_lineno": 94,
  "end_col": 37,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "app/routers/index_admin.py",
  "module": "app.routers.index_admin",
  "qualname": "status_endpoint",
  "name": "status_endpoint",
  "node_type": "AsyncFunctionDef",
  "lineno": 98,
  "col": 0,
  "end_lineno": 147,
  "end_col": 32,
  "parent_qualname": null,
  "decorators": [
    "router.get('/status')"
  ],
  "bases": [],
  "docstring": "Return the current index version and health.\n\nExtended Summary\n----------------\nThis endpoint provides visibility into the index lifecycle state for\nadministrative monitoring and debugging. It reports the currently active\nversion, available versions, asset availability, and directory locations.\nUsed by operators to verify index deployment status and troubleshoot\nversion management issues.\n\nParameters\n----------\nrequest : Request\n    FastAPI request object containing application state with context.\n\nReturns\n-------\nJSONResponse\n    Snapshot containing:\n    - \"current\": str | None, active version identifier\n    - \"dir\": str | None, path to current version directory\n    - \"assets_ok\": bool, whether index assets are readable\n    - \"versions\": list[str], all available version identifiers\n\nNotes\n-----\nThis endpoint requires admin privileges (CODEINTEL_ADMIN=1). It performs\nnon-blocking checks on index assets and gracefully handles missing or\ncorrupted versions. Time complexity: O(1) for version lookup, O(n) for\nlisting versions where n is the number of published versions.",
  "is_public": true
}
{
  "path": "app/routers/index_admin.py",
  "module": "app.routers.index_admin",
  "qualname": "PublishBody",
  "name": "PublishBody",
  "node_type": "ClassDef",
  "lineno": 150,
  "col": 0,
  "end_lineno": 210,
  "end_col": 30,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "TypedDict"
  ],
  "docstring": "Request body schema for index publication endpoint.\n\nExtended Summary\n----------------\nThis TypedDict defines the structure for publishing a new index version via\nthe /admin/index/publish endpoint. It specifies all required and optional\nindex asset paths (FAISS, DuckDB, SCIP, BM25, SPLADE, XTR) that must be\nstaged before publication. The publication process validates these paths,\nstages them in a versioned directory, and updates the CURRENT symlink to\nactivate the new version.\n\nAttributes\n----------\nversion : str\n    Version identifier for the new index (e.g., \"v1.2.3\"). Must be unique\n    and follow semantic versioning conventions. Used to create the versioned\n    directory structure.\nfaiss_index : str\n    Path to the FAISS vector index directory. Required. Must exist and be\n    readable. Contains the vector index files for dense retrieval.\nduckdb_path : str\n    Path to the DuckDB catalog database file. Required. Must exist and be\n    readable. Contains symbol metadata and chunk catalog for hybrid search.\nscip_index : str\n    Path to the SCIP index file (JSON or protobuf). Required. Must exist and\n    be readable. Contains symbol definitions and cross-references for code\n    intelligence.\nbm25_dir : str | None\n    Optional path to the BM25 sparse index directory. If None, BM25 retrieval\n    is unavailable for this version. Used for keyword-based sparse retrieval.\nsplade_dir : str | None\n    Optional path to the SPLADE sparse index directory. If None, SPLADE\n    retrieval is unavailable for this version. Used for learned sparse retrieval.\nxtr_dir : str | None\n    Optional path to the XTR token index directory. If None, XTR reranking\n    is unavailable for this version. Used for late-interaction reranking.\nfaiss_idmap : str | None\n    Optional path to the FAISS ID map sidecar. If provided, the lifecycle\n    manager copies the parquet file into the version directory.\ntuning_profile : str | None\n    Optional path to a tuning.json profile. When present, the profile is\n    staged next to the index assets and applied at runtime.\n\nNotes\n-----\nAll paths are resolved relative to the repository root. Required paths (faiss_index,\nduckdb_path, scip_index) are validated during staging. Optional paths are validated\nonly if provided. The publication process is atomic: if any required asset fails\nvalidation, the entire operation is rolled back.",
  "is_public": true
}
{
  "path": "app/routers/index_admin.py",
  "module": "app.routers.index_admin",
  "qualname": "TuningBody",
  "name": "TuningBody",
  "node_type": "ClassDef",
  "lineno": 213,
  "col": 0,
  "end_lineno": 259,
  "end_col": 31,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "TypedDict"
  ],
  "docstring": "Request body schema for runtime tuning endpoint.\n\nExtended Summary\n----------------\nThis TypedDict defines optional runtime tuning parameters that can be applied\nto the application context's factory adjuster. All fields are optional (total=False),\nallowing partial updates to specific tuning knobs. Tuning parameters affect how\nruntime cells (FAISS manager, hybrid search engine) are created and configured.\nChanges take effect immediately for new runtime cell instances.\n\nAttributes\n----------\nfaiss_nprobe : int, optional\n    FAISS IVF nprobe parameter override. Controls the number of IVF clusters\n    probed during search. Higher values improve recall but increase latency.\n    Applied to FAISS manager factory configuration.\nfaiss_gpu_preference : bool, optional\n    GPU preference flag for FAISS operations. If True, prefers GPU execution\n    when CUDA is available. If False, forces CPU execution. Applied to FAISS\n    manager factory configuration.\nhybrid_rrf_k : int, optional\n    Reciprocal Rank Fusion k parameter for hybrid search. Controls the\n    fusion algorithm's rank aggregation behavior. Higher k values give more\n    weight to top-ranked results. Applied to hybrid search engine configuration.\nhybrid_bm25_weight : float, optional\n    BM25 weight in hybrid search fusion. Must be non-negative. Controls the\n    contribution of BM25 scores to the final hybrid ranking. Applied to hybrid\n    search engine configuration.\nhybrid_splade_weight : float, optional\n    SPLADE weight in hybrid search fusion. Must be non-negative. Controls the\n    contribution of SPLADE scores to the final hybrid ranking. Applied to hybrid\n    search engine configuration.\n\nNotes\n-----\nAll fields are optional. Only non-None values are applied to the factory adjuster.\nTuning changes affect future runtime cell creation but do not modify existing cells.\nFor immediate effect, combine with index reload operations. Weight parameters should\nbe normalized appropriately for the fusion algorithm.",
  "is_public": true
}
{
  "path": "app/routers/index_admin.py",
  "module": "app.routers.index_admin",
  "qualname": "FaissRuntimeTuningBody",
  "name": "FaissRuntimeTuningBody",
  "node_type": "ClassDef",
  "lineno": 262,
  "col": 0,
  "end_lineno": 310,
  "end_col": 19,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "TypedDict"
  ],
  "docstring": "Request body schema for FAISS runtime tuning endpoint.\n\nExtended Summary\n----------------\nThis TypedDict defines optional FAISS runtime tuning parameters that can be\napplied either globally (affecting all searches) or session-specifically (stored\nin scope metadata for a particular session). All fields are optional (total=False),\nallowing partial updates to specific tuning knobs. Runtime tuning overrides take\nprecedence over factory defaults and autotune profiles.\n\nAttributes\n----------\nnprobe : int, optional\n    IVF nprobe override for FAISS search. Controls the number of IVF clusters\n    probed during approximate nearest neighbor search. Higher values improve recall\n    but increase latency. Applied as a runtime override to the FAISS manager.\nef_search : int, optional\n    HNSW ef_search parameter override. Controls the size of the candidate set\n    during HNSW graph traversal. Higher values improve recall but increase latency.\n    Only applicable to HNSW indexes. Applied as a runtime override.\nquantizer_ef_search : int, optional\n    IVF quantizer ef_search parameter override. Controls the quantizer search\n    depth for IVF indexes with HNSW quantizers. Higher values improve quantizer\n    accuracy but increase latency. Applied as a runtime override.\nk_factor : float, optional\n    Search k factor multiplier. Multiplies the requested k value before performing\n    search, then returns the top-k results. Used to improve recall by searching\n    more candidates than requested. Must be >= 1.0. Applied as a runtime override.\nsession_id : str, optional\n    Optional session identifier for session-scoped tuning. If provided, tuning\n    parameters are persisted in the scope store and applied to searches for that\n    session. If None, parameters are applied globally to the FAISS manager runtime\n    overrides. Session-scoped tuning takes precedence over global tuning.\n\nNotes\n-----\nAll fields are optional. Only non-None values are applied. When session_id is\nprovided, tuning is stored in scope metadata and persists across requests for\nthat session. Global tuning affects all searches immediately. Runtime overrides\ntake precedence over factory defaults and autotune profiles. The k_factor must\nbe >= 1.0 or validation will fail.",
  "is_public": true
}
{
  "path": "app/routers/index_admin.py",
  "module": "app.routers.index_admin",
  "qualname": "publish_endpoint",
  "name": "publish_endpoint",
  "node_type": "AsyncFunctionDef",
  "lineno": 314,
  "col": 0,
  "end_lineno": 403,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [
    "router.post('/publish')"
  ],
  "bases": [],
  "docstring": "Stage and publish a new index version, then reload runtimes.\n\nExtended Summary\n----------------\nThis endpoint orchestrates the index publication workflow: staging assets\n(FAISS, DuckDB, SCIP, BM25, SPLADE, XTR), validating completeness, publishing\nto the versioned directory structure, updating the CURRENT symlink, and\nreloading runtime cells to pick up the new index. This is the primary\nmechanism for deploying new index versions in production.\n\nParameters\n----------\nbody : PublishBody\n    Request body containing:\n    - \"version\": str, version identifier (e.g., \"v1.2.3\")\n    - \"faiss_dir\": str, path to FAISS index directory\n    - \"duckdb_dir\": str, path to DuckDB catalog directory\n    - \"scip_dir\": str | None, optional path to SCIP index directory\n    - \"bm25_dir\": str | None, optional path to BM25 index directory\n    - \"splade_dir\": str | None, optional path to SPLADE index directory\n    - \"xtr_dir\": str | None, optional path to XTR index directory\n    - \"faiss_idmap\": str | None, optional path to faiss_idmap.parquet sidecar\n    - \"tuning_profile\": str | None, optional path to tuning.json profile\nrequest : Request\n    FastAPI request object containing application state with context.\n\nReturns\n-------\nJSONResponse\n    Confirmation payload with:\n    - \"version\": str, published version identifier\n    - \"staging\": str, staging directory path\n    - \"final\": str, final published directory path\n\nRaises\n------\nHTTPException\n    If validation fails (missing required assets), publishing encounters\n    runtime errors (filesystem I/O, symlink creation), or index manager\n    operations fail (status code 400 or 500).\n\nNotes\n-----\nThis endpoint requires admin privileges (CODEINTEL_ADMIN=1). The publication\nprocess is atomic: if any step fails, the operation is rolled back. After\nsuccessful publication, runtime cells are reloaded to ensure all components\nuse the new index version. Time complexity: O(asset_count) for validation\nand staging, plus I/O time for directory operations.",
  "is_public": true
}
{
  "path": "app/routers/index_admin.py",
  "module": "app.routers.index_admin",
  "qualname": "rollback_endpoint",
  "name": "rollback_endpoint",
  "node_type": "AsyncFunctionDef",
  "lineno": 407,
  "col": 0,
  "end_lineno": 456,
  "end_col": 57,
  "parent_qualname": null,
  "decorators": [
    "router.post('/rollback/{version}')"
  ],
  "bases": [],
  "docstring": "Flip ``CURRENT`` to a previously published version.\n\nExtended Summary\n----------------\nThis endpoint performs a rollback operation by updating the CURRENT symlink\nto point to a previously published version. After updating the symlink, it\nreloads runtime cells to ensure all components use the rolled-back index.\nUsed for rapid recovery from problematic index deployments without requiring\nfull re-publication.\n\nParameters\n----------\nversion : str\n    Version identifier to rollback to (e.g., \"v1.2.0\"). Must exist in\n    the published versions list.\nrequest : Request\n    FastAPI request object containing application state with context.\n\nReturns\n-------\nJSONResponse\n    Confirmation payload with:\n    - \"ok\": bool, True if rollback succeeded\n    - \"version\": str, the version that is now active\n\nRaises\n------\nHTTPException\n    If the requested version cannot be located (status code 400) or if\n    rollback operations fail (filesystem errors, symlink creation failures).\n\nNotes\n-----\nThis endpoint requires admin privileges (CODEINTEL_ADMIN=1). Rollback is\na fast operation (O(1) symlink update) but triggers full runtime cell\nreload. The operation is atomic: if reload fails, the symlink change is\nreverted. Use this for emergency rollbacks when a new version causes issues.",
  "is_public": true
}
{
  "path": "app/routers/index_admin.py",
  "module": "app.routers.index_admin",
  "qualname": "tuning_endpoint",
  "name": "tuning_endpoint",
  "node_type": "AsyncFunctionDef",
  "lineno": 460,
  "col": 0,
  "end_lineno": 512,
  "end_col": 97,
  "parent_qualname": null,
  "decorators": [
    "router.post('/tuning')"
  ],
  "bases": [],
  "docstring": "Update runtime tuning knobs (nprobe, fusion weights, etc.).\n\nExtended Summary\n----------------\nThis endpoint applies runtime tuning parameters to the application context's\nfactory adjuster, affecting how runtime cells (FAISS manager, hybrid search\nengine) are created and configured. Tuning parameters include FAISS search\nknobs (nprobe, GPU preference) and hybrid search fusion weights (BM25, SPLADE).\nChanges take effect immediately for new runtime cell instances.\n\nParameters\n----------\nbody : TuningBody\n    Request body containing optional tuning parameters:\n    - \"faiss_nprobe\": int | None, FAISS IVF nprobe override\n    - \"faiss_gpu_preference\": str | None, GPU preference (\"gpu\", \"cpu\", \"auto\")\n    - \"hybrid_rrf_k\": int | None, Reciprocal Rank Fusion k parameter\n    - \"hybrid_bm25_weight\": float | None, BM25 weight in hybrid fusion\n    - \"hybrid_splade_weight\": float | None, SPLADE weight in hybrid fusion\nrequest : Request\n    FastAPI request object containing application state with context.\n\nReturns\n-------\nJSONResponse\n    Summary payload with:\n    - \"ok\": bool, True if tuning was applied\n    - \"tuning\": dict[str, object], dictionary of applied tuning parameters\n      (only includes non-None values from the request)\n\nNotes\n-----\nThis endpoint requires admin privileges (CODEINTEL_ADMIN=1). Tuning changes\nare applied to the factory adjuster and affect future runtime cell creation.\nExisting cells are not modified; they continue using their current configuration\nuntil reloaded. For immediate effect, combine with index reload operations.\nTime complexity: O(1) for factory adjuster update.",
  "is_public": true
}
{
  "path": "app/routers/index_admin.py",
  "module": "app.routers.index_admin",
  "qualname": "faiss_runtime_status",
  "name": "faiss_runtime_status",
  "node_type": "AsyncFunctionDef",
  "lineno": 516,
  "col": 0,
  "end_lineno": 550,
  "end_col": 53,
  "parent_qualname": null,
  "decorators": [
    "router.get('/tuning/faiss')"
  ],
  "bases": [],
  "docstring": "Return the active FAISS runtime tuning profile.\n\nExtended Summary\n----------------\nThis endpoint provides visibility into the current FAISS runtime tuning\nstate, including active parameters (nprobe, ef_search, quantizer_ef_search,\nk_factor), runtime overrides, and persisted autotune profiles. Used for\nmonitoring and debugging FAISS search performance tuning.\n\nParameters\n----------\nrequest : Request\n    FastAPI request object containing application state with context.\n\nReturns\n-------\nJSONResponse\n    JSON document with keys:\n    - \"active\": dict[str, object], current effective parameters\n    - \"overrides\": dict[str, object], runtime override parameters\n    - \"autotune_profile\": dict[str, object], persisted autotune profile\n\nNotes\n-----\nThis endpoint requires admin privileges (CODEINTEL_ADMIN=1). The response\nreflects the tuning state of the FAISS manager for the coderank index.\nTime complexity: O(1) for tuning state retrieval.",
  "is_public": true
}
{
  "path": "app/routers/index_admin.py",
  "module": "app.routers.index_admin",
  "qualname": "faiss_runtime_tuning_endpoint",
  "name": "faiss_runtime_tuning_endpoint",
  "node_type": "AsyncFunctionDef",
  "lineno": 554,
  "col": 0,
  "end_lineno": 629,
  "end_col": 31,
  "parent_qualname": null,
  "decorators": [
    "router.post('/tuning/faiss')"
  ],
  "bases": [],
  "docstring": "Apply FAISS runtime tuning overrides or persist them for a specific session.\n\nExtended Summary\n----------------\nThis endpoint applies FAISS runtime tuning parameters either globally (affecting\nall searches) or session-specifically (stored in scope metadata). When a\nsession_id is provided, tuning parameters are persisted in the scope store\nand applied to searches for that session. Without a session_id, parameters\nare applied globally to the FAISS manager runtime overrides.\n\nParameters\n----------\nbody : FaissRuntimeTuningBody\n    Request body containing optional tuning parameters:\n    - \"nprobe\": int | None, IVF nprobe override\n    - \"ef_search\": int | None, HNSW ef_search override\n    - \"quantizer_ef_search\": int | None, IVF quantizer ef_search override\n    - \"k_factor\": float | None, search k factor multiplier\n    - \"session_id\": str | None, optional session identifier for session-scoped tuning\nrequest : Request\n    FastAPI request object containing application state with context.\n\nReturns\n-------\nJSONResponse\n    Payload describing the applied overrides (same format as GET /tuning/faiss).\n\nRaises\n------\nHTTPException\n    If the request body contains no tunable fields (all parameters are None)\n    or fails validation (status code 400).\n\nNotes\n-----\nThis endpoint requires admin privileges (CODEINTEL_ADMIN=1). Session-scoped\ntuning takes precedence over global tuning for searches within that session.\nGlobal tuning affects all searches immediately. Time complexity: O(1) for\nglobal tuning, O(1) for session-scoped tuning (scope store update).",
  "is_public": true
}
{
  "path": "app/routers/index_admin.py",
  "module": "app.routers.index_admin",
  "qualname": "faiss_runtime_reset_endpoint",
  "name": "faiss_runtime_reset_endpoint",
  "node_type": "AsyncFunctionDef",
  "lineno": 633,
  "col": 0,
  "end_lineno": 679,
  "end_col": 55,
  "parent_qualname": null,
  "decorators": [
    "router.delete('/tuning/faiss')"
  ],
  "bases": [],
  "docstring": "Reset FAISS runtime tuning overrides globally or for a session.\n\nExtended Summary\n----------------\nThis endpoint clears FAISS runtime tuning overrides, reverting to default\n(or autotuned) parameters. When a session_id is provided, clears session-scoped\ntuning from the scope store. Without a session_id, clears global runtime\noverrides from the FAISS manager. Used to reset tuning experiments or\nrecover from misconfigured parameters.\n\nParameters\n----------\nrequest : Request\n    FastAPI request object containing application state with context.\nsession_id : str | None, optional\n    Optional session identifier. If provided, clears session-scoped tuning\n    for that session. If None, clears global runtime overrides.\n\nReturns\n-------\nJSONResponse\n    Confirmation payload:\n    - If session_id provided: {\"session_id\": str, \"faiss_tuning\": None}\n    - If global reset: same format as GET /tuning/faiss with cleared overrides\n\nNotes\n-----\nThis endpoint requires admin privileges (CODEINTEL_ADMIN=1). Resetting\nglobal overrides immediately affects all searches. Resetting session-scoped\ntuning only affects searches for that session. Time complexity: O(1) for\nboth global and session-scoped resets.",
  "is_public": true
}
{
  "path": "app/scope_registry.py",
  "module": "app.scope_registry",
  "qualname": "app.scope_registry",
  "name": "app.scope_registry",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Session-scoped scope registry for CodeIntel MCP (legacy helper).\n\nThis helper predates the Redis-backed :mod:`codeintel_rev.app.scope_store` that\nApplicationContext wires up automatically today. The registry is still available\nfor standalone tooling, but production adapters should use ``context.scope_store``\ndirectly rather than mutating ``ApplicationContext``.\n\nKey Components\n--------------\nScopeRegistry : class\n    Thread-safe registry mapping session IDs to ScopeIn dictionaries.\n\nDesign Principles\n-----------------\n- **Thread Safety**: Uses threading.RLock for concurrent access protection\n- **LRU Behavior**: Updates timestamps on access for activity-based expiration\n- **Immutable Results**: Returns copies of stored scopes to prevent mutation\n- **Fail-Safe**: Missing sessions return None rather than raising exceptions\n\nExample Usage\n--------------\nInitialize registry manually (e.g., in a short-lived script). When running the\nfull FastAPI app, use ``ApplicationContext.scope_store`` insteadapplication\ncontexts are frozen and cannot be reassigned after creation.\n\n>>> registry = ScopeRegistry()\n>>> registry.set_scope(\"session\", {\"languages\": [\"python\"]})\n\nStore scope for a session:\n\n>>> session_id = \"abc123...\"\n>>> scope = {\"languages\": [\"python\"], \"include_globs\": [\"src/**\"]}\n>>> registry.set_scope(session_id, scope)\n\nRetrieve scope in adapter:\n\n>>> scope = registry.get_scope(session_id)\n>>> if scope:\n...     # Apply scope filters\n...     include_globs = scope.get(\"include_globs\")\n\nPrune expired sessions (background task):\n\n>>> pruned = registry.prune_expired(max_age_seconds=3600)\n>>> logger.info(f\"Pruned {pruned} expired sessions\")\n\nSee Also\n--------\ncodeintel_rev.app.middleware : Session ID extraction and ContextVar management\ncodeintel_rev.mcp_server.scope_utils : Scope merging and filtering utilities",
  "is_public": true
}
{
  "path": "app/scope_registry.py",
  "module": "app.scope_registry",
  "qualname": "ScopeRegistry",
  "name": "ScopeRegistry",
  "node_type": "ClassDef",
  "lineno": 81,
  "col": 0,
  "end_lineno": 398,
  "end_col": 36,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Thread-safe registry for session-scoped query scopes.\n\nMaintains an in-memory mapping of session IDs to ScopeIn dictionaries with\nlast-accessed timestamps for LRU expiration. Designed for concurrent access\nfrom FastAPI request handlers running in a threadpool.\n\nNotes\n-----\nThe registry is NOT persistentserver restart clears all sessions. For\npersistent scope storage, consider Redis or database backing (Phase 3+).\n\nPerformance characteristics:\n- set_scope: O(1) with lock acquisition overhead (~1s)\n- get_scope: O(1) with lock acquisition + dict copy (~2s)\n- prune_expired: O(n) where n = active session count\n\nThread safety:\n- All public methods acquire _lock before dict access.\n- RLock prevents deadlocks when methods call each other.\n- ContextVar in middleware ensures session ID isolation across threads.\n\nInternal attributes (not part of public API):\n- ``_scopes``: Internal storage: {session_id: (scope, last_accessed_timestamp)}.\n  Timestamps are from time.monotonic() for monotonic clock guarantees.\n- ``_lock``: Reentrant lock protecting dict operations. RLock allows same thread\n  to acquire lock multiple times (e.g., set_scope calls _update_timestamp).\n\nExamples\n--------\nCreate registry and store scope:\n\n>>> registry = ScopeRegistry()\n>>> session_id = \"test-session-123\"\n>>> scope = {\"languages\": [\"python\"], \"include_globs\": [\"**/*.py\"]}\n>>> registry.set_scope(session_id, scope)\n>>> retrieved = registry.get_scope(session_id)\n>>> retrieved == scope\nTrue\n\nScope expiration:\n\n>>> import time\n>>> registry.set_scope(\"old-session\", {\"languages\": [\"python\"]})\n>>> time.sleep(2)\n>>> pruned = registry.prune_expired(max_age_seconds=1)\n>>> pruned\n1\n>>> registry.get_scope(\"old-session\") is None\nTrue",
  "is_public": true
}
{
  "path": "app/scope_registry.py",
  "module": "app.scope_registry",
  "qualname": "ScopeRegistry.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 133,
  "col": 4,
  "end_lineno": 138,
  "end_col": 72,
  "parent_qualname": "ScopeRegistry",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "app/scope_registry.py",
  "module": "app.scope_registry",
  "qualname": "ScopeRegistry.set_scope",
  "name": "set_scope",
  "node_type": "FunctionDef",
  "lineno": 140,
  "col": 4,
  "end_lineno": 186,
  "end_col": 9,
  "parent_qualname": "ScopeRegistry",
  "decorators": [],
  "bases": [],
  "docstring": "Store scope for session.\n\nCreates or updates session entry with current timestamp. If session\nalready exists, overwrites previous scope (last-write-wins semantics).\n\nParameters\n----------\nsession_id : str\n    Unique session identifier (typically UUID from middleware).\nscope : ScopeIn\n    Scope configuration to store. May contain repos, branches, globs,\n    languages. Empty dict is valid (means \"no filters\").\n\nExamples\n--------\n>>> registry = ScopeRegistry()\n>>> registry.set_scope(\"session1\", {\"languages\": [\"python\"]})\n>>> registry.set_scope(\"session2\", {\"include_globs\": [\"src/**\"]})\n\nNotes\n-----\nThe method stores a deep copy of the scope dict, preventing subsequent\ncaller mutations from affecting the cached value. Callers may safely\nreuse or modify the original scope object after calling ``set_scope``.",
  "is_public": true
}
{
  "path": "app/scope_registry.py",
  "module": "app.scope_registry",
  "qualname": "ScopeRegistry.get_scope",
  "name": "get_scope",
  "node_type": "FunctionDef",
  "lineno": 188,
  "col": 4,
  "end_lineno": 248,
  "end_col": 29,
  "parent_qualname": "ScopeRegistry",
  "decorators": [],
  "bases": [],
  "docstring": "Retrieve scope for session.\n\nReturns a copy of the stored scope to prevent caller mutations from\naffecting registry state. Updates last-accessed timestamp for LRU\ntracking (accessed sessions are less likely to be pruned).\n\nParameters\n----------\nsession_id : str\n    Session identifier to look up.\n\nReturns\n-------\nScopeIn | None\n    Copy of stored scope if session exists, None otherwise.\n\nExamples\n--------\n>>> registry = ScopeRegistry()\n>>> registry.set_scope(\"session1\", {\"languages\": [\"python\"]})\n>>> scope = registry.get_scope(\"session1\")\n>>> scope\n{'languages': ['python']}\n>>> registry.get_scope(\"nonexistent\") is None\nTrue\n\nNotes\n-----\nReturning None for missing sessions allows adapters to gracefully\nfall back to \"no scope\" behavior without catching exceptions.",
  "is_public": true
}
{
  "path": "app/scope_registry.py",
  "module": "app.scope_registry",
  "qualname": "ScopeRegistry.clear_scope",
  "name": "clear_scope",
  "node_type": "FunctionDef",
  "lineno": 250,
  "col": 4,
  "end_lineno": 291,
  "end_col": 17,
  "parent_qualname": "ScopeRegistry",
  "decorators": [],
  "bases": [],
  "docstring": "Remove scope for session.\n\nDeletes session entry from registry. Subsequent get_scope calls for\nthis session will return None. Clearing non-existent sessions is a\nno-op (does not raise exception).\n\nParameters\n----------\nsession_id : str\n    Session identifier to remove.\n\nExamples\n--------\n>>> registry = ScopeRegistry()\n>>> registry.set_scope(\"session1\", {\"languages\": [\"python\"]})\n>>> registry.clear_scope(\"session1\")\n>>> registry.get_scope(\"session1\") is None\nTrue\n>>> registry.clear_scope(\"nonexistent\")  # No error\n\nNotes\n-----\nThis method is useful for explicit session cleanup (e.g., user logout).\nFor automatic cleanup, use prune_expired() in a background task.",
  "is_public": true
}
{
  "path": "app/scope_registry.py",
  "module": "app.scope_registry",
  "qualname": "ScopeRegistry.prune_expired",
  "name": "prune_expired",
  "node_type": "FunctionDef",
  "lineno": 293,
  "col": 4,
  "end_lineno": 373,
  "end_col": 27,
  "parent_qualname": "ScopeRegistry",
  "decorators": [],
  "bases": [],
  "docstring": "Remove sessions inactive for longer than max_age_seconds.\n\nIterates all sessions and removes those whose last-accessed timestamp\nis older than threshold. This prevents memory leaks from abandoned\nsessions (e.g., clients that crash without cleanup).\n\nThe method is designed to be called from a background task (e.g.,\nevery 10 minutes) rather than on every request for performance.\n\nParameters\n----------\nmax_age_seconds : int\n    Inactivity threshold in seconds. Sessions with (current_time -\n    last_accessed) > max_age_seconds are removed. Typical value: 3600\n    (1 hour).\n\nReturns\n-------\nint\n    Number of sessions pruned.\n\nExamples\n--------\n>>> registry = ScopeRegistry()\n>>> registry.set_scope(\"session1\", {\"languages\": [\"python\"]})\n>>> import time\n>>> time.sleep(2)\n>>> pruned = registry.prune_expired(max_age_seconds=1)\n>>> pruned\n1\n>>> registry.get_scope(\"session1\") is None\nTrue\n\nNotes\n-----\nTime measurement uses time.monotonic() to avoid issues with system\nclock adjustments (e.g., NTP corrections, daylight saving).\n\nFor large session counts (>10K), consider incremental pruning: remove\na fixed number of oldest sessions per invocation rather than iterating\nall sessions at once.",
  "is_public": true
}
{
  "path": "app/scope_registry.py",
  "module": "app.scope_registry",
  "qualname": "ScopeRegistry.get_session_count",
  "name": "get_session_count",
  "node_type": "FunctionDef",
  "lineno": 375,
  "col": 4,
  "end_lineno": 398,
  "end_col": 36,
  "parent_qualname": "ScopeRegistry",
  "decorators": [],
  "bases": [],
  "docstring": "Return number of active sessions.\n\nUseful for monitoring and health checks. If count exceeds threshold\n(e.g., 10,000), it may indicate pruning failure or attack (session\nexhaustion).\n\nReturns\n-------\nint\n    Number of sessions currently in registry.\n\nExamples\n--------\n>>> registry = ScopeRegistry()\n>>> registry.get_session_count()\n0\n>>> registry.set_scope(\"session1\", {})\n>>> registry.set_scope(\"session2\", {})\n>>> registry.get_session_count()\n2",
  "is_public": true
}
{
  "path": "app/scope_store.py",
  "module": "app.scope_store",
  "qualname": "app.scope_store",
  "name": "app.scope_store",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Scope store utilities for session state management.",
  "is_public": true
}
{
  "path": "app/scope_store.py",
  "module": "app.scope_store",
  "qualname": "SupportsAsyncRedis",
  "name": "SupportsAsyncRedis",
  "node_type": "ClassDef",
  "lineno": 23,
  "col": 0,
  "end_lineno": 39,
  "end_col": 43,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "Protocol"
  ],
  "docstring": "Protocol describing the Redis operations required by ``ScopeStore``.",
  "is_public": true
}
{
  "path": "app/scope_store.py",
  "module": "app.scope_store",
  "qualname": "SupportsAsyncRedis.get",
  "name": "get",
  "node_type": "AsyncFunctionDef",
  "lineno": 26,
  "col": 4,
  "end_lineno": 27,
  "end_col": 42,
  "parent_qualname": "SupportsAsyncRedis",
  "decorators": [],
  "bases": [],
  "docstring": "Retrieve a value by ``key``.",
  "is_public": true
}
{
  "path": "app/scope_store.py",
  "module": "app.scope_store",
  "qualname": "SupportsAsyncRedis.setex",
  "name": "setex",
  "node_type": "AsyncFunctionDef",
  "lineno": 29,
  "col": 4,
  "end_lineno": 30,
  "end_col": 72,
  "parent_qualname": "SupportsAsyncRedis",
  "decorators": [],
  "bases": [],
  "docstring": "Set ``key`` to ``value`` with the provided TTL in seconds.",
  "is_public": true
}
{
  "path": "app/scope_store.py",
  "module": "app.scope_store",
  "qualname": "SupportsAsyncRedis.set",
  "name": "set",
  "node_type": "AsyncFunctionDef",
  "lineno": 32,
  "col": 4,
  "end_lineno": 33,
  "end_col": 61,
  "parent_qualname": "SupportsAsyncRedis",
  "decorators": [],
  "bases": [],
  "docstring": "Set ``key`` to ``value`` without TTL semantics.",
  "is_public": true
}
{
  "path": "app/scope_store.py",
  "module": "app.scope_store",
  "qualname": "SupportsAsyncRedis.delete",
  "name": "delete",
  "node_type": "AsyncFunctionDef",
  "lineno": 35,
  "col": 4,
  "end_lineno": 36,
  "end_col": 40,
  "parent_qualname": "SupportsAsyncRedis",
  "decorators": [],
  "bases": [],
  "docstring": "Delete ``key`` if present.",
  "is_public": true
}
{
  "path": "app/scope_store.py",
  "module": "app.scope_store",
  "qualname": "SupportsAsyncRedis.close",
  "name": "close",
  "node_type": "AsyncFunctionDef",
  "lineno": 38,
  "col": 4,
  "end_lineno": 39,
  "end_col": 43,
  "parent_qualname": "SupportsAsyncRedis",
  "decorators": [],
  "bases": [],
  "docstring": "Close open Redis connections.",
  "is_public": true
}
{
  "path": "app/scope_store.py",
  "module": "app.scope_store",
  "qualname": "_CacheRecord",
  "name": "_CacheRecord",
  "node_type": "ClassDef",
  "lineno": 43,
  "col": 0,
  "end_lineno": 47,
  "end_col": 22,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Internal cache record containing a value and its insertion timestamp.",
  "is_public": false
}
{
  "path": "app/scope_store.py",
  "module": "app.scope_store",
  "qualname": "LRUCache",
  "name": "LRUCache",
  "node_type": "ClassDef",
  "lineno": 50,
  "col": 0,
  "end_lineno": 232,
  "end_col": 53,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Thread-safe least-recently-used cache with TTL-based eviction.\n\nParameters\n----------\nmaxsize : int, optional\n    Maximum number of entries to retain. Must be positive.\nttl_seconds : float | None, optional\n    Time-to-live for each entry in seconds. When ``None``, entries never\n    expire due to age.\nnow_fn : Callable[[], float], optional\n    Injectable monotonic time source, primarily for testing. Defaults to\n    ``time.monotonic``.\n\nRaises\n------\nValueError\n    If ``maxsize`` is not positive or if ``ttl_seconds`` is provided but\n    not positive (when not ``None``).",
  "is_public": true
}
{
  "path": "app/scope_store.py",
  "module": "app.scope_store",
  "qualname": "LRUCache.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 71,
  "col": 4,
  "end_lineno": 90,
  "end_col": 76,
  "parent_qualname": "LRUCache",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "app/scope_store.py",
  "module": "app.scope_store",
  "qualname": "LRUCache.get",
  "name": "get",
  "node_type": "FunctionDef",
  "lineno": 92,
  "col": 4,
  "end_lineno": 116,
  "end_col": 31,
  "parent_qualname": "LRUCache",
  "decorators": [],
  "bases": [],
  "docstring": "Return the cached value for ``key`` or ``None`` if it is missing or stale.\n\nParameters\n----------\nkey : KeyT\n    Cache key to retrieve.\n\nReturns\n-------\nValueT | None\n    Cached value when present and not expired; otherwise ``None``.",
  "is_public": true
}
{
  "path": "app/scope_store.py",
  "module": "app.scope_store",
  "qualname": "LRUCache.set",
  "name": "set",
  "node_type": "FunctionDef",
  "lineno": 118,
  "col": 4,
  "end_lineno": 125,
  "end_col": 32,
  "parent_qualname": "LRUCache",
  "decorators": [],
  "bases": [],
  "docstring": "Insert or update ``key`` with ``value`` and refresh its recency.",
  "is_public": true
}
{
  "path": "app/scope_store.py",
  "module": "app.scope_store",
  "qualname": "LRUCache.delete",
  "name": "delete",
  "node_type": "FunctionDef",
  "lineno": 127,
  "col": 4,
  "end_lineno": 130,
  "end_col": 38,
  "parent_qualname": "LRUCache",
  "decorators": [],
  "bases": [],
  "docstring": "Remove ``key`` from the cache if present.",
  "is_public": true
}
{
  "path": "app/scope_store.py",
  "module": "app.scope_store",
  "qualname": "LRUCache.clear",
  "name": "clear",
  "node_type": "FunctionDef",
  "lineno": 132,
  "col": 4,
  "end_lineno": 135,
  "end_col": 31,
  "parent_qualname": "LRUCache",
  "decorators": [],
  "bases": [],
  "docstring": "Remove all entries from the cache.",
  "is_public": true
}
{
  "path": "app/scope_store.py",
  "module": "app.scope_store",
  "qualname": "LRUCache.__contains__",
  "name": "__contains__",
  "node_type": "FunctionDef",
  "lineno": 137,
  "col": 4,
  "end_lineno": 164,
  "end_col": 23,
  "parent_qualname": "LRUCache",
  "decorators": [],
  "bases": [],
  "docstring": "Return ``True`` when ``key`` is present and not expired.\n\nParameters\n----------\nkey : object\n    Candidate cache key.\n\nReturns\n-------\nbool\n    ``True`` if the key exists and has not expired; otherwise ``False``.",
  "is_public": false
}
{
  "path": "app/scope_store.py",
  "module": "app.scope_store",
  "qualname": "LRUCache.__len__",
  "name": "__len__",
  "node_type": "FunctionDef",
  "lineno": 166,
  "col": 4,
  "end_lineno": 177,
  "end_col": 35,
  "parent_qualname": "LRUCache",
  "decorators": [],
  "bases": [],
  "docstring": "Return the number of live entries in the cache.\n\nReturns\n-------\nint\n    Count of entries that have not expired.",
  "is_public": false
}
{
  "path": "app/scope_store.py",
  "module": "app.scope_store",
  "qualname": "LRUCache.items",
  "name": "items",
  "node_type": "FunctionDef",
  "lineno": 179,
  "col": 4,
  "end_lineno": 194,
  "end_col": 39,
  "parent_qualname": "LRUCache",
  "decorators": [],
  "bases": [],
  "docstring": "Yield current cache entries, purging expired ones as needed.\n\nYields\n------\ntuple[KeyT, ValueT]\n    Key-value pairs for each live cache entry in LRU order.",
  "is_public": true
}
{
  "path": "app/scope_store.py",
  "module": "app.scope_store",
  "qualname": "LRUCache.snapshot",
  "name": "snapshot",
  "node_type": "FunctionDef",
  "lineno": 196,
  "col": 4,
  "end_lineno": 207,
  "end_col": 90,
  "parent_qualname": "LRUCache",
  "decorators": [],
  "bases": [],
  "docstring": "Return a shallow copy of the cache contents.\n\nReturns\n-------\nMutableMapping[KeyT, ValueT]\n    Ordered mapping containing live cache entries.",
  "is_public": true
}
{
  "path": "app/scope_store.py",
  "module": "app.scope_store",
  "qualname": "LRUCache._enforce_size",
  "name": "_enforce_size",
  "node_type": "FunctionDef",
  "lineno": 209,
  "col": 4,
  "end_lineno": 211,
  "end_col": 43,
  "parent_qualname": "LRUCache",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "app/scope_store.py",
  "module": "app.scope_store",
  "qualname": "LRUCache._purge_expired_entries",
  "name": "_purge_expired_entries",
  "node_type": "FunctionDef",
  "lineno": 213,
  "col": 4,
  "end_lineno": 222,
  "end_col": 38,
  "parent_qualname": "LRUCache",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "app/scope_store.py",
  "module": "app.scope_store",
  "qualname": "LRUCache._is_expired",
  "name": "_is_expired",
  "node_type": "FunctionDef",
  "lineno": 224,
  "col": 4,
  "end_lineno": 227,
  "end_col": 65,
  "parent_qualname": "LRUCache",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "app/scope_store.py",
  "module": "app.scope_store",
  "qualname": "LRUCache._has_expired",
  "name": "_has_expired",
  "node_type": "FunctionDef",
  "lineno": 229,
  "col": 4,
  "end_lineno": 232,
  "end_col": 53,
  "parent_qualname": "LRUCache",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "app/scope_store.py",
  "module": "app.scope_store",
  "qualname": "AsyncSingleFlight",
  "name": "AsyncSingleFlight",
  "node_type": "ClassDef",
  "lineno": 235,
  "col": 0,
  "end_lineno": 271,
  "end_col": 45,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Deduplicate concurrent coroutine execution keyed by ``KeyT``.",
  "is_public": true
}
{
  "path": "app/scope_store.py",
  "module": "app.scope_store",
  "qualname": "AsyncSingleFlight.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 238,
  "col": 4,
  "end_lineno": 240,
  "end_col": 63,
  "parent_qualname": "AsyncSingleFlight",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "app/scope_store.py",
  "module": "app.scope_store",
  "qualname": "AsyncSingleFlight.do",
  "name": "do",
  "node_type": "AsyncFunctionDef",
  "lineno": 242,
  "col": 4,
  "end_lineno": 264,
  "end_col": 45,
  "parent_qualname": "AsyncSingleFlight",
  "decorators": [],
  "bases": [],
  "docstring": "Execute ``fn`` once for all concurrent callers associated with ``key``.\n\nParameters\n----------\nkey : KeyT\n    Deduplication key.\nfn : Callable[[], Awaitable[ValueT]]\n    Awaitable factory executed at most once while in-flight for ``key``.\n\nReturns\n-------\nValueT\n    Result produced by ``fn``.",
  "is_public": true
}
{
  "path": "app/scope_store.py",
  "module": "app.scope_store",
  "qualname": "AsyncSingleFlight._execute",
  "name": "_execute",
  "node_type": "AsyncFunctionDef",
  "lineno": 266,
  "col": 4,
  "end_lineno": 271,
  "end_col": 45,
  "parent_qualname": "AsyncSingleFlight",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "app/scope_store.py",
  "module": "app.scope_store",
  "qualname": "ScopeStoreMetrics",
  "name": "ScopeStoreMetrics",
  "node_type": "ClassDef",
  "lineno": 275,
  "col": 0,
  "end_lineno": 375,
  "end_col": 9,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Runtime counters describing scope store cache performance.",
  "is_public": true
}
{
  "path": "app/scope_store.py",
  "module": "app.scope_store",
  "qualname": "ScopeStoreMetrics.record_l1_hit",
  "name": "record_l1_hit",
  "node_type": "FunctionDef",
  "lineno": 283,
  "col": 4,
  "end_lineno": 297,
  "end_col": 9,
  "parent_qualname": "ScopeStoreMetrics",
  "decorators": [],
  "bases": [],
  "docstring": "Return a new metrics instance with an incremented L1 hit counter.\n\nReturns\n-------\nScopeStoreMetrics\n    Fresh metrics snapshot reflecting the increment.",
  "is_public": true
}
{
  "path": "app/scope_store.py",
  "module": "app.scope_store",
  "qualname": "ScopeStoreMetrics.record_l1_miss",
  "name": "record_l1_miss",
  "node_type": "FunctionDef",
  "lineno": 299,
  "col": 4,
  "end_lineno": 313,
  "end_col": 9,
  "parent_qualname": "ScopeStoreMetrics",
  "decorators": [],
  "bases": [],
  "docstring": "Return a new metrics instance with an incremented L1 miss counter.\n\nReturns\n-------\nScopeStoreMetrics\n    Fresh metrics snapshot reflecting the increment.",
  "is_public": true
}
{
  "path": "app/scope_store.py",
  "module": "app.scope_store",
  "qualname": "ScopeStoreMetrics.record_l2_hit",
  "name": "record_l2_hit",
  "node_type": "FunctionDef",
  "lineno": 315,
  "col": 4,
  "end_lineno": 329,
  "end_col": 9,
  "parent_qualname": "ScopeStoreMetrics",
  "decorators": [],
  "bases": [],
  "docstring": "Return a new metrics instance with an incremented L2 hit counter.\n\nReturns\n-------\nScopeStoreMetrics\n    Fresh metrics snapshot reflecting the increment.",
  "is_public": true
}
{
  "path": "app/scope_store.py",
  "module": "app.scope_store",
  "qualname": "ScopeStoreMetrics.record_l2_miss",
  "name": "record_l2_miss",
  "node_type": "FunctionDef",
  "lineno": 331,
  "col": 4,
  "end_lineno": 345,
  "end_col": 9,
  "parent_qualname": "ScopeStoreMetrics",
  "decorators": [],
  "bases": [],
  "docstring": "Return a new metrics instance with an incremented L2 miss counter.\n\nReturns\n-------\nScopeStoreMetrics\n    Fresh metrics snapshot reflecting the increment.",
  "is_public": true
}
{
  "path": "app/scope_store.py",
  "module": "app.scope_store",
  "qualname": "ScopeStoreMetrics.l1_hit_rate",
  "name": "l1_hit_rate",
  "node_type": "FunctionDef",
  "lineno": 348,
  "col": 4,
  "end_lineno": 351,
  "end_col": 53,
  "parent_qualname": "ScopeStoreMetrics",
  "decorators": [
    "property"
  ],
  "bases": [],
  "docstring": "Return the L1 hit rate as a floating point ratio.",
  "is_public": true
}
{
  "path": "app/scope_store.py",
  "module": "app.scope_store",
  "qualname": "ScopeStoreMetrics.l2_hit_rate",
  "name": "l2_hit_rate",
  "node_type": "FunctionDef",
  "lineno": 354,
  "col": 4,
  "end_lineno": 357,
  "end_col": 53,
  "parent_qualname": "ScopeStoreMetrics",
  "decorators": [
    "property"
  ],
  "bases": [],
  "docstring": "Return the L2 hit rate as a floating point ratio.",
  "is_public": true
}
{
  "path": "app/scope_store.py",
  "module": "app.scope_store",
  "qualname": "ScopeStoreMetrics.as_dict",
  "name": "as_dict",
  "node_type": "FunctionDef",
  "lineno": 359,
  "col": 4,
  "end_lineno": 375,
  "end_col": 9,
  "parent_qualname": "ScopeStoreMetrics",
  "decorators": [],
  "bases": [],
  "docstring": "Return a serialisable snapshot of the metrics.\n\nReturns\n-------\ndict[str, float | int]\n    Dictionary containing counters and hit rates.",
  "is_public": true
}
{
  "path": "app/scope_store.py",
  "module": "app.scope_store",
  "qualname": "ScopeStore",
  "name": "ScopeStore",
  "node_type": "ClassDef",
  "lineno": 378,
  "col": 0,
  "end_lineno": 535,
  "end_col": 20,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Redis-backed scope store with L1/L2 caching and single-flight coalescing.",
  "is_public": true
}
{
  "path": "app/scope_store.py",
  "module": "app.scope_store",
  "qualname": "ScopeStore.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 381,
  "col": 4,
  "end_lineno": 399,
  "end_col": 37,
  "parent_qualname": "ScopeStore",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "app/scope_store.py",
  "module": "app.scope_store",
  "qualname": "ScopeStore.metrics",
  "name": "metrics",
  "node_type": "FunctionDef",
  "lineno": 402,
  "col": 4,
  "end_lineno": 404,
  "end_col": 28,
  "parent_qualname": "ScopeStore",
  "decorators": [
    "property"
  ],
  "bases": [],
  "docstring": "Return live cache metrics.",
  "is_public": true
}
{
  "path": "app/scope_store.py",
  "module": "app.scope_store",
  "qualname": "ScopeStore.get",
  "name": "get",
  "node_type": "AsyncFunctionDef",
  "lineno": 406,
  "col": 4,
  "end_lineno": 435,
  "end_col": 89,
  "parent_qualname": "ScopeStore",
  "decorators": [],
  "bases": [],
  "docstring": "Retrieve scope for ``session_id``, favouring the L1 cache.\n\nParameters\n----------\nsession_id : str\n    Session identifier to retrieve.\n\nReturns\n-------\nScopeIn | None\n    Scope data when present; otherwise ``None``.\n\nRaises\n------\nValueError\n    If ``session_id`` is empty.",
  "is_public": true
}
{
  "path": "app/scope_store.py",
  "module": "app.scope_store",
  "qualname": "ScopeStore.set",
  "name": "set",
  "node_type": "AsyncFunctionDef",
  "lineno": 437,
  "col": 4,
  "end_lineno": 468,
  "end_col": 41,
  "parent_qualname": "ScopeStore",
  "decorators": [],
  "bases": [],
  "docstring": "Persist scope for ``session_id`` in both caches.\n\nParameters\n----------\nsession_id : str\n    Session identifier to update.\nscope : ScopeIn\n    Scope payload to cache.\n\nRaises\n------\nValueError\n    If ``session_id`` is empty.",
  "is_public": true
}
{
  "path": "app/scope_store.py",
  "module": "app.scope_store",
  "qualname": "ScopeStore.delete",
  "name": "delete",
  "node_type": "AsyncFunctionDef",
  "lineno": 470,
  "col": 4,
  "end_lineno": 489,
  "end_col": 61,
  "parent_qualname": "ScopeStore",
  "decorators": [],
  "bases": [],
  "docstring": "Remove cached scope for ``session_id`` from both layers.\n\nParameters\n----------\nsession_id : str\n    Session identifier to remove.\n\nRaises\n------\nValueError\n    If ``session_id`` is empty.",
  "is_public": true
}
{
  "path": "app/scope_store.py",
  "module": "app.scope_store",
  "qualname": "ScopeStore.evict_l1",
  "name": "evict_l1",
  "node_type": "FunctionDef",
  "lineno": 491,
  "col": 4,
  "end_lineno": 509,
  "end_col": 35,
  "parent_qualname": "ScopeStore",
  "decorators": [],
  "bases": [],
  "docstring": "Remove ``session_id`` from the L1 cache only.\n\nParameters\n----------\nsession_id : str\n    Session identifier to evict.\n\nRaises\n------\nValueError\n    If ``session_id`` is empty.",
  "is_public": true
}
{
  "path": "app/scope_store.py",
  "module": "app.scope_store",
  "qualname": "ScopeStore.close",
  "name": "close",
  "node_type": "AsyncFunctionDef",
  "lineno": 511,
  "col": 4,
  "end_lineno": 513,
  "end_col": 33,
  "parent_qualname": "ScopeStore",
  "decorators": [],
  "bases": [],
  "docstring": "Close underlying Redis resources.",
  "is_public": true
}
{
  "path": "app/scope_store.py",
  "module": "app.scope_store",
  "qualname": "ScopeStore._redis_key",
  "name": "_redis_key",
  "node_type": "FunctionDef",
  "lineno": 515,
  "col": 4,
  "end_lineno": 516,
  "end_col": 49,
  "parent_qualname": "ScopeStore",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "app/scope_store.py",
  "module": "app.scope_store",
  "qualname": "ScopeStore._fetch_from_l2",
  "name": "_fetch_from_l2",
  "node_type": "AsyncFunctionDef",
  "lineno": 518,
  "col": 4,
  "end_lineno": 535,
  "end_col": 20,
  "parent_qualname": "ScopeStore",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "app/serve_hypercorn.py",
  "module": "app.serve_hypercorn",
  "qualname": "app.serve_hypercorn",
  "name": "app.serve_hypercorn",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Hypercorn runner with graceful signal handling.\n\nExposes helpers so deployments (systemd, tests, dev scripts) can start the\nASGI stack without relying on shell-specific wrappers.",
  "is_public": true
}
{
  "path": "app/serve_hypercorn.py",
  "module": "app.serve_hypercorn",
  "qualname": "_load_config",
  "name": "_load_config",
  "node_type": "FunctionDef",
  "lineno": 28,
  "col": 0,
  "end_lineno": 47,
  "end_col": 17,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return a Hypercorn :class:`Config` from the given TOML path.\n\nParameters\n----------\nconfig_path : str | None, optional\n    Optional override path to the Hypercorn TOML file. When omitted,\n    falls back to ``HYPERCORN_CONFIG`` or the repo-default path.\n\nReturns\n-------\nConfig\n    Config loaded from the resolved TOML path (or defaults when absent).",
  "is_public": false
}
{
  "path": "app/serve_hypercorn.py",
  "module": "app.serve_hypercorn",
  "qualname": "_build_shutdown_trigger",
  "name": "_build_shutdown_trigger",
  "node_type": "FunctionDef",
  "lineno": 50,
  "col": 0,
  "end_lineno": 64,
  "end_col": 36,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Create an asyncio event and shutdown trigger callable.\n\nReturns\n-------\ntuple[asyncio.Event, ShutdownTrigger]\n    Tuple containing the event to signal shutdown and the trigger callable\n    passed to Hypercorn's ``shutdown_trigger`` hook.",
  "is_public": false
}
{
  "path": "app/serve_hypercorn.py",
  "module": "app.serve_hypercorn",
  "qualname": "_build_shutdown_trigger._wait_for_shutdown",
  "name": "_wait_for_shutdown",
  "node_type": "AsyncFunctionDef",
  "lineno": 61,
  "col": 4,
  "end_lineno": 62,
  "end_col": 26,
  "parent_qualname": "_build_shutdown_trigger",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "app/serve_hypercorn.py",
  "module": "app.serve_hypercorn",
  "qualname": "serve_app",
  "name": "serve_app",
  "node_type": "AsyncFunctionDef",
  "lineno": 67,
  "col": 0,
  "end_lineno": 85,
  "end_col": 72,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Run Hypercorn with signal-aware shutdown semantics.",
  "is_public": true
}
{
  "path": "app/serve_hypercorn.py",
  "module": "app.serve_hypercorn",
  "qualname": "serve_app._set_event",
  "name": "_set_event",
  "node_type": "FunctionDef",
  "lineno": 80,
  "col": 12,
  "end_lineno": 82,
  "end_col": 27,
  "parent_qualname": "serve_app",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "app/serve_hypercorn.py",
  "module": "app.serve_hypercorn",
  "qualname": "main",
  "name": "main",
  "node_type": "FunctionDef",
  "lineno": 88,
  "col": 0,
  "end_lineno": 91,
  "end_col": 84,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Execute Hypercorn with the repo default configuration.",
  "is_public": true
}
{
  "path": "app/server_settings.py",
  "module": "app.server_settings",
  "qualname": "app.server_settings",
  "name": "app.server_settings",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Server-facing configuration for FastAPI + Hypercorn deployment.\n\nThis module centralizes HTTP listener parameters, CORS defaults, and proxy\ntrust knobs so deployments can be tuned via environment variables (or a\n``.env`` file) without touching application code. The settings are consumed\nby :mod:`codeintel_rev.app.main` when constructing the FastAPI application\nand when exporting the Hypercorn-facing ASGI callable.",
  "is_public": true
}
{
  "path": "app/server_settings.py",
  "module": "app.server_settings",
  "qualname": "ServerSettings",
  "name": "ServerSettings",
  "node_type": "ClassDef",
  "lineno": 19,
  "col": 0,
  "end_lineno": 102,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "BaseSettings"
  ],
  "docstring": "Container for server/network level toggles.\n\nThis class centralizes HTTP listener parameters, CORS defaults, and proxy\ntrust knobs for FastAPI + Hypercorn deployment. Settings are loaded from\nenvironment variables (with CODEINTEL_SERVER_ prefix) or a .env file.\nThe settings are consumed by the FastAPI application and Hypercorn ASGI\ncallable for server configuration.\n\nAttributes\n----------\nhost : str\n    Bind address used for local development (default: \"127.0.0.1\"). In\n    production Hypercorn typically listens on loopback while NGINX\n    terminates TLS/QUIC.\nport : int\n    Application port when Hypercorn listens directly (default: 8080).\n    Used for Topology A deployments where Hypercorn is the direct listener.\nallowed_hosts : list[str]\n    Hostnames accepted by TrustedHostMiddleware (default: [\"localhost\", \"127.0.0.1\"]).\n    Include public domains (e.g., \"mcp.example.com\") when running behind NGINX.\ncors_allow_origins : list[str]\n    Origins permitted by the CORS middleware (default: [\"https://chat.openai.com\", \"http://localhost:3000\"]).\n    Defaults to ChatGPT and localhost for local UI experiments.\ncors_allow_methods : list[str]\n    HTTP verbs allowed via CORS preflight responses (default: [\"*\"]).\n    Keeps the configuration permissive while tooling evolves.\ncors_allow_headers : list[str]\n    Headers allowed via CORS (default: [\"*\"]). Permissive default for\n    development and tooling compatibility.\ncors_allow_credentials : bool\n    Whether to allow credentials in CORS requests (default: True).\n    Enables cookies and authentication headers in cross-origin requests.\nenable_trusted_hosts : bool\n    When True (default), the FastAPI app installs TrustedHostMiddleware.\n    Validates Host headers against allowed_hosts to prevent host header\n    injection attacks.\nenable_proxy_fix : bool\n    When True (default), the exported ASGI object is wrapped with\n    ProxyFixMiddleware so scheme/host/client information from NGINX\n    is honored. Required when running behind a reverse proxy.\nproxy_mode : Literal[\"legacy\", \"modern\"]\n    ProxyFix mode (default: \"modern\"). \"modern\" reads the standardized\n    Forwarded header; \"legacy\" falls back to X-Forwarded-* headers.\nproxy_trusted_hops : int\n    Number of proxy hops to trust when parsing Forwarded headers (default: 1).\n    Used by ProxyFixMiddleware to validate proxy chain length.\ndomain : str | None\n    Canonical domain used in docs/runbooks (default: None). Does not affect\n    runtime behavior but avoids duplicating values elsewhere. Optional\n    metadata field for documentation purposes.\nmodel_config : ClassVar[SettingsConfigDict]\n    Pydantic settings configuration dict. Configures pydantic-settings to\n    load from .env (if present) and to use the CODEINTEL_SERVER_ prefix\n    for environment variables. Also sets env_file_encoding to utf-8 and\n    extra to \"ignore\". The attribute is assigned a SettingsConfigDict instance\n    with env_file, env_file_encoding, env_prefix, and extra settings.\n    This is a class variable (ClassVar) used by Pydantic BaseSettings.",
  "is_public": true
}
{
  "path": "app/server_settings.py",
  "module": "app.server_settings",
  "qualname": "get_server_settings",
  "name": "get_server_settings",
  "node_type": "FunctionDef",
  "lineno": 106,
  "col": 0,
  "end_lineno": 117,
  "end_col": 27,
  "parent_qualname": null,
  "decorators": [
    "lru_cache"
  ],
  "bases": [],
  "docstring": "Return (and cache) :class:`ServerSettings` for reuse.\n\nThe LRU cache ensures settings are parsed only once per interpreter run,\nmirroring FastAPI's preferred configuration pattern.\n\nReturns\n-------\nServerSettings\n    Parsed configuration object.",
  "is_public": true
}
{
  "path": "bin/__init__.py",
  "module": "bin",
  "qualname": "bin",
  "name": "bin",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "CLI entry points for CodeIntel MCP indexing pipelines.",
  "is_public": true
}
{
  "path": "bin/eval_coverage.py",
  "module": "bin.eval_coverage",
  "qualname": "bin.eval_coverage",
  "name": "bin.eval_coverage",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Command-line entry point for SCIP function coverage evaluation.",
  "is_public": true
}
{
  "path": "bin/eval_coverage.py",
  "module": "bin.eval_coverage",
  "qualname": "build_parser",
  "name": "build_parser",
  "node_type": "FunctionDef",
  "lineno": 19,
  "col": 0,
  "end_lineno": 43,
  "end_col": 17,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return an argument parser for the coverage evaluator CLI.\n\nReturns\n-------\nargparse.ArgumentParser\n    Configured argument parser with --k, --limit, and --output options.",
  "is_public": true
}
{
  "path": "bin/eval_coverage.py",
  "module": "bin.eval_coverage",
  "qualname": "main",
  "name": "main",
  "node_type": "FunctionDef",
  "lineno": 46,
  "col": 0,
  "end_lineno": 90,
  "end_col": 12,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Execute the coverage evaluator with the provided CLI arguments.\n\nExtended Summary\n----------------\nThis CLI entry point runs SCIP function coverage evaluation across FAISS\nretrieval results. It fetches symbol definitions from the DuckDB catalog,\nperforms FAISS searches for each symbol, and computes coverage metrics\n(how many symbols are retrievable at top-k). Results are written to\noutput directory as JSON reports.\n\nParameters\n----------\nargv : list[str] | None, optional\n    Command-line arguments. If None, uses `sys.argv[1:]`. Arguments are\n    parsed by `build_parser()`: --k (top-k), --limit (symbol limit),\n    --output (output directory).\n\nReturns\n-------\nint\n    Exit code: 0 on success, non-zero on error (e.g., missing context,\n    evaluation failures).\n\nNotes\n-----\nThis tool requires an active ApplicationContext with FAISS manager and\nDuckDB catalog initialized. Coverage evaluation iterates over symbol\ndefinitions and performs FAISS searches, so runtime scales with symbol\ncount and search latency. Time complexity: O(n_symbols * search_time).",
  "is_public": true
}
{
  "path": "bin/eval_offline.py",
  "module": "bin.eval_offline",
  "qualname": "bin.eval_offline",
  "name": "bin.eval_offline",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Command-line entry point for offline FAISS recall evaluation.",
  "is_public": true
}
{
  "path": "bin/eval_offline.py",
  "module": "bin.eval_offline",
  "qualname": "build_parser",
  "name": "build_parser",
  "node_type": "FunctionDef",
  "lineno": 17,
  "col": 0,
  "end_lineno": 38,
  "end_col": 17,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return an argument parser for the offline evaluator CLI.\n\nReturns\n-------\nargparse.ArgumentParser\n    Configured argument parser with --queries and --output options.",
  "is_public": true
}
{
  "path": "bin/eval_offline.py",
  "module": "bin.eval_offline",
  "qualname": "main",
  "name": "main",
  "node_type": "FunctionDef",
  "lineno": 41,
  "col": 0,
  "end_lineno": 80,
  "end_col": 12,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Execute the evaluator using CLI arguments.\n\nExtended Summary\n----------------\nThis CLI entry point runs offline FAISS recall evaluation. It loads queries\n(from file or synthesizes them), performs FAISS searches, computes recall\nagainst ground truth, and writes evaluation reports. Used for validating\nindex quality and tuning search parameters.\n\nParameters\n----------\nargv : list[str] | None, optional\n    Command-line arguments. If None, uses `sys.argv[1:]`. Arguments are\n    parsed by `build_parser()`: --queries (query file path), --output\n    (output directory).\n\nReturns\n-------\nint\n    Exit code: 0 on success, 1 on error (e.g., evaluator disabled, missing\n    context, evaluation failures).\n\nNotes\n-----\nThis tool requires an active ApplicationContext with offline recall evaluator\nenabled. Evaluation performs searches and computes recall metrics, so runtime\nscales with query count and search latency. Time complexity: O(n_queries * search_time).",
  "is_public": true
}
{
  "path": "bin/index_all.py",
  "module": "bin.index_all",
  "qualname": "bin.index_all",
  "name": "bin.index_all",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "One-shot indexing: SCIP  chunk  embed  Parquet  FAISS.\n\nThis script orchestrates the full indexing pipeline:\n1. Parse SCIP index for symbol definitions\n2. Chunk files using cAST (SCIP-based)\n3. Embed chunks with vLLM\n4. Write to Parquet with embeddings\n5. Build FAISS index with adaptive type selection\n\nThe FAISS index type is automatically selected based on corpus size:\n- Small (<5K vectors): Flat index (exact search, fast training)\n- Medium (5K-50K vectors): IVFFlat (balanced training/recall)\n- Large (>50K vectors): IVF-PQ (memory efficient, fast search)",
  "is_public": true
}
{
  "path": "bin/index_all.py",
  "module": "bin.index_all",
  "qualname": "PipelinePaths",
  "name": "PipelinePaths",
  "node_type": "ClassDef",
  "lineno": 64,
  "col": 0,
  "end_lineno": 71,
  "end_col": 21,
  "parent_qualname": null,
  "decorators": [
    "dataclass(frozen=True)"
  ],
  "bases": [],
  "docstring": "Resolved filesystem paths for the indexing pipeline.",
  "is_public": true
}
{
  "path": "bin/index_all.py",
  "module": "bin.index_all",
  "qualname": "main",
  "name": "main",
  "node_type": "FunctionDef",
  "lineno": 74,
  "col": 0,
  "end_lineno": 146,
  "end_col": 67,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Run the end-to-end indexing pipeline.\n\nSupports both full rebuild (default) and incremental update modes.\nUse --incremental to add new chunks to an existing index instead of rebuilding.",
  "is_public": true
}
{
  "path": "bin/index_all.py",
  "module": "bin.index_all",
  "qualname": "_resolve_paths",
  "name": "_resolve_paths",
  "node_type": "FunctionDef",
  "lineno": 149,
  "col": 0,
  "end_lineno": 176,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Resolve and normalize key filesystem paths.\n\nParameters\n----------\nsettings : Settings\n    Application settings containing path configuration.\n\nReturns\n-------\nPipelinePaths\n    Absolute paths for all filesystem locations used by the pipeline.",
  "is_public": false
}
{
  "path": "bin/index_all.py",
  "module": "bin.index_all",
  "qualname": "_resolve_paths._resolve",
  "name": "_resolve",
  "node_type": "FunctionDef",
  "lineno": 164,
  "col": 4,
  "end_lineno": 168,
  "end_col": 43,
  "parent_qualname": "_resolve_paths",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "bin/index_all.py",
  "module": "bin.index_all",
  "qualname": "_load_scip_index",
  "name": "_load_scip_index",
  "node_type": "FunctionDef",
  "lineno": 179,
  "col": 0,
  "end_lineno": 203,
  "end_col": 16,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Load and parse the SCIP index from disk.\n\nParameters\n----------\npaths : PipelinePaths\n    Pipeline paths configuration containing SCIP index location.\n\nReturns\n-------\nSCIPIndex\n    Parsed SCIP index containing all documents and occurrences.\n\nRaises\n------\nFileNotFoundError\n    If the configured SCIP index file does not exist.",
  "is_public": false
}
{
  "path": "bin/index_all.py",
  "module": "bin.index_all",
  "qualname": "_group_definitions_by_file",
  "name": "_group_definitions_by_file",
  "node_type": "FunctionDef",
  "lineno": 206,
  "col": 0,
  "end_lineno": 224,
  "end_col": 18,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Group symbol definitions by their relative file path.\n\nParameters\n----------\nindex : SCIPIndex\n    SCIP index containing symbol definitions.\n\nReturns\n-------\nMapping[str, list[SymbolDef]]\n    Definitions grouped by file path for downstream chunking.",
  "is_public": false
}
{
  "path": "bin/index_all.py",
  "module": "bin.index_all",
  "qualname": "_chunk_repository",
  "name": "_chunk_repository",
  "node_type": "FunctionDef",
  "lineno": 227,
  "col": 0,
  "end_lineno": 276,
  "end_col": 17,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Chunk all files referenced by the SCIP index.\n\nParameters\n----------\npaths : PipelinePaths\n    Pipeline paths configuration.\ndefinitions_by_file : Mapping[str, Sequence[SymbolDef]]\n    Symbol definitions grouped by file path.\nbudget : int\n    Character budget per chunk.\n\nReturns\n-------\nlist[Chunk]\n    Collection of generated chunks across the repository.",
  "is_public": false
}
{
  "path": "bin/index_all.py",
  "module": "bin.index_all",
  "qualname": "_embed_chunks",
  "name": "_embed_chunks",
  "node_type": "FunctionDef",
  "lineno": 279,
  "col": 0,
  "end_lineno": 306,
  "end_col": 18,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Generate embeddings for the supplied chunks using vLLM.\n\nParameters\n----------\nchunks : Sequence[Chunk]\n    Chunks to embed.\nsettings : Settings\n    Application settings (provider + embedding config).\n\nReturns\n-------\nNDArrayF32\n    Embedding matrix aligned with the chunk order.",
  "is_public": false
}
{
  "path": "bin/index_all.py",
  "module": "bin.index_all",
  "qualname": "_write_parquet",
  "name": "_write_parquet",
  "node_type": "FunctionDef",
  "lineno": 309,
  "col": 0,
  "end_lineno": 349,
  "end_col": 22,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Persist chunk metadata and embeddings to Parquet.\n\nParameters\n----------\nchunks : Sequence[Chunk]\n    Chunks to persist.\nembeddings : NDArrayF32\n    Embedding vectors aligned with chunks.\npaths : PipelinePaths\n    Pipeline paths configuration.\nvec_dim : int\n    Embedding vector dimension.\npreview_max_chars : int\n    Maximum number of characters to persist in chunk previews.\n\nReturns\n-------\nPath\n    Path to the written Parquet file containing chunk data.",
  "is_public": false
}
{
  "path": "bin/index_all.py",
  "module": "bin.index_all",
  "qualname": "_build_faiss_index",
  "name": "_build_faiss_index",
  "node_type": "FunctionDef",
  "lineno": 352,
  "col": 0,
  "end_lineno": 410,
  "end_col": 65,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Train and persist the FAISS index with adaptive type selection.\n\nThe index type is automatically selected based on corpus size for optimal\nperformance. Small corpora use flat indexes (fast training), medium corpora\nuse IVFFlat (balanced), and large corpora use IVF-PQ (memory efficient).\n\nParameters\n----------\nembeddings : NDArrayF32\n    Embedding vectors to index.\npaths : PipelinePaths\n    Pipeline paths configuration.\nindex_config : IndexConfig\n    FAISS index configuration.\n\nRaises\n------\nRuntimeError\n    If embeddings are empty and the index cannot be trained.",
  "is_public": false
}
{
  "path": "bin/index_all.py",
  "module": "bin.index_all",
  "qualname": "_update_faiss_index_incremental",
  "name": "_update_faiss_index_incremental",
  "node_type": "FunctionDef",
  "lineno": 413,
  "col": 0,
  "end_lineno": 519,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Update FAISS index incrementally by adding new chunks to secondary index.\n\nLoads existing primary index and identifies new chunks that aren't already\nindexed. Adds new chunks to the secondary flat index for fast incremental\nupdates without rebuilding the primary index.\n\nParameters\n----------\nchunks : Sequence[Chunk]\n    All chunks from the current indexing run.\nembeddings : NDArrayF32\n    Embedding vectors aligned with chunks.\npaths : PipelinePaths\n    Pipeline paths configuration.\nindex_config : IndexConfig\n    FAISS index configuration.\n\nRaises\n------\nFileNotFoundError\n    If the primary index does not exist. Use full rebuild mode first.\nRuntimeError\n    If embeddings are empty or index loading fails.",
  "is_public": false
}
{
  "path": "bin/index_all.py",
  "module": "bin.index_all",
  "qualname": "_runtime_options_from_index",
  "name": "_runtime_options_from_index",
  "node_type": "FunctionDef",
  "lineno": 522,
  "col": 0,
  "end_lineno": 570,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return FAISS runtime options derived from the active index configuration.\n\nExtended Summary\n----------------\nThis helper converts structured IndexConfig (from index manifest or settings)\ninto FAISS-specific runtime options. It maps configuration parameters (family,\nPQ settings, HNSW parameters, GPU options) to FAISSRuntimeOptions fields.\nUsed during index building to configure FAISS manager with index-specific\nruntime behavior.\n\nParameters\n----------\nindex_config : IndexConfig\n    Structured index configuration containing FAISS parameters: family type,\n    quantization settings (pq_m, pq_nbits, opq_m), HNSW parameters (m,\n    ef_construction, ef_search), GPU preferences, and search tuning defaults.\n\nReturns\n-------\nFAISSRuntimeOptions\n    Runtime options instance populated from index_config parameters. The\n    returned object is used to initialize FAISS manager with index-appropriate\n    runtime configuration.\n\nNotes\n-----\nThis helper ensures runtime options match the index structure (e.g., HNSW\nparameters only apply to HNSW indexes). Used during index building and\nmanager initialization to maintain consistency between index type and runtime\nbehavior. Time complexity: O(1) for option construction.",
  "is_public": false
}
{
  "path": "bin/index_all.py",
  "module": "bin.index_all",
  "qualname": "_resolve_nlist",
  "name": "_resolve_nlist",
  "node_type": "FunctionDef",
  "lineno": 573,
  "col": 0,
  "end_lineno": 588,
  "end_col": 35,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return an integer ``nlist`` value with legacy fallback.\n\nParameters\n----------\nindex_config : IndexConfig\n    Index configuration possibly containing explicit ``nlist``.\n\nReturns\n-------\nint\n    ``nlist`` resolved from configuration, falling back to legacy field.",
  "is_public": false
}
{
  "path": "bin/index_all.py",
  "module": "bin.index_all",
  "qualname": "_run_offline_evaluation",
  "name": "_run_offline_evaluation",
  "node_type": "FunctionDef",
  "lineno": 591,
  "col": 0,
  "end_lineno": 623,
  "end_col": 67,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Execute the offline recall evaluator if enabled.",
  "is_public": false
}
{
  "path": "bin/index_all.py",
  "module": "bin.index_all",
  "qualname": "_initialize_duckdb",
  "name": "_initialize_duckdb",
  "node_type": "FunctionDef",
  "lineno": 626,
  "col": 0,
  "end_lineno": 654,
  "end_col": 16,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Create or refresh the DuckDB catalog and return the chunk count.\n\nParameters\n----------\npaths : PipelinePaths\n    Pipeline paths configuration.\nmaterialize : bool\n    Whether to materialize Parquet data into a DuckDB table with indexes.\n\nReturns\n-------\nint\n    Number of chunk records registered in the catalog.",
  "is_public": false
}
{
  "path": "bin/index_all.py",
  "module": "bin.index_all",
  "qualname": "_write_symbols",
  "name": "_write_symbols",
  "node_type": "FunctionDef",
  "lineno": 657,
  "col": 0,
  "end_lineno": 723,
  "end_col": 46,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Derive symbol tables and persist them into DuckDB.",
  "is_public": false
}
{
  "path": "bin/index_all.py",
  "module": "bin.index_all",
  "qualname": "_write_symbols._chunk_for",
  "name": "_chunk_for",
  "node_type": "FunctionDef",
  "lineno": 667,
  "col": 4,
  "end_lineno": 671,
  "end_col": 17,
  "parent_qualname": "_write_symbols",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cache/__init__.py",
  "module": "cache",
  "qualname": "cache",
  "name": "cache",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Interfaces for caching results within the CodeIntel MCP stack.",
  "is_public": true
}
{
  "path": "cli/__init__.py",
  "module": "cli",
  "qualname": "cli",
  "name": "cli",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Entry point aggregating CodeIntel CLI subcommands.",
  "is_public": true
}
{
  "path": "cli/__init__.py",
  "module": "cli",
  "qualname": "_load_cli_module",
  "name": "_load_cli_module",
  "node_type": "FunctionDef",
  "lineno": 24,
  "col": 0,
  "end_lineno": 45,
  "end_col": 40,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Import a CLI module lazily to avoid circular imports.\n\nThis function dynamically imports a CLI module by its dotted path to avoid\ncircular import issues during module initialization. The function uses\nimportlib.import_module() to perform the import at runtime.\n\nParameters\n----------\npath : str\n    Dotted module path to import (e.g., \"codeintel_rev.cli.indexctl\").\n    The path must be a valid Python module path accessible from the current\n    import context. Used to lazily load CLI command modules.\n\nReturns\n-------\nModuleType\n    Imported module object referenced by path. The module is loaded and\n    cached by Python's import system. Subsequent calls with the same path\n    return the cached module instance.",
  "is_public": false
}
{
  "path": "cli/__init__.py",
  "module": "cli",
  "qualname": "main",
  "name": "main",
  "node_type": "FunctionDef",
  "lineno": 81,
  "col": 0,
  "end_lineno": 116,
  "end_col": 45,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Run the aggregated CodeIntel CLI.",
  "is_public": true
}
{
  "path": "cli/__init__.py",
  "module": "cli",
  "qualname": "_maybe_write_cli_report",
  "name": "_maybe_write_cli_report",
  "node_type": "FunctionDef",
  "lineno": 119,
  "col": 0,
  "end_lineno": 123,
  "end_col": 35,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli/bm25.py",
  "module": "cli.bm25",
  "qualname": "cli.bm25",
  "name": "cli.bm25",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Command-line interface for BM25 corpus preparation and index builds.",
  "is_public": true
}
{
  "path": "cli/bm25.py",
  "module": "cli.bm25",
  "qualname": "_create_bm25_manager",
  "name": "_create_bm25_manager",
  "node_type": "FunctionDef",
  "lineno": 20,
  "col": 0,
  "end_lineno": 28,
  "end_col": 44,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return an index manager configured from environment settings.\n\nReturns\n-------\nBM25IndexManager\n    Manager using the active environment configuration.",
  "is_public": false
}
{
  "path": "cli/bm25.py",
  "module": "cli.bm25",
  "qualname": "_add_metadata_artifact",
  "name": "_add_metadata_artifact",
  "node_type": "FunctionDef",
  "lineno": 31,
  "col": 0,
  "end_lineno": 34,
  "end_col": 74,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Attach metadata artifact information to the CLI envelope.",
  "is_public": false
}
{
  "path": "cli/bm25.py",
  "module": "cli.bm25",
  "qualname": "prepare_corpus",
  "name": "prepare_corpus",
  "node_type": "FunctionDef",
  "lineno": 57,
  "col": 0,
  "end_lineno": 102,
  "end_col": 67,
  "parent_qualname": null,
  "decorators": [
    "app.command('prepare-corpus')"
  ],
  "bases": [],
  "docstring": "Prepare a BM25 JsonCollection from a JSONL source.",
  "is_public": true
}
{
  "path": "cli/bm25.py",
  "module": "cli.bm25",
  "qualname": "prepare_corpus._run",
  "name": "_run",
  "node_type": "FunctionDef",
  "lineno": 66,
  "col": 4,
  "end_lineno": 100,
  "end_col": 9,
  "parent_qualname": "prepare_corpus",
  "decorators": [
    "cli_operation(echo_args=True, echo_env=True)"
  ],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli/bm25.py",
  "module": "cli.bm25",
  "qualname": "build_index",
  "name": "build_index",
  "node_type": "FunctionDef",
  "lineno": 127,
  "col": 0,
  "end_lineno": 180,
  "end_col": 65,
  "parent_qualname": null,
  "decorators": [
    "app.command('build-index')"
  ],
  "bases": [],
  "docstring": "Build a Lucene BM25 index using Pyserini.",
  "is_public": true
}
{
  "path": "cli/bm25.py",
  "module": "cli.bm25",
  "qualname": "build_index._run",
  "name": "_run",
  "node_type": "FunctionDef",
  "lineno": 136,
  "col": 4,
  "end_lineno": 178,
  "end_col": 9,
  "parent_qualname": "build_index",
  "decorators": [
    "cli_operation(echo_args=True, echo_env=True)"
  ],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli/bm25.py",
  "module": "cli.bm25",
  "qualname": "main",
  "name": "main",
  "node_type": "FunctionDef",
  "lineno": 183,
  "col": 0,
  "end_lineno": 185,
  "end_col": 9,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Run the BM25 CLI directly.",
  "is_public": true
}
{
  "path": "cli/build_indexes.py",
  "module": "cli.build_indexes",
  "qualname": "cli.build_indexes",
  "name": "cli.build_indexes",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "CLI helpers for building Lucene indexes and flipping lifecycle pointers.",
  "is_public": true
}
{
  "path": "cli/build_indexes.py",
  "module": "cli.build_indexes",
  "qualname": "_bm25_manager",
  "name": "_bm25_manager",
  "node_type": "FunctionDef",
  "lineno": 93,
  "col": 0,
  "end_lineno": 101,
  "end_col": 44,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return a BM25 index manager configured from the active settings.\n\nReturns\n-------\nBM25IndexManager\n    Manager initialised with the currently loaded settings.",
  "is_public": false
}
{
  "path": "cli/build_indexes.py",
  "module": "cli.build_indexes",
  "qualname": "_splade_manager",
  "name": "_splade_manager",
  "node_type": "FunctionDef",
  "lineno": 104,
  "col": 0,
  "end_lineno": 112,
  "end_col": 46,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return a SPLADE index manager configured from the active settings.\n\nReturns\n-------\nSpladeIndexManager\n    Manager initialised with the currently loaded settings.",
  "is_public": false
}
{
  "path": "cli/build_indexes.py",
  "module": "cli.build_indexes",
  "qualname": "build_bm25_index",
  "name": "build_bm25_index",
  "node_type": "FunctionDef",
  "lineno": 116,
  "col": 0,
  "end_lineno": 138,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [
    "app.command('bm25')"
  ],
  "bases": [],
  "docstring": "Build a Lucene BM25 index with positional/docvector/raw storage enabled.",
  "is_public": true
}
{
  "path": "cli/build_indexes.py",
  "module": "cli.build_indexes",
  "qualname": "build_splade_impact_index",
  "name": "build_splade_impact_index",
  "node_type": "FunctionDef",
  "lineno": 142,
  "col": 0,
  "end_lineno": 163,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [
    "app.command('splade-impact')"
  ],
  "bases": [],
  "docstring": "Build a SPLADE Lucene impact index from JsonVectorCollection shards.",
  "is_public": true
}
{
  "path": "cli/build_indexes.py",
  "module": "cli.build_indexes",
  "qualname": "publish_lucene_assets",
  "name": "publish_lucene_assets",
  "node_type": "FunctionDef",
  "lineno": 167,
  "col": 0,
  "end_lineno": 183,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [
    "app.command('publish')"
  ],
  "bases": [],
  "docstring": "Copy Lucene assets into the lifecycle root and flip the CURRENT pointer.",
  "is_public": true
}
{
  "path": "cli/build_indexes.py",
  "module": "cli.build_indexes",
  "qualname": "main",
  "name": "main",
  "node_type": "FunctionDef",
  "lineno": 186,
  "col": 0,
  "end_lineno": 188,
  "end_col": 9,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Execute the build_indexes CLI.",
  "is_public": true
}
{
  "path": "cli/indexctl.py",
  "module": "cli.indexctl",
  "qualname": "cli.indexctl",
  "name": "cli.indexctl",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Typer CLI for managing index lifecycle operations.",
  "is_public": true
}
{
  "path": "cli/indexctl.py",
  "module": "cli.indexctl",
  "qualname": "_get_settings",
  "name": "_get_settings",
  "node_type": "FunctionDef",
  "lineno": 61,
  "col": 0,
  "end_lineno": 69,
  "end_col": 26,
  "parent_qualname": null,
  "decorators": [
    "lru_cache(maxsize=1)"
  ],
  "bases": [],
  "docstring": "Load settings once and reuse for subsequent commands.\n\nReturns\n-------\nSettings\n    Cached settings object.",
  "is_public": false
}
{
  "path": "cli/indexctl.py",
  "module": "cli.indexctl",
  "qualname": "SearchCommandParams",
  "name": "SearchCommandParams",
  "node_type": "ClassDef",
  "lineno": 136,
  "col": 0,
  "end_lineno": 144,
  "end_col": 23,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Typed container for CLI-provided semantic search arguments.",
  "is_public": true
}
{
  "path": "cli/indexctl.py",
  "module": "cli.indexctl",
  "qualname": "global_options",
  "name": "global_options",
  "node_type": "FunctionDef",
  "lineno": 182,
  "col": 0,
  "end_lineno": 184,
  "end_col": 28,
  "parent_qualname": null,
  "decorators": [
    "app.callback()"
  ],
  "bases": [],
  "docstring": "Configure shared CLI options.",
  "is_public": true
}
{
  "path": "cli/indexctl.py",
  "module": "cli.indexctl",
  "qualname": "_default_root",
  "name": "_default_root",
  "node_type": "FunctionDef",
  "lineno": 187,
  "col": 0,
  "end_lineno": 191,
  "end_col": 36,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli/indexctl.py",
  "module": "cli.indexctl",
  "qualname": "_resolve_root",
  "name": "_resolve_root",
  "node_type": "FunctionDef",
  "lineno": 194,
  "col": 0,
  "end_lineno": 197,
  "end_col": 34,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli/indexctl.py",
  "module": "cli.indexctl",
  "qualname": "_manager",
  "name": "_manager",
  "node_type": "FunctionDef",
  "lineno": 200,
  "col": 0,
  "end_lineno": 202,
  "end_col": 67,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli/indexctl.py",
  "module": "cli.indexctl",
  "qualname": "_build_assets",
  "name": "_build_assets",
  "node_type": "FunctionDef",
  "lineno": 205,
  "col": 0,
  "end_lineno": 220,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli/indexctl.py",
  "module": "cli.indexctl",
  "qualname": "_parse_extras",
  "name": "_parse_extras",
  "node_type": "FunctionDef",
  "lineno": 223,
  "col": 0,
  "end_lineno": 231,
  "end_col": 17,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli/indexctl.py",
  "module": "cli.indexctl",
  "qualname": "_parse_sidecars",
  "name": "_parse_sidecars",
  "node_type": "FunctionDef",
  "lineno": 234,
  "col": 0,
  "end_lineno": 250,
  "end_col": 17,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli/indexctl.py",
  "module": "cli.indexctl",
  "qualname": "_resolve_version_dir",
  "name": "_resolve_version_dir",
  "node_type": "FunctionDef",
  "lineno": 253,
  "col": 0,
  "end_lineno": 260,
  "end_col": 32,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli/indexctl.py",
  "module": "cli.indexctl",
  "qualname": "_manifest_path_for",
  "name": "_manifest_path_for",
  "node_type": "FunctionDef",
  "lineno": 263,
  "col": 0,
  "end_lineno": 264,
  "end_col": 52,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli/indexctl.py",
  "module": "cli.indexctl",
  "qualname": "_load_manifest",
  "name": "_load_manifest",
  "node_type": "FunctionDef",
  "lineno": 267,
  "col": 0,
  "end_lineno": 274,
  "end_col": 17,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli/indexctl.py",
  "module": "cli.indexctl",
  "qualname": "_write_manifest",
  "name": "_write_manifest",
  "node_type": "FunctionDef",
  "lineno": 277,
  "col": 0,
  "end_lineno": 278,
  "end_col": 84,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli/indexctl.py",
  "module": "cli.indexctl",
  "qualname": "_EmbeddingBuildContext",
  "name": "_EmbeddingBuildContext",
  "node_type": "ClassDef",
  "lineno": 282,
  "col": 0,
  "end_lineno": 289,
  "end_col": 23,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=False)"
  ],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli/indexctl.py",
  "module": "cli.indexctl",
  "qualname": "_build_context",
  "name": "_build_context",
  "node_type": "FunctionDef",
  "lineno": 292,
  "col": 0,
  "end_lineno": 317,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli/indexctl.py",
  "module": "cli.indexctl",
  "qualname": "_resolve_duck_path",
  "name": "_resolve_duck_path",
  "node_type": "FunctionDef",
  "lineno": 320,
  "col": 0,
  "end_lineno": 334,
  "end_col": 20,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli/indexctl.py",
  "module": "cli.indexctl",
  "qualname": "_resolve_output_path",
  "name": "_resolve_output_path",
  "node_type": "FunctionDef",
  "lineno": 337,
  "col": 0,
  "end_lineno": 354,
  "end_col": 22,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli/indexctl.py",
  "module": "cli.indexctl",
  "qualname": "_parquet_meta",
  "name": "_parquet_meta",
  "node_type": "FunctionDef",
  "lineno": 357,
  "col": 0,
  "end_lineno": 367,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli/indexctl.py",
  "module": "cli.indexctl",
  "qualname": "_build_embedding_manifest",
  "name": "_build_embedding_manifest",
  "node_type": "FunctionDef",
  "lineno": 370,
  "col": 0,
  "end_lineno": 393,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli/indexctl.py",
  "module": "cli.indexctl",
  "qualname": "_compute_chunk_checksum",
  "name": "_compute_chunk_checksum",
  "node_type": "FunctionDef",
  "lineno": 396,
  "col": 0,
  "end_lineno": 408,
  "end_col": 36,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli/indexctl.py",
  "module": "cli.indexctl",
  "qualname": "_collect_chunks_and_embeddings",
  "name": "_collect_chunks_and_embeddings",
  "node_type": "FunctionDef",
  "lineno": 411,
  "col": 0,
  "end_lineno": 455,
  "end_col": 29,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli/indexctl.py",
  "module": "cli.indexctl",
  "qualname": "_deterministic_sample",
  "name": "_deterministic_sample",
  "node_type": "FunctionDef",
  "lineno": 458,
  "col": 0,
  "end_lineno": 489,
  "end_col": 30,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return a deterministic pseudo-random selection of indices.\n\nThis function generates a deterministic sample of indices by sorting all\nindices by a hash-based key derived from each index value. The function\nuses SHA-256 hashing to create a stable ordering that appears random but\nis reproducible across runs. This enables consistent sampling for validation\nand testing purposes.\n\nParameters\n----------\ntotal_rows : int\n    Total number of rows/indices available for sampling. The function\n    generates indices in the range [0, total_rows). Must be non-negative.\nsample_size : int\n    Maximum number of indices to return in the sample. The function returns\n    at most sample_size indices, or all indices if total_rows <= sample_size.\n    Must be non-negative.\n\nReturns\n-------\nlist[int]\n    Ordered list of sampled indices, capped at sample_size. The indices\n    are sorted by their hash-based keys, providing a deterministic but\n    pseudo-random selection. Empty list if total_rows is 0 or sample_size\n    is 0. Contains min(total_rows, sample_size) elements.",
  "is_public": false
}
{
  "path": "cli/indexctl.py",
  "module": "cli.indexctl",
  "qualname": "_evaluate_drift",
  "name": "_evaluate_drift",
  "node_type": "FunctionDef",
  "lineno": 492,
  "col": 0,
  "end_lineno": 514,
  "end_col": 46,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli/indexctl.py",
  "module": "cli.indexctl",
  "qualname": "_execute_embeddings_build",
  "name": "_execute_embeddings_build",
  "node_type": "FunctionDef",
  "lineno": 517,
  "col": 0,
  "end_lineno": 576,
  "end_col": 24,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli/indexctl.py",
  "module": "cli.indexctl",
  "qualname": "_run_embedding_validation",
  "name": "_run_embedding_validation",
  "node_type": "FunctionDef",
  "lineno": 579,
  "col": 0,
  "end_lineno": 613,
  "end_col": 24,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli/indexctl.py",
  "module": "cli.indexctl",
  "qualname": "_write_embedding_meta",
  "name": "_write_embedding_meta",
  "node_type": "FunctionDef",
  "lineno": 616,
  "col": 0,
  "end_lineno": 627,
  "end_col": 9,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli/indexctl.py",
  "module": "cli.indexctl",
  "qualname": "embeddings_build_command",
  "name": "embeddings_build_command",
  "node_type": "FunctionDef",
  "lineno": 631,
  "col": 0,
  "end_lineno": 652,
  "end_col": 82,
  "parent_qualname": null,
  "decorators": [
    "embeddings_app.command('build')"
  ],
  "bases": [],
  "docstring": "Embed chunks from DuckDB and write Parquet + manifest artifacts.",
  "is_public": true
}
{
  "path": "cli/indexctl.py",
  "module": "cli.indexctl",
  "qualname": "embeddings_validate_command",
  "name": "embeddings_validate_command",
  "node_type": "FunctionDef",
  "lineno": 656,
  "col": 0,
  "end_lineno": 715,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [
    "embeddings_app.command('validate')"
  ],
  "bases": [],
  "docstring": "Sample stored embeddings, recompute vectors, and detect drift.\n\nThis command validates stored embeddings by sampling vectors from the Parquet\nfile, recomputing embeddings for the same texts using the current model,\nand comparing them to detect drift. The command reports drift statistics\nand can help identify when embeddings need to be regenerated due to model\nchanges or configuration updates.\n\nParameters\n----------\nparquet : ParquetOption, optional\n    Path to the embeddings Parquet file to validate. If None, uses the\n    default path from the active index version. The file must exist and\n    contain embedding vectors for validation.\nversion : VersionOption, optional\n    Index version to validate embeddings for. If None, uses the active\n    version. Used to locate the embeddings Parquet file when parquet\n    path is not explicitly provided.\nsamples : SampleOption, optional\n    Number of embedding vectors to sample for validation (defaults to 32).\n    Larger samples provide more accurate drift detection but take longer\n    to compute. The sampled vectors are randomly selected from the Parquet\n    file.\nepsilon : EpsilonOption, optional\n    Tolerance threshold for drift detection (defaults to 5e-3). Embeddings\n    with differences greater than epsilon are considered drifted. Used to\n    determine if recomputed embeddings match stored embeddings within the\n    specified tolerance.\n\nRaises\n------\ntyper.BadParameter\n    Raised when the embeddings Parquet file is missing or cannot be accessed.\n    The error includes the expected path for debugging.",
  "is_public": true
}
{
  "path": "cli/indexctl.py",
  "module": "cli.indexctl",
  "qualname": "_parse_tune_overrides",
  "name": "_parse_tune_overrides",
  "node_type": "FunctionDef",
  "lineno": 718,
  "col": 0,
  "end_lineno": 755,
  "end_col": 32,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli/indexctl.py",
  "module": "cli.indexctl",
  "qualname": "_faiss_manager",
  "name": "_faiss_manager",
  "node_type": "FunctionDef",
  "lineno": 758,
  "col": 0,
  "end_lineno": 769,
  "end_col": 18,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli/indexctl.py",
  "module": "cli.indexctl",
  "qualname": "_duckdb_catalog",
  "name": "_duckdb_catalog",
  "node_type": "FunctionDef",
  "lineno": 772,
  "col": 0,
  "end_lineno": 783,
  "end_col": 18,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli/indexctl.py",
  "module": "cli.indexctl",
  "qualname": "_duckdb_embedding_dim",
  "name": "_duckdb_embedding_dim",
  "node_type": "FunctionDef",
  "lineno": 786,
  "col": 0,
  "end_lineno": 809,
  "end_col": 16,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return the embedding dimension stored in DuckDB.\n\nParameters\n----------\ncatalog : DuckDBCatalog\n    DuckDB catalog instance to query for embedding dimension. The catalog\n    must have a chunks table with an embedding column.\n\nReturns\n-------\nint\n    The dimension of embeddings stored in the catalog. Returns 0 if no\n    embeddings are found or if the embedding column is empty/None.",
  "is_public": false
}
{
  "path": "cli/indexctl.py",
  "module": "cli.indexctl",
  "qualname": "_count_idmap_rows",
  "name": "_count_idmap_rows",
  "node_type": "FunctionDef",
  "lineno": 812,
  "col": 0,
  "end_lineno": 839,
  "end_col": 59,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return row count for a FAISS idmap sidecar.\n\nParameters\n----------\npath : Path\n    Path to the Parquet file containing the FAISS ID map sidecar. The file\n    may not exist, in which case 0 is returned.\n\nReturns\n-------\nint\n    Number of rows in the ID map Parquet file, or 0 if the file doesn't\n    exist.\n\nRaises\n------\nRuntimeError\n    Raised when pyarrow is not installed. pyarrow is required to read\n    Parquet metadata and determine the row count.",
  "is_public": false
}
{
  "path": "cli/indexctl.py",
  "module": "cli.indexctl",
  "qualname": "_load_xtr_index",
  "name": "_load_xtr_index",
  "node_type": "FunctionDef",
  "lineno": 842,
  "col": 0,
  "end_lineno": 855,
  "end_col": 16,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli/indexctl.py",
  "module": "cli.indexctl",
  "qualname": "_eval_paths",
  "name": "_eval_paths",
  "node_type": "FunctionDef",
  "lineno": 858,
  "col": 0,
  "end_lineno": 864,
  "end_col": 74,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli/indexctl.py",
  "module": "cli.indexctl",
  "qualname": "status_command",
  "name": "status_command",
  "node_type": "FunctionDef",
  "lineno": 868,
  "col": 0,
  "end_lineno": 874,
  "end_col": 34,
  "parent_qualname": null,
  "decorators": [
    "app.command('status')"
  ],
  "bases": [],
  "docstring": "Print the active version and available versions.",
  "is_public": true
}
{
  "path": "cli/indexctl.py",
  "module": "cli.indexctl",
  "qualname": "stage_command",
  "name": "stage_command",
  "node_type": "FunctionDef",
  "lineno": 878,
  "col": 0,
  "end_lineno": 931,
  "end_col": 45,
  "parent_qualname": null,
  "decorators": [
    "app.command('stage')"
  ],
  "bases": [],
  "docstring": "Stage a new version by copying assets into the lifecycle root.\n\nThis command stages a new index version by copying FAISS, DuckDB, and SCIP\nassets into the lifecycle root directory. The command validates asset paths,\nresolves sidecar files (BM25, SPLADE indices), and prepares the version for\npublishing. Staged versions can be published or rolled back as needed.\n\nParameters\n----------\nversion : VersionArg\n    Version identifier for the staged index (e.g., \"v1.0.0\"). The version\n    is used to create a versioned directory in the lifecycle root. Must be\n    a valid version string.\nassets : AssetsArg\n    Tuple of three primary asset paths: (FAISS index, DuckDB catalog, SCIP\n    index). These are the required assets for index functionality. Paths\n    are resolved to absolute paths before staging.\nextras : ExtraOption\n    List of extra channel indices to include (e.g., BM25, SPLADE). Each\n    extra is a path to an additional index file that extends the base\n    functionality. Extras are optional and can be empty.\nsidecars : SidecarOption\n    List of sidecar file paths to include with the staged version. Sidecars\n    are additional files (e.g., metadata, configuration) that are staged\n    alongside the primary assets. Can be empty if no sidecars are needed.\n\nRaises\n------\ntyper.BadParameter\n    Raised when the primary assets are not provided in the expected order\n    or when asset paths cannot be resolved. The error includes details about\n    which assets are missing or invalid.",
  "is_public": true
}
{
  "path": "cli/indexctl.py",
  "module": "cli.indexctl",
  "qualname": "publish_command",
  "name": "publish_command",
  "node_type": "FunctionDef",
  "lineno": 935,
  "col": 0,
  "end_lineno": 941,
  "end_col": 61,
  "parent_qualname": null,
  "decorators": [
    "app.command('publish')"
  ],
  "bases": [],
  "docstring": "Publish a previously staged version.",
  "is_public": true
}
{
  "path": "cli/indexctl.py",
  "module": "cli.indexctl",
  "qualname": "rollback_command",
  "name": "rollback_command",
  "node_type": "FunctionDef",
  "lineno": 945,
  "col": 0,
  "end_lineno": 951,
  "end_col": 43,
  "parent_qualname": null,
  "decorators": [
    "app.command('rollback')"
  ],
  "bases": [],
  "docstring": "Rollback to a previously published version.",
  "is_public": true
}
{
  "path": "cli/indexctl.py",
  "module": "cli.indexctl",
  "qualname": "list_command",
  "name": "list_command",
  "node_type": "FunctionDef",
  "lineno": 955,
  "col": 0,
  "end_lineno": 963,
  "end_col": 27,
  "parent_qualname": null,
  "decorators": [
    "app.command('ls')"
  ],
  "bases": [],
  "docstring": "List all published versions.",
  "is_public": true
}
{
  "path": "cli/indexctl.py",
  "module": "cli.indexctl",
  "qualname": "health_command",
  "name": "health_command",
  "node_type": "FunctionDef",
  "lineno": 967,
  "col": 0,
  "end_lineno": 1022,
  "end_col": 45,
  "parent_qualname": null,
  "decorators": [
    "app.command('health')"
  ],
  "bases": [],
  "docstring": "Validate FAISS, DuckDB, and ID map invariants.",
  "is_public": true
}
{
  "path": "cli/indexctl.py",
  "module": "cli.indexctl",
  "qualname": "export_idmap_command",
  "name": "export_idmap_command",
  "node_type": "FunctionDef",
  "lineno": 1026,
  "col": 0,
  "end_lineno": 1043,
  "end_col": 9,
  "parent_qualname": null,
  "decorators": [
    "app.command('export-idmap')"
  ],
  "bases": [],
  "docstring": "Export FAISS ID map to Parquet and optionally refresh DuckDB materialization.",
  "is_public": true
}
{
  "path": "cli/indexctl.py",
  "module": "cli.indexctl",
  "qualname": "materialize_join_command",
  "name": "materialize_join_command",
  "node_type": "FunctionDef",
  "lineno": 1047,
  "col": 0,
  "end_lineno": 1056,
  "end_col": 99,
  "parent_qualname": null,
  "decorators": [
    "app.command('materialize-join')"
  ],
  "bases": [],
  "docstring": "Refresh DuckDB's materialized FAISS join if the ID map sidecar changed.",
  "is_public": true
}
{
  "path": "cli/indexctl.py",
  "module": "cli.indexctl",
  "qualname": "tune_command",
  "name": "tune_command",
  "node_type": "FunctionDef",
  "lineno": 1063,
  "col": 0,
  "end_lineno": 1129,
  "end_col": 64,
  "parent_qualname": null,
  "decorators": [
    "app.command('tune', context_settings={'allow_extra_args': True, 'ignore_unknown_options': True})"
  ],
  "bases": [],
  "docstring": "Apply FAISS tuning overrides or run an autotune sweep.\n\nThis command applies FAISS search parameter overrides (nprobe, ef_search,\nquantizer_ef_search, k_factor) or runs an autotune sweep to find optimal\nparameters. The command can apply immediate overrides via command-line\narguments or run a parameter sweep to discover optimal settings. Tuning\nprofiles are saved for future use.\n\nParameters\n----------\nctx : typer.Context\n    Typer context object providing access to command-line arguments and\n    shared CLI state. Used to parse tuning overrides from ctx.args.\nindex : IndexOption, optional\n    Path to the FAISS index to tune. If None, uses the active index from\n    configuration. The index must exist and be loadable for tuning operations.\nsweep : Annotated[SweepMode | None, SWEEP_OPTION], optional\n    Sweep mode to use for autotune (e.g., \"quick\", \"full\"). If None, applies\n    overrides from command-line arguments instead of running a sweep. When\n    provided, runs an autotune sweep to discover optimal parameters. The\n    parameter is annotated with SWEEP_OPTION for Typer CLI integration.\n\nRaises\n------\ntyper.BadParameter\n    Raised in the following cases:\n    - Conflicting sweep modes: both --sweep flag and inferred sweep mode\n      are provided with different values\n    - Missing overrides: no tuning overrides provided and no sweep mode\n      specified (at least one override or sweep mode is required)",
  "is_public": true
}
{
  "path": "cli/indexctl.py",
  "module": "cli.indexctl",
  "qualname": "tune_params_command",
  "name": "tune_params_command",
  "node_type": "FunctionDef",
  "lineno": 1133,
  "col": 0,
  "end_lineno": 1171,
  "end_col": 64,
  "parent_qualname": null,
  "decorators": [
    "app.command('tune-params')"
  ],
  "bases": [],
  "docstring": "Apply FAISS ParameterSpace string (nprobe/efSearch/quantizer/k_factor).\n\nThis command applies FAISS search parameters from a ParameterSpace string\nformat. The string specifies tuning parameters as key-value pairs (e.g.,\n\"nprobe=64,efSearch=128\"). The command validates the parameters, applies\nthem to the FAISS manager, and writes an audit log of the tuning changes.\n\nParameters\n----------\nparams : ParamSpaceArg\n    ParameterSpace string containing FAISS tuning parameters in key=value\n    format (e.g., \"nprobe=64,efSearch=128,quantizer_ef_search=256,k_factor=1.5\").\n    Supported keys: nprobe, efSearch, quantizer_ef_search, k_factor.\n    The string is parsed and validated before application.\nindex : IndexOption, optional\n    Path to the FAISS index to tune. If None, uses the active index from\n    configuration. The index must exist and be loadable for parameter\n    application.\n\nRaises\n------\ntyper.BadParameter\n    Raised when the ParameterSpace string includes unsupported keys or\n    invalid parameter values. The error includes details about which keys\n    are unsupported or which values are invalid. Wraps ValueError from\n    FAISS manager parameter validation.",
  "is_public": true
}
{
  "path": "cli/indexctl.py",
  "module": "cli.indexctl",
  "qualname": "show_profile_command",
  "name": "show_profile_command",
  "node_type": "FunctionDef",
  "lineno": 1175,
  "col": 0,
  "end_lineno": 1178,
  "end_col": 66,
  "parent_qualname": null,
  "decorators": [
    "app.command('show-profile')"
  ],
  "bases": [],
  "docstring": "Print the active tuning profile, overrides, and saved ParameterSpace.",
  "is_public": true
}
{
  "path": "cli/indexctl.py",
  "module": "cli.indexctl",
  "qualname": "_write_tuning_audit",
  "name": "_write_tuning_audit",
  "node_type": "FunctionDef",
  "lineno": 1181,
  "col": 0,
  "end_lineno": 1185,
  "end_col": 21,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli/indexctl.py",
  "module": "cli.indexctl",
  "qualname": "_run_autotune",
  "name": "_run_autotune",
  "node_type": "FunctionDef",
  "lineno": 1192,
  "col": 0,
  "end_lineno": 1214,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli/indexctl.py",
  "module": "cli.indexctl",
  "qualname": "eval_command",
  "name": "eval_command",
  "node_type": "FunctionDef",
  "lineno": 1218,
  "col": 0,
  "end_lineno": 1248,
  "end_col": 53,
  "parent_qualname": null,
  "decorators": [
    "app.command('eval')"
  ],
  "bases": [],
  "docstring": "Run ANN vs Flat evaluation and optionally rescore with XTR.",
  "is_public": true
}
{
  "path": "cli/indexctl.py",
  "module": "cli.indexctl",
  "qualname": "_execute_search",
  "name": "_execute_search",
  "node_type": "FunctionDef",
  "lineno": 1251,
  "col": 0,
  "end_lineno": 1329,
  "end_col": 85,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Execute ANN + refine search for newline-delimited queries.\n\nParameters\n----------\nparams : SearchCommandParams\n    Search command parameters including queries file path, search options,\n    and index/catalog paths.\n\nRaises\n------\ntyper.BadParameter\n    Raised when the queries file cannot be read.",
  "is_public": false
}
{
  "path": "cli/indexctl.py",
  "module": "cli.indexctl",
  "qualname": "_execute_search._summarize_query",
  "name": "_summarize_query",
  "node_type": "FunctionDef",
  "lineno": 1278,
  "col": 8,
  "end_lineno": 1320,
  "end_col": 13,
  "parent_qualname": "_execute_search",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli/splade.py",
  "module": "cli.splade",
  "qualname": "cli.splade",
  "name": "cli.splade",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Command-line interface for SPLADE artifact management.",
  "is_public": true
}
{
  "path": "cli/splade.py",
  "module": "cli.splade",
  "qualname": "_create_artifacts_manager",
  "name": "_create_artifacts_manager",
  "node_type": "FunctionDef",
  "lineno": 55,
  "col": 0,
  "end_lineno": 63,
  "end_col": 50,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Construct an artifacts manager using the active settings.\n\nReturns\n-------\nSpladeArtifactsManager\n    Manager initialized with the current environment configuration.",
  "is_public": false
}
{
  "path": "cli/splade.py",
  "module": "cli.splade",
  "qualname": "_create_encoder_service",
  "name": "_create_encoder_service",
  "node_type": "FunctionDef",
  "lineno": 66,
  "col": 0,
  "end_lineno": 74,
  "end_col": 48,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Construct an encoder service using the active settings.\n\nReturns\n-------\nSpladeEncoderService\n    Encoder service initialized with the current environment configuration.",
  "is_public": false
}
{
  "path": "cli/splade.py",
  "module": "cli.splade",
  "qualname": "_create_index_manager",
  "name": "_create_index_manager",
  "node_type": "FunctionDef",
  "lineno": 77,
  "col": 0,
  "end_lineno": 85,
  "end_col": 46,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Construct an index manager using the active settings.\n\nReturns\n-------\nSpladeIndexManager\n    Index manager initialized with the current environment configuration.",
  "is_public": false
}
{
  "path": "cli/splade.py",
  "module": "cli.splade",
  "qualname": "_add_metadata_artifact",
  "name": "_add_metadata_artifact",
  "node_type": "FunctionDef",
  "lineno": 88,
  "col": 0,
  "end_lineno": 91,
  "end_col": 74,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Attach metadata artifacts to CLI envelopes when available.",
  "is_public": false
}
{
  "path": "cli/splade.py",
  "module": "cli.splade",
  "qualname": "export_onnx",
  "name": "export_onnx",
  "node_type": "FunctionDef",
  "lineno": 107,
  "col": 0,
  "end_lineno": 159,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [
    "app.command('export-onnx')"
  ],
  "bases": [],
  "docstring": "Export SPLADE ONNX artifacts (optimized and quantized).",
  "is_public": true
}
{
  "path": "cli/splade.py",
  "module": "cli.splade",
  "qualname": "export_onnx._run",
  "name": "_run",
  "node_type": "FunctionDef",
  "lineno": 117,
  "col": 4,
  "end_lineno": 150,
  "end_col": 9,
  "parent_qualname": "export_onnx",
  "decorators": [
    "cli_operation(echo_args=True, echo_env=True)"
  ],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli/splade.py",
  "module": "cli.splade",
  "qualname": "encode",
  "name": "encode",
  "node_type": "FunctionDef",
  "lineno": 196,
  "col": 0,
  "end_lineno": 251,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [
    "app.command('encode')"
  ],
  "bases": [],
  "docstring": "Encode a corpus into SPLADE JsonVectorCollection shards.",
  "is_public": true
}
{
  "path": "cli/splade.py",
  "module": "cli.splade",
  "qualname": "encode._run",
  "name": "_run",
  "node_type": "FunctionDef",
  "lineno": 207,
  "col": 4,
  "end_lineno": 241,
  "end_col": 9,
  "parent_qualname": "encode",
  "decorators": [
    "cli_operation(echo_args=True, echo_env=True)"
  ],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli/splade.py",
  "module": "cli.splade",
  "qualname": "build_index",
  "name": "build_index",
  "node_type": "FunctionDef",
  "lineno": 308,
  "col": 0,
  "end_lineno": 365,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [
    "app.command('build-index')"
  ],
  "bases": [],
  "docstring": "Build a SPLADE Lucene impact index from JsonVectorCollection shards.",
  "is_public": true
}
{
  "path": "cli/splade.py",
  "module": "cli.splade",
  "qualname": "build_index._run",
  "name": "_run",
  "node_type": "FunctionDef",
  "lineno": 319,
  "col": 4,
  "end_lineno": 355,
  "end_col": 9,
  "parent_qualname": "build_index",
  "decorators": [
    "cli_operation(echo_args=True, echo_env=True)"
  ],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli/splade.py",
  "module": "cli.splade",
  "qualname": "bench",
  "name": "bench",
  "node_type": "FunctionDef",
  "lineno": 369,
  "col": 0,
  "end_lineno": 477,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [
    "app.command('bench')"
  ],
  "bases": [],
  "docstring": "Benchmark SPLADE query encoding latency.\n\nThis command measures the performance of SPLADE query encoding by running\nmultiple iterations of encoding operations and reporting statistical metrics\n(mean, p50, p95 latency). It supports benchmarking single queries or batches\nof queries from a file, with configurable warmup and measurement iterations\nto ensure accurate performance measurements.\n\nThe benchmark initializes the SPLADE encoder service, performs warmup runs\nto stabilize performance (accounting for JIT compilation, cache warming, etc.),\nthen executes measurement runs and calculates latency statistics. Results are\ndisplayed to stdout and logged with structured metadata.\n\nParameters\n----------\nquery : str | None, optional\n    Single query string to benchmark. If provided, this query is included in\n    the benchmark set. Can be combined with queries_file to benchmark multiple\n    queries. Defaults to None (no single query).\nqueries_file : Path | None, optional\n    Path to a text file containing one query per line. All non-empty lines\n    are read and included in the benchmark. Can be combined with query to\n    benchmark both. Defaults to None (no file queries).\nwarmup : int, optional\n    Number of warmup iterations to perform before measurement. Warmup runs\n    help stabilize performance by allowing JIT compilation, cache warming,\n    and other one-time optimizations to complete. Defaults to the value from\n    WARMUP_OPTION constant.\nruns : int, optional\n    Number of measurement iterations to perform after warmup. These runs\n    are used to calculate latency statistics (mean, p50, p95). More runs\n    provide more accurate statistics but take longer. Defaults to the value\n    from RUNS_OPTION constant.\n\nRaises\n------\ntyper.BadParameter\n    If no queries are provided (both query and queries_file are None/empty)\n    or if the queries_file path exists but is invalid/unreadable.",
  "is_public": true
}
{
  "path": "cli/splade.py",
  "module": "cli.splade",
  "qualname": "bench._run",
  "name": "_run",
  "node_type": "FunctionDef",
  "lineno": 437,
  "col": 4,
  "end_lineno": 469,
  "end_col": 9,
  "parent_qualname": "bench",
  "decorators": [
    "cli_operation(echo_args=True, echo_env=True)"
  ],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli/splade.py",
  "module": "cli.splade",
  "qualname": "main",
  "name": "main",
  "node_type": "FunctionDef",
  "lineno": 480,
  "col": 0,
  "end_lineno": 482,
  "end_col": 9,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Run the SPLADE CLI directly.",
  "is_public": true
}
{
  "path": "cli/telemetry.py",
  "module": "cli.telemetry",
  "qualname": "cli.telemetry",
  "name": "cli.telemetry",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Telemetry-focused CLI commands.",
  "is_public": true
}
{
  "path": "cli/telemetry.py",
  "module": "cli.telemetry",
  "qualname": "OutputFormat",
  "name": "OutputFormat",
  "node_type": "ClassDef",
  "lineno": 41,
  "col": 0,
  "end_lineno": 46,
  "end_col": 19,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "Enum"
  ],
  "docstring": "Output formats supported by the run report command.",
  "is_public": true
}
{
  "path": "cli/telemetry.py",
  "module": "cli.telemetry",
  "qualname": "run_report",
  "name": "run_report",
  "node_type": "FunctionDef",
  "lineno": 50,
  "col": 0,
  "end_lineno": 76,
  "end_col": 44,
  "parent_qualname": null,
  "decorators": [
    "app.command('report')"
  ],
  "bases": [],
  "docstring": "Render a run report from Timeline JSONL artifacts.",
  "is_public": true
}
{
  "path": "cli/telemetry.py",
  "module": "cli.telemetry",
  "qualname": "runpack",
  "name": "runpack",
  "node_type": "FunctionDef",
  "lineno": 80,
  "col": 0,
  "end_lineno": 138,
  "end_col": 29,
  "parent_qualname": null,
  "decorators": [
    "app.command('runpack')"
  ],
  "bases": [],
  "docstring": "Create a runpack zip for the specified session/run.\n\nThis command packages telemetry artifacts (timeline events, run reports, and\nconfiguration snapshots) into a zip archive for offline analysis. The runpack\nincludes all events for the specified session and optional run identifier,\nmaking it useful for debugging and performance analysis.\n\nParameters\n----------\nsession_id : str\n    Session identifier to inspect. Provided via typer.Argument.\nrun_id : str | None\n    Optional run identifier when multiple runs share a session. Defaults to None.\n    Provided via typer.Option with flag \"--run-id\".\nreason : str | None\n    Optional reason stored in metadata. Defaults to None. Provided via\n    typer.Option with flag \"--reason\".\ntrace_id : str | None\n    Optional trace identifier to record. Defaults to None. Provided via\n    typer.Option with flag \"--trace-id\".\n\nRaises\n------\ntyper.BadParameter\n    Raised when the application context cannot be initialized.",
  "is_public": true
}
{
  "path": "cli/xtr.py",
  "module": "cli.xtr",
  "qualname": "cli.xtr",
  "name": "cli.xtr",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Backward-compatible entrypoint for the XTR Typer CLI.",
  "is_public": true
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "cli_enrich",
  "name": "cli_enrich",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "CLI entrypoint for repo enrichment and targeted overlay generation.",
  "is_public": true
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "_format_stage_meta",
  "name": "_format_stage_meta",
  "node_type": "FunctionDef",
  "lineno": 81,
  "col": 0,
  "end_lineno": 83,
  "end_col": 26,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "_stage_span",
  "name": "_stage_span",
  "node_type": "FunctionDef",
  "lineno": 87,
  "col": 0,
  "end_lineno": 125,
  "end_col": 9,
  "parent_qualname": null,
  "decorators": [
    "contextmanager"
  ],
  "bases": [],
  "docstring": "Context manager logging structured stage timings.\n\nParameters\n----------\nstage : str\n    Stage name used for logging identification. Appears in all log messages\n    emitted by this context manager.\n**start_meta : object\n    Additional metadata key-value pairs to include in the start event log.\n    These are formatted and logged when the context manager enters.\n\nYields\n------\ndict[str, object]\n    Mutable dictionary that can be populated with additional metadata prior\n    to logging the ``event=finish`` line.\n\nRaises\n------\nException\n    Any exception raised within the context is re-raised after logging an\n    error event. The original exception is preserved.",
  "is_public": false
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "_YamlDumpFn",
  "name": "_YamlDumpFn",
  "node_type": "ClassDef",
  "lineno": 128,
  "col": 0,
  "end_lineno": 129,
  "end_col": 91,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "Protocol"
  ],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "_YamlDumpFn.__call__",
  "name": "__call__",
  "node_type": "FunctionDef",
  "lineno": 129,
  "col": 4,
  "end_lineno": 129,
  "end_col": 91,
  "parent_qualname": "_YamlDumpFn",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "PipelineOptions",
  "name": "PipelineOptions",
  "node_type": "ClassDef",
  "lineno": 156,
  "col": 0,
  "end_lineno": 166,
  "end_col": 48,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Resolved paths and filters required for pipeline execution.",
  "is_public": true
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "AnalyticsOptions",
  "name": "AnalyticsOptions",
  "node_type": "ClassDef",
  "lineno": 170,
  "col": 0,
  "end_lineno": 177,
  "end_col": 39,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Optional analytics toggles shared across commands.",
  "is_public": true
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "CLIContextState",
  "name": "CLIContextState",
  "node_type": "ClassDef",
  "lineno": 181,
  "col": 0,
  "end_lineno": 185,
  "end_col": 73,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "CLI-scoped state shared between commands.",
  "is_public": true
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "_ensure_state",
  "name": "_ensure_state",
  "node_type": "FunctionDef",
  "lineno": 305,
  "col": 0,
  "end_lineno": 310,
  "end_col": 16,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "_capture_shared_state",
  "name": "_capture_shared_state",
  "node_type": "FunctionDef",
  "lineno": 313,
  "col": 0,
  "end_lineno": 394,
  "end_col": 16,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Persist shared pipeline + analytics options on the Typer context.\n\nParameters\n----------\nctx : typer.Context\n    Typer context object to store the shared state. The state is attached\n    to ``ctx.obj`` for retrieval by downstream commands.\nroot : Path\n    Repository root directory path. Resolved to an absolute path before\n    storing in pipeline options.\nscip : Path | None\n    Optional path to SCIP index file. Resolved to absolute path if provided.\nout : Path\n    Output directory path for generated artifacts. Resolved to absolute path.\npyrefly_json : Path | None\n    Optional path to Pyrefly JSON report. Resolved to absolute path if provided.\ntags_yaml : Path | None\n    Optional path to tags YAML configuration file. Resolved to absolute path\n    if provided.\ncoverage_xml : Path\n    Path to coverage XML report file. Resolved to absolute path.\nonly : list[str] | None\n    Optional list of file patterns to include. Converted to tuple for pipeline\n    options. If None, all files are processed.\nmax_file_bytes : int\n    Maximum file size in bytes. Files exceeding this limit are skipped during\n    processing.\nowners : bool\n    Whether to include code ownership analytics in the pipeline.\nhistory_window_days : int\n    Number of days to look back for git history analysis.\ncommits_window : int\n    Number of commits to analyze for git-based metrics.\nemit_slices : bool\n    Whether to emit code slice analytics in the output.\nslices_filter : list[str] | None\n    Optional list of slice filter patterns. Converted to tuple for analytics\n    options. If None, all slices are included.\n\nReturns\n-------\nCLIContextState\n    New context state object containing pipeline and analytics options. The\n    state is also stored in ``ctx.obj`` for subsequent command invocations.",
  "is_public": false
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "OverlayCLIOptions",
  "name": "OverlayCLIOptions",
  "node_type": "ClassDef",
  "lineno": 398,
  "col": 0,
  "end_lineno": 410,
  "end_col": 63,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Mutable overlay generation options parsed from CLI/config.",
  "is_public": true
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "OverlayContext",
  "name": "OverlayContext",
  "node_type": "ClassDef",
  "lineno": 414,
  "col": 0,
  "end_lineno": 424,
  "end_col": 25,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Aggregated context used during overlay generation.",
  "is_public": true
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "_load_overlay_options",
  "name": "_load_overlay_options",
  "node_type": "FunctionDef",
  "lineno": 427,
  "col": 0,
  "end_lineno": 439,
  "end_col": 18,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "_read_overlay_config",
  "name": "_read_overlay_config",
  "node_type": "FunctionDef",
  "lineno": 442,
  "col": 0,
  "end_lineno": 455,
  "end_col": 15,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "_parse_bool",
  "name": "_parse_bool",
  "node_type": "FunctionDef",
  "lineno": 458,
  "col": 0,
  "end_lineno": 468,
  "end_col": 37,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "_resolve_path",
  "name": "_resolve_path",
  "node_type": "FunctionDef",
  "lineno": 471,
  "col": 0,
  "end_lineno": 474,
  "end_col": 44,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "_parse_int_option",
  "name": "_parse_int_option",
  "node_type": "FunctionDef",
  "lineno": 477,
  "col": 0,
  "end_lineno": 487,
  "end_col": 37,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "_parse_path_option",
  "name": "_parse_path_option",
  "node_type": "FunctionDef",
  "lineno": 490,
  "col": 0,
  "end_lineno": 496,
  "end_col": 37,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "_set_overlay_option",
  "name": "_set_overlay_option",
  "node_type": "FunctionDef",
  "lineno": 499,
  "col": 0,
  "end_lineno": 521,
  "end_col": 41,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "ScipContext",
  "name": "ScipContext",
  "node_type": "ClassDef",
  "lineno": 525,
  "col": 0,
  "end_lineno": 529,
  "end_col": 35,
  "parent_qualname": null,
  "decorators": [
    "dataclass(frozen=True)"
  ],
  "bases": [],
  "docstring": "Cache of SCIP lookups used during scanning.",
  "is_public": true
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "ScanInputs",
  "name": "ScanInputs",
  "node_type": "ClassDef",
  "lineno": 533,
  "col": 0,
  "end_lineno": 542,
  "end_col": 30,
  "parent_qualname": null,
  "decorators": [
    "dataclass(frozen=True)"
  ],
  "bases": [],
  "docstring": "Bundle of contextual inputs used during module row construction.",
  "is_public": true
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "PipelineContext",
  "name": "PipelineContext",
  "node_type": "ClassDef",
  "lineno": 546,
  "col": 0,
  "end_lineno": 557,
  "end_col": 30,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Aggregated context derived from CLI inputs and repo state.",
  "is_public": true
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "PipelineResult",
  "name": "PipelineResult",
  "node_type": "ClassDef",
  "lineno": 561,
  "col": 0,
  "end_lineno": 573,
  "end_col": 35,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Aggregate artifact bundle produced by a pipeline run.",
  "is_public": true
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "_discover_py_files",
  "name": "_discover_py_files",
  "node_type": "FunctionDef",
  "lineno": 576,
  "col": 0,
  "end_lineno": 597,
  "end_col": 16,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return ordered Python files under ``root`` honoring include patterns.\n\nParameters\n----------\nroot : Path\n    Root directory to search for Python files. Files are discovered recursively\n    using ``rglob(\"*.py\")``, excluding any paths containing hidden directories\n    (starting with ``.``).\npatterns : tuple[str, ...]\n    Glob patterns to filter files. If empty, all Python files are returned.\n    Patterns are matched against paths relative to ``root`` using ``fnmatch``.\n\nReturns\n-------\nlist[Path]\n    Sorted list of files relative to ``root`` matching the configured patterns.",
  "is_public": false
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "_load_scip_artifacts",
  "name": "_load_scip_artifacts",
  "node_type": "FunctionDef",
  "lineno": 600,
  "col": 0,
  "end_lineno": 626,
  "end_col": 25,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Load the SCIP index and derive lookup helpers.\n\nParameters\n----------\npath : Path\n    Path to the SCIP index file to load. The file must exist and be readable.\n\nReturns\n-------\ntuple[SCIPIndex, ScipContext]\n    Parsed SCIP index and context lookups.\n\nRaises\n------\nIngestError\n    Raised when the SCIP payload cannot be read or parsed.",
  "is_public": false
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "_collect_type_signal_map",
  "name": "_collect_type_signal_map",
  "node_type": "FunctionDef",
  "lineno": 629,
  "col": 0,
  "end_lineno": 666,
  "end_col": 25,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Collect Pyrefly/Pyright summaries and normalize path keys.\n\nParameters\n----------\nroot : Path\n    Root directory path used for normalizing file paths. Also serves as the\n    base path for locating Pyright JSON reports.\npyrefly_json : Path | None\n    Optional path to a Pyrefly JSON report file. If None, only Pyright\n    reports are collected.\n\nReturns\n-------\ndict[str, FileTypeSignals]\n    Mapping of normalized repo paths to joined type signal counts.\n\nRaises\n------\nTypeSignalError\n    Raised when either tool report cannot be parsed.",
  "is_public": false
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "_collect_coverage_map",
  "name": "_collect_coverage_map",
  "node_type": "FunctionDef",
  "lineno": 669,
  "col": 0,
  "end_lineno": 691,
  "end_col": 25,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Collect coverage metrics keyed by normalized path.\n\nParameters\n----------\nroot : Path\n    Root directory path used for normalizing file paths in the coverage map.\ncoverage_xml : Path | None\n    Optional path to a coverage XML report file. If None or the file does\n    not exist, returns an empty mapping.\n\nReturns\n-------\ndict[str, Mapping[str, float]]\n    Mapping of repo paths to coverage metrics (may be empty).",
  "is_public": false
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "_index_config_records",
  "name": "_index_config_records",
  "node_type": "FunctionDef",
  "lineno": 694,
  "col": 0,
  "end_lineno": 711,
  "end_col": 22,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return discovered config records under ``root``.\n\nParameters\n----------\nroot : Path\n    Root directory to search for configuration files. The function discovers\n    config files using the indexing logic from ``index_config_files``.\n\nReturns\n-------\nlist[dict[str, Any]]\n    Config metadata rows consumed by downstream stages.",
  "is_public": false
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "_load_tagging_rules",
  "name": "_load_tagging_rules",
  "node_type": "FunctionDef",
  "lineno": 714,
  "col": 0,
  "end_lineno": 741,
  "end_col": 20,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Load YAML tagging rules or fall back to defaults.\n\nParameters\n----------\npath : Path | None\n    Optional path to a custom YAML tagging rules file. If None, default\n    rules are loaded.\n\nReturns\n-------\nMapping[str, Any]\n    Rule dictionary keyed by tag name.\n\nRaises\n------\nTaggingError\n    Raised when a custom rules file cannot be parsed.",
  "is_public": false
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "_should_skip_candidate",
  "name": "_should_skip_candidate",
  "node_type": "FunctionDef",
  "lineno": 747,
  "col": 0,
  "end_lineno": 755,
  "end_col": 50,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "_iter_files",
  "name": "_iter_files",
  "node_type": "FunctionDef",
  "lineno": 758,
  "col": 0,
  "end_lineno": 767,
  "end_col": 23,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "_run_pipeline",
  "name": "_run_pipeline",
  "node_type": "FunctionDef",
  "lineno": 770,
  "col": 0,
  "end_lineno": 827,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "_execute_pipeline",
  "name": "_execute_pipeline",
  "node_type": "FunctionDef",
  "lineno": 830,
  "col": 0,
  "end_lineno": 834,
  "end_col": 24,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "_execute_pipeline_or_exit",
  "name": "_execute_pipeline_or_exit",
  "node_type": "FunctionDef",
  "lineno": 837,
  "col": 0,
  "end_lineno": 844,
  "end_col": 36,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "_handle_dry_run",
  "name": "_handle_dry_run",
  "node_type": "FunctionDef",
  "lineno": 847,
  "col": 0,
  "end_lineno": 878,
  "end_col": 15,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Emit deterministic dry-run summaries and signal whether callers should return.\n\nParameters\n----------\ncommand : str\n    Command name to include in the dry-run summary output. Used for\n    identifying which command is running in dry-run mode.\ndry_run : bool\n    If True, emit summary and return True to signal early return. If False,\n    return False to allow normal execution to continue.\nresult : PipelineResult\n    Pipeline result object containing module rows, symbol edges, tag index,\n    and other metrics to summarize in dry-run output.\n\nReturns\n-------\nbool\n    True if dry_run is True (indicating callers should return early),\n    False otherwise (indicating normal execution should continue).",
  "is_public": false
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "_scan_modules",
  "name": "_scan_modules",
  "node_type": "FunctionDef",
  "lineno": 881,
  "col": 0,
  "end_lineno": 903,
  "end_col": 36,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "run_all",
  "name": "run_all",
  "node_type": "FunctionDef",
  "lineno": 907,
  "col": 0,
  "end_lineno": 968,
  "end_col": 84,
  "parent_qualname": null,
  "decorators": [
    "app.command('all')"
  ],
  "bases": [],
  "docstring": "Run the full enrichment pipeline and emit all artifacts.",
  "is_public": true
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "run",
  "name": "run",
  "node_type": "FunctionDef",
  "lineno": 972,
  "col": 0,
  "end_lineno": 1009,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [
    "app.command('run')"
  ],
  "bases": [],
  "docstring": "Alias for ``all`` to match historical CLI entrypoints.",
  "is_public": true
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "scan",
  "name": "scan",
  "node_type": "FunctionDef",
  "lineno": 1013,
  "col": 0,
  "end_lineno": 1051,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [
    "app.command('scan')"
  ],
  "bases": [],
  "docstring": "Backward-compatible alias for ``all``.",
  "is_public": true
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "exports",
  "name": "exports",
  "node_type": "FunctionDef",
  "lineno": 1055,
  "col": 0,
  "end_lineno": 1107,
  "end_col": 90,
  "parent_qualname": null,
  "decorators": [
    "app.command('exports')"
  ],
  "bases": [],
  "docstring": "Emit modules.jsonl, repo map, tag index, and Markdown module sheets.",
  "is_public": true
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "graph",
  "name": "graph",
  "node_type": "FunctionDef",
  "lineno": 1111,
  "col": 0,
  "end_lineno": 1150,
  "end_col": 57,
  "parent_qualname": null,
  "decorators": [
    "app.command('graph')"
  ],
  "bases": [],
  "docstring": "Emit symbol and import graph artifacts.",
  "is_public": true
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "uses",
  "name": "uses",
  "node_type": "FunctionDef",
  "lineno": 1154,
  "col": 0,
  "end_lineno": 1193,
  "end_col": 42,
  "parent_qualname": null,
  "decorators": [
    "app.command('uses')"
  ],
  "bases": [],
  "docstring": "Emit the definition-to-use graph derived from SCIP.",
  "is_public": true
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "typedness",
  "name": "typedness",
  "node_type": "FunctionDef",
  "lineno": 1197,
  "col": 0,
  "end_lineno": 1236,
  "end_col": 56,
  "parent_qualname": null,
  "decorators": [
    "app.command('typedness')"
  ],
  "bases": [],
  "docstring": "Emit typedness analytics (errors, annotation ratios, untyped defs).",
  "is_public": true
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "doc",
  "name": "doc",
  "node_type": "FunctionDef",
  "lineno": 1240,
  "col": 0,
  "end_lineno": 1279,
  "end_col": 51,
  "parent_qualname": null,
  "decorators": [
    "app.command('doc')"
  ],
  "bases": [],
  "docstring": "Emit doc health analytics for module docstrings.",
  "is_public": true
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "coverage",
  "name": "coverage",
  "node_type": "FunctionDef",
  "lineno": 1283,
  "col": 0,
  "end_lineno": 1322,
  "end_col": 54,
  "parent_qualname": null,
  "decorators": [
    "app.command('coverage')"
  ],
  "bases": [],
  "docstring": "Emit coverage analytics table.",
  "is_public": true
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "config",
  "name": "config",
  "node_type": "FunctionDef",
  "lineno": 1326,
  "col": 0,
  "end_lineno": 1365,
  "end_col": 46,
  "parent_qualname": null,
  "decorators": [
    "app.command('config')"
  ],
  "bases": [],
  "docstring": "Emit config index (YAML/TOML/JSON/Markdown references).",
  "is_public": true
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "hotspots",
  "name": "hotspots",
  "node_type": "FunctionDef",
  "lineno": 1369,
  "col": 0,
  "end_lineno": 1408,
  "end_col": 53,
  "parent_qualname": null,
  "decorators": [
    "app.command('hotspots')"
  ],
  "bases": [],
  "docstring": "Emit hotspot analytics (complexity x churn x centrality).",
  "is_public": true
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "overlays",
  "name": "overlays",
  "node_type": "FunctionDef",
  "lineno": 1412,
  "col": 0,
  "end_lineno": 1616,
  "end_col": 65,
  "parent_qualname": null,
  "decorators": [
    "app.command('overlays')"
  ],
  "bases": [],
  "docstring": "Generate targeted overlays and optionally activate them into the stub path.\n\nThis command generates type stub overlays (.pyi files) for modules with type\nerrors, missing annotations, or other typing issues. Overlays are generated based\non SCIP index data, type error reports, and configurable policies. The command\ncan optionally activate overlays into the stub path for immediate use by type\ncheckers, or deactivate existing overlays before generating new ones.\n\nParameters\n----------\nctx : typer.Context\n    Typer context object providing access to shared CLI state (pipeline options,\n    analytics settings). The context is used to retrieve SCIP index path and\n    other pipeline configuration required for overlay generation.\nroot : Path\n    Repository root directory path. Provided via typer.Option. Used as the\n    base directory for discovering Python files and resolving relative paths.\nscip : Path | None, optional\n    Optional path to SCIP index file. Provided via typer.Option. If None,\n    overlay generation may be limited or disabled. Defaults to None.\nout : Path\n    Output directory path for generated overlay files. Provided via typer.Option.\n    Overlays are written to a subdirectory within this output directory.\npyrefly_json : Path | None, optional\n    Optional path to Pyrefly JSON report. Provided via typer.Option. Used to\n    identify type errors and inform overlay generation decisions. Defaults to None.\ntags_yaml : Path | None, optional\n    Optional path to tags YAML configuration file. Provided via typer.Option.\n    Used for filtering and tagging modules that require overlays. Defaults to None.\ncoverage_xml : Path\n    Path to coverage XML report file. Provided via typer.Option. Used for\n    identifying covered code paths that may need type annotations.\nonly : list[str] | None, optional\n    Optional list of file patterns to include. Provided via typer.Option.\n    If provided, only files matching these patterns are processed. Defaults to None.\nmax_file_bytes : int, optional\n    Maximum file size in bytes. Provided via typer.Option. Files exceeding\n    this limit are skipped during processing. Defaults to a configured maximum.\nowners : bool, optional\n    Whether to include code ownership analytics. Provided via typer.Option.\n    Used for identifying code owners of modules requiring overlays. Defaults to False.\nhistory_window_days : int, optional\n    Number of days to look back for git history analysis. Provided via typer.Option.\n    Used for computing code churn metrics. Defaults to a configured window.\ncommits_window : int, optional\n    Number of commits to analyze for git-based metrics. Provided via typer.Option.\n    Used for identifying frequently changed files that may need overlays. Defaults\n    to a configured window.\nemit_slices : bool, optional\n    Whether to emit code slice analytics. Provided via typer.Option. Slices can\n    help identify code patterns that need type annotations. Defaults to False.\nslices_filter : list[str] | None, optional\n    Optional list of slice filter patterns. Provided via typer.Option. If provided,\n    only slices matching these patterns are included. Defaults to None.\nconfig_path : Path | None, optional\n    Path to a YAML/JSON configuration file describing overlay generation settings\n    (e.g., min_errors, max_overlays, include_public_defs). If None, default\n    settings are used. The config file can specify overlay policies, paths,\n    and generation rules.\noverrides : list[str] | None, optional\n    List of KEY=VALUE override strings to modify overlay settings from config\n    or defaults. Each override must use the format \"KEY=VALUE\" (e.g., \"min_errors=5\").\n    Overrides take precedence over config file settings. If None, no overrides\n    are applied.\ndry_run : bool, optional\n    If True, perform a dry run without writing overlay files. Provided via\n    typer.Option. Shows what would be generated without actually creating files.\n    Defaults to False.\n\nRaises\n------\ntyper.BadParameter\n    Raised in the following cases:\n    - ``--scip`` option is missing or invalid: SCIP index is required for\n      overlay generation as it provides symbol definitions and type information\n    - Override format is invalid: override strings must use KEY=VALUE format\n    - Config file parsing fails: YAML/JSON config cannot be parsed or contains\n      invalid values\n\nNotes\n-----\nThis command performs overlay generation by analyzing SCIP index data and type\nerror reports to identify modules that would benefit from type stub overlays.\nOverlays are generated based on configurable policies (e.g., minimum type errors,\nmaximum overlays per run, public definitions only). The command writes overlay\nfiles to the configured overlays root directory and optionally activates them\ninto the stub path. A manifest file tracks generated overlays for management\nand cleanup. The command respects the --deactivate-all-first option to clear\nexisting overlays before generating new ones.",
  "is_public": true
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "to_duckdb",
  "name": "to_duckdb",
  "node_type": "FunctionDef",
  "lineno": 1620,
  "col": 0,
  "end_lineno": 1642,
  "end_col": 65,
  "parent_qualname": null,
  "decorators": [
    "app.command('to-duckdb')"
  ],
  "bases": [],
  "docstring": "Load ``modules.jsonl`` into DuckDB (idempotent on ``path``).",
  "is_public": true
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "_load_overlay_tagged_paths",
  "name": "_load_overlay_tagged_paths",
  "node_type": "FunctionDef",
  "lineno": 1645,
  "col": 0,
  "end_lineno": 1679,
  "end_col": 76,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return cached overlay-needed paths from the most recent tag index.\n\nParameters\n----------\nout_dir : Path\n    Output directory containing the tags subdirectory. The function looks\n    for ``tags/tags_index.yaml`` within this directory.\noverlay_tag : str\n    Tag name to filter overlay paths. If empty, returns an empty frozenset.\n    The tag is used to identify which paths require overlay generation.\n\nReturns\n-------\nfrozenset[str]\n    Set of file paths that require overlay generation, filtered by the\n    specified tag. Returns an empty frozenset if the tag is empty, the\n    tags file doesn't exist, or YAML parsing fails.",
  "is_public": false
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "_build_overlay_context",
  "name": "_build_overlay_context",
  "node_type": "FunctionDef",
  "lineno": 1682,
  "col": 0,
  "end_lineno": 1730,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "_build_module_row",
  "name": "_build_module_row",
  "node_type": "FunctionDef",
  "lineno": 1733,
  "col": 0,
  "end_lineno": 1783,
  "end_col": 31,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "_scip_symbols_and_edges",
  "name": "_scip_symbols_and_edges",
  "node_type": "FunctionDef",
  "lineno": 1786,
  "col": 0,
  "end_lineno": 1794,
  "end_col": 62,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "_index_module_safe",
  "name": "_index_module_safe",
  "node_type": "FunctionDef",
  "lineno": 1797,
  "col": 0,
  "end_lineno": 1823,
  "end_col": 76,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Run LibCST indexing with structured error reporting.\n\nParameters\n----------\nrel_path : str\n    Relative path to the module being indexed. Used for error reporting and\n    context in the returned ModuleIndex.\ncode : str\n    Source code content of the module to parse. Must be valid Python syntax\n    for LibCST to successfully parse.\n\nReturns\n-------\nModuleIndex\n    Parsed LibCST metadata for the module.\n\nRaises\n------\nIndexingError\n    Raised when LibCST fails to parse the module.",
  "is_public": false
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "_read_module_source",
  "name": "_read_module_source",
  "node_type": "FunctionDef",
  "lineno": 1826,
  "col": 0,
  "end_lineno": 1870,
  "end_col": 19,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return module source or record a structured error.\n\nParameters\n----------\nfp : Path\n    File path to read source from. The file must exist and be readable.\nrel_path : str\n    Relative path to the module, used for error reporting when read fails.\nrecord : ModuleRecord\n    Module record to update with errors if reading fails. Errors are added\n    via ``record.add_error()`` and ``parse_ok`` is set to False.\nmax_file_bytes : int\n    Maximum file size in bytes. Files exceeding this limit are skipped and\n    an error is recorded.\n\nReturns\n-------\nstr | None\n    Source text when available, otherwise ``None`` after recording an error.",
  "is_public": false
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "_collect_outline_nodes",
  "name": "_collect_outline_nodes",
  "node_type": "FunctionDef",
  "lineno": 1873,
  "col": 0,
  "end_lineno": 1902,
  "end_col": 17,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return Tree-sitter outline nodes while capturing failures.\n\nParameters\n----------\nrel_path : str\n    Relative path to the module being processed. Used for error reporting\n    when Tree-sitter parsing fails.\ncode : str\n    Source code content to parse with Tree-sitter. Must be valid Python\n    syntax for successful parsing.\nrecord : ModuleRecord\n    Module record to update with errors if Tree-sitter parsing fails. Errors\n    are added via ``record.add_error()``.\n\nReturns\n-------\nlist[dict[str, Any]]\n    Outline nodes; empty list when extraction fails.",
  "is_public": false
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "_apply_index_results",
  "name": "_apply_index_results",
  "node_type": "FunctionDef",
  "lineno": 1905,
  "col": 0,
  "end_lineno": 1942,
  "end_col": 44,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Populate ``record`` with data derived from LibCST/Tree-sitter.",
  "is_public": false
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "_outline_nodes_for",
  "name": "_outline_nodes_for",
  "node_type": "FunctionDef",
  "lineno": 1945,
  "col": 0,
  "end_lineno": 1982,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Build Tree-sitter outline nodes for ``rel_path``.\n\nParameters\n----------\nrel_path : str\n    Relative path to the module being processed. Used for error reporting\n    when Tree-sitter parsing fails.\ncode : str\n    Source code content to parse with Tree-sitter. Must be valid Python\n    syntax for successful parsing.\n\nReturns\n-------\nlist[dict[str, Any]]\n    Outline node structures capturing names and byte offsets.\n\nRaises\n------\nIndexingError\n    Raised when Tree-sitter parsing fails.",
  "is_public": false
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "_type_error_count",
  "name": "_type_error_count",
  "node_type": "FunctionDef",
  "lineno": 1985,
  "col": 0,
  "end_lineno": 1987,
  "end_col": 40,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "_coverage_value",
  "name": "_coverage_value",
  "node_type": "FunctionDef",
  "lineno": 1990,
  "col": 0,
  "end_lineno": 1992,
  "end_col": 37,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "_augment_module_rows",
  "name": "_augment_module_rows",
  "node_type": "FunctionDef",
  "lineno": 1995,
  "col": 0,
  "end_lineno": 2064,
  "end_col": 50,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Attach graph/usage/export metadata and emit module artifacts.\n\nParameters\n----------\nmodule_rows : list[ModuleRecord]\n    Module metadata rows (mutable mapping) to augment with graph and export information.\nscip_index : SCIPIndex\n    SCIP index for building use graphs and resolving symbol references.\npackage_prefix : str | None\n    Optional package prefix for module name normalization.\nconfig_records : list[dict[str, Any]] | None, optional\n    Optional configuration file records to cross-reference with modules.\n\nReturns\n-------\ntuple[ImportGraph, UseGraph, list[dict[str, Any]]]\n    Graphs and config index records with reference metadata.",
  "is_public": false
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "_build_tag_index",
  "name": "_build_tag_index",
  "node_type": "FunctionDef",
  "lineno": 2067,
  "col": 0,
  "end_lineno": 2078,
  "end_col": 20,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "_infer_tags",
  "name": "_infer_tags",
  "node_type": "FunctionDef",
  "lineno": 2081,
  "col": 0,
  "end_lineno": 2085,
  "end_col": 66,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Apply tagging rules with logging/telemetry.",
  "is_public": false
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "_apply_tagging",
  "name": "_apply_tagging",
  "node_type": "FunctionDef",
  "lineno": 2088,
  "col": 0,
  "end_lineno": 2106,
  "end_col": 37,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Apply tagging rules to module rows and update their tags in-place.\n\nParameters\n----------\nrows : list[ModuleRecord]\n    Module metadata rows to tag. Modified in-place.\nrules : Mapping[str, Any]\n    Tagging rules dictionary for inferring tags from module traits.",
  "is_public": false
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "_traits_from_row",
  "name": "_traits_from_row",
  "node_type": "FunctionDef",
  "lineno": 2109,
  "col": 0,
  "end_lineno": 2167,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Extract ModuleTraits from a module metadata row.\n\nParameters\n----------\nrow : Mapping[str, Any]\n    Module metadata row containing imports, exports, metrics, etc.\n\nReturns\n-------\nModuleTraits\n    Extracted traits object for tag inference.",
  "is_public": false
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "_build_coverage_rows",
  "name": "_build_coverage_rows",
  "node_type": "FunctionDef",
  "lineno": 2170,
  "col": 0,
  "end_lineno": 2178,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "_build_hotspot_rows",
  "name": "_build_hotspot_rows",
  "node_type": "FunctionDef",
  "lineno": 2181,
  "col": 0,
  "end_lineno": 2192,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "_write_exports_outputs",
  "name": "_write_exports_outputs",
  "node_type": "FunctionDef",
  "lineno": 2195,
  "col": 0,
  "end_lineno": 2201,
  "end_col": 50,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "_write_graph_outputs",
  "name": "_write_graph_outputs",
  "node_type": "FunctionDef",
  "lineno": 2204,
  "col": 0,
  "end_lineno": 2208,
  "end_col": 89,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "_write_uses_output",
  "name": "_write_uses_output",
  "node_type": "FunctionDef",
  "lineno": 2211,
  "col": 0,
  "end_lineno": 2214,
  "end_col": 91,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "_apply_ownership",
  "name": "_apply_ownership",
  "node_type": "FunctionDef",
  "lineno": 2217,
  "col": 0,
  "end_lineno": 2243,
  "end_col": 20,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "_write_ownership_output",
  "name": "_write_ownership_output",
  "node_type": "FunctionDef",
  "lineno": 2246,
  "col": 0,
  "end_lineno": 2258,
  "end_col": 64,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "_write_slices_output",
  "name": "_write_slices_output",
  "node_type": "FunctionDef",
  "lineno": 2261,
  "col": 0,
  "end_lineno": 2295,
  "end_col": 59,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "_write_typedness_output",
  "name": "_write_typedness_output",
  "node_type": "FunctionDef",
  "lineno": 2298,
  "col": 0,
  "end_lineno": 2309,
  "end_col": 73,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "_write_doc_output",
  "name": "_write_doc_output",
  "node_type": "FunctionDef",
  "lineno": 2312,
  "col": 0,
  "end_lineno": 2323,
  "end_col": 69,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "_write_coverage_output",
  "name": "_write_coverage_output",
  "node_type": "FunctionDef",
  "lineno": 2326,
  "col": 0,
  "end_lineno": 2327,
  "end_col": 87,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "_write_config_output",
  "name": "_write_config_output",
  "node_type": "FunctionDef",
  "lineno": 2330,
  "col": 0,
  "end_lineno": 2331,
  "end_col": 76,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "_write_hotspot_output",
  "name": "_write_hotspot_output",
  "node_type": "FunctionDef",
  "lineno": 2334,
  "col": 0,
  "end_lineno": 2335,
  "end_col": 87,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "_write_ast_outputs",
  "name": "_write_ast_outputs",
  "node_type": "FunctionDef",
  "lineno": 2338,
  "col": 0,
  "end_lineno": 2354,
  "end_col": 100,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "_write_modules_json",
  "name": "_write_modules_json",
  "node_type": "FunctionDef",
  "lineno": 2357,
  "col": 0,
  "end_lineno": 2363,
  "end_col": 59,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "_write_markdown_modules",
  "name": "_write_markdown_modules",
  "node_type": "FunctionDef",
  "lineno": 2366,
  "col": 0,
  "end_lineno": 2377,
  "end_col": 45,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "_write_repo_map",
  "name": "_write_repo_map",
  "node_type": "FunctionDef",
  "lineno": 2380,
  "col": 0,
  "end_lineno": 2402,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "_write_symbol_graph",
  "name": "_write_symbol_graph",
  "node_type": "FunctionDef",
  "lineno": 2405,
  "col": 0,
  "end_lineno": 2409,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "_write_tabular_records",
  "name": "_write_tabular_records",
  "node_type": "FunctionDef",
  "lineno": 2412,
  "col": 0,
  "end_lineno": 2414,
  "end_col": 57,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "_collect_ast_artifacts",
  "name": "_collect_ast_artifacts",
  "node_type": "FunctionDef",
  "lineno": 2417,
  "col": 0,
  "end_lineno": 2437,
  "end_col": 33,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "_write_ast_jsonl",
  "name": "_write_ast_jsonl",
  "node_type": "FunctionDef",
  "lineno": 2440,
  "col": 0,
  "end_lineno": 2442,
  "end_col": 56,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Persist AST artifacts to JSONL for portability.",
  "is_public": false
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "_normalize_type_signal_map",
  "name": "_normalize_type_signal_map",
  "node_type": "FunctionDef",
  "lineno": 2445,
  "col": 0,
  "end_lineno": 2458,
  "end_col": 21,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "_normalize_metric_map",
  "name": "_normalize_metric_map",
  "node_type": "FunctionDef",
  "lineno": 2461,
  "col": 0,
  "end_lineno": 2476,
  "end_col": 21,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "_normalize_path_key",
  "name": "_normalize_path_key",
  "node_type": "FunctionDef",
  "lineno": 2479,
  "col": 0,
  "end_lineno": 2480,
  "end_col": 34,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "_group_configs_by_dir",
  "name": "_group_configs_by_dir",
  "node_type": "FunctionDef",
  "lineno": 2483,
  "col": 0,
  "end_lineno": 2491,
  "end_col": 18,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "_config_refs_for_row",
  "name": "_config_refs_for_row",
  "node_type": "FunctionDef",
  "lineno": 2494,
  "col": 0,
  "end_lineno": 2507,
  "end_col": 15,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "_ancestor_dirs",
  "name": "_ancestor_dirs",
  "node_type": "FunctionDef",
  "lineno": 2510,
  "col": 0,
  "end_lineno": 2522,
  "end_col": 20,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "_dir_key_from_path",
  "name": "_dir_key_from_path",
  "node_type": "FunctionDef",
  "lineno": 2525,
  "col": 0,
  "end_lineno": 2529,
  "end_col": 38,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "_should_mark_overlay",
  "name": "_should_mark_overlay",
  "node_type": "FunctionDef",
  "lineno": 2532,
  "col": 0,
  "end_lineno": 2559,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "_ensure_package_overlays",
  "name": "_ensure_package_overlays",
  "node_type": "FunctionDef",
  "lineno": 2562,
  "col": 0,
  "end_lineno": 2645,
  "end_col": 16,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Ensure package ``__init__`` overlays exist for ancestors of ``rel_path``.\n\nParameters\n----------\nrel_path : Path\n    Relative path to a Python file. Package overlays are created for\n    all ancestor directories containing ``__init__.py`` files.\ngenerated : list[str]\n    Mutable list of generated overlay paths (relative keys). New overlays\n    are appended to this list.\ngenerated_set : set[str]\n    Set of generated overlay paths for fast membership testing. Updated\n    in parallel with ``generated``.\nmanifest_entries : list[str]\n    Mutable list of manifest entry strings. New entries are appended\n    in the format ``{package_name}/{rel_key}``.\npackage_name : str\n    Package name prefix for manifest entries.\npackage_overlays : set[str]\n    Set of package overlay paths that have already been processed. Used\n    to avoid duplicate work when traversing ancestor directories.\nroot : Path\n    Root directory of the package. Used to resolve absolute paths for\n    ``__init__.py`` files.\nscip_index : SCIPIndex\n    SCIP index for resolving star import re-exports in package overlays.\npolicy : OverlayPolicy\n    Policy controlling overlay generation (max_overlays, etc.).\ntype_error_counts : Mapping[str, int]\n    Mapping of module keys to type error counts. Used to determine\n    eligibility for overlay generation.\n\nReturns\n-------\nbool\n    True when the overlay budget (``policy.max_overlays``) was exhausted\n    while creating package overlays. False otherwise.",
  "is_public": false
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "_normalized_rel_path",
  "name": "_normalized_rel_path",
  "node_type": "FunctionDef",
  "lineno": 2648,
  "col": 0,
  "end_lineno": 2649,
  "end_col": 41,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cli_enrich.py",
  "module": "cli_enrich",
  "qualname": "_write_tag_index",
  "name": "_write_tag_index",
  "node_type": "FunctionDef",
  "lineno": 2652,
  "col": 0,
  "end_lineno": 2664,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "config/__init__.py",
  "module": "config",
  "qualname": "config",
  "name": "config",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Configuration loading and environment settings for CodeIntel MCP.",
  "is_public": true
}
{
  "path": "config/settings.py",
  "module": "config.settings",
  "qualname": "config.settings",
  "name": "config.settings",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Configuration settings using msgspec for fast, validated config.\n\nNO Pydantic - using msgspec.Struct for performance-critical settings.\nAll configuration loaded from environment variables with sensible defaults.",
  "is_public": true
}
{
  "path": "config/settings.py",
  "module": "config.settings",
  "qualname": "_HybridChannelSettings",
  "name": "_HybridChannelSettings",
  "node_type": "ClassDef",
  "lineno": 28,
  "col": 0,
  "end_lineno": 32,
  "end_col": 17,
  "parent_qualname": null,
  "decorators": [
    "dataclass(frozen=True)"
  ],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "config/settings.py",
  "module": "config.settings",
  "qualname": "_env_bool",
  "name": "_env_bool",
  "node_type": "FunctionDef",
  "lineno": 35,
  "col": 0,
  "end_lineno": 52,
  "end_col": 83,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return a boolean flag parsed from environment variables.\n\nParameters\n----------\nkey : str\n    Environment variable name to read.\ndefault : bool, optional\n    Default value if the environment variable is not set. Defaults to False.\n\nReturns\n-------\nbool\n    Boolean value parsed from the environment variable. Returns True if the\n    value is \"1\", \"true\", or \"yes\" (case-insensitive), False otherwise.",
  "is_public": false
}
{
  "path": "config/settings.py",
  "module": "config.settings",
  "qualname": "_parse_int_with_suffix",
  "name": "_parse_int_with_suffix",
  "node_type": "FunctionDef",
  "lineno": 55,
  "col": 0,
  "end_lineno": 96,
  "end_col": 22,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return an integer, accepting 1k-style suffixes (k=1_000).\n\nExtended Summary\n----------------\nThis helper parses integer values from configuration strings, supporting\ncompact notation with 'k' suffix (e.g., \"10k\" = 10000). Used for parsing\nenvironment variables that specify sizes or counts in a human-readable format.\nNormalizes input by stripping whitespace, converting to lowercase, and removing\nunderscores before parsing.\n\nParameters\n----------\nvalue : str\n    String to parse, optionally ending with 'k' suffix (e.g., \"10k\", \"1_000k\").\n    Whitespace and underscores are normalized before parsing.\ndefault : int\n    Default value returned if parsing fails, value is empty, or ValueError\n    is raised during conversion.\n\nReturns\n-------\nint\n    Parsed integer value, or default if parsing fails or value is empty.\n    Suffix 'k' multiplies the numeric part by 1000.\n\nNotes\n-----\nThis helper is used for parsing configuration values that may be specified\nin compact notation (e.g., \"10k\" instead of \"10000\"). Defensively handles\nmalformed input by returning the default value. Time complexity: O(n) where\nn is the length of the input string.",
  "is_public": false
}
{
  "path": "config/settings.py",
  "module": "config.settings",
  "qualname": "_parse_int_list",
  "name": "_parse_int_list",
  "node_type": "FunctionDef",
  "lineno": 99,
  "col": 0,
  "end_lineno": 142,
  "end_col": 48,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return a tuple of integers from a comma-separated configuration string.\n\nExtended Summary\n----------------\nThis helper parses comma-separated integer lists from configuration strings\n(e.g., \"10,20,30\" -> (10, 20, 30)). Used for parsing environment variables\nthat specify multiple integer values. If any element fails to parse, the\nentire operation fails and returns the fallback value.\n\nParameters\n----------\nenv_value : str | None\n    Comma-separated string of integers (e.g., \"10,20,30\"). Whitespace around\n    commas is stripped. If None or empty, returns fallback.\nfallback : tuple[int, ...]\n    Default value returned if parsing fails, env_value is None/empty, or\n    any element cannot be converted to int.\n\nReturns\n-------\ntuple[int, ...]\n    Parsed integers, or fallback if parsing fails or env_value is None/empty.\n    Empty strings between commas are ignored.\n\nNotes\n-----\nThis helper is used for parsing configuration values that specify multiple\nintegers (e.g., nlist values for adaptive indexing). Defensively handles\nmalformed input by returning the fallback value. Time complexity: O(n) where\nn is the length of the input string.",
  "is_public": false
}
{
  "path": "config/settings.py",
  "module": "config.settings",
  "qualname": "_optional_int",
  "name": "_optional_int",
  "node_type": "FunctionDef",
  "lineno": 145,
  "col": 0,
  "end_lineno": 179,
  "end_col": 19,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Convert an optional string to ``int`` when possible.\n\nExtended Summary\n----------------\nThis helper safely converts optional configuration strings to integers.\nUsed for parsing environment variables that may be unset or empty. Returns\nNone for None, empty strings, or invalid values, allowing callers to use\nNone as a sentinel for \"not configured\".\n\nParameters\n----------\nraw : str | None\n    String to convert to integer. If None, empty, or contains non-numeric\n    characters (after stripping), returns None.\n\nReturns\n-------\nint | None\n    Parsed integer, or None if raw is None, empty, or invalid. ValueError\n    during conversion is caught and returns None.\n\nNotes\n-----\nThis helper is used for parsing optional configuration values where None\nindicates \"use default\" rather than \"zero\". Defensively handles malformed\ninput by returning None. Time complexity: O(1) for None/empty, O(n) for\nparsing where n is the string length.",
  "is_public": false
}
{
  "path": "config/settings.py",
  "module": "config.settings",
  "qualname": "_build_vllm_config",
  "name": "_build_vllm_config",
  "node_type": "FunctionDef",
  "lineno": 182,
  "col": 0,
  "end_lineno": 207,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "config/settings.py",
  "module": "config.settings",
  "qualname": "_build_embeddings_config",
  "name": "_build_embeddings_config",
  "node_type": "FunctionDef",
  "lineno": 210,
  "col": 0,
  "end_lineno": 244,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "config/settings.py",
  "module": "config.settings",
  "qualname": "_build_xtr_config",
  "name": "_build_xtr_config",
  "node_type": "FunctionDef",
  "lineno": 247,
  "col": 0,
  "end_lineno": 260,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "config/settings.py",
  "module": "config.settings",
  "qualname": "_build_rerank_config",
  "name": "_build_rerank_config",
  "node_type": "FunctionDef",
  "lineno": 263,
  "col": 0,
  "end_lineno": 271,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "config/settings.py",
  "module": "config.settings",
  "qualname": "CodeRankConfig",
  "name": "CodeRankConfig",
  "node_type": "ClassDef",
  "lineno": 274,
  "col": 0,
  "end_lineno": 310,
  "end_col": 35,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "msgspec.Struct"
  ],
  "docstring": "Configuration for the CodeRank dense retriever.\n\nAttributes\n----------\nmodel_id : str\n    Hugging Face model identifier for CodeRank embeddings (bi-encoder).\ntrust_remote_code : bool\n    Whether to allow custom modules provided by the model repository.\ndevice : str\n    Device identifier (\"cpu\", \"cuda\", or \"auto\") used for inference.\nbatch_size : int\n    Batch size used while encoding queries or code chunks.\nnormalize : bool\n    When ``True`` (default), normalize embeddings for cosine similarity.\nquery_prefix : str\n    Instruction prefix required by the CodeRank model card for queries.\ntop_k : int\n    Maximum number of candidates to retrieve during Stage-A.\nbudget_ms : int\n    Soft latency budget for CodeRank embedding + ANN search.\nmin_stage2_margin : float\n    Score margin threshold that skips Stage-B when confidence is high.\nmin_stage2_candidates : int\n    Minimum candidate count required to invoke Stage-B.",
  "is_public": true
}
{
  "path": "config/settings.py",
  "module": "config.settings",
  "qualname": "WarpConfig",
  "name": "WarpConfig",
  "node_type": "ClassDef",
  "lineno": 313,
  "col": 0,
  "end_lineno": 337,
  "end_col": 24,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "msgspec.Struct"
  ],
  "docstring": "Configuration for the WARP/XTR late-interaction reranker.\n\nAttributes\n----------\nindex_dir : str\n    Directory containing the compiled WARP/XTR index artifacts.\nmodel_id : str\n    Identifier for the multivector encoder used by WARP (for reference).\ndevice : str\n    Target device for the WARP executor (\"cpu\" or \"cuda\").\ntop_k : int\n    Candidate fan-out requested from the WARP executor.\nenabled : bool\n    Gate to enable/disable WARP at runtime (defaults to ``False``).\nbudget_ms : int\n    Soft latency budget for the WARP reranking stage.",
  "is_public": true
}
{
  "path": "config/settings.py",
  "module": "config.settings",
  "qualname": "XTRConfig",
  "name": "XTRConfig",
  "node_type": "ClassDef",
  "lineno": 340,
  "col": 0,
  "end_lineno": 350,
  "end_col": 46,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "msgspec.Struct"
  ],
  "docstring": "Configuration for XTR token storage and scoring.",
  "is_public": true
}
{
  "path": "config/settings.py",
  "module": "config.settings",
  "qualname": "RerankConfig",
  "name": "RerankConfig",
  "node_type": "ClassDef",
  "lineno": 353,
  "col": 0,
  "end_lineno": 359,
  "end_col": 25,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "msgspec.Struct"
  ],
  "docstring": "Configuration for optional late-interaction reranking.",
  "is_public": true
}
{
  "path": "config/settings.py",
  "module": "config.settings",
  "qualname": "EvalConfig",
  "name": "EvalConfig",
  "node_type": "ClassDef",
  "lineno": 362,
  "col": 0,
  "end_lineno": 371,
  "end_col": 31,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "msgspec.Struct"
  ],
  "docstring": "Offline evaluation configuration.",
  "is_public": true
}
{
  "path": "config/settings.py",
  "module": "config.settings",
  "qualname": "CodeRankLLMConfig",
  "name": "CodeRankLLMConfig",
  "node_type": "ClassDef",
  "lineno": 374,
  "col": 0,
  "end_lineno": 383,
  "end_col": 24,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "msgspec.Struct"
  ],
  "docstring": "Configuration for the CodeRank listwise reranker.",
  "is_public": true
}
{
  "path": "config/settings.py",
  "module": "config.settings",
  "qualname": "VLLMRunMode",
  "name": "VLLMRunMode",
  "node_type": "ClassDef",
  "lineno": 386,
  "col": 0,
  "end_lineno": 389,
  "end_col": 52,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "msgspec.Struct"
  ],
  "docstring": "Execution mode for the vLLM embedder.",
  "is_public": true
}
{
  "path": "config/settings.py",
  "module": "config.settings",
  "qualname": "VLLMConfig",
  "name": "VLLMConfig",
  "node_type": "ClassDef",
  "lineno": 392,
  "col": 0,
  "end_lineno": 456,
  "end_col": 36,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "msgspec.Struct"
  ],
  "docstring": "vLLM embedding service configuration.\n\nConfiguration for connecting to a vLLM embedding service that provides\nOpenAI-compatible embeddings API. This is used for generating vector embeddings\nof code chunks during indexing and for query embeddings during semantic search.\n\nThe vLLM service runs separately (typically on a GPU-enabled machine) and\nprovides fast batch embedding generation. The configuration includes connection\ndetails, model selection, and performance tuning parameters.\n\nAttributes\n----------\nbase_url : str\n    Base URL for the vLLM embeddings API endpoint. Should point to the /v1\n    endpoint of a running vLLM server. Defaults to localhost:8001.\nmodel : str\n    Model identifier for embeddings. This should match a model that the\n    vLLM server has loaded. Defaults to \"nomic-ai/nomic-embed-code\" which\n    is a code-specific embedding model with 2560 dimensions.\nbatch_size : int\n    Number of texts to embed in a single batch request. Larger batches improve\n    throughput but increase memory usage. Defaults to 64, which is a good\n    balance for most GPU setups.\nembedding_dim : int\n    Dimensionality of embeddings returned by the configured model. Defaults to\n    2560 to match the deployed nomic-embed-code checkpoint. Consumers should\n    keep this aligned with :class:`IndexConfig` ``vec_dim``.\ntimeout_s : float\n    HTTP request timeout in seconds. Embedding requests can take time for\n    large batches, so this should be set appropriately. Defaults to 120 seconds.\nrun : VLLMRunMode\n    Runtime execution mode for vLLM. Controls whether embeddings are generated\n    via HTTP requests to a remote service (\"http\") or using an in-process vLLM\n    engine (\"inprocess\"). Defaults to \"inprocess\" for local development.\ngpu_memory_utilization : float\n    Fraction of GPU memory to allocate for vLLM model and KV cache. Range [0.0, 1.0].\n    Higher values improve throughput but reduce available memory for other operations.\n    Defaults to 0.92 (92% of GPU memory).\nmax_num_batched_tokens : int\n    Maximum number of tokens to process in a single batch. Larger values improve\n    throughput but increase memory usage and latency. Defaults to 65536 tokens.\nnormalize : bool\n    Whether to L2-normalize embeddings after generation. Normalized embeddings\n    enable cosine similarity computation via dot product. Defaults to True.\npooling_type : Literal[\"lasttoken\", \"cls\", \"mean\"]\n    Token pooling strategy for generating embeddings from token-level outputs.\n    \"lasttoken\" uses the final token embedding, \"cls\" uses a special CLS token,\n    \"mean\" averages all token embeddings. Defaults to \"lasttoken\".\nmax_concurrent_requests : int\n    Maximum number of concurrent embedding requests allowed when using HTTP mode.\n    Higher values improve throughput but increase memory usage. Defaults to 4.",
  "is_public": true
}
{
  "path": "config/settings.py",
  "module": "config.settings",
  "qualname": "EmbeddingsConfig",
  "name": "EmbeddingsConfig",
  "node_type": "ClassDef",
  "lineno": 459,
  "col": 0,
  "end_lineno": 508,
  "end_col": 34,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "msgspec.Struct"
  ],
  "docstring": "Embedding provider configuration shared by CLIs and services.\n\nAttributes\n----------\nprovider : Literal[\"vllm\", \"hf\"]\n    Embedding backend to use. ``\"vllm\"`` runs the vLLM engine locally while\n    ``\"hf\"`` uses a lightweight Hugging Face runtime for CPU-only hosts.\nmodel_name : str\n    Fully-qualified model identifier (e.g., ``nomic-ai/nomic-embed-code``).\ndevice : str\n    Target device string (``\"auto\"``, ``\"cuda\"``, ``\"cpu\"``). ``\"auto\"``\n    picks ``\"cuda\"`` when GPUs are available.\nbatch_size : int\n    Maximum logical batch size requested by callers.\nmicro_batch_size : int\n    Size of the internal micro-batches executed by the provider. Used by the\n    bounded executor to coalesce small jobs.\nnormalize : bool\n    Whether to enforce L2 normalization after pooling.\nmax_tokens : int\n    Upper bound on tokens per sequence. Used to guard pathological inputs.\nmax_sequence_chars : int\n    Hard clamp on the number of UTF-8 characters accepted per chunk.\nretry_max_attempts : int\n    Number of retries for transient provider errors.\nretry_backoff_ms : int\n    Initial exponential backoff delay in milliseconds.\nmax_pending_batches : int\n    Maximum number of pending batches in the bounded executor queue.\nmax_wait_ms : int\n    Aggregator wait window for fusing small jobs into a single batch.\nallow_hf_fallback : bool\n    When ``True``, automatically fall back to the Hugging Face provider if\n    vLLM initialization fails.",
  "is_public": true
}
{
  "path": "config/settings.py",
  "module": "config.settings",
  "qualname": "BM25Config",
  "name": "BM25Config",
  "node_type": "ClassDef",
  "lineno": 511,
  "col": 0,
  "end_lineno": 525,
  "end_col": 35,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "msgspec.Struct"
  ],
  "docstring": "BM25 indexing and search configuration.",
  "is_public": true
}
{
  "path": "config/settings.py",
  "module": "config.settings",
  "qualname": "PRFConfig",
  "name": "PRFConfig",
  "node_type": "ClassDef",
  "lineno": 528,
  "col": 0,
  "end_lineno": 537,
  "end_col": 37,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "msgspec.Struct"
  ],
  "docstring": "Pseudo relevance feedback (RM3) configuration.",
  "is_public": true
}
{
  "path": "config/settings.py",
  "module": "config.settings",
  "qualname": "SpladeConfig",
  "name": "SpladeConfig",
  "node_type": "ClassDef",
  "lineno": 540,
  "col": 0,
  "end_lineno": 605,
  "end_col": 33,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "msgspec.Struct"
  ],
  "docstring": "SPLADE v3 configuration covering model artifacts and index directories.\n\nAttributes\n----------\nmodel_id : str\n    Hugging Face model identifier used for training or export. Defaults to\n    ``naver/splade-v3``.\nmodel_dir : str\n    Local directory that stores exported model artifacts. Defaults to\n    ``models/splade-v3``.\nonnx_dir : str\n    Directory containing exported ONNX models. Defaults to ``models/splade-v3/onnx``.\nonnx_file : str\n    Primary ONNX file name (relative to ``onnx_dir``). Defaults to ``model_qint8.onnx``.\nvectors_dir : str\n    Directory that stores SPLADE JsonVectorCollection shards. Defaults to\n    ``data/splade_vectors``.\nindex_dir : str\n    Output directory for the Lucene impact index. Defaults to ``indexes/splade_v3_impact``.\nprovider : str\n    Default ONNX Runtime execution provider. Defaults to ``CPUExecutionProvider``.\nquantization : int\n    Integer quantization factor applied during encoding. Defaults to ``100``.\nmax_terms : int\n    Maximum number of query terms to retain when expanding SPLADE queries. Defaults to ``3000``.\nmax_clause_count : int\n    Lucene Boolean clause limit applied during indexing. Defaults to ``4096``.\nbatch_size : int\n    Default encoding batch size for CLI utilities. Defaults to ``32``.\nthreads : int\n    Default thread count used for Lucene impact index builds. Defaults to ``8``.\nenabled : bool\n    Whether the SPLADE channel is enabled. Defaults to ``True``. When disabled,\n    the SPLADE channel is skipped during hybrid search.\nmax_query_terms : int\n    Maximum number of query terms to retain when expanding SPLADE queries.\n    Defaults to ``64``.\nprune_below : float\n    Minimum score threshold for pruning query terms. Terms with scores below\n    this threshold are excluded. Defaults to ``0.0`` (no pruning).\nanalyzer : Literal[\"wordpiece\", \"code\"]\n    Tokenizer analyzer type. \"wordpiece\" uses standard WordPiece tokenization,\n    \"code\" uses code-aware tokenization. Defaults to ``\"wordpiece\"``.\nstatic_prune_pct : float\n    Static pruning percentage applied during query expansion. Defaults to ``0.0``\n    (no static pruning).",
  "is_public": true
}
{
  "path": "config/settings.py",
  "module": "config.settings",
  "qualname": "PathsConfig",
  "name": "PathsConfig",
  "node_type": "ClassDef",
  "lineno": 608,
  "col": 0,
  "end_lineno": 678,
  "end_col": 29,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "msgspec.Struct"
  ],
  "docstring": "File system paths configuration.\n\nCentralized configuration for all file system paths used by the code intelligence\nsystem. This includes paths for data storage, indexes, and source code locations.\nAll paths can be relative (to repo_root) or absolute.\n\nThe paths are organized hierarchically: data_dir contains subdirectories for\ndifferent types of data (vectors, indexes, etc.). This structure makes it easy\nto manage and back up the entire index state.\n\nAttributes\n----------\nrepo_root : str\n    Absolute path to the repository root directory. This is the base directory\n    for all source code indexing and is used to resolve relative file paths\n    from SCIP indexes. Required - no default.\ndata_dir : str\n    Base directory for all data storage (indexes, vectors, databases). Defaults\n    to \"data\" relative to repo_root. This directory will contain subdirectories\n    for vectors, FAISS indexes, Lucene indexes, etc.\nvectors_dir : str\n    Directory containing Parquet files with vector embeddings. Each Parquet file\n    stores chunks with their embeddings in Arrow FixedSizeList format for\n    efficient zero-copy access. Defaults to \"data/vectors\".\nfaiss_index : str\n    Path to the FAISS IVF-PQ index file (CPU version). This is the persisted\n    index that can be loaded and cloned to GPU. Defaults to\n    \"data/faiss/code.ivfpq.faiss\".\nfaiss_idmap_path : str\n    Path to the FAISS ID map Parquet sidecar. This file stores the mapping\n    from FAISS row IDs to external chunk IDs for deterministic hydration.\n    Defaults to \"data/faiss/faiss_idmap.parquet\".\nlucene_dir : str\n    Directory for Lucene/BM25 indexes. Used for sparse retrieval methods like\n    BM25 keyword search. Defaults to \"data/lucene\".\nsplade_dir : str\n    Directory for SPLADE (Sparse Lexical and Dense) impact indexes. SPLADE\n    provides learned sparse representations that combine benefits of keyword\n    and dense search. Defaults to \"data/splade\".\nduckdb_path : str\n    Path to the DuckDB catalog database file. DuckDB provides SQL views over\n    Parquet files, enabling fast queries for chunk metadata, filtering, and\n    joins. Defaults to \"data/catalog.duckdb\".\nscip_index : str\n    Path to the SCIP index file (either protobuf .scip or JSON .scip.json).\n    This is the source of truth for symbol definitions and is generated by\n    the SCIP Python indexer. Defaults to \"index.scip\" in repo_root.\ncoderank_vectors_dir : str\n    Directory that stores CodeRank chunk embeddings (parquet or npy shards).\ncoderank_faiss_index : str\n    Path to the CodeRank FAISS index file used for Stage-A retrieval.\nwarp_index_dir : str\n    Directory containing WARP/XTR index artifacts.\nxtr_dir : str\n    Directory containing XTR token-level artifacts (memmaps + metadata).",
  "is_public": true
}
{
  "path": "config/settings.py",
  "module": "config.settings",
  "qualname": "IndexConfig",
  "name": "IndexConfig",
  "node_type": "ClassDef",
  "lineno": 681,
  "col": 0,
  "end_lineno": 752,
  "end_col": 67,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "msgspec.Struct"
  ],
  "docstring": "Indexing and search configuration.\n\nThis configuration controls chunking, embedding dimensionality, FAISS build and\nsearch-time parameters, and the hybrid retrieval stacks (BM25, SPLADE, fusion).\nThe defaults favor accuracy-first personal RAG deployments: IVF/PQ with OPQ\npre-rotation, higher search fan-out, structured logging, and GPU/cuVS when\navailable. Backwards-compatible legacy knobs (``faiss_nlist`` / ``faiss_nprobe``)\nremain but new code should prefer the richer ``faiss_family`` + runtime tuning\ncontrols introduced here.",
  "is_public": true
}
{
  "path": "config/settings.py",
  "module": "config.settings",
  "qualname": "IndexConfig.__post_init__",
  "name": "__post_init__",
  "node_type": "FunctionDef",
  "lineno": 747,
  "col": 4,
  "end_lineno": 752,
  "end_col": 67,
  "parent_qualname": "IndexConfig",
  "decorators": [],
  "bases": [],
  "docstring": "Bridge legacy and new fields so existing callers continue to work.",
  "is_public": false
}
{
  "path": "config/settings.py",
  "module": "config.settings",
  "qualname": "ServerLimits",
  "name": "ServerLimits",
  "node_type": "ClassDef",
  "lineno": 755,
  "col": 0,
  "end_lineno": 798,
  "end_col": 42,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "msgspec.Struct"
  ],
  "docstring": "Server resource limits and rate limiting configuration.\n\nConfiguration for protecting the server from resource exhaustion and ensuring\nfair usage. These limits prevent individual queries from consuming excessive\nresources and provide basic rate limiting for API access.\n\nThe defaults are conservative and suitable for production deployments. Adjust\nbased on your hardware capabilities and expected load patterns.\n\nAttributes\n----------\nmax_results : int\n    Maximum number of results to return per query. This prevents queries from\n    returning excessively large result sets that could cause memory issues or\n    slow response times. Defaults to 1000 results, which is typically more\n    than needed for most use cases. For interactive search, 50-100 is usually\n    sufficient.\nquery_timeout_s : float\n    Maximum time in seconds that a query is allowed to run before timing out.\n    This protects against slow queries (e.g., very large FAISS searches) that\n    could block the server. Defaults to 30 seconds, which should be sufficient\n    for most semantic searches even on large indexes. For very large indexes\n    (>10M vectors), consider increasing to 60 seconds.\nrate_limit_qps : float\n    Queries per second (QPS) rate limit. This is the sustained rate at which\n    queries are allowed. Defaults to 10 QPS, which is reasonable for a single\n    server instance. For production deployments behind a load balancer, this\n    should be set per-instance (total QPS = instances * rate_limit_qps).\nrate_limit_burst : int\n    Burst capacity for the rate limiter. This allows short bursts above the\n    QPS limit to handle traffic spikes. Defaults to 20 queries, which allows\n    a 2-second burst at 10 QPS. Set higher (40-60) if you expect more variable\n    traffic patterns.\nsemantic_overfetch_multiplier : int\n    Multiplier applied to FAISS search fan-out when scope filters are active.\n    Defaults to 2 (fetch twice the requested limit to compensate for filtering).",
  "is_public": true
}
{
  "path": "config/settings.py",
  "module": "config.settings",
  "qualname": "RedisConfig",
  "name": "RedisConfig",
  "node_type": "ClassDef",
  "lineno": 801,
  "col": 0,
  "end_lineno": 819,
  "end_col": 36,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "msgspec.Struct"
  ],
  "docstring": "Redis configuration for scope storage.\n\nAttributes\n----------\nurl : str\n    Redis connection URL. Defaults to local Redis on standard port.\nscope_l1_size : int\n    Maximum number of entries to retain in the in-process L1 cache.\nscope_l1_ttl_seconds : float\n    Time-to-live in seconds for L1 cache entries.\nscope_l2_ttl_seconds : int\n    Time-to-live in seconds for Redis entries (L2 cache).",
  "is_public": true
}
{
  "path": "config/settings.py",
  "module": "config.settings",
  "qualname": "Settings",
  "name": "Settings",
  "node_type": "ClassDef",
  "lineno": 822,
  "col": 0,
  "end_lineno": 889,
  "end_col": 20,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "msgspec.Struct"
  ],
  "docstring": "Global settings container for the entire code intelligence system.\n\nThis is the root configuration object that aggregates all subsystem\nconfigurations. It's loaded once at application startup from environment\nvariables and remains immutable throughout the application lifetime.\n\nThe Settings object is frozen (immutable) to prevent accidental modification\nand ensure thread-safe access. All configuration is validated at load time\nthrough msgspec's type system.\n\nAttributes\n----------\nvllm : VLLMConfig\n    Configuration for the vLLM embedding service. Includes connection details,\n    model selection, and batching parameters for generating code embeddings.\nembeddings : EmbeddingsConfig\n    Runtime-agnostic embedding provider configuration shared by CLIs and\n    services. Controls provider selection, device, normalization, and\n    batching/backpressure settings.\npaths : PathsConfig\n    File system path configuration. Defines where indexes, vectors, databases,\n    and source code are stored. All paths are resolved relative to repo_root.\nindex : IndexConfig\n    Indexing and search algorithm configuration. Includes chunking parameters,\n    FAISS index structure, BM25 settings, and hybrid retrieval fusion parameters.\nlimits : ServerLimits\n    Server resource limits and rate limiting configuration. Protects against\n    resource exhaustion and provides basic API rate limiting.\nredis : RedisConfig\n    Redis configuration for session scope caching.\nduckdb : DuckDBConfig\n    DuckDB connection configuration (threading, object cache).\nbm25 : BM25Config\n    BM25 indexing configuration, including corpus preparation directories and\n    default thread settings.\nsplade : SpladeConfig\n    SPLADE v3 configuration covering model artifacts, ONNX execution defaults, and\n    Lucene impact index locations.\ncoderank : CodeRankConfig\n    Dense CodeRank retriever configuration.\nwarp : WarpConfig\n    WARP/XTR late-interaction configuration.\nxtr : XTRConfig\n    Token-level index and scoring configuration.\nrerank : RerankConfig\n    Late-interaction reranker configuration.\ncoderank_llm : CodeRankLLMConfig\n    CodeRank listwise reranker configuration.\neval : EvalConfig\n    Offline evaluation (recall/coverage) configuration.",
  "is_public": true
}
{
  "path": "config/settings.py",
  "module": "config.settings",
  "qualname": "load_settings",
  "name": "load_settings",
  "node_type": "FunctionDef",
  "lineno": 892,
  "col": 0,
  "end_lineno": 1127,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Load settings from environment variables with sensible defaults.\n\nThis function reads configuration from environment variables and constructs\na Settings object with all subsystem configurations. Environment variables\nfollow a hierarchical naming scheme: subsystem name in uppercase, then\nthe parameter name.\n\nAll environment variables are optional - sensible defaults are provided for\ndevelopment and testing. For production deployments, you should set at minimum:\nREPO_ROOT, VLLM_URL, and any paths that differ from defaults.\n\nThe function validates types (converting strings to int/float/bool as needed)\nand ensures required fields (like repo_root) have values. If REPO_ROOT is\nnot set, it defaults to the current working directory.\n\nReturns\n-------\nSettings\n    Fully configured Settings instance with all subsystems initialized.\n    The Settings object is frozen (immutable) and can be safely shared across\n    threads.\n\nSee Also\n--------\nThe following environment variables can be used to configure the settings:\n---------------------\nVLLM_URL : str, optional\n    vLLM service base URL (default: \"http://127.0.0.1:8001/v1\").\nVLLM_MODEL : str, optional\n    Embedding model identifier (default: \"nomic-ai/nomic-embed-code\").\nVLLM_BATCH_SIZE : int, optional\n    Batch size for embedding requests (default: 64).\nVLLM_TIMEOUT_S : float, optional\n    HTTP timeout for vLLM requests in seconds (default: 120.0).\nVLLM_EMBED_DIM : int, optional\n    Embedding vector dimension for empty responses and validation\n    (default: 2560).\nREPO_ROOT : str, optional\n    Repository root directory path (default: current working directory).\nDATA_DIR : str, optional\n    Base data directory (default: \"data\").\nVECTORS_DIR : str, optional\n    Vector storage directory (default: \"data/vectors\").\nFAISS_INDEX : str, optional\n    FAISS index file path (default: \"data/faiss/code.ivfpq.faiss\").\nFAISS_IDMAP_PATH : str, optional\n    Path to the FAISS ID map Parquet sidecar (default: \"data/faiss/faiss_idmap.parquet\").\nLUCENE_DIR : str, optional\n    Lucene index directory (default: \"data/lucene\").\nSPLADE_DIR : str, optional\n    SPLADE index directory (default: \"data/splade\").\nDUCKDB_PATH : str, optional\n    DuckDB catalog database path (default: \"data/catalog.duckdb\").\nSCIP_INDEX : str, optional\n    SCIP index file path (default: \"index.scip\").\nVEC_DIM : int, optional\n    Embedding vector dimension (default: 2560).\nCHUNK_BUDGET : int, optional\n    Target chunk size in characters (default: 2200).\nFAISS_NLIST : int, optional\n    Number of IVF centroids (default: 8192).\nFAISS_NPROBE : int, optional\n    Number of IVF cells to probe during search (default: 128).\nFAISS_COMPACTION_THRESHOLD : float, optional\n    Secondary-to-primary ratio that triggers compaction (default: 0.05).\nBM25_K1 : float, optional\n    BM25 k1 parameter (default: 0.9).\nBM25_B : float, optional\n    BM25 b parameter (default: 0.4).\nRRF_K : int, optional\n    RRF fusion K parameter (default: 60).\nHYBRID_ENABLE_BM25 : str, optional\n    Enable BM25 channel within hybrid retrieval fusion (\"1\"/\"true\" to enable, default enabled).\nHYBRID_ENABLE_SPLADE : str, optional\n    Enable SPLADE channel within hybrid retrieval fusion\n    (\"1\"/\"true\" to enable, default enabled).\nHYBRID_TOP_K_PER_CHANNEL : int, optional\n    Per-channel candidate fan-out gathered prior to RRF fusion (default: 50).\nUSE_CUVS : str, optional\n    Enable cuVS acceleration: \"1\", \"true\", or \"yes\" (default: \"1\").\nFAISS_PRELOAD : str, optional\n    Pre-load FAISS index at startup: \"1\", \"true\", or \"yes\" (default: \"0\").\n    When enabled, startup takes 2-10 seconds longer but first request is faster.\nMAX_RESULTS : int, optional\n    Maximum results per query (default: 1000).\nQUERY_TIMEOUT_S : float, optional\n    Query timeout in seconds (default: 30.0).\nRATE_LIMIT_QPS : float, optional\n    Rate limit queries per second (default: 10.0).\nRATE_LIMIT_BURST : int, optional\n    Rate limit burst capacity (default: 20).\nREDIS_URL : str, optional\n    Redis connection URL for Session scope storage (default: \"redis://127.0.0.1:6379/0\").\nREDIS_SCOPE_L1_SIZE : int, optional\n    Maximum number of entries for the in-process L1 cache (default: 256).\nREDIS_SCOPE_L1_TTL_SECONDS : float, optional\n    TTL in seconds for L1 cache entries (default: 300).\nREDIS_SCOPE_L2_TTL_SECONDS : int, optional\n    TTL in seconds for Redis entries (default: 3600).\nDUCKDB_THREADS : int, optional\n    Worker thread budget for DuckDB connections (default: 4).\nDUCKDB_OBJECT_CACHE : str, optional\n    Enable DuckDB object cache (\"1\"/\"true\" to enable, default enabled).\nDUCKDB_LOG_QUERIES : str, optional\n    Emit DuckDB SQL statements at debug level (\"1\"/\"true\" to enable).\nBM25_JSONL_DIR : str, optional\n    Directory containing BM25 JsonCollection documents (default: \"data/jsonl\").\nBM25_INDEX_DIR : str, optional\n    Directory for the Lucene BM25 index (default: \"indexes/bm25\").\nBM25_THREADS : int, optional\n    Worker thread budget for BM25 indexing (default: 8).\nSPLADE_MODEL_ID : str, optional\n    Hugging Face model identifier for SPLADE (default: \"naver/splade-v3\").\nSPLADE_MODEL_DIR : str, optional\n    Local directory for SPLADE model artifacts (default: \"models/splade-v3\").\nSPLADE_ONNX_DIR : str, optional\n    Directory that stores exported SPLADE ONNX artifacts (default: \"models/splade-v3/onnx\").\nSPLADE_ONNX_FILE : str, optional\n    Primary SPLADE ONNX file name (default: \"model_qint8.onnx\").\nSPLADE_VECTORS_DIR : str, optional\n    Directory containing SPLADE JsonVectorCollection shards (default: \"data/splade_vectors\").\nSPLADE_INDEX_DIR : str, optional\n    Directory for the SPLADE impact index (default: \"indexes/splade_v3_impact\").\nSPLADE_PROVIDER : str, optional\n    Default ONNX Runtime execution provider (default: \"CPUExecutionProvider\").\nSPLADE_QUANTIZATION : int, optional\n    Integer quantization factor applied during SPLADE encoding (default: 100).\nSPLADE_MAX_TERMS : int, optional\n    Maximum SPLADE query terms retained after expansion (default: 3000).\nSPLADE_MAX_CLAUSE : int, optional\n    Lucene Boolean clause limit used while indexing SPLADE vectors (default: 4096).\nSPLADE_BATCH_SIZE : int, optional\n    Default batch size for SPLADE encoding CLI commands (default: 32).\nCODERANK_MODEL_ID : str, optional\n    Hugging Face identifier for CodeRank embeddings (default: \"nomic-ai/CodeRankEmbed\").\nCODERANK_TRUST_REMOTE_CODE : str, optional\n    Allow custom code from the model repo (\"1\"/\"true\" to enable, default enabled).\nCODERANK_DEVICE : str, optional\n    Device string for CodeRank embeddings (default: \"cpu\").\nCODERANK_BATCH : int, optional\n    Batch size for CodeRank encoding (default: 128).\nCODERANK_NORMALIZE : str, optional\n    Enable L2 normalization for CodeRank embeddings (default enabled).\nCODERANK_QUERY_PREFIX : str, optional\n    Override the CodeRank instruction prefix when necessary.\nCODERANK_VECTORS_DIR : str, optional\n    Storage directory for CodeRank vectors (default: \"data/coderank_vectors\").\nCODERANK_FAISS_INDEX : str, optional\n    CodeRank FAISS index path (default: \"data/faiss/coderank.ivfpq.faiss\").\nWARP_INDEX_DIR : str, optional\n    Directory containing WARP/XTR index artifacts (default: \"indexes/warp_xtr\").\nWARP_MODEL_ID : str, optional\n    Identifier for WARP's multivector encoder (default: \"intfloat/e5-multivector-large\").\nWARP_DEVICE : str, optional\n    Device for the WARP executor (default: \"cpu\").\nWARP_TOP_K : int, optional\n    Candidate fan-out requested from WARP (default: 200).\nWARP_ENABLED : str, optional\n    Enable WARP channel (\"1\"/\"true\" to enable, default disabled).\nXTR_DIR : str, optional\n    Directory containing XTR token artifacts (default: \"data/xtr\").\nXTR_MODEL_ID : str, optional\n    Encoder checkpoint for XTR tokens (default: \"nomic-ai/CodeRankEmbed\").\nXTR_DEVICE : str, optional\n    Device for XTR query encoding (\"cuda\" default).\nXTR_MAX_QUERY_TOKENS : int, optional\n    Maximum number of query tokens processed (default: 256).\nXTR_CANDIDATE_K : int, optional\n    Number of Stage-A candidates to rescore (default: 200).\nXTR_DIM : int, optional\n    Token embedding dimensionality (default: 768).\nXTR_DTYPE : str, optional\n    Token storage dtype (\"float16\" default).\nXTR_ENABLE : str, optional\n    Enable XTR rescoring (\"1\"/\"true\" to enable, default disabled).\nCODERANK_LLM_MODEL_ID : str, optional\n    Identifier for the CodeRank listwise reranker (default: \"nomic-ai/CodeRankLLM\").\nCODERANK_LLM_DEVICE : str, optional\n    Device for the listwise reranker (default: \"cpu\").\nCODERANK_LLM_MAX_NEW_TOKENS : int, optional\n    Max tokens generated when reranking (default: 256).\nCODERANK_LLM_TEMPERATURE : float, optional\n    Sampling temperature for reranker generations (default: 0.0).\nCODERANK_LLM_TOP_P : float, optional\n    Top-p nucleus sampling parameter (default: 1.0).\nCODERANK_LLM_ENABLED : str, optional\n    Enable the CodeRank listwise reranker (\"1\"/\"true\" to enable, default disabled).",
  "is_public": true
}
{
  "path": "config/settings.py",
  "module": "config.settings",
  "qualname": "_build_paths_config",
  "name": "_build_paths_config",
  "node_type": "FunctionDef",
  "lineno": 1130,
  "col": 0,
  "end_lineno": 1148,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "config/settings.py",
  "module": "config.settings",
  "qualname": "_load_rrf_weights",
  "name": "_load_rrf_weights",
  "node_type": "FunctionDef",
  "lineno": 1151,
  "col": 0,
  "end_lineno": 1169,
  "end_col": 18,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "config/settings.py",
  "module": "config.settings",
  "qualname": "_load_hybrid_prefetch",
  "name": "_load_hybrid_prefetch",
  "node_type": "FunctionDef",
  "lineno": 1172,
  "col": 0,
  "end_lineno": 1190,
  "end_col": 27,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "config/settings.py",
  "module": "config.settings",
  "qualname": "_load_hybrid_weights_override",
  "name": "_load_hybrid_weights_override",
  "node_type": "FunctionDef",
  "lineno": 1193,
  "col": 0,
  "end_lineno": 1209,
  "end_col": 13,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "config/settings.py",
  "module": "config.settings",
  "qualname": "_build_prf_config",
  "name": "_build_prf_config",
  "node_type": "FunctionDef",
  "lineno": 1212,
  "col": 0,
  "end_lineno": 1221,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "config/settings.py",
  "module": "config.settings",
  "qualname": "_load_hybrid_channel_settings",
  "name": "_load_hybrid_channel_settings",
  "node_type": "FunctionDef",
  "lineno": 1224,
  "col": 0,
  "end_lineno": 1230,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "config/settings.py",
  "module": "config.settings",
  "qualname": "_build_index_config",
  "name": "_build_index_config",
  "node_type": "FunctionDef",
  "lineno": 1233,
  "col": 0,
  "end_lineno": 1270,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "config/settings.py",
  "module": "config.settings",
  "qualname": "_build_server_limits",
  "name": "_build_server_limits",
  "node_type": "FunctionDef",
  "lineno": 1273,
  "col": 0,
  "end_lineno": 1280,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "config/settings.py",
  "module": "config.settings",
  "qualname": "_build_redis_config",
  "name": "_build_redis_config",
  "node_type": "FunctionDef",
  "lineno": 1283,
  "col": 0,
  "end_lineno": 1294,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "config/settings.py",
  "module": "config.settings",
  "qualname": "_build_duckdb_config",
  "name": "_build_duckdb_config",
  "node_type": "FunctionDef",
  "lineno": 1297,
  "col": 0,
  "end_lineno": 1310,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "config/settings.py",
  "module": "config.settings",
  "qualname": "_build_eval_config",
  "name": "_build_eval_config",
  "node_type": "FunctionDef",
  "lineno": 1313,
  "col": 0,
  "end_lineno": 1322,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "config/settings.py",
  "module": "config.settings",
  "qualname": "_resolve_bm25_analyzer",
  "name": "_resolve_bm25_analyzer",
  "node_type": "FunctionDef",
  "lineno": 1325,
  "col": 0,
  "end_lineno": 1329,
  "end_col": 17,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "config/settings.py",
  "module": "config.settings",
  "qualname": "_resolve_splade_analyzer",
  "name": "_resolve_splade_analyzer",
  "node_type": "FunctionDef",
  "lineno": 1332,
  "col": 0,
  "end_lineno": 1336,
  "end_col": 22,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "config/settings.py",
  "module": "config.settings",
  "qualname": "_build_bm25_config",
  "name": "_build_bm25_config",
  "node_type": "FunctionDef",
  "lineno": 1339,
  "col": 0,
  "end_lineno": 1367,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "config/settings.py",
  "module": "config.settings",
  "qualname": "_build_splade_config",
  "name": "_build_splade_config",
  "node_type": "FunctionDef",
  "lineno": 1370,
  "col": 0,
  "end_lineno": 1390,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "config/settings.py",
  "module": "config.settings",
  "qualname": "_build_coderank_config",
  "name": "_build_coderank_config",
  "node_type": "FunctionDef",
  "lineno": 1393,
  "col": 0,
  "end_lineno": 1408,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "config/settings.py",
  "module": "config.settings",
  "qualname": "_build_warp_config",
  "name": "_build_warp_config",
  "node_type": "FunctionDef",
  "lineno": 1411,
  "col": 0,
  "end_lineno": 1419,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "config/settings.py",
  "module": "config.settings",
  "qualname": "_build_coderank_llm_config",
  "name": "_build_coderank_llm_config",
  "node_type": "FunctionDef",
  "lineno": 1422,
  "col": 0,
  "end_lineno": 1431,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "config/utils.py",
  "module": "config.utils",
  "qualname": "config.utils",
  "name": "config.utils",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Helpers for working with msgspec-based settings structs.",
  "is_public": true
}
{
  "path": "config/utils.py",
  "module": "config.utils",
  "qualname": "replace_settings",
  "name": "replace_settings",
  "node_type": "FunctionDef",
  "lineno": 10,
  "col": 0,
  "end_lineno": 42,
  "end_col": 47,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return a new Settings instance with updates applied.\n\nExtended Summary\n----------------\nThis function creates a new Settings instance by cloning the provided settings\nand applying field overrides via keyword arguments. It uses msgspec's structs.replace\nutility to perform immutable updates, ensuring the original settings object remains\nunchanged. This is useful for creating modified settings configurations for testing\nor specialized use cases without mutating the original.\n\nParameters\n----------\nsettings : Settings\n    Original Settings instance to clone and modify. The instance is not modified.\n**updates : object\n    Keyword arguments mapping field names to new values. Only fields that exist\n    in the Settings struct can be overridden. Invalid field names are ignored\n    by msgspec.\n\nReturns\n-------\nSettings\n    New Settings instance with the provided fields overridden. All other fields\n    are copied from the original settings instance.\n\nNotes\n-----\nTime complexity O(1) for struct cloning. Space complexity O(1) aside from the\nnew Settings object. The function performs no I/O and has no side effects.\nThread-safe as it operates on immutable structs.",
  "is_public": true
}
{
  "path": "config/utils.py",
  "module": "config.utils",
  "qualname": "replace_struct",
  "name": "replace_struct",
  "node_type": "FunctionDef",
  "lineno": 45,
  "col": 0,
  "end_lineno": 80,
  "end_col": 47,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Clone a struct instance with the provided field overrides applied.\n\nExtended Summary\n----------------\nThis generic function creates a new struct instance by cloning the provided\ninstance and applying field overrides via keyword arguments. It uses msgspec's\nstructs.replace utility to perform immutable updates, ensuring the original\ninstance remains unchanged. This is a type-safe way to create modified struct\ninstances for any msgspec Struct type, useful for configuration overrides and\ntest fixtures.\n\nParameters\n----------\ninstance : T\n    Original struct instance to clone and modify. Must be an instance of a\n    class that inherits from msgspec.Struct. The instance is not modified.\n**updates : object\n    Keyword arguments mapping field names to new values. Only fields that exist\n    in the struct type T can be overridden. Invalid field names are ignored\n    by msgspec.\n\nReturns\n-------\nT\n    New struct instance of the same type as instance, with the provided fields\n    overridden. All other fields are copied from the original instance.\n\nNotes\n-----\nTime complexity O(1) for struct cloning. Space complexity O(1) aside from the\nnew struct object. The function performs no I/O and has no side effects.\nThread-safe as it operates on immutable structs. Type-safe via generic type\nparameter T constrained to Struct.",
  "is_public": true
}
{
  "path": "config_indexer.py",
  "module": "config_indexer",
  "qualname": "config_indexer",
  "name": "config_indexer",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Config awareness helpers (YAML/TOML/JSON/Markdown).",
  "is_public": true
}
{
  "path": "config_indexer.py",
  "module": "config_indexer",
  "qualname": "index_config_files",
  "name": "index_config_files",
  "node_type": "FunctionDef",
  "lineno": 14,
  "col": 0,
  "end_lineno": 44,
  "end_col": 18,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return config metadata (path + extracted keys/headings).\n\nParameters\n----------\nroot : Path\n    Root directory to search for configuration files.\npatterns : tuple[str, ...], optional\n    File extension patterns to match (defaults to CONFIG_EXTENSIONS).\n\nReturns\n-------\nlist[dict[str, Any]]\n    Records containing ``path``, ``keys``, and ``references``.",
  "is_public": true
}
{
  "path": "config_indexer.py",
  "module": "config_indexer",
  "qualname": "_extract_keys",
  "name": "_extract_keys",
  "node_type": "FunctionDef",
  "lineno": 47,
  "col": 0,
  "end_lineno": 57,
  "end_col": 13,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "config_indexer.py",
  "module": "config_indexer",
  "qualname": "_extract_yaml_keys",
  "name": "_extract_yaml_keys",
  "node_type": "FunctionDef",
  "lineno": 60,
  "col": 0,
  "end_lineno": 70,
  "end_col": 15,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "config_indexer.py",
  "module": "config_indexer",
  "qualname": "_extract_toml_keys",
  "name": "_extract_toml_keys",
  "node_type": "FunctionDef",
  "lineno": 73,
  "col": 0,
  "end_lineno": 83,
  "end_col": 15,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "config_indexer.py",
  "module": "config_indexer",
  "qualname": "_extract_json_keys",
  "name": "_extract_json_keys",
  "node_type": "FunctionDef",
  "lineno": 86,
  "col": 0,
  "end_lineno": 142,
  "end_col": 27,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "config_indexer.py",
  "module": "config_indexer",
  "qualname": "_extract_json_keys.flatten",
  "name": "flatten",
  "node_type": "FunctionDef",
  "lineno": 92,
  "col": 4,
  "end_lineno": 140,
  "end_col": 17,
  "parent_qualname": "_extract_json_keys",
  "decorators": [],
  "bases": [],
  "docstring": "Recursively flatten nested JSON structure into dot-notation key paths.\n\nThis nested function traverses JSON objects and arrays recursively, building\ndot-notation paths for all keys. Dictionary keys are joined with dots (e.g.,\n\"config.database.host\"), while array indices are represented with brackets\n(e.g., \"items[0].name\"). The function handles nested structures of arbitrary\ndepth and returns all key paths found in the structure.\n\nParameters\n----------\nobj : object\n    JSON value to flatten (dict, list, or primitive). Dictionaries and lists\n    are traversed recursively; primitives are ignored (no keys to extract).\nprefix : str, optional\n    Current path prefix for building nested key paths. Empty string for root\n    level keys. Used recursively to build dot-notation paths.\n\nReturns\n-------\nlist[str]\n    List of dot-notation key paths found in the JSON structure. Dictionary\n    keys use dot notation (e.g., \"config.database\"), array indices use bracket\n    notation (e.g., \"items[0]\"). Empty list for primitive values.\n\nNotes\n-----\nThis function is part of JSON key extraction for config file indexing. It\nrecursively traverses nested structures to build a flat list of all accessible\nkey paths. Time complexity: O(n) where n is the total number of keys and array\nelements in the structure. The function handles circular references gracefully\nby only traversing each structure once (no cycles in JSON). Thread-safe as it\noperates on immutable input data.",
  "is_public": true
}
{
  "path": "config_indexer.py",
  "module": "config_indexer",
  "qualname": "_extract_markdown_headings",
  "name": "_extract_markdown_headings",
  "node_type": "FunctionDef",
  "lineno": 145,
  "col": 0,
  "end_lineno": 150,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "coverage_ingest.py",
  "module": "coverage_ingest",
  "qualname": "coverage_ingest",
  "name": "coverage_ingest",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Coverage ingestion utilities (Cobertura-style XML).",
  "is_public": true
}
{
  "path": "coverage_ingest.py",
  "module": "coverage_ingest",
  "qualname": "collect_coverage",
  "name": "collect_coverage",
  "node_type": "FunctionDef",
  "lineno": 11,
  "col": 0,
  "end_lineno": 52,
  "end_col": 18,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Collect per-file coverage ratios from ``coverage.xml``.\n\nParameters\n----------\ncoverage_xml : str | Path\n    Path to coverage XML file (typically ``coverage.xml``).\n\nReturns\n-------\ndict[str, dict[str, float]]\n    Mapping of paths to coverage ratios; empty when file is missing.",
  "is_public": true
}
{
  "path": "coverage_ingest.py",
  "module": "coverage_ingest",
  "qualname": "_parse_int",
  "name": "_parse_int",
  "node_type": "FunctionDef",
  "lineno": 55,
  "col": 0,
  "end_lineno": 73,
  "end_col": 16,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return integer conversion fallback to zero on failure.\n\nParameters\n----------\nvalue : float | str | None\n    Value to convert to integer.\n\nReturns\n-------\nint\n    Converted integer value, or 0 if conversion fails.",
  "is_public": false
}
{
  "path": "cst_build/__init__.py",
  "module": "cst_build",
  "qualname": "cst_build",
  "name": "cst_build",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "CST build package exposing the LibCST-based dataset pipeline.",
  "is_public": true
}
{
  "path": "cst_build/cst_cli.py",
  "module": "cst_build.cst_cli",
  "qualname": "cst_build.cst_cli",
  "name": "cst_build.cst_cli",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "CLI entrypoint for CST dataset builds.",
  "is_public": true
}
{
  "path": "cst_build/cst_cli.py",
  "module": "cst_build.cst_cli",
  "qualname": "CLIOptions",
  "name": "CLIOptions",
  "node_type": "ClassDef",
  "lineno": 25,
  "col": 0,
  "end_lineno": 36,
  "end_col": 21,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Normalized command-line options.",
  "is_public": true
}
{
  "path": "cst_build/cst_cli.py",
  "module": "cst_build.cst_cli",
  "qualname": "_build_options",
  "name": "_build_options",
  "node_type": "FunctionDef",
  "lineno": 45,
  "col": 0,
  "end_lineno": 69,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Extract and normalize CLI options from Click context.\n\nParameters\n----------\nctx : click.Context\n    Click context object containing parsed command-line parameters.\n\nReturns\n-------\nCLIOptions\n    Normalized dataclass instance containing all CLI options with resolved paths.",
  "is_public": false
}
{
  "path": "cst_build/cst_cli.py",
  "module": "cst_build.cst_cli",
  "qualname": "main",
  "name": "main",
  "node_type": "FunctionDef",
  "lineno": 135,
  "col": 0,
  "end_lineno": 221,
  "end_col": 38,
  "parent_qualname": null,
  "decorators": [
    "click.command()",
    "click.pass_context",
    "click.option('--root', type=click.Path(file_okay=False, dir_okay=True, exists=True, path_type=Path), default=ROOT_DEFAULT, show_default=True, help='Repo root to scan.')",
    "click.option('--scip', type=click.Path(file_okay=True, dir_okay=False, exists=True, path_type=Path), default=SCIP_DEFAULT, show_default=True, help='Path to SCIP index JSON.')",
    "click.option('--modules', type=click.Path(file_okay=True, dir_okay=False, exists=True, path_type=Path), default=MODULES_DEFAULT, show_default=True, help='Path to modules.jsonl produced by codeintel-enrich.')",
    "click.option('--out', type=click.Path(file_okay=False, dir_okay=True, path_type=Path), default=OUT_DEFAULT, show_default=True, help='Output directory for CST artifacts.')",
    "click.option('--include', 'include', multiple=True, show_default=False, help='Glob pattern(s) limiting files relative to --root (repeatable).')",
    "click.option('--exclude', 'exclude', multiple=True, show_default=False, help='Glob pattern(s) to skip files (repeatable).')",
    "click.option('--limit', type=int, default=None, show_default=False, help='Maximum number of files to process (debugging).')",
    "click.option('--fail-on-parse-error/--no-fail-on-parse-error', default=False, show_default=True, help='Exit with non-zero status when LibCST parsing fails.')",
    "click.option('--debug-joins/--no-debug-joins', default=False, show_default=True, help='Capture stitch candidate details for debugging.')"
  ],
  "bases": [],
  "docstring": "Entry point invoked by the console script.\n\nScans the repository root for Python files, collects CST nodes, stitches them\nto module and SCIP symbols, and writes dataset artifacts to the output directory.\n\nParameters\n----------\nctx : click.Context\n    Click context object containing parsed command-line options.\n**_ : object\n    Additional keyword arguments (unused, required by Click decorator).\n    Accepts any keyword arguments but ignores them. Required by Click's\n    decorator signature but not used in the function body.\n\nRaises\n------\nclick.exceptions.Exit\n    Exit code 1 when no files match or when parse errors occur while\n    ``--fail-on-parse-error`` is enabled.",
  "is_public": true
}
{
  "path": "cst_build/cst_cli.py",
  "module": "cst_build.cst_cli",
  "qualname": "_iter_py_files",
  "name": "_iter_py_files",
  "node_type": "FunctionDef",
  "lineno": 224,
  "col": 0,
  "end_lineno": 259,
  "end_col": 16,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Discover Python files matching include/exclude glob patterns.\n\nRecursively scans the root directory for .py files and filters them based on\ninclude and exclude glob patterns. Patterns are matched against relative paths\nfrom the root directory.\n\nParameters\n----------\nroot : Path\n    Root directory to scan for Python files.\ninclude : Sequence[str]\n    Glob patterns that files must match to be included. Empty sequence means\n    all files are included (subject to exclude patterns).\nexclude : Sequence[str]\n    Glob patterns that exclude files from the result set.\n\nReturns\n-------\nlist[Path]\n    Sorted list of absolute paths to Python files matching the filters.",
  "is_public": false
}
{
  "path": "cst_build/cst_collect.py",
  "module": "cst_build.cst_collect",
  "qualname": "cst_build.cst_collect",
  "name": "cst_build.cst_collect",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "LibCST traversal utilities that emit normalized node records.",
  "is_public": true
}
{
  "path": "cst_build/cst_collect.py",
  "module": "cst_build.cst_collect",
  "qualname": "CollectorConfig",
  "name": "CollectorConfig",
  "node_type": "ClassDef",
  "lineno": 37,
  "col": 0,
  "end_lineno": 43,
  "end_col": 44,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Configurable knobs for CST extraction.",
  "is_public": true
}
{
  "path": "cst_build/cst_collect.py",
  "module": "cst_build.cst_collect",
  "qualname": "_CollectorStatsBuilder",
  "name": "_CollectorStatsBuilder",
  "node_type": "ClassDef",
  "lineno": 46,
  "col": 0,
  "end_lineno": 147,
  "end_col": 9,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Mutable builder used while collecting CST stats.",
  "is_public": false
}
{
  "path": "cst_build/cst_collect.py",
  "module": "cst_build.cst_collect",
  "qualname": "_CollectorStatsBuilder.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 57,
  "col": 4,
  "end_lineno": 70,
  "end_col": 44,
  "parent_qualname": "_CollectorStatsBuilder",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cst_build/cst_collect.py",
  "module": "cst_build.cst_collect",
  "qualname": "_CollectorStatsBuilder.increment_parse_errors",
  "name": "increment_parse_errors",
  "node_type": "FunctionDef",
  "lineno": 72,
  "col": 4,
  "end_lineno": 85,
  "end_col": 34,
  "parent_qualname": "_CollectorStatsBuilder",
  "decorators": [],
  "bases": [],
  "docstring": "Increment the parse error counter.\n\nThis method increments the parse error count, tracking the number of files\nthat failed to parse during CST collection. Used for statistics and error\nreporting.\n\nParameters\n----------\ncount : int, optional\n    Number of parse errors to add (defaults to 1). Used when multiple\n    errors occur in a single operation or when batching error counts.",
  "is_public": true
}
{
  "path": "cst_build/cst_collect.py",
  "module": "cst_build.cst_collect",
  "qualname": "_CollectorStatsBuilder.set_node_rows",
  "name": "set_node_rows",
  "node_type": "FunctionDef",
  "lineno": 87,
  "col": 4,
  "end_lineno": 101,
  "end_col": 30,
  "parent_qualname": "_CollectorStatsBuilder",
  "decorators": [],
  "bases": [],
  "docstring": "Set the total number of node rows collected.\n\nThis method sets the node_rows counter to the specified count, representing\nthe total number of node records emitted during CST collection. Used to\ntrack collection output size.\n\nParameters\n----------\ncount : int\n    Total number of node records collected. Must be non-negative. This count\n    represents the number of NodeRecord objects emitted for the processed\n    files.",
  "is_public": true
}
{
  "path": "cst_build/cst_collect.py",
  "module": "cst_build.cst_collect",
  "qualname": "_CollectorStatsBuilder.increment_qname_hits",
  "name": "increment_qname_hits",
  "node_type": "FunctionDef",
  "lineno": 103,
  "col": 4,
  "end_lineno": 116,
  "end_col": 28,
  "parent_qualname": "_CollectorStatsBuilder",
  "decorators": [],
  "bases": [],
  "docstring": "Increment the qualified name resolution hit counter.\n\nThis method increments the qname_hits counter, tracking the number of nodes\nfor which qualified names were successfully resolved. Used to measure the\neffectiveness of qualified name resolution during CST collection.\n\nNotes\n-----\nQualified names (qnames) are fully qualified identifiers like \"module.Class.method\".\nThis counter tracks how many nodes had their qnames successfully resolved,\nproviding a metric for scope resolution quality.",
  "is_public": true
}
{
  "path": "cst_build/cst_collect.py",
  "module": "cst_build.cst_collect",
  "qualname": "_CollectorStatsBuilder.increment_scope_resolved",
  "name": "increment_scope_resolved",
  "node_type": "FunctionDef",
  "lineno": 118,
  "col": 4,
  "end_lineno": 131,
  "end_col": 32,
  "parent_qualname": "_CollectorStatsBuilder",
  "decorators": [],
  "bases": [],
  "docstring": "Increment the scope resolution hit counter.\n\nThis method increments the scope_resolved counter, tracking the number of\nnodes for which scope information was successfully resolved. Used to measure\nthe effectiveness of scope resolution during CST collection.\n\nNotes\n-----\nScope resolution identifies whether a node belongs to Global, Class, Function,\nor Comprehension scope. This counter tracks how many nodes had their scope\nsuccessfully resolved, providing a metric for scope analysis quality.",
  "is_public": true
}
{
  "path": "cst_build/cst_collect.py",
  "module": "cst_build.cst_collect",
  "qualname": "_CollectorStatsBuilder.snapshot",
  "name": "snapshot",
  "node_type": "FunctionDef",
  "lineno": 133,
  "col": 4,
  "end_lineno": 147,
  "end_col": 9,
  "parent_qualname": "_CollectorStatsBuilder",
  "decorators": [],
  "bases": [],
  "docstring": "Return an immutable CollectorStats instance.\n\nReturns\n-------\nCollectorStats\n    Frozen stats object ready for serialization.",
  "is_public": true
}
{
  "path": "cst_build/cst_collect.py",
  "module": "cst_build.cst_collect",
  "qualname": "CSTCollector",
  "name": "CSTCollector",
  "node_type": "ClassDef",
  "lineno": 151,
  "col": 0,
  "end_lineno": 373,
  "end_col": 29,
  "parent_qualname": null,
  "decorators": [
    "final"
  ],
  "bases": [],
  "docstring": "Collect LibCST node records for a repository.",
  "is_public": true
}
{
  "path": "cst_build/cst_collect.py",
  "module": "cst_build.cst_collect",
  "qualname": "CSTCollector.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 161,
  "col": 4,
  "end_lineno": 173,
  "end_col": 59,
  "parent_qualname": "CSTCollector",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cst_build/cst_collect.py",
  "module": "cst_build.cst_collect",
  "qualname": "CSTCollector._build_repo_manager",
  "name": "_build_repo_manager",
  "node_type": "FunctionDef",
  "lineno": 175,
  "col": 4,
  "end_lineno": 209,
  "end_col": 23,
  "parent_qualname": "CSTCollector",
  "decorators": [],
  "bases": [],
  "docstring": "Build a repo-scoped metadata manager when a file list is available.\n\nThis method creates a FullRepoManager instance for repository-wide metadata\ncollection when a file list is provided. The manager is configured with\nLibCST metadata providers and supports pyproject.toml parsing. If file\nlist is None or manager creation fails, returns None gracefully.\n\nParameters\n----------\nfiles : Sequence[Path] | None\n    Sequence of file paths to include in the repository manager. If None\n    or empty, returns None without creating a manager. The paths are\n    converted to relative paths from the collector's root directory.\n\nReturns\n-------\nFullRepoManager | None\n    Configured FullRepoManager instance if files are provided and manager\n    creation succeeds, otherwise None. Returns None when files is None/empty\n    or when manager creation fails (OSError, ValueError).",
  "is_public": false
}
{
  "path": "cst_build/cst_collect.py",
  "module": "cst_build.cst_collect",
  "qualname": "CSTCollector.collect_file",
  "name": "collect_file",
  "node_type": "FunctionDef",
  "lineno": 211,
  "col": 4,
  "end_lineno": 248,
  "end_col": 46,
  "parent_qualname": "CSTCollector",
  "decorators": [],
  "bases": [],
  "docstring": "Parse ``path`` and return serialized node records.\n\nParameters\n----------\npath : Path\n    File system path to the Python source file to parse.\n\nReturns\n-------\ntuple[list[NodeRecord], CollectorStats]\n    Tuple containing the list of parsed node records and collection statistics.",
  "is_public": true
}
{
  "path": "cst_build/cst_collect.py",
  "module": "cst_build.cst_collect",
  "qualname": "CSTCollector._wrap_module",
  "name": "_wrap_module",
  "node_type": "FunctionDef",
  "lineno": 250,
  "col": 4,
  "end_lineno": 275,
  "end_col": 23,
  "parent_qualname": "CSTCollector",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cst_build/cst_collect.py",
  "module": "cst_build.cst_collect",
  "qualname": "CSTCollector._emit_nodes",
  "name": "_emit_nodes",
  "node_type": "FunctionDef",
  "lineno": 277,
  "col": 4,
  "end_lineno": 366,
  "end_col": 24,
  "parent_qualname": "CSTCollector",
  "decorators": [],
  "bases": [],
  "docstring": "Yield NodeRecord rows for ``rel_path``.\n\nThis method traverses the LibCST AST and yields NodeRecord instances for\neach node that should be emitted (functions, classes, assignments, etc.).\nThe method resolves metadata (parent maps, positions, scopes, qualified\nnames) and builds serialized node records matching the schema contract.\n\nParameters\n----------\nrel_path : str\n    Relative file path from the repository root. Used to identify the\n    source file in node records and for module name extraction.\ncode : str\n    Source code content of the file. Used to extract text previews for\n    nodes when skip_preview is False. The code is already parsed into\n    the CST module in wrapper.\nwrapper : cst_metadata.MetadataWrapper\n    LibCST metadata wrapper containing the parsed module and resolved\n    metadata providers (parent maps, positions, scopes, qualified names).\n    Used to extract node metadata during traversal.\nskip_preview : bool\n    Flag indicating whether to skip text preview extraction for nodes.\n    When True, text_preview is set to None for all nodes, reducing\n    memory usage and serialization size.\nstats_builder : _CollectorStatsBuilder\n    Statistics builder instance for tracking collection metrics (node\n    counts, parse errors, etc.). Updated during node emission.\n\nYields\n------\nNodeRecord\n    Serialized node record matching the schema contract. Each record\n    contains node metadata (kind, name, span, parents, scope, qnames)\n    and optional text preview. Records are yielded in depth-first\n    traversal order.",
  "is_public": false
}
{
  "path": "cst_build/cst_collect.py",
  "module": "cst_build.cst_collect",
  "qualname": "CSTCollector._relative_path",
  "name": "_relative_path",
  "node_type": "FunctionDef",
  "lineno": 368,
  "col": 4,
  "end_lineno": 373,
  "end_col": 29,
  "parent_qualname": "CSTCollector",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cst_build/cst_collect.py",
  "module": "cst_build.cst_collect",
  "qualname": "index_file",
  "name": "index_file",
  "node_type": "FunctionDef",
  "lineno": 376,
  "col": 0,
  "end_lineno": 393,
  "end_col": 15,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Index a single file and return node records.\n\nConvenience helper used by tests to index a single file.\n\nParameters\n----------\npath : Path\n    File system path to the Python source file to index.\n\nReturns\n-------\nlist[NodeRecord]\n    List of parsed node records from the file.",
  "is_public": true
}
{
  "path": "cst_build/cst_collect.py",
  "module": "cst_build.cst_collect",
  "qualname": "_should_emit",
  "name": "_should_emit",
  "node_type": "FunctionDef",
  "lineno": 396,
  "col": 0,
  "end_lineno": 420,
  "end_col": 40,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cst_build/cst_collect.py",
  "module": "cst_build.cst_collect",
  "qualname": "_resolve_span",
  "name": "_resolve_span",
  "node_type": "FunctionDef",
  "lineno": 423,
  "col": 0,
  "end_lineno": 430,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cst_build/cst_collect.py",
  "module": "cst_build.cst_collect",
  "qualname": "_node_id",
  "name": "_node_id",
  "node_type": "FunctionDef",
  "lineno": 433,
  "col": 0,
  "end_lineno": 436,
  "end_col": 29,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cst_build/cst_collect.py",
  "module": "cst_build.cst_collect",
  "qualname": "_node_name",
  "name": "_node_name",
  "node_type": "FunctionDef",
  "lineno": 439,
  "col": 0,
  "end_lineno": 447,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cst_build/cst_collect.py",
  "module": "cst_build.cst_collect",
  "qualname": "_definition_or_class_name",
  "name": "_definition_or_class_name",
  "node_type": "FunctionDef",
  "lineno": 450,
  "col": 0,
  "end_lineno": 453,
  "end_col": 15,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cst_build/cst_collect.py",
  "module": "cst_build.cst_collect",
  "qualname": "_assign_target_name",
  "name": "_assign_target_name",
  "node_type": "FunctionDef",
  "lineno": 456,
  "col": 0,
  "end_lineno": 461,
  "end_col": 15,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cst_build/cst_collect.py",
  "module": "cst_build.cst_collect",
  "qualname": "_annassign_target_name",
  "name": "_annassign_target_name",
  "node_type": "FunctionDef",
  "lineno": 464,
  "col": 0,
  "end_lineno": 467,
  "end_col": 15,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cst_build/cst_collect.py",
  "module": "cst_build.cst_collect",
  "qualname": "_attribute_or_name",
  "name": "_attribute_or_name",
  "node_type": "FunctionDef",
  "lineno": 470,
  "col": 0,
  "end_lineno": 475,
  "end_col": 15,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cst_build/cst_collect.py",
  "module": "cst_build.cst_collect",
  "qualname": "_call_target_name",
  "name": "_call_target_name",
  "node_type": "FunctionDef",
  "lineno": 478,
  "col": 0,
  "end_lineno": 481,
  "end_col": 15,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cst_build/cst_collect.py",
  "module": "cst_build.cst_collect",
  "qualname": "_import_alias_name",
  "name": "_import_alias_name",
  "node_type": "FunctionDef",
  "lineno": 484,
  "col": 0,
  "end_lineno": 499,
  "end_col": 15,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cst_build/cst_collect.py",
  "module": "cst_build.cst_collect",
  "qualname": "_parent_chain",
  "name": "_parent_chain",
  "node_type": "FunctionDef",
  "lineno": 502,
  "col": 0,
  "end_lineno": 528,
  "end_col": 16,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cst_build/cst_collect.py",
  "module": "cst_build.cst_collect",
  "qualname": "_scope",
  "name": "_scope",
  "node_type": "FunctionDef",
  "lineno": 531,
  "col": 0,
  "end_lineno": 545,
  "end_col": 35,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cst_build/cst_collect.py",
  "module": "cst_build.cst_collect",
  "qualname": "_extract_module_doc",
  "name": "_extract_module_doc",
  "node_type": "FunctionDef",
  "lineno": 548,
  "col": 0,
  "end_lineno": 552,
  "end_col": 37,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cst_build/cst_collect.py",
  "module": "cst_build.cst_collect",
  "qualname": "_summarize",
  "name": "_summarize",
  "node_type": "FunctionDef",
  "lineno": 555,
  "col": 0,
  "end_lineno": 559,
  "end_col": 57,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cst_build/cst_collect.py",
  "module": "cst_build.cst_collect",
  "qualname": "_doc_snippet",
  "name": "_doc_snippet",
  "node_type": "FunctionDef",
  "lineno": 562,
  "col": 0,
  "end_lineno": 570,
  "end_col": 15,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cst_build/cst_collect.py",
  "module": "cst_build.cst_collect",
  "qualname": "_preview_text",
  "name": "_preview_text",
  "node_type": "FunctionDef",
  "lineno": 573,
  "col": 0,
  "end_lineno": 578,
  "end_col": 70,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cst_build/cst_collect.py",
  "module": "cst_build.cst_collect",
  "qualname": "_decorators",
  "name": "_decorators",
  "node_type": "FunctionDef",
  "lineno": 581,
  "col": 0,
  "end_lineno": 594,
  "end_col": 29,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cst_build/cst_collect.py",
  "module": "cst_build.cst_collect",
  "qualname": "_call_targets",
  "name": "_call_targets",
  "node_type": "FunctionDef",
  "lineno": 597,
  "col": 0,
  "end_lineno": 606,
  "end_col": 26,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cst_build/cst_collect.py",
  "module": "cst_build.cst_collect",
  "qualname": "_annotation",
  "name": "_annotation",
  "node_type": "FunctionDef",
  "lineno": 609,
  "col": 0,
  "end_lineno": 622,
  "end_col": 15,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cst_build/cst_collect.py",
  "module": "cst_build.cst_collect",
  "qualname": "_import_metadata",
  "name": "_import_metadata",
  "node_type": "FunctionDef",
  "lineno": 625,
  "col": 0,
  "end_lineno": 660,
  "end_col": 15,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cst_build/cst_collect.py",
  "module": "cst_build.cst_collect",
  "qualname": "_normalize_alias",
  "name": "_normalize_alias",
  "node_type": "FunctionDef",
  "lineno": 663,
  "col": 0,
  "end_lineno": 677,
  "end_col": 28,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cst_build/cst_collect.py",
  "module": "cst_build.cst_collect",
  "qualname": "_normalize_module_expr",
  "name": "_normalize_module_expr",
  "node_type": "FunctionDef",
  "lineno": 680,
  "col": 0,
  "end_lineno": 687,
  "end_col": 19,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cst_build/cst_collect.py",
  "module": "cst_build.cst_collect",
  "qualname": "_is_public",
  "name": "_is_public",
  "node_type": "FunctionDef",
  "lineno": 690,
  "col": 0,
  "end_lineno": 697,
  "end_col": 15,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cst_build/cst_collect.py",
  "module": "cst_build.cst_collect",
  "qualname": "_resolve_lazy",
  "name": "_resolve_lazy",
  "node_type": "FunctionDef",
  "lineno": 700,
  "col": 0,
  "end_lineno": 706,
  "end_col": 16,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cst_build/cst_collect.py",
  "module": "cst_build.cst_collect",
  "qualname": "_qualified_name_entries",
  "name": "_qualified_name_entries",
  "node_type": "FunctionDef",
  "lineno": 709,
  "col": 0,
  "end_lineno": 725,
  "end_col": 18,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cst_build/cst_collect.py",
  "module": "cst_build.cst_collect",
  "qualname": "_normalize_qnames",
  "name": "_normalize_qnames",
  "node_type": "FunctionDef",
  "lineno": 728,
  "col": 0,
  "end_lineno": 734,
  "end_col": 24,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cst_build/cst_collect.py",
  "module": "cst_build.cst_collect",
  "qualname": "_module_name_from_path",
  "name": "_module_name_from_path",
  "node_type": "FunctionDef",
  "lineno": 737,
  "col": 0,
  "end_lineno": 765,
  "end_col": 39,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Convert a relative file path into its dotted module name.\n\nThis function converts a relative file path (e.g., \"src/pkg/module.py\") into\na dotted module name (e.g., \"src.pkg.module\"). It handles Windows path\nseparators, strips .py extension, handles __init__.py files, and converts\npath separators to dots.\n\nParameters\n----------\nrel_path : str\n    Relative file path from repository root (e.g., \"src/pkg/module.py\").\n    Windows backslashes are normalized to forward slashes. The path may\n    include .py extension and __init__.py files.\n\nReturns\n-------\nstr\n    Dotted module name (e.g., \"src.pkg.module\"). Empty string for top-level\n    modules or when rel_path is empty. Path separators are converted to dots,\n    .py extension is stripped, and __init__ is removed from package paths.",
  "is_public": false
}
{
  "path": "cst_build/cst_collect.py",
  "module": "cst_build.cst_collect",
  "qualname": "_build_parse_error_node",
  "name": "_build_parse_error_node",
  "node_type": "FunctionDef",
  "lineno": 768,
  "col": 0,
  "end_lineno": 806,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return a placeholder row describing a parse failure.\n\nThis function creates a synthetic NodeRecord for files that failed to parse.\nThe record captures the parse error message and provides a placeholder entry\nin the node collection output, enabling downstream tools to identify and\nreport parse failures.\n\nParameters\n----------\nrel_path : str\n    Relative file path from repository root where the parse error occurred.\n    Used to identify the problematic file in the node record.\nmessage : str\n    Parse error message describing the failure. The message is truncated to\n    240 characters and included in the node record's doc snippet and errors\n    list. Used for debugging and error reporting.\n\nReturns\n-------\nNodeRecord\n    Synthetic node record with kind=\"ParseError\" capturing the parse issue.\n    The record includes the rel_path, a synthetic node_id, an empty span\n    (1,0,1,0), the error message in doc and errors fields, and minimal\n    metadata (parents=[\"Module\"], scope=\"Global\", empty qnames).",
  "is_public": false
}
{
  "path": "cst_build/cst_resolve.py",
  "module": "cst_build.cst_resolve",
  "qualname": "cst_build.cst_resolve",
  "name": "cst_build.cst_resolve",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Stitch CST nodes to module summary rows and SCIP symbols.",
  "is_public": true
}
{
  "path": "cst_build/cst_resolve.py",
  "module": "cst_build.cst_resolve",
  "qualname": "ModuleRow",
  "name": "ModuleRow",
  "node_type": "ClassDef",
  "lineno": 17,
  "col": 0,
  "end_lineno": 21,
  "end_col": 26,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Lightweight projection of a module.jsonl row.",
  "is_public": true
}
{
  "path": "cst_build/cst_resolve.py",
  "module": "cst_build.cst_resolve",
  "qualname": "StitchCounters",
  "name": "StitchCounters",
  "node_type": "ClassDef",
  "lineno": 25,
  "col": 0,
  "end_lineno": 55,
  "end_col": 9,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Aggregate match counters used for index.json.",
  "is_public": true
}
{
  "path": "cst_build/cst_resolve.py",
  "module": "cst_build.cst_resolve",
  "qualname": "StitchCounters.merge",
  "name": "merge",
  "node_type": "FunctionDef",
  "lineno": 31,
  "col": 4,
  "end_lineno": 55,
  "end_col": 9,
  "parent_qualname": "StitchCounters",
  "decorators": [],
  "bases": [],
  "docstring": "Return a new StitchCounters instance with merged totals.\n\nThis method creates a new StitchCounters instance by adding the counter\nvalues from another instance to this instance's values. The method is\nused to aggregate match statistics across multiple files or collections.\n\nParameters\n----------\nother : StitchCounters\n    Another StitchCounters instance whose values should be merged into\n    this instance. The method adds other.module_matches and other.scip_matches\n    to this instance's corresponding counters.\n\nReturns\n-------\nStitchCounters\n    New StitchCounters instance with accumulated counter values. The\n    module_matches and scip_matches fields contain the sum of this instance's\n    and other's values. The original instances are not modified.",
  "is_public": true
}
{
  "path": "cst_build/cst_resolve.py",
  "module": "cst_build.cst_resolve",
  "qualname": "_SymbolCandidate",
  "name": "_SymbolCandidate",
  "node_type": "ClassDef",
  "lineno": 59,
  "col": 0,
  "end_lineno": 63,
  "end_col": 26,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cst_build/cst_resolve.py",
  "module": "cst_build.cst_resolve",
  "qualname": "SCIPResolver",
  "name": "SCIPResolver",
  "node_type": "ClassDef",
  "lineno": 66,
  "col": 0,
  "end_lineno": 169,
  "end_col": 81,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Best-effort matcher between CST spans and SCIP occurrences.",
  "is_public": true
}
{
  "path": "cst_build/cst_resolve.py",
  "module": "cst_build.cst_resolve",
  "qualname": "SCIPResolver.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 78,
  "col": 4,
  "end_lineno": 99,
  "end_col": 71,
  "parent_qualname": "SCIPResolver",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cst_build/cst_resolve.py",
  "module": "cst_build.cst_resolve",
  "qualname": "SCIPResolver.match",
  "name": "match",
  "node_type": "FunctionDef",
  "lineno": 101,
  "col": 4,
  "end_lineno": 169,
  "end_col": 81,
  "parent_qualname": "SCIPResolver",
  "decorators": [],
  "bases": [],
  "docstring": "Return (symbol, evidence, confidence, debug candidates) if matched.\n\nThis method attempts to match a CST node record to a SCIP symbol by\nsearching the symbol index for candidates matching the node's kind,\nname, and line position. The method uses best-effort matching with\nconfidence scoring based on name hints and qualified names. When debug\nis enabled, returns candidate information for diagnostics.\n\nParameters\n----------\nnode : NodeRecord\n    CST node record to match against SCIP symbols. The node's kind,\n    name, and line position are used to search for matching symbols.\n    Only nodes with kinds in _DEF_KINDS or _USE_KINDS are processed.\ndebug : bool, optional\n    Flag indicating whether to include debug candidate information in\n    the result (default: False). When True, the returned tuple includes\n    a list of StitchCandidate objects for diagnostics. When False, the\n    candidate list is None.\n\nReturns\n-------\ntuple[str, list[str], float, list[StitchCandidate] | None] | None\n    Tuple containing:\n    - symbol: Matched SCIP symbol identifier (e.g., \"scip-python python ...\")\n    - evidence: List of evidence strings describing the match (e.g., [\"name\", \"qname\"])\n    - confidence: Confidence score between 0.0 and 1.0 indicating match quality\n    - debug candidates: Optional list of StitchCandidate objects when debug=True\n    Returns None when no stitch candidate matched or node kind is not supported.",
  "is_public": true
}
{
  "path": "cst_build/cst_resolve.py",
  "module": "cst_build.cst_resolve",
  "qualname": "load_modules",
  "name": "load_modules",
  "node_type": "FunctionDef",
  "lineno": 172,
  "col": 0,
  "end_lineno": 205,
  "end_col": 15,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Load modules.jsonl rows into a lookup keyed by normalized path.\n\nParameters\n----------\npath : Path | None\n    File system path to the modules.jsonl file, or None to return empty dict.\n\nReturns\n-------\ndict[str, ModuleRow]\n    Dictionary mapping normalized file paths to module row records.",
  "is_public": true
}
{
  "path": "cst_build/cst_resolve.py",
  "module": "cst_build.cst_resolve",
  "qualname": "load_scip_index",
  "name": "load_scip_index",
  "node_type": "FunctionDef",
  "lineno": 208,
  "col": 0,
  "end_lineno": 224,
  "end_col": 40,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Load the SCIP resolver when ``path`` exists.\n\nParameters\n----------\npath : Path | None\n    File system path to the SCIP index file, or None to return None.\n\nReturns\n-------\nSCIPResolver | None\n    SCIP resolver instance if the index file exists, otherwise None.",
  "is_public": true
}
{
  "path": "cst_build/cst_resolve.py",
  "module": "cst_build.cst_resolve",
  "qualname": "stitch_nodes",
  "name": "stitch_nodes",
  "node_type": "FunctionDef",
  "lineno": 227,
  "col": 0,
  "end_lineno": 285,
  "end_col": 29,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Attach StitchInfo to ``nodes``.\n\nParameters\n----------\nnodes : Iterable[NodeRecord]\n    Collection of node records to stitch.\nmodule_lookup : Mapping[str, ModuleRow]\n    Dictionary mapping normalized paths to module row records.\nscip_resolver : SCIPResolver | None\n    Optional SCIP resolver for symbol resolution.\ndebug : bool, optional\n    Whether to include debug candidate information. Defaults to False.\n\nReturns\n-------\ntuple[list[NodeRecord], StitchCounters]\n    Tuple containing the list of stitched node records and stitch counters.",
  "is_public": true
}
{
  "path": "cst_build/cst_resolve.py",
  "module": "cst_build.cst_resolve",
  "qualname": "_normalize_path",
  "name": "_normalize_path",
  "node_type": "FunctionDef",
  "lineno": 288,
  "col": 0,
  "end_lineno": 294,
  "end_col": 21,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cst_build/cst_resolve.py",
  "module": "cst_build.cst_resolve",
  "qualname": "_collect_candidates",
  "name": "_collect_candidates",
  "node_type": "FunctionDef",
  "lineno": 297,
  "col": 0,
  "end_lineno": 307,
  "end_col": 21,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cst_build/cst_resolve.py",
  "module": "cst_build.cst_resolve",
  "qualname": "_select_best_candidate",
  "name": "_select_best_candidate",
  "node_type": "FunctionDef",
  "lineno": 310,
  "col": 0,
  "end_lineno": 334,
  "end_col": 63,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cst_build/cst_resolve.py",
  "module": "cst_build.cst_resolve",
  "qualname": "_symbol_name_hint",
  "name": "_symbol_name_hint",
  "node_type": "FunctionDef",
  "lineno": 337,
  "col": 0,
  "end_lineno": 347,
  "end_col": 30,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cst_build/cst_resolve.py",
  "module": "cst_build.cst_resolve",
  "qualname": "_symbol_qname_hint",
  "name": "_symbol_qname_hint",
  "node_type": "FunctionDef",
  "lineno": 350,
  "col": 0,
  "end_lineno": 360,
  "end_col": 27,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cst_build/cst_resolve.py",
  "module": "cst_build.cst_resolve",
  "qualname": "_normalize_qname",
  "name": "_normalize_qname",
  "node_type": "FunctionDef",
  "lineno": 363,
  "col": 0,
  "end_lineno": 366,
  "end_col": 41,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cst_build/cst_resolve.py",
  "module": "cst_build.cst_resolve",
  "qualname": "_score_candidate",
  "name": "_score_candidate",
  "node_type": "FunctionDef",
  "lineno": 369,
  "col": 0,
  "end_lineno": 391,
  "end_col": 18,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cst_build/cst_schema.py",
  "module": "cst_build.cst_schema",
  "qualname": "cst_build.cst_schema",
  "name": "cst_build.cst_schema",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Dataclasses and helpers describing the CST dataset schema.",
  "is_public": true
}
{
  "path": "cst_build/cst_schema.py",
  "module": "cst_build.cst_schema",
  "qualname": "DocSnippet",
  "name": "DocSnippet",
  "node_type": "ClassDef",
  "lineno": 12,
  "col": 0,
  "end_lineno": 16,
  "end_col": 13,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "TypedDict"
  ],
  "docstring": "Short docstring snippets recorded on nodes.",
  "is_public": true
}
{
  "path": "cst_build/cst_schema.py",
  "module": "cst_build.cst_schema",
  "qualname": "ImportMetadata",
  "name": "ImportMetadata",
  "node_type": "ClassDef",
  "lineno": 19,
  "col": 0,
  "end_lineno": 26,
  "end_col": 14,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "TypedDict"
  ],
  "docstring": "Normalized import metadata for Import/ImportFrom nodes.",
  "is_public": true
}
{
  "path": "cst_build/cst_schema.py",
  "module": "cst_build.cst_schema",
  "qualname": "StitchCandidate",
  "name": "StitchCandidate",
  "node_type": "ClassDef",
  "lineno": 29,
  "col": 0,
  "end_lineno": 34,
  "end_col": 16,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "TypedDict"
  ],
  "docstring": "Debug candidate entry for stitching heuristics.",
  "is_public": true
}
{
  "path": "cst_build/cst_schema.py",
  "module": "cst_build.cst_schema",
  "qualname": "Span",
  "name": "Span",
  "node_type": "ClassDef",
  "lineno": 38,
  "col": 0,
  "end_lineno": 57,
  "end_col": 9,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Source span tracked for each node.",
  "is_public": true
}
{
  "path": "cst_build/cst_schema.py",
  "module": "cst_build.cst_schema",
  "qualname": "Span.to_dict",
  "name": "to_dict",
  "node_type": "FunctionDef",
  "lineno": 46,
  "col": 4,
  "end_lineno": 57,
  "end_col": 9,
  "parent_qualname": "Span",
  "decorators": [],
  "bases": [],
  "docstring": "Return the serialized span payload.\n\nReturns\n-------\ndict[str, list[int]]\n    Dictionary with \"start\" and \"end\" keys containing [line, column] lists.",
  "is_public": true
}
{
  "path": "cst_build/cst_schema.py",
  "module": "cst_build.cst_schema",
  "qualname": "StitchInfo",
  "name": "StitchInfo",
  "node_type": "ClassDef",
  "lineno": 61,
  "col": 0,
  "end_lineno": 88,
  "end_col": 22,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Join metadata linking nodes to module records and SCIP symbols.",
  "is_public": true
}
{
  "path": "cst_build/cst_schema.py",
  "module": "cst_build.cst_schema",
  "qualname": "StitchInfo.to_dict",
  "name": "to_dict",
  "node_type": "FunctionDef",
  "lineno": 70,
  "col": 4,
  "end_lineno": 88,
  "end_col": 22,
  "parent_qualname": "StitchInfo",
  "decorators": [],
  "bases": [],
  "docstring": "Return a JSON-serializable representation.\n\nReturns\n-------\ndict[str, object]\n    Dictionary containing module_id, scip_symbol, evidence, and optionally\n    confidence and candidates fields.",
  "is_public": true
}
{
  "path": "cst_build/cst_schema.py",
  "module": "cst_build.cst_schema",
  "qualname": "NodeRecord",
  "name": "NodeRecord",
  "node_type": "ClassDef",
  "lineno": 92,
  "col": 0,
  "end_lineno": 143,
  "end_col": 22,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Single CST node row ready for serialization.",
  "is_public": true
}
{
  "path": "cst_build/cst_schema.py",
  "module": "cst_build.cst_schema",
  "qualname": "NodeRecord.to_dict",
  "name": "to_dict",
  "node_type": "FunctionDef",
  "lineno": 113,
  "col": 4,
  "end_lineno": 143,
  "end_col": 22,
  "parent_qualname": "NodeRecord",
  "decorators": [],
  "bases": [],
  "docstring": "Serialize the node into the schema-compliant dict.\n\nReturns\n-------\ndict[str, object]\n    Dictionary containing all node fields in the schema-compliant format,\n    including path, node_id, kind, name, span, text_preview, parents, scope,\n    qnames, and optional fields like doc, is_public, decorators, etc.",
  "is_public": true
}
{
  "path": "cst_build/cst_schema.py",
  "module": "cst_build.cst_schema",
  "qualname": "CollectorStats",
  "name": "CollectorStats",
  "node_type": "ClassDef",
  "lineno": 147,
  "col": 0,
  "end_lineno": 195,
  "end_col": 27,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Aggregated counters for provider usage.",
  "is_public": true
}
{
  "path": "cst_build/cst_schema.py",
  "module": "cst_build.cst_schema",
  "qualname": "CollectorStats.merge",
  "name": "merge",
  "node_type": "FunctionDef",
  "lineno": 156,
  "col": 4,
  "end_lineno": 184,
  "end_col": 9,
  "parent_qualname": "CollectorStats",
  "decorators": [],
  "bases": [],
  "docstring": "Return a new CollectorStats representing the merged totals.\n\nThis method creates a new CollectorStats instance by adding the counter\nvalues from another instance to this instance's values. The method is\nused to aggregate collection statistics across multiple files or batches.\n\nParameters\n----------\nother : CollectorStats\n    Another CollectorStats instance whose values should be merged into\n    this instance. The method adds all counter fields (files_indexed,\n    node_rows, parse_errors, qname_hits, scope_resolved) from other\n    to this instance's corresponding counters.\n\nReturns\n-------\nCollectorStats\n    New CollectorStats instance with accumulated counter values. All\n    counter fields contain the sum of this instance's and other's values.\n    The original instances are not modified.",
  "is_public": true
}
{
  "path": "cst_build/cst_schema.py",
  "module": "cst_build.cst_schema",
  "qualname": "CollectorStats.to_dict",
  "name": "to_dict",
  "node_type": "FunctionDef",
  "lineno": 186,
  "col": 4,
  "end_lineno": 195,
  "end_col": 27,
  "parent_qualname": "CollectorStats",
  "decorators": [],
  "bases": [],
  "docstring": "Return JSON payload for provider stats.\n\nReturns\n-------\ndict[str, int]\n    Dictionary containing files_indexed, node_rows, parse_errors, qname_hits,\n    and scope_resolved counters.",
  "is_public": true
}
{
  "path": "cst_build/cst_schema.py",
  "module": "cst_build.cst_schema",
  "qualname": "_format_doc",
  "name": "_format_doc",
  "node_type": "FunctionDef",
  "lineno": 198,
  "col": 0,
  "end_lineno": 206,
  "end_col": 29,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cst_build/cst_schema.py",
  "module": "cst_build.cst_schema",
  "qualname": "_assign_optional",
  "name": "_assign_optional",
  "node_type": "FunctionDef",
  "lineno": 209,
  "col": 0,
  "end_lineno": 220,
  "end_col": 24,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cst_build/cst_serialize.py",
  "module": "cst_build.cst_serialize",
  "qualname": "cst_build.cst_serialize",
  "name": "cst_build.cst_serialize",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Writers and helpers that persist CST datasets to disk.",
  "is_public": true
}
{
  "path": "cst_build/cst_serialize.py",
  "module": "cst_build.cst_serialize",
  "qualname": "DatasetWriter",
  "name": "DatasetWriter",
  "node_type": "ClassDef",
  "lineno": 21,
  "col": 0,
  "end_lineno": 152,
  "end_col": 23,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Stream-oriented writer that materializes the dataset artifacts.",
  "is_public": true
}
{
  "path": "cst_build/cst_serialize.py",
  "module": "cst_build.cst_serialize",
  "qualname": "DatasetWriter.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 24,
  "col": 4,
  "end_lineno": 34,
  "end_col": 32,
  "parent_qualname": "DatasetWriter",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cst_build/cst_serialize.py",
  "module": "cst_build.cst_serialize",
  "qualname": "DatasetWriter.__enter__",
  "name": "__enter__",
  "node_type": "FunctionDef",
  "lineno": 36,
  "col": 4,
  "end_lineno": 51,
  "end_col": 19,
  "parent_qualname": "DatasetWriter",
  "decorators": [],
  "bases": [],
  "docstring": "Open the gzip stream and module writers.\n\nReturns\n-------\nSelf\n    Active writer bound to the destination directory. Returns self\n    for use as a context manager.",
  "is_public": false
}
{
  "path": "cst_build/cst_serialize.py",
  "module": "cst_build.cst_serialize",
  "qualname": "DatasetWriter.__exit__",
  "name": "__exit__",
  "node_type": "FunctionDef",
  "lineno": 53,
  "col": 4,
  "end_lineno": 60,
  "end_col": 23,
  "parent_qualname": "DatasetWriter",
  "decorators": [],
  "bases": [],
  "docstring": "Close any open resources when leaving the context manager.",
  "is_public": false
}
{
  "path": "cst_build/cst_serialize.py",
  "module": "cst_build.cst_serialize",
  "qualname": "DatasetWriter.node_count",
  "name": "node_count",
  "node_type": "FunctionDef",
  "lineno": 63,
  "col": 4,
  "end_lineno": 71,
  "end_col": 31,
  "parent_qualname": "DatasetWriter",
  "decorators": [
    "property"
  ],
  "bases": [],
  "docstring": "Return the total number of nodes collected.\n\nReturns\n-------\nint\n    Total count of nodes collected across all files.",
  "is_public": true
}
{
  "path": "cst_build/cst_serialize.py",
  "module": "cst_build.cst_serialize",
  "qualname": "DatasetWriter.files_indexed",
  "name": "files_indexed",
  "node_type": "FunctionDef",
  "lineno": 74,
  "col": 4,
  "end_lineno": 82,
  "end_col": 34,
  "parent_qualname": "DatasetWriter",
  "decorators": [
    "property"
  ],
  "bases": [],
  "docstring": "Return the number of files indexed.\n\nReturns\n-------\nint\n    Count of unique files that have been indexed.",
  "is_public": true
}
{
  "path": "cst_build/cst_serialize.py",
  "module": "cst_build.cst_serialize",
  "qualname": "DatasetWriter.samples",
  "name": "samples",
  "node_type": "FunctionDef",
  "lineno": 85,
  "col": 4,
  "end_lineno": 93,
  "end_col": 34,
  "parent_qualname": "DatasetWriter",
  "decorators": [
    "property"
  ],
  "bases": [],
  "docstring": "Return a sample of collected node records.\n\nReturns\n-------\nlist[NodeRecord]\n    List of sampled node records, limited by the configured sample size.",
  "is_public": true
}
{
  "path": "cst_build/cst_serialize.py",
  "module": "cst_build.cst_serialize",
  "qualname": "DatasetWriter.observe_file",
  "name": "observe_file",
  "node_type": "FunctionDef",
  "lineno": 95,
  "col": 4,
  "end_lineno": 97,
  "end_col": 36,
  "parent_qualname": "DatasetWriter",
  "decorators": [],
  "bases": [],
  "docstring": "Record that a new file is being streamed.",
  "is_public": true
}
{
  "path": "cst_build/cst_serialize.py",
  "module": "cst_build.cst_serialize",
  "qualname": "DatasetWriter.write_nodes",
  "name": "write_nodes",
  "node_type": "FunctionDef",
  "lineno": 99,
  "col": 4,
  "end_lineno": 108,
  "end_col": 36,
  "parent_qualname": "DatasetWriter",
  "decorators": [],
  "bases": [],
  "docstring": "Write ``nodes`` to the gzipped dataset and per-module shards.",
  "is_public": true
}
{
  "path": "cst_build/cst_serialize.py",
  "module": "cst_build.cst_serialize",
  "qualname": "DatasetWriter.finalize",
  "name": "finalize",
  "node_type": "FunctionDef",
  "lineno": 110,
  "col": 4,
  "end_lineno": 117,
  "end_col": 36,
  "parent_qualname": "DatasetWriter",
  "decorators": [],
  "bases": [],
  "docstring": "Close open streams.",
  "is_public": true
}
{
  "path": "cst_build/cst_serialize.py",
  "module": "cst_build.cst_serialize",
  "qualname": "DatasetWriter._write_module_row",
  "name": "_write_module_row",
  "node_type": "FunctionDef",
  "lineno": 119,
  "col": 4,
  "end_lineno": 132,
  "end_col": 26,
  "parent_qualname": "DatasetWriter",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cst_build/cst_serialize.py",
  "module": "cst_build.cst_serialize",
  "qualname": "DatasetWriter._maybe_sample",
  "name": "_maybe_sample",
  "node_type": "FunctionDef",
  "lineno": 134,
  "col": 4,
  "end_lineno": 146,
  "end_col": 33,
  "parent_qualname": "DatasetWriter",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cst_build/cst_serialize.py",
  "module": "cst_build.cst_serialize",
  "qualname": "DatasetWriter._ensure_writer",
  "name": "_ensure_writer",
  "node_type": "FunctionDef",
  "lineno": 148,
  "col": 4,
  "end_lineno": 152,
  "end_col": 23,
  "parent_qualname": "DatasetWriter",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "cst_build/cst_serialize.py",
  "module": "cst_build.cst_serialize",
  "qualname": "write_index",
  "name": "write_index",
  "node_type": "FunctionDef",
  "lineno": 155,
  "col": 0,
  "end_lineno": 181,
  "end_col": 47,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Persist index.json summarizing the build.",
  "is_public": true
}
{
  "path": "cst_build/cst_serialize.py",
  "module": "cst_build.cst_serialize",
  "qualname": "write_join_examples",
  "name": "write_join_examples",
  "node_type": "FunctionDef",
  "lineno": 184,
  "col": 0,
  "end_lineno": 212,
  "end_col": 87,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Write markdown examples linking nodes to SCIP symbols.",
  "is_public": true
}
{
  "path": "cst_build/cst_serialize.py",
  "module": "cst_build.cst_serialize",
  "qualname": "_module_slug",
  "name": "_module_slug",
  "node_type": "FunctionDef",
  "lineno": 215,
  "col": 0,
  "end_lineno": 220,
  "end_col": 53,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "diagnostics/__init__.py",
  "module": "diagnostics",
  "qualname": "diagnostics",
  "name": "diagnostics",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Diagnostics helpers for CodeIntel.",
  "is_public": true
}
{
  "path": "diagnostics/detectors.py",
  "module": "diagnostics.detectors",
  "qualname": "diagnostics.detectors",
  "name": "diagnostics.detectors",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Lightweight heuristics over run reports to surface diagnostics hints.",
  "is_public": true
}
{
  "path": "diagnostics/detectors.py",
  "module": "diagnostics.detectors",
  "qualname": "_stage_by_prefix",
  "name": "_stage_by_prefix",
  "node_type": "FunctionDef",
  "lineno": 15,
  "col": 0,
  "end_lineno": 20,
  "end_col": 15,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "diagnostics/detectors.py",
  "module": "diagnostics.detectors",
  "qualname": "_stage_attr",
  "name": "_stage_attr",
  "node_type": "FunctionDef",
  "lineno": 23,
  "col": 0,
  "end_lineno": 29,
  "end_col": 15,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "diagnostics/detectors.py",
  "module": "diagnostics.detectors",
  "qualname": "_collect_mapping",
  "name": "_collect_mapping",
  "node_type": "FunctionDef",
  "lineno": 32,
  "col": 0,
  "end_lineno": 36,
  "end_col": 13,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "diagnostics/detectors.py",
  "module": "diagnostics.detectors",
  "qualname": "_collect_stages",
  "name": "_collect_stages",
  "node_type": "FunctionDef",
  "lineno": 39,
  "col": 0,
  "end_lineno": 43,
  "end_col": 13,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "diagnostics/detectors.py",
  "module": "diagnostics.detectors",
  "qualname": "_gap_hint",
  "name": "_gap_hint",
  "node_type": "FunctionDef",
  "lineno": 46,
  "col": 0,
  "end_lineno": 53,
  "end_col": 15,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "diagnostics/detectors.py",
  "module": "diagnostics.detectors",
  "qualname": "_sparse_hint",
  "name": "_sparse_hint",
  "node_type": "FunctionDef",
  "lineno": 56,
  "col": 0,
  "end_lineno": 63,
  "end_col": 15,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "diagnostics/detectors.py",
  "module": "diagnostics.detectors",
  "qualname": "_vllm_hints",
  "name": "_vllm_hints",
  "node_type": "FunctionDef",
  "lineno": 66,
  "col": 0,
  "end_lineno": 87,
  "end_col": 16,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "diagnostics/detectors.py",
  "module": "diagnostics.detectors",
  "qualname": "_faiss_hint",
  "name": "_faiss_hint",
  "node_type": "FunctionDef",
  "lineno": 90,
  "col": 0,
  "end_lineno": 103,
  "end_col": 15,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "diagnostics/detectors.py",
  "module": "diagnostics.detectors",
  "qualname": "_rrf_hint",
  "name": "_rrf_hint",
  "node_type": "FunctionDef",
  "lineno": 106,
  "col": 0,
  "end_lineno": 120,
  "end_col": 15,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "diagnostics/detectors.py",
  "module": "diagnostics.detectors",
  "qualname": "detect",
  "name": "detect",
  "node_type": "FunctionDef",
  "lineno": 123,
  "col": 0,
  "end_lineno": 162,
  "end_col": 16,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return structured hints derived from the run report payload.\n\nThis function analyzes a run report and generates diagnostic hints based on\npatterns in operations coverage, budget allocations, and stage execution. It is\ncalled by diagnostic tools to provide actionable insights about search\nperformance and configuration issues.\n\nParameters\n----------\nreport : Mapping[str, Any]\n    Run report dictionary containing events, operations coverage, budgets,\n    and stage information.\n\nReturns\n-------\nlist[dict[str, Any]]\n    Collection of diagnostic hints with ``kind``, ``msg``, and ``why`` fields.\n    Each hint describes a potential issue or optimization opportunity detected\n    in the report.",
  "is_public": true
}
{
  "path": "diagnostics/report_cli.py",
  "module": "diagnostics.report_cli",
  "qualname": "diagnostics.report_cli",
  "name": "diagnostics.report_cli",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Diagnostics CLI for rendering run reports from session event ledgers.",
  "is_public": true
}
{
  "path": "diagnostics/report_cli.py",
  "module": "diagnostics.report_cli",
  "qualname": "ReportFormat",
  "name": "ReportFormat",
  "node_type": "ClassDef",
  "lineno": 22,
  "col": 0,
  "end_lineno": 26,
  "end_col": 17,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "StrEnum"
  ],
  "docstring": "Supported output encodings for diagnostics reports.",
  "is_public": true
}
{
  "path": "diagnostics/report_cli.py",
  "module": "diagnostics.report_cli",
  "qualname": "_coerce_str",
  "name": "_coerce_str",
  "node_type": "FunctionDef",
  "lineno": 32,
  "col": 0,
  "end_lineno": 35,
  "end_col": 15,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "diagnostics/report_cli.py",
  "module": "diagnostics.report_cli",
  "qualname": "_coerce_number",
  "name": "_coerce_number",
  "node_type": "FunctionDef",
  "lineno": 38,
  "col": 0,
  "end_lineno": 41,
  "end_col": 15,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "diagnostics/report_cli.py",
  "module": "diagnostics.report_cli",
  "qualname": "_event_ts",
  "name": "_event_ts",
  "node_type": "FunctionDef",
  "lineno": 44,
  "col": 0,
  "end_lineno": 48,
  "end_col": 12,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "diagnostics/report_cli.py",
  "module": "diagnostics.report_cli",
  "qualname": "_event_attrs",
  "name": "_event_attrs",
  "node_type": "FunctionDef",
  "lineno": 51,
  "col": 0,
  "end_lineno": 55,
  "end_col": 13,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "diagnostics/report_cli.py",
  "module": "diagnostics.report_cli",
  "qualname": "_stage_label",
  "name": "_stage_label",
  "node_type": "FunctionDef",
  "lineno": 58,
  "col": 0,
  "end_lineno": 59,
  "end_col": 76,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "diagnostics/report_cli.py",
  "module": "diagnostics.report_cli",
  "qualname": "_group_events_by_run",
  "name": "_group_events_by_run",
  "node_type": "FunctionDef",
  "lineno": 62,
  "col": 0,
  "end_lineno": 74,
  "end_col": 18,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "diagnostics/report_cli.py",
  "module": "diagnostics.report_cli",
  "qualname": "_max_ts",
  "name": "_max_ts",
  "node_type": "FunctionDef",
  "lineno": 77,
  "col": 0,
  "end_lineno": 85,
  "end_col": 25,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "diagnostics/report_cli.py",
  "module": "diagnostics.report_cli",
  "qualname": "_select_run",
  "name": "_select_run",
  "node_type": "FunctionDef",
  "lineno": 88,
  "col": 0,
  "end_lineno": 101,
  "end_col": 25,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "diagnostics/report_cli.py",
  "module": "diagnostics.report_cli",
  "qualname": "_stage_rows",
  "name": "_stage_rows",
  "node_type": "FunctionDef",
  "lineno": 104,
  "col": 0,
  "end_lineno": 117,
  "end_col": 15,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "diagnostics/report_cli.py",
  "module": "diagnostics.report_cli",
  "qualname": "_skip_rows",
  "name": "_skip_rows",
  "node_type": "FunctionDef",
  "lineno": 120,
  "col": 0,
  "end_lineno": 133,
  "end_col": 15,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "diagnostics/report_cli.py",
  "module": "diagnostics.report_cli",
  "qualname": "_render_stage_section",
  "name": "_render_stage_section",
  "node_type": "FunctionDef",
  "lineno": 136,
  "col": 0,
  "end_lineno": 148,
  "end_col": 16,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "diagnostics/report_cli.py",
  "module": "diagnostics.report_cli",
  "qualname": "_render_skip_section",
  "name": "_render_skip_section",
  "node_type": "FunctionDef",
  "lineno": 151,
  "col": 0,
  "end_lineno": 163,
  "end_col": 16,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "diagnostics/report_cli.py",
  "module": "diagnostics.report_cli",
  "qualname": "_render_markdown",
  "name": "_render_markdown",
  "node_type": "FunctionDef",
  "lineno": 166,
  "col": 0,
  "end_lineno": 177,
  "end_col": 26,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "diagnostics/report_cli.py",
  "module": "diagnostics.report_cli",
  "qualname": "_structured_report",
  "name": "_structured_report",
  "node_type": "FunctionDef",
  "lineno": 180,
  "col": 0,
  "end_lineno": 195,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "diagnostics/report_cli.py",
  "module": "diagnostics.report_cli",
  "qualname": "session_report",
  "name": "session_report",
  "node_type": "FunctionDef",
  "lineno": 199,
  "col": 0,
  "end_lineno": 277,
  "end_col": 42,
  "parent_qualname": null,
  "decorators": [
    "app.command('session')"
  ],
  "bases": [],
  "docstring": "Render the latest (or requested) run for a session from an events ledger.\n\nParameters\n----------\nevents : Path\n    JSONL ledger containing mixed run events. Must exist and be readable.\n    Provided via typer.Option.\nsession : str\n    Session identifier to filter runs. Provided via typer.Option.\nrun : str | None\n    Optional run identifier to force selection. Defaults to None.\n    Provided via typer.Option.\nout : Path | None\n    Optional output path. When omitted the report is printed to stdout.\n    Defaults to None. Provided via typer.Option.\nfmt : ReportFormat\n    Output format for the report (markdown or json). Defaults to MARKDOWN.\n    Provided via typer.Option with flag \"--format\".\n\nRaises\n------\ntyper.BadParameter\n    If the session identifier is empty, the requested run is missing, or no\n    events exist for the resolved run.",
  "is_public": true
}
{
  "path": "diagnostics/report_cli.py",
  "module": "diagnostics.report_cli",
  "qualname": "ledger_report",
  "name": "ledger_report",
  "node_type": "FunctionDef",
  "lineno": 281,
  "col": 0,
  "end_lineno": 313,
  "end_col": 52,
  "parent_qualname": null,
  "decorators": [
    "app.command('run')"
  ],
  "bases": [],
  "docstring": "Render structured JSON for a run ledger stored under ``data/telemetry``.\n\nParameters\n----------\nrun_id : str\n    Run identifier returned via API response headers. Provided via typer.Argument.\ndata_dir : Path\n    Data directory whose telemetry sub-directory stores run ledgers.\n    Defaults to Path(\"data\"). Provided via typer.Option.\n\nRaises\n------\ntyper.BadParameter\n    If the run ledger cannot be located under ``data/telemetry``.",
  "is_public": true
}
{
  "path": "diagnostics/report_cli.py",
  "module": "diagnostics.report_cli",
  "qualname": "main",
  "name": "main",
  "node_type": "FunctionDef",
  "lineno": 316,
  "col": 0,
  "end_lineno": 344,
  "end_col": 12,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Invoke the Typer application while supporting programmatic argv injection.\n\nParameters\n----------\nargv : Sequence[str] | None\n    Argument vector override. When None, ``sys.argv[1:]`` is used.\n\nReturns\n-------\nint\n    Process-style exit code emitted by Typer.",
  "is_public": true
}
{
  "path": "doc_health.py",
  "module": "doc_health",
  "qualname": "doc_health",
  "name": "doc_health",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Docstring summarization helpers.",
  "is_public": true
}
{
  "path": "doc_health.py",
  "module": "doc_health",
  "qualname": "summarize_doc_health",
  "name": "summarize_doc_health",
  "node_type": "FunctionDef",
  "lineno": 11,
  "col": 0,
  "end_lineno": 28,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return a normalized doc health summary for a module.\n\nParameters\n----------\nindex : ModuleIndex\n    Module index containing docstring health metrics.\n\nReturns\n-------\ndict[str, Any]\n    Dictionary containing ``doc_summary``, ``doc_metrics``, and ``doc_items``.",
  "is_public": true
}
{
  "path": "embeddings/__init__.py",
  "module": "embeddings",
  "qualname": "embeddings",
  "name": "embeddings",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Embedding provider public API.",
  "is_public": true
}
{
  "path": "embeddings/embedding_service.py",
  "module": "embeddings.embedding_service",
  "qualname": "embeddings.embedding_service",
  "name": "embeddings.embedding_service",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Embedding provider abstractions for chunk ingestion and runtime services.",
  "is_public": true
}
{
  "path": "embeddings/embedding_service.py",
  "module": "embeddings.embedding_service",
  "qualname": "EmbeddingRuntimeError",
  "name": "EmbeddingRuntimeError",
  "node_type": "ClassDef",
  "lineno": 52,
  "col": 0,
  "end_lineno": 53,
  "end_col": 57,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "RuntimeError"
  ],
  "docstring": "Raised when an embedding provider fails to run.",
  "is_public": true
}
{
  "path": "embeddings/embedding_service.py",
  "module": "embeddings.embedding_service",
  "qualname": "EmbeddingConfigError",
  "name": "EmbeddingConfigError",
  "node_type": "ClassDef",
  "lineno": 56,
  "col": 0,
  "end_lineno": 57,
  "end_col": 57,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "ValueError"
  ],
  "docstring": "Raised when embedding configuration is invalid.",
  "is_public": true
}
{
  "path": "embeddings/embedding_service.py",
  "module": "embeddings.embedding_service",
  "qualname": "EmbeddingMetadata",
  "name": "EmbeddingMetadata",
  "node_type": "ClassDef",
  "lineno": 61,
  "col": 0,
  "end_lineno": 86,
  "end_col": 9,
  "parent_qualname": null,
  "decorators": [
    "dataclass(frozen=True)"
  ],
  "bases": [],
  "docstring": "Structured metadata describing the active embedding provider.",
  "is_public": true
}
{
  "path": "embeddings/embedding_service.py",
  "module": "embeddings.embedding_service",
  "qualname": "EmbeddingMetadata.as_dict",
  "name": "as_dict",
  "node_type": "FunctionDef",
  "lineno": 71,
  "col": 4,
  "end_lineno": 86,
  "end_col": 9,
  "parent_qualname": "EmbeddingMetadata",
  "decorators": [],
  "bases": [],
  "docstring": "Return a JSON-serialisable dictionary.\n\nReturns\n-------\ndict[str, object]\n    Provider metadata mapped to primitive types.",
  "is_public": true
}
{
  "path": "embeddings/embedding_service.py",
  "module": "embeddings.embedding_service",
  "qualname": "EmbeddingProvider",
  "name": "EmbeddingProvider",
  "node_type": "ClassDef",
  "lineno": 90,
  "col": 0,
  "end_lineno": 114,
  "end_col": 11,
  "parent_qualname": null,
  "decorators": [
    "runtime_checkable"
  ],
  "bases": [
    "Protocol"
  ],
  "docstring": "Common surface for embedding providers used across CLIs and services.",
  "is_public": true
}
{
  "path": "embeddings/embedding_service.py",
  "module": "embeddings.embedding_service",
  "qualname": "EmbeddingProvider.embed_texts",
  "name": "embed_texts",
  "node_type": "FunctionDef",
  "lineno": 93,
  "col": 4,
  "end_lineno": 95,
  "end_col": 11,
  "parent_qualname": "EmbeddingProvider",
  "decorators": [],
  "bases": [],
  "docstring": "Embed a short batch of texts and return a dense matrix.",
  "is_public": true
}
{
  "path": "embeddings/embedding_service.py",
  "module": "embeddings.embedding_service",
  "qualname": "EmbeddingProvider.embed_stream",
  "name": "embed_stream",
  "node_type": "FunctionDef",
  "lineno": 97,
  "col": 4,
  "end_lineno": 101,
  "end_col": 11,
  "parent_qualname": "EmbeddingProvider",
  "decorators": [],
  "bases": [],
  "docstring": "Embed a potentially large iterator, yielding one matrix per chunk.",
  "is_public": true
}
{
  "path": "embeddings/embedding_service.py",
  "module": "embeddings.embedding_service",
  "qualname": "EmbeddingProvider.metadata",
  "name": "metadata",
  "node_type": "FunctionDef",
  "lineno": 104,
  "col": 4,
  "end_lineno": 106,
  "end_col": 11,
  "parent_qualname": "EmbeddingProvider",
  "decorators": [
    "property"
  ],
  "bases": [],
  "docstring": "Return static provider metadata.",
  "is_public": true
}
{
  "path": "embeddings/embedding_service.py",
  "module": "embeddings.embedding_service",
  "qualname": "EmbeddingProvider.fingerprint",
  "name": "fingerprint",
  "node_type": "FunctionDef",
  "lineno": 108,
  "col": 4,
  "end_lineno": 110,
  "end_col": 11,
  "parent_qualname": "EmbeddingProvider",
  "decorators": [],
  "bases": [],
  "docstring": "Return a stable fingerprint suitable for manifests and checksums.",
  "is_public": true
}
{
  "path": "embeddings/embedding_service.py",
  "module": "embeddings.embedding_service",
  "qualname": "EmbeddingProvider.close",
  "name": "close",
  "node_type": "FunctionDef",
  "lineno": 112,
  "col": 4,
  "end_lineno": 114,
  "end_col": 11,
  "parent_qualname": "EmbeddingProvider",
  "decorators": [],
  "bases": [],
  "docstring": "Release provider resources.",
  "is_public": true
}
{
  "path": "embeddings/embedding_service.py",
  "module": "embeddings.embedding_service",
  "qualname": "_numpy",
  "name": "_numpy",
  "node_type": "FunctionDef",
  "lineno": 117,
  "col": 0,
  "end_lineno": 125,
  "end_col": 91,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return the lazily imported NumPy module for vector ops.\n\nReturns\n-------\nModuleType\n    The ``numpy`` module resolved via the typing gate.",
  "is_public": false
}
{
  "path": "embeddings/embedding_service.py",
  "module": "embeddings.embedding_service",
  "qualname": "_l2_normalize",
  "name": "_l2_normalize",
  "node_type": "FunctionDef",
  "lineno": 128,
  "col": 0,
  "end_lineno": 157,
  "end_col": 22,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return vectors scaled to unit length along axis 1.\n\nThis function normalizes input vectors to unit length using L2 (Euclidean)\nnorm. Each row vector is scaled so that its L2 norm equals 1.0, ensuring\nall vectors have the same magnitude for consistent similarity computation.\nZero vectors are handled by setting their norm to 1.0 to avoid division\nby zero.\n\nParameters\n----------\nvectors : NDArrayF32\n    Input vectors with shape `(N, dim)` and dtype float32. Each row represents\n    a vector to normalize. The function computes L2 norm along axis 1 (per row)\n    and scales each vector to unit length.\n\nReturns\n-------\nNDArrayF32\n    Normalized vectors with the same shape as ``vectors`` and dtype float32.\n    Each row vector has L2 norm of 1.0 (unit length). Zero vectors are\n    preserved as zero vectors (norm set to 1.0 to avoid division by zero).",
  "is_public": false
}
{
  "path": "embeddings/embedding_service.py",
  "module": "embeddings.embedding_service",
  "qualname": "_ExecutorJob",
  "name": "_ExecutorJob",
  "node_type": "ClassDef",
  "lineno": 161,
  "col": 0,
  "end_lineno": 163,
  "end_col": 30,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "embeddings/embedding_service.py",
  "module": "embeddings.embedding_service",
  "qualname": "_FailureCounter",
  "name": "_FailureCounter",
  "node_type": "ClassDef",
  "lineno": 166,
  "col": 0,
  "end_lineno": 184,
  "end_col": 20,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Increment error counters when an exception bubbles out of a context.",
  "is_public": false
}
{
  "path": "embeddings/embedding_service.py",
  "module": "embeddings.embedding_service",
  "qualname": "_FailureCounter.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 169,
  "col": 4,
  "end_lineno": 170,
  "end_col": 43,
  "parent_qualname": "_FailureCounter",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "embeddings/embedding_service.py",
  "module": "embeddings.embedding_service",
  "qualname": "_FailureCounter.__enter__",
  "name": "__enter__",
  "node_type": "FunctionDef",
  "lineno": 172,
  "col": 4,
  "end_lineno": 173,
  "end_col": 19,
  "parent_qualname": "_FailureCounter",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "embeddings/embedding_service.py",
  "module": "embeddings.embedding_service",
  "qualname": "_FailureCounter.__exit__",
  "name": "__exit__",
  "node_type": "FunctionDef",
  "lineno": 175,
  "col": 4,
  "end_lineno": 184,
  "end_col": 20,
  "parent_qualname": "_FailureCounter",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "embeddings/embedding_service.py",
  "module": "embeddings.embedding_service",
  "qualname": "_BatchResultHandler",
  "name": "_BatchResultHandler",
  "node_type": "ClassDef",
  "lineno": 187,
  "col": 0,
  "end_lineno": 241,
  "end_col": 19,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Resolve futures when a fused batch completes or fails.",
  "is_public": false
}
{
  "path": "embeddings/embedding_service.py",
  "module": "embeddings.embedding_service",
  "qualname": "_BatchResultHandler.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 190,
  "col": 4,
  "end_lineno": 191,
  "end_col": 31,
  "parent_qualname": "_BatchResultHandler",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "embeddings/embedding_service.py",
  "module": "embeddings.embedding_service",
  "qualname": "_BatchResultHandler.__enter__",
  "name": "__enter__",
  "node_type": "FunctionDef",
  "lineno": 193,
  "col": 4,
  "end_lineno": 194,
  "end_col": 19,
  "parent_qualname": "_BatchResultHandler",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "embeddings/embedding_service.py",
  "module": "embeddings.embedding_service",
  "qualname": "_BatchResultHandler.set_result",
  "name": "set_result",
  "node_type": "FunctionDef",
  "lineno": 196,
  "col": 4,
  "end_lineno": 225,
  "end_col": 27,
  "parent_qualname": "_BatchResultHandler",
  "decorators": [],
  "bases": [],
  "docstring": "Distribute fused batch result to individual job futures.\n\nThis method splits a fused batch result (containing embeddings for multiple\njobs) into individual slices and sets each job's future with its corresponding\nportion. The method maintains the order of jobs and ensures each future\nreceives the correct slice of embeddings aligned with its input texts.\n\nParameters\n----------\nresult : NDArrayF32\n    Fused embedding matrix with shape `(total_texts, dim)` containing\n    embeddings for all texts from all jobs in sequence. The matrix is\n    split sequentially, with each job receiving a contiguous slice\n    corresponding to its input texts.\n\nNotes\n-----\nThis method is called when a fused batch completes successfully. It\ndistributes the result to all pending futures, allowing callers to\nretrieve their embeddings. The method assumes the result matrix is\ncorrectly sized to match the total number of texts across all jobs.\nTime complexity: O(n) where n is the number of jobs. Thread-safe if\nFuture.set_result() is thread-safe.",
  "is_public": true
}
{
  "path": "embeddings/embedding_service.py",
  "module": "embeddings.embedding_service",
  "qualname": "_BatchResultHandler.__exit__",
  "name": "__exit__",
  "node_type": "FunctionDef",
  "lineno": 227,
  "col": 4,
  "end_lineno": 241,
  "end_col": 19,
  "parent_qualname": "_BatchResultHandler",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "embeddings/embedding_service.py",
  "module": "embeddings.embedding_service",
  "qualname": "_QueueSentinel",
  "name": "_QueueSentinel",
  "node_type": "ClassDef",
  "lineno": 244,
  "col": 0,
  "end_lineno": 245,
  "end_col": 54,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Unique sentinel signaling executor shutdown.",
  "is_public": false
}
{
  "path": "embeddings/embedding_service.py",
  "module": "embeddings.embedding_service",
  "qualname": "_BoundedBatchExecutor",
  "name": "_BoundedBatchExecutor",
  "node_type": "ClassDef",
  "lineno": 248,
  "col": 0,
  "end_lineno": 359,
  "end_col": 19,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Opportunistically coalesces pending embedding jobs into micro-batches.",
  "is_public": false
}
{
  "path": "embeddings/embedding_service.py",
  "module": "embeddings.embedding_service",
  "qualname": "_BoundedBatchExecutor.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 253,
  "col": 4,
  "end_lineno": 271,
  "end_col": 28,
  "parent_qualname": "_BoundedBatchExecutor",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "embeddings/embedding_service.py",
  "module": "embeddings.embedding_service",
  "qualname": "_BoundedBatchExecutor.submit",
  "name": "submit",
  "node_type": "FunctionDef",
  "lineno": 273,
  "col": 4,
  "end_lineno": 307,
  "end_col": 30,
  "parent_qualname": "_BoundedBatchExecutor",
  "decorators": [],
  "bases": [],
  "docstring": "Enqueue ``texts`` and block until the fused batch completes.\n\nThis method submits a batch of texts to the background executor for\nembedding generation. The texts are enqueued and may be fused with other\npending batches to improve throughput. The method blocks until the batch\ncompletes and embeddings are available.\n\nParameters\n----------\ntexts : list[str]\n    List of text strings to embed. The texts are enqueued as a job and\n    processed by the background executor. The texts may be fused with\n    other pending batches if micro-batching is enabled.\n\nReturns\n-------\nNDArrayF32\n    Embedding matrix with shape `(len(texts), dim)` aligned with the\n    input texts. Dtype is float32. The embeddings are generated by the\n    background executor and returned once the batch completes.\n\nRaises\n------\nEmbeddingRuntimeError\n    Raised when the executor has already been stopped. The executor\n    cannot accept new jobs after close() has been called.",
  "is_public": true
}
{
  "path": "embeddings/embedding_service.py",
  "module": "embeddings.embedding_service",
  "qualname": "_BoundedBatchExecutor.close",
  "name": "close",
  "node_type": "FunctionDef",
  "lineno": 309,
  "col": 4,
  "end_lineno": 313,
  "end_col": 36,
  "parent_qualname": "_BoundedBatchExecutor",
  "decorators": [],
  "bases": [],
  "docstring": "Stop the background worker and drain the queue.",
  "is_public": true
}
{
  "path": "embeddings/embedding_service.py",
  "module": "embeddings.embedding_service",
  "qualname": "_BoundedBatchExecutor._run",
  "name": "_run",
  "node_type": "FunctionDef",
  "lineno": 315,
  "col": 4,
  "end_lineno": 324,
  "end_col": 43,
  "parent_qualname": "_BoundedBatchExecutor",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "embeddings/embedding_service.py",
  "module": "embeddings.embedding_service",
  "qualname": "_BoundedBatchExecutor._next_job",
  "name": "_next_job",
  "node_type": "FunctionDef",
  "lineno": 326,
  "col": 4,
  "end_lineno": 334,
  "end_col": 19,
  "parent_qualname": "_BoundedBatchExecutor",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "embeddings/embedding_service.py",
  "module": "embeddings.embedding_service",
  "qualname": "_BoundedBatchExecutor._gather_jobs",
  "name": "_gather_jobs",
  "node_type": "FunctionDef",
  "lineno": 336,
  "col": 4,
  "end_lineno": 349,
  "end_col": 19,
  "parent_qualname": "_BoundedBatchExecutor",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "embeddings/embedding_service.py",
  "module": "embeddings.embedding_service",
  "qualname": "_BoundedBatchExecutor._fetch_with_timeout",
  "name": "_fetch_with_timeout",
  "node_type": "FunctionDef",
  "lineno": 351,
  "col": 4,
  "end_lineno": 359,
  "end_col": 19,
  "parent_qualname": "_BoundedBatchExecutor",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "embeddings/embedding_service.py",
  "module": "embeddings.embedding_service",
  "qualname": "_ProviderState",
  "name": "_ProviderState",
  "node_type": "ClassDef",
  "lineno": 363,
  "col": 0,
  "end_lineno": 372,
  "end_col": 34,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=False)"
  ],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "embeddings/embedding_service.py",
  "module": "embeddings.embedding_service",
  "qualname": "_ProviderBase",
  "name": "_ProviderBase",
  "node_type": "ClassDef",
  "lineno": 375,
  "col": 0,
  "end_lineno": 690,
  "end_col": 52,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "EmbeddingProvider"
  ],
  "docstring": "Shared batching/metrics logic used by concrete providers.",
  "is_public": false
}
{
  "path": "embeddings/embedding_service.py",
  "module": "embeddings.embedding_service",
  "qualname": "_ProviderBase.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 378,
  "col": 4,
  "end_lineno": 402,
  "end_col": 26,
  "parent_qualname": "_ProviderBase",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "embeddings/embedding_service.py",
  "module": "embeddings.embedding_service",
  "qualname": "_ProviderBase.embed_texts",
  "name": "embed_texts",
  "node_type": "FunctionDef",
  "lineno": 404,
  "col": 4,
  "end_lineno": 436,
  "end_col": 42,
  "parent_qualname": "_ProviderBase",
  "decorators": [],
  "bases": [],
  "docstring": "Embed short batches of texts synchronously.\n\nThis method generates embeddings for a batch of text inputs. For small\nbatches (within configured batch_size), the method may use the background\nexecutor for micro-batching if enabled. For larger batches or when the\nexecutor is disabled, embeddings are generated directly. The method\nsanitizes inputs (truncating long texts) and returns normalized embeddings\nif configured.\n\nParameters\n----------\ntexts : Sequence[str]\n    Sequence of text strings to embed. Each string is tokenized and passed\n    through the embedding model to generate a dense vector representation.\n    Texts exceeding max_sequence_chars are truncated.\n\nReturns\n-------\nNDArrayF32\n    Embedding matrix with shape `(len(texts), dim)` aligned with the input\n    texts. Dtype is float32. Embeddings are normalized if the normalize\n    configuration is enabled, otherwise raw model outputs. Empty input\n    returns a zero matrix with shape `(0, vec_dim)`.",
  "is_public": true
}
{
  "path": "embeddings/embedding_service.py",
  "module": "embeddings.embedding_service",
  "qualname": "_ProviderBase.embed_stream",
  "name": "embed_stream",
  "node_type": "FunctionDef",
  "lineno": 438,
  "col": 4,
  "end_lineno": 479,
  "end_col": 60,
  "parent_qualname": "_ProviderBase",
  "decorators": [],
  "bases": [],
  "docstring": "Yield embeddings over ``texts`` in streaming batches.\n\nThis method processes a potentially large iterable of texts in streaming\nfashion, yielding embedding matrices for each batch. The method buffers\ntexts until the chunk size is reached, then generates embeddings and\nyields the result. This enables memory-efficient processing of large\ntext collections without loading everything into memory.\n\nParameters\n----------\ntexts : Iterable[str]\n    Iterable of text strings to embed. The texts are processed in batches,\n    with each batch yielding an embedding matrix. The iterable is consumed\n    lazily, enabling memory-efficient processing of large collections.\nchunk_size : int | None, optional\n    Number of texts per batch (defaults to configured batch_size). Controls\n    the size of each embedding matrix yielded. Larger chunks improve\n    throughput but increase memory usage.\n\nYields\n------\nNDArrayF32\n    Embedding matrix per chunk with shape `(batch, dim)` where batch is\n    the number of texts in the chunk (up to chunk_size). Dtype is float32.\n    Embeddings are normalized if configured. The final chunk may be smaller\n    than chunk_size if the input iterable is exhausted.",
  "is_public": true
}
{
  "path": "embeddings/embedding_service.py",
  "module": "embeddings.embedding_service",
  "qualname": "_ProviderBase.metadata",
  "name": "metadata",
  "node_type": "FunctionDef",
  "lineno": 482,
  "col": 4,
  "end_lineno": 521,
  "end_col": 19,
  "parent_qualname": "_ProviderBase",
  "decorators": [
    "property"
  ],
  "bases": [],
  "docstring": "Return static provider metadata.\n\nThis property returns cached provider metadata describing the embedding\nprovider configuration. The metadata includes provider name, model name,\nembedding dimension, dtype, normalization settings, and device information.\nThe metadata is computed lazily on first access and cached for subsequent\ncalls.\n\nReturns\n-------\nEmbeddingMetadata\n    Immutable metadata object containing:\n    - provider: Provider name (e.g., \"vllm\", \"hf\")\n    - model_name: Model identifier from configuration\n    - dimension: Embedding dimension (detected or configured)\n    - dtype: Data type string (e.g., \"float32\")\n    - normalize: Whether embeddings are L2-normalized\n    - device: Device label (e.g., \"cuda\", \"cpu\")\n\nNotes\n-----\nThe metadata is cached in the provider state after first computation.\nIf dimension is not yet detected, uses the configured index vector\ndimension. The metadata is used for logging, telemetry, and provider\nidentification. Thread-safe if state access is thread-safe.",
  "is_public": true
}
{
  "path": "embeddings/embedding_service.py",
  "module": "embeddings.embedding_service",
  "qualname": "_ProviderBase.fingerprint",
  "name": "fingerprint",
  "node_type": "FunctionDef",
  "lineno": 523,
  "col": 4,
  "end_lineno": 555,
  "end_col": 38,
  "parent_qualname": "_ProviderBase",
  "decorators": [],
  "bases": [],
  "docstring": "Return a stable fingerprint suitable for manifests and checksums.\n\nThis method computes a deterministic fingerprint based on provider metadata\n(provider name, model name, and embedding dimension). The fingerprint is\ncomputed as a SHA-256 hash of the metadata string, providing a stable\nidentifier that can be used for caching, manifest generation, and checksum\nvalidation. The fingerprint is cached after first computation.\n\nReturns\n-------\nstr\n    Hexadecimal SHA-256 hash string (64 characters) representing the\n    provider configuration fingerprint. The fingerprint is deterministic\n    for the same provider, model, and dimension combination, enabling\n    stable identification across runs.\n\nNotes\n-----\nThe fingerprint is computed from provider metadata (provider:model:dimension)\nand cached in the provider state. It is used for manifest generation,\ncache keys, and checksum validation. The fingerprint does not include\nruntime state or device information, ensuring consistency across different\nexecution environments with the same configuration. Thread-safe if state\naccess is thread-safe.",
  "is_public": true
}
{
  "path": "embeddings/embedding_service.py",
  "module": "embeddings.embedding_service",
  "qualname": "_ProviderBase.close",
  "name": "close",
  "node_type": "FunctionDef",
  "lineno": 557,
  "col": 4,
  "end_lineno": 579,
  "end_col": 26,
  "parent_qualname": "_ProviderBase",
  "decorators": [],
  "bases": [],
  "docstring": "Release provider resources.\n\nThis method performs cleanup operations to release provider resources,\nincluding stopping the background batch executor (if configured) and\ncalling the implementation-specific cleanup hook. The method should be\ncalled when the provider is no longer needed to free memory, GPU\nresources, and background threads.\n\nNotes\n-----\nThis method stops the background batch executor if one was created,\nwhich drains pending jobs and stops the worker thread. It then calls\nthe implementation-specific _close_impl() hook for provider-specific\ncleanup (e.g., releasing model weights, clearing GPU cache). The method\nis idempotent and safe to call multiple times. After calling close(),\nthe provider should not be used for further embedding operations.\nThread-safe if executor and implementation cleanup are thread-safe.",
  "is_public": true
}
{
  "path": "embeddings/embedding_service.py",
  "module": "embeddings.embedding_service",
  "qualname": "_ProviderBase._embed_direct",
  "name": "_embed_direct",
  "node_type": "FunctionDef",
  "lineno": 582,
  "col": 4,
  "end_lineno": 597,
  "end_col": 22,
  "parent_qualname": "_ProviderBase",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "embeddings/embedding_service.py",
  "module": "embeddings.embedding_service",
  "qualname": "_ProviderBase._post_process",
  "name": "_post_process",
  "node_type": "FunctionDef",
  "lineno": 599,
  "col": 4,
  "end_lineno": 620,
  "end_col": 20,
  "parent_qualname": "_ProviderBase",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "embeddings/embedding_service.py",
  "module": "embeddings.embedding_service",
  "qualname": "_ProviderBase._record_metrics",
  "name": "_record_metrics",
  "node_type": "FunctionDef",
  "lineno": 622,
  "col": 4,
  "end_lineno": 647,
  "end_col": 9,
  "parent_qualname": "_ProviderBase",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "embeddings/embedding_service.py",
  "module": "embeddings.embedding_service",
  "qualname": "_ProviderBase._inflight_guard",
  "name": "_inflight_guard",
  "node_type": "FunctionDef",
  "lineno": 650,
  "col": 4,
  "end_lineno": 660,
  "end_col": 88,
  "parent_qualname": "_ProviderBase",
  "decorators": [
    "contextmanager"
  ],
  "bases": [],
  "docstring": "Track in-flight batches for Prometheus gauges.",
  "is_public": false
}
{
  "path": "embeddings/embedding_service.py",
  "module": "embeddings.embedding_service",
  "qualname": "_ProviderBase._memory_bytes",
  "name": "_memory_bytes",
  "node_type": "FunctionDef",
  "lineno": 663,
  "col": 4,
  "end_lineno": 664,
  "end_col": 16,
  "parent_qualname": "_ProviderBase",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "embeddings/embedding_service.py",
  "module": "embeddings.embedding_service",
  "qualname": "_ProviderBase._sanitize",
  "name": "_sanitize",
  "node_type": "FunctionDef",
  "lineno": 666,
  "col": 4,
  "end_lineno": 683,
  "end_col": 22,
  "parent_qualname": "_ProviderBase",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "embeddings/embedding_service.py",
  "module": "embeddings.embedding_service",
  "qualname": "_ProviderBase._run_inference",
  "name": "_run_inference",
  "node_type": "FunctionDef",
  "lineno": 686,
  "col": 4,
  "end_lineno": 687,
  "end_col": 33,
  "parent_qualname": "_ProviderBase",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "embeddings/embedding_service.py",
  "module": "embeddings.embedding_service",
  "qualname": "_ProviderBase._close_impl",
  "name": "_close_impl",
  "node_type": "FunctionDef",
  "lineno": 689,
  "col": 4,
  "end_lineno": 690,
  "end_col": 52,
  "parent_qualname": "_ProviderBase",
  "decorators": [],
  "bases": [],
  "docstring": "Allow subclasses to release resources.",
  "is_public": false
}
{
  "path": "embeddings/embedding_service.py",
  "module": "embeddings.embedding_service",
  "qualname": "VLLMProvider",
  "name": "VLLMProvider",
  "node_type": "ClassDef",
  "lineno": 693,
  "col": 0,
  "end_lineno": 715,
  "end_col": 30,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "_ProviderBase"
  ],
  "docstring": "Embedding provider backed by the in-process vLLM engine.",
  "is_public": true
}
{
  "path": "embeddings/embedding_service.py",
  "module": "embeddings.embedding_service",
  "qualname": "VLLMProvider.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 696,
  "col": 4,
  "end_lineno": 709,
  "end_col": 59,
  "parent_qualname": "VLLMProvider",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "embeddings/embedding_service.py",
  "module": "embeddings.embedding_service",
  "qualname": "VLLMProvider._run_inference",
  "name": "_run_inference",
  "node_type": "FunctionDef",
  "lineno": 711,
  "col": 4,
  "end_lineno": 712,
  "end_col": 59,
  "parent_qualname": "VLLMProvider",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "embeddings/embedding_service.py",
  "module": "embeddings.embedding_service",
  "qualname": "VLLMProvider._close_impl",
  "name": "_close_impl",
  "node_type": "FunctionDef",
  "lineno": 714,
  "col": 4,
  "end_lineno": 715,
  "end_col": 30,
  "parent_qualname": "VLLMProvider",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "embeddings/embedding_service.py",
  "module": "embeddings.embedding_service",
  "qualname": "get_embedding_provider",
  "name": "get_embedding_provider",
  "node_type": "FunctionDef",
  "lineno": 718,
  "col": 0,
  "end_lineno": 802,
  "end_col": 13,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return the configured embedding provider, falling back when allowed.\n\nThis function creates and returns an embedding provider instance based on\nthe provided settings. It supports multiple provider types (vLLM, HuggingFace)\nand can fall back to alternative providers when the preferred provider fails\nto initialize. The function handles provider initialization errors gracefully\nand provides fallback behavior when configured.\n\nParameters\n----------\nsettings : Settings\n    Application settings containing embedding configuration (provider name,\n    model name, device, normalization, etc.) and index configuration (vector\n    dimension). Used to initialize the selected provider.\nprefer : str | None, optional\n    Preferred provider name to use instead of settings.embeddings.provider.\n    If None, uses the configured provider from settings. Valid values are\n    \"vllm\" or \"hf\" (case-insensitive). Used to override default provider\n    selection.\n\nReturns\n-------\nEmbeddingProvider\n    Concrete provider implementation (VLLMProvider or HFEmbeddingProvider)\n    initialized with the provided settings. The provider is ready for use\n    and can generate embeddings via embed_texts() or embed_stream().\n\nRaises\n------\nEmbeddingConfigError\n    Raised when the requested provider name is unsupported or invalid.\n    Valid provider names are \"vllm\" and \"hf\" (case-insensitive).\nEmbeddingRuntimeError\n    Raised when a provider fails to initialize and no fallback is allowed.\n    For vLLM provider, falls back to HF if allow_hf_fallback is enabled.\n    For HF provider, no fallback is available. Also raised when HF provider\n    initialization fails and no fallback is configured. Wraps underlying\n    provider initialization exceptions with context.\nException\n    When vLLM provider initialization fails and allow_hf_fallback is False,\n    the original exception from VLLMProvider initialization is re-raised\n    (not wrapped) using a bare `raise` statement. This allows callers to\n    handle provider-specific exceptions (e.g., CUDA errors, model loading\n    failures) when fallback is disabled. The exception is re-raised using\n    `raise` where the exception comes from the except block. Note: The\n    exception is re-raised using a bare `raise`, so pydoclint may flag this\n    as DOC502, but the exception is correctly propagated.\n\nNotes\n-----\nThis function handles provider initialization errors gracefully. When vLLM\nprovider initialization fails and allow_hf_fallback is True, it automatically\nfalls back to HF provider. When fallback is disabled, provider-specific\nexceptions (e.g., CUDA errors, model loading failures, import errors) are\nre-raised directly. The function ensures at least one provider is available\nwhen fallback is enabled, or raises appropriate errors when no provider can\nbe initialized.",
  "is_public": true
}
{
  "path": "embeddings/embedding_service.py",
  "module": "embeddings.embedding_service",
  "qualname": "HFEmbeddingProvider",
  "name": "HFEmbeddingProvider",
  "node_type": "ClassDef",
  "lineno": 805,
  "col": 0,
  "end_lineno": 874,
  "end_col": 76,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "_ProviderBase"
  ],
  "docstring": "CPU/GPU fallback using Hugging Face transformers.",
  "is_public": true
}
{
  "path": "embeddings/embedding_service.py",
  "module": "embeddings.embedding_service",
  "qualname": "HFEmbeddingProvider.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 808,
  "col": 4,
  "end_lineno": 832,
  "end_col": 26,
  "parent_qualname": "HFEmbeddingProvider",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "embeddings/embedding_service.py",
  "module": "embeddings.embedding_service",
  "qualname": "HFEmbeddingProvider._run_inference",
  "name": "_run_inference",
  "node_type": "FunctionDef",
  "lineno": 834,
  "col": 4,
  "end_lineno": 856,
  "end_col": 30,
  "parent_qualname": "HFEmbeddingProvider",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "embeddings/embedding_service.py",
  "module": "embeddings.embedding_service",
  "qualname": "HFEmbeddingProvider._memory_bytes",
  "name": "_memory_bytes",
  "node_type": "FunctionDef",
  "lineno": 858,
  "col": 4,
  "end_lineno": 864,
  "end_col": 16,
  "parent_qualname": "HFEmbeddingProvider",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "embeddings/embedding_service.py",
  "module": "embeddings.embedding_service",
  "qualname": "HFEmbeddingProvider._close_impl",
  "name": "_close_impl",
  "node_type": "FunctionDef",
  "lineno": 866,
  "col": 4,
  "end_lineno": 874,
  "end_col": 76,
  "parent_qualname": "HFEmbeddingProvider",
  "decorators": [],
  "bases": [],
  "docstring": "Release Hugging Face resources.",
  "is_public": false
}
{
  "path": "enrich/__init__.py",
  "module": "enrich",
  "qualname": "enrich",
  "name": "enrich",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Utilities for building repo-enrichment artifacts (LibCST, SCIP, tagging, overlays).",
  "is_public": true
}
{
  "path": "enrich/ast_indexer.py",
  "module": "enrich.ast_indexer",
  "qualname": "enrich.ast_indexer",
  "name": "enrich.ast_indexer",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "AST indexer producing join-ready Parquet datasets.",
  "is_public": true
}
{
  "path": "enrich/ast_indexer.py",
  "module": "enrich.ast_indexer",
  "qualname": "DefInfo",
  "name": "DefInfo",
  "node_type": "ClassDef",
  "lineno": 20,
  "col": 0,
  "end_lineno": 26,
  "end_col": 31,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Intermediate representation for definition nodes with qualnames.",
  "is_public": true
}
{
  "path": "enrich/ast_indexer.py",
  "module": "enrich.ast_indexer",
  "qualname": "AstNodeRow",
  "name": "AstNodeRow",
  "node_type": "ClassDef",
  "lineno": 30,
  "col": 0,
  "end_lineno": 59,
  "end_col": 21,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Row emitted to ast_nodes.parquet.",
  "is_public": true
}
{
  "path": "enrich/ast_indexer.py",
  "module": "enrich.ast_indexer",
  "qualname": "AstNodeRow.as_record",
  "name": "as_record",
  "node_type": "FunctionDef",
  "lineno": 48,
  "col": 4,
  "end_lineno": 59,
  "end_col": 21,
  "parent_qualname": "AstNodeRow",
  "decorators": [],
  "bases": [],
  "docstring": "Return a JSON/Arrow friendly mapping.\n\nReturns\n-------\ndict[str, object]\n    Mapping ready for pyarrow ingestion.",
  "is_public": true
}
{
  "path": "enrich/ast_indexer.py",
  "module": "enrich.ast_indexer",
  "qualname": "AstMetricsRow",
  "name": "AstMetricsRow",
  "node_type": "ClassDef",
  "lineno": 63,
  "col": 0,
  "end_lineno": 86,
  "end_col": 27,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Row emitted to ast_metrics.parquet.",
  "is_public": true
}
{
  "path": "enrich/ast_indexer.py",
  "module": "enrich.ast_indexer",
  "qualname": "AstMetricsRow.as_record",
  "name": "as_record",
  "node_type": "FunctionDef",
  "lineno": 78,
  "col": 4,
  "end_lineno": 86,
  "end_col": 27,
  "parent_qualname": "AstMetricsRow",
  "decorators": [],
  "bases": [],
  "docstring": "Return a JSON/Arrow friendly mapping.\n\nReturns\n-------\ndict[str, object]\n    Mapping ready for analytics layers.",
  "is_public": true
}
{
  "path": "enrich/ast_indexer.py",
  "module": "enrich.ast_indexer",
  "qualname": "stable_module_path",
  "name": "stable_module_path",
  "node_type": "FunctionDef",
  "lineno": 125,
  "col": 0,
  "end_lineno": 156,
  "end_col": 25,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return a repo-relative POSIX path for the given file.\n\nThis function converts an absolute or relative file path into a normalized\nPOSIX-style path relative to the repository root. The function resolves both\npaths to absolute paths, computes the relative path, and normalizes it to\nuse forward slashes (POSIX style) regardless of the platform.\n\nParameters\n----------\nrepo_root : Path\n    Root directory of the repository used for path normalization. The path\n    is resolved to an absolute path before computing the relative path.\nfile_path : Path\n    Absolute or relative file path to normalize. The path is resolved to an\n    absolute path before computing the relative path from repo_root.\n\nReturns\n-------\nstr\n    POSIX-style path relative to repo_root, using forward slashes as path\n    separators. The path is normalized and suitable for use in module names\n    or cross-platform file references. Raises ValueError if file_path is not\n    within repo_root (defensive fallback returns file_path as string).",
  "is_public": true
}
{
  "path": "enrich/ast_indexer.py",
  "module": "enrich.ast_indexer",
  "qualname": "_module_name_from_path",
  "name": "_module_name_from_path",
  "node_type": "FunctionDef",
  "lineno": 159,
  "col": 0,
  "end_lineno": 167,
  "end_col": 45,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "enrich/ast_indexer.py",
  "module": "enrich.ast_indexer",
  "qualname": "_safe_unparse",
  "name": "_safe_unparse",
  "node_type": "FunctionDef",
  "lineno": 170,
  "col": 0,
  "end_lineno": 176,
  "end_col": 38,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "enrich/ast_indexer.py",
  "module": "enrich.ast_indexer",
  "qualname": "walk_defs_with_qualname",
  "name": "walk_defs_with_qualname",
  "node_type": "FunctionDef",
  "lineno": 179,
  "col": 0,
  "end_lineno": 221,
  "end_col": 27,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Yield definition nodes with fully-qualified names.\n\nThis function traverses an AST tree and yields DefInfo objects for each\nclass, function, or async function definition encountered. The function\nbuilds fully-qualified names by tracking the nesting stack (class/function\nhierarchy) and constructs qualified names for each definition.\n\nParameters\n----------\ntree : ast.AST\n    Parsed module AST tree from the ast module. The tree is traversed\n    recursively to find all class, function, and async function definitions.\n    Must be an ast.Module or other AST node containing definitions.\n\nYields\n------\nDefInfo\n    Metadata object for each class, function, or async function definition\n    found in the tree. Each DefInfo contains the node, qualified name,\n    and definition kind. Definitions are yielded in depth-first traversal\n    order.",
  "is_public": true
}
{
  "path": "enrich/ast_indexer.py",
  "module": "enrich.ast_indexer",
  "qualname": "walk_defs_with_qualname._visit",
  "name": "_visit",
  "node_type": "FunctionDef",
  "lineno": 204,
  "col": 4,
  "end_lineno": 219,
  "end_col": 40,
  "parent_qualname": "walk_defs_with_qualname",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "enrich/ast_indexer.py",
  "module": "enrich.ast_indexer",
  "qualname": "collect_ast_nodes",
  "name": "collect_ast_nodes",
  "node_type": "FunctionDef",
  "lineno": 224,
  "col": 0,
  "end_lineno": 256,
  "end_col": 50,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Parse code and collect node rows for Parquet output.\n\nThis function parses Python source code into an AST and collects node rows\n(module, class, function definitions) for Parquet serialization. The function\nextracts AST metrics (complexity, statements, functions, classes) and builds\nAstNodeRow objects containing definition metadata and metrics.\n\nParameters\n----------\npath : str\n    Repo-relative module path using POSIX separators (e.g., \"src/pkg/module.py\").\n    Used to identify the source file in the collected node rows. The path\n    is normalized and used for module name extraction.\ncode : str\n    Source code content to parse. The code is parsed using ast.parse() to\n    build an AST tree, which is then traversed to collect definitions and\n    compute metrics.\n\nReturns\n-------\nlist[AstNodeRow]\n    List of AstNodeRow objects containing module, class, and function definitions\n    with their metadata and AST metrics. Each row includes path, name, kind,\n    complexity, statements count, and other metrics. Empty list if parsing\n    fails or no definitions are found.",
  "is_public": true
}
{
  "path": "enrich/ast_indexer.py",
  "module": "enrich.ast_indexer",
  "qualname": "collect_ast_nodes_from_tree",
  "name": "collect_ast_nodes_from_tree",
  "node_type": "FunctionDef",
  "lineno": 259,
  "col": 0,
  "end_lineno": 356,
  "end_col": 15,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Collect AstNodeRow entries from a pre-parsed AST module.\n\nThis function collects node rows from a pre-parsed AST tree, extracting\ndefinitions (module, classes, functions) and computing AST metrics. The\nfunction is more efficient than collect_ast_nodes() when the AST is already\navailable, avoiding redundant parsing.\n\nParameters\n----------\npath : str\n    Repo-relative module path using POSIX separators (e.g., \"src/pkg/module.py\").\n    Used to identify the source file in the collected node rows. The path\n    is normalized and used for module name extraction.\ntree : ast.AST\n    Pre-parsed AST module tree from the ast module. The tree is traversed\n    to collect definitions and compute metrics. Must be an ast.Module or\n    compatible AST node containing definitions.\n\nReturns\n-------\nlist[AstNodeRow]\n    List of AstNodeRow objects ready for Parquet serialization. Each row\n    contains definition metadata (path, name, kind) and AST metrics\n    (complexity, statements, functions, classes). Empty list if no definitions\n    are found or tree is invalid.",
  "is_public": true
}
{
  "path": "enrich/ast_indexer.py",
  "module": "enrich.ast_indexer",
  "qualname": "compute_ast_metrics",
  "name": "compute_ast_metrics",
  "node_type": "FunctionDef",
  "lineno": 359,
  "col": 0,
  "end_lineno": 403,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Compute per-file metrics from a parsed AST.\n\nThis function computes AST metrics (complexity, statements, functions, classes)\nby traversing a parsed AST tree with a metrics visitor. The function extracts\ncyclomatic complexity, cognitive complexity, nesting depth, and various node\ncounts to build a comprehensive metrics row for the module.\n\nParameters\n----------\npath : str\n    Repo-relative module path using POSIX separators (e.g., \"src/pkg/module.py\").\n    Used to identify the source file in the metrics row. The path is normalized\n    and used for module name extraction.\ntree : ast.AST\n    Parsed AST tree for the module from the ast module. The tree is traversed\n    by a _MetricsVisitor to collect complexity metrics, node counts, and nesting\n    information. Must be an ast.Module or compatible AST node.\n\nReturns\n-------\nAstMetricsRow\n    Aggregate metrics row describing the module with computed complexity metrics\n    and node counts. The row includes path, module name, function/class counts,\n    cyclomatic complexity, cognitive complexity, max nesting depth, and statement\n    count.",
  "is_public": true
}
{
  "path": "enrich/ast_indexer.py",
  "module": "enrich.ast_indexer",
  "qualname": "empty_metrics_row",
  "name": "empty_metrics_row",
  "node_type": "FunctionDef",
  "lineno": 406,
  "col": 0,
  "end_lineno": 442,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return a zeroed metrics row for parse failures.\n\nThis function creates an AstMetricsRow with all metrics set to zero for files\nthat failed to parse. The function extracts the module name from the path and\ncreates a placeholder row that can be included in metrics output even when\nparsing fails, enabling downstream tools to identify problematic files.\n\nParameters\n----------\npath : str\n    Repo-relative module path using POSIX separators (e.g., \"src/pkg/module.py\").\n    Used to identify the source file in the metrics row. The path is normalized\n    and used for module name extraction.\n\nReturns\n-------\nAstMetricsRow\n    Metrics row with zeros for all counters (func_count, class_count, assign_count,\n    import_count, branch_nodes, cyclomatic, cognitive, max_nesting, statements).\n    The row includes the path and extracted module name, but all metric values\n    are zero to indicate parse failure.",
  "is_public": true
}
{
  "path": "enrich/ast_indexer.py",
  "module": "enrich.ast_indexer",
  "qualname": "write_ast_parquet",
  "name": "write_ast_parquet",
  "node_type": "FunctionDef",
  "lineno": 445,
  "col": 0,
  "end_lineno": 456,
  "end_col": 65,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Persist AST datasets to Parquet files expected by DuckDB.",
  "is_public": true
}
{
  "path": "enrich/ast_indexer.py",
  "module": "enrich.ast_indexer",
  "qualname": "_table_from_rows",
  "name": "_table_from_rows",
  "node_type": "FunctionDef",
  "lineno": 462,
  "col": 0,
  "end_lineno": 467,
  "end_col": 56,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "enrich/ast_indexer.py",
  "module": "enrich.ast_indexer",
  "qualname": "_MetricsVisitor",
  "name": "_MetricsVisitor",
  "node_type": "ClassDef",
  "lineno": 470,
  "col": 0,
  "end_lineno": 563,
  "end_col": 34,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "ast.NodeVisitor"
  ],
  "docstring": "Collects aggregate counts for AST metrics.",
  "is_public": false
}
{
  "path": "enrich/ast_indexer.py",
  "module": "enrich.ast_indexer",
  "qualname": "_MetricsVisitor.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 483,
  "col": 4,
  "end_lineno": 491,
  "end_col": 33,
  "parent_qualname": "_MetricsVisitor",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "enrich/ast_indexer.py",
  "module": "enrich.ast_indexer",
  "qualname": "_MetricsVisitor.generic_visit",
  "name": "generic_visit",
  "node_type": "FunctionDef",
  "lineno": 493,
  "col": 4,
  "end_lineno": 508,
  "end_col": 35,
  "parent_qualname": "_MetricsVisitor",
  "decorators": [],
  "bases": [],
  "docstring": "Visit a generic AST node and increment statement counter if applicable.\n\nThis method is called for nodes that don't have a specific visitor method.\nIt increments the statement counter for statement nodes and then calls\nthe parent class's generic_visit to continue traversal.\n\nParameters\n----------\nnode : ast.AST\n    Generic AST node being visited. If the node is a statement, the\n    statement counter is incremented.",
  "is_public": true
}
{
  "path": "enrich/ast_indexer.py",
  "module": "enrich.ast_indexer",
  "qualname": "_MetricsVisitor.visit_FunctionDef",
  "name": "visit_FunctionDef",
  "node_type": "FunctionDef",
  "lineno": 510,
  "col": 4,
  "end_lineno": 519,
  "end_col": 32,
  "parent_qualname": "_MetricsVisitor",
  "decorators": [],
  "bases": [],
  "docstring": "Visit a function definition and increment function counter.\n\nParameters\n----------\nnode : ast.FunctionDef\n    AST node representing a function definition (e.g., ``def func(): ...``).",
  "is_public": true
}
{
  "path": "enrich/ast_indexer.py",
  "module": "enrich.ast_indexer",
  "qualname": "_MetricsVisitor.visit_ClassDef",
  "name": "visit_ClassDef",
  "node_type": "FunctionDef",
  "lineno": 521,
  "col": 4,
  "end_lineno": 530,
  "end_col": 32,
  "parent_qualname": "_MetricsVisitor",
  "decorators": [],
  "bases": [],
  "docstring": "Visit a class definition and increment class counter.\n\nParameters\n----------\nnode : ast.ClassDef\n    AST node representing a class definition (e.g., ``class MyClass: ...``).",
  "is_public": true
}
{
  "path": "enrich/ast_indexer.py",
  "module": "enrich.ast_indexer",
  "qualname": "_MetricsVisitor.visit_Assign",
  "name": "visit_Assign",
  "node_type": "FunctionDef",
  "lineno": 532,
  "col": 4,
  "end_lineno": 541,
  "end_col": 32,
  "parent_qualname": "_MetricsVisitor",
  "decorators": [],
  "bases": [],
  "docstring": "Visit an assignment statement and increment assignment counter.\n\nParameters\n----------\nnode : ast.Assign\n    AST node representing an assignment statement (e.g., ``x = 1``, ``a, b = 1, 2``).",
  "is_public": true
}
{
  "path": "enrich/ast_indexer.py",
  "module": "enrich.ast_indexer",
  "qualname": "_MetricsVisitor.visit_Import",
  "name": "visit_Import",
  "node_type": "FunctionDef",
  "lineno": 543,
  "col": 4,
  "end_lineno": 552,
  "end_col": 32,
  "parent_qualname": "_MetricsVisitor",
  "decorators": [],
  "bases": [],
  "docstring": "Visit an import statement and increment import counter.\n\nParameters\n----------\nnode : ast.Import\n    AST node representing an import statement (e.g., ``import os``).",
  "is_public": true
}
{
  "path": "enrich/ast_indexer.py",
  "module": "enrich.ast_indexer",
  "qualname": "_MetricsVisitor.branch_visit",
  "name": "branch_visit",
  "node_type": "FunctionDef",
  "lineno": 554,
  "col": 4,
  "end_lineno": 556,
  "end_col": 51,
  "parent_qualname": "_MetricsVisitor",
  "decorators": [],
  "bases": [],
  "docstring": "Increment branch metrics for complex control-flow nodes.",
  "is_public": true
}
{
  "path": "enrich/ast_indexer.py",
  "module": "enrich.ast_indexer",
  "qualname": "_MetricsVisitor._with_branch",
  "name": "_with_branch",
  "node_type": "FunctionDef",
  "lineno": 558,
  "col": 4,
  "end_lineno": 563,
  "end_col": 34,
  "parent_qualname": "_MetricsVisitor",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "enrich/duckdb_store.py",
  "module": "enrich.duckdb_store",
  "qualname": "enrich.duckdb_store",
  "name": "enrich.duckdb_store",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Utilities for loading enrichment artifacts into DuckDB.",
  "is_public": true
}
{
  "path": "enrich/duckdb_store.py",
  "module": "enrich.duckdb_store",
  "qualname": "DuckConn",
  "name": "DuckConn",
  "node_type": "ClassDef",
  "lineno": 60,
  "col": 0,
  "end_lineno": 63,
  "end_col": 17,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Connection metadata for enrichment DuckDB ingestion.",
  "is_public": true
}
{
  "path": "enrich/duckdb_store.py",
  "module": "enrich.duckdb_store",
  "qualname": "_duckdb",
  "name": "_duckdb",
  "node_type": "FunctionDef",
  "lineno": 66,
  "col": 0,
  "end_lineno": 74,
  "end_col": 64,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Import duckdb on demand to keep it optional at runtime.\n\nReturns\n-------\nobject\n    DuckDB module ready for connections.",
  "is_public": false
}
{
  "path": "enrich/duckdb_store.py",
  "module": "enrich.duckdb_store",
  "qualname": "ensure_schema",
  "name": "ensure_schema",
  "node_type": "FunctionDef",
  "lineno": 77,
  "col": 0,
  "end_lineno": 118,
  "end_col": 9,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Create the ``modules`` table if it does not already exist.",
  "is_public": true
}
{
  "path": "enrich/duckdb_store.py",
  "module": "enrich.duckdb_store",
  "qualname": "ingest_modules_jsonl",
  "name": "ingest_modules_jsonl",
  "node_type": "FunctionDef",
  "lineno": 121,
  "col": 0,
  "end_lineno": 148,
  "end_col": 21,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Load modules.jsonl rows into DuckDB, replacing existing paths.\n\nParameters\n----------\nconn : DuckConn\n    DuckDB connection wrapper containing the database path. The connection\n    is used to ensure the schema exists and to execute insert/delete queries.\nmodules_jsonl : Path\n    Path to the JSONL file containing module records. Each line must be a\n    valid JSON object representing a ModuleRecord. Existing records with\n    matching paths are deleted before insertion.\n\nReturns\n-------\nint\n    Total number of rows now present in the ``modules`` table.",
  "is_public": true
}
{
  "path": "enrich/duckdb_store.py",
  "module": "enrich.duckdb_store",
  "qualname": "_load_json_rows",
  "name": "_load_json_rows",
  "node_type": "FunctionDef",
  "lineno": 151,
  "col": 0,
  "end_lineno": 166,
  "end_col": 15,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "enrich/duckdb_store.py",
  "module": "enrich.duckdb_store",
  "qualname": "_coerce_value",
  "name": "_coerce_value",
  "node_type": "FunctionDef",
  "lineno": 169,
  "col": 0,
  "end_lineno": 175,
  "end_col": 16,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "enrich/duckdb_store.py",
  "module": "enrich.duckdb_store",
  "qualname": "_apply_pragmas",
  "name": "_apply_pragmas",
  "node_type": "FunctionDef",
  "lineno": 178,
  "col": 0,
  "end_lineno": 188,
  "end_col": 46,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "enrich/duckdb_store.py",
  "module": "enrich.duckdb_store",
  "qualname": "_ingest_via_native_json",
  "name": "_ingest_via_native_json",
  "node_type": "FunctionDef",
  "lineno": 191,
  "col": 0,
  "end_lineno": 216,
  "end_col": 54,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "enrich/duckdb_store.py",
  "module": "enrich.duckdb_store",
  "qualname": "_ingest_via_python",
  "name": "_ingest_via_python",
  "node_type": "FunctionDef",
  "lineno": 219,
  "col": 0,
  "end_lineno": 236,
  "end_col": 47,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "enrich/errors.py",
  "module": "enrich.errors",
  "qualname": "enrich.errors",
  "name": "enrich.errors",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Typed exceptions for enrichment pipeline stages.",
  "is_public": true
}
{
  "path": "enrich/errors.py",
  "module": "enrich.errors",
  "qualname": "StageError",
  "name": "StageError",
  "node_type": "ClassDef",
  "lineno": 23,
  "col": 0,
  "end_lineno": 61,
  "end_col": 21,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [
    "Exception"
  ],
  "docstring": "Base error describing a failed enrichment stage.",
  "is_public": true
}
{
  "path": "enrich/errors.py",
  "module": "enrich.errors",
  "qualname": "StageError.token",
  "name": "token",
  "node_type": "FunctionDef",
  "lineno": 32,
  "col": 4,
  "end_lineno": 45,
  "end_col": 62,
  "parent_qualname": "StageError",
  "decorators": [],
  "bases": [],
  "docstring": "Return a compact token suitable for embedding in module rows.\n\nReturns\n-------\nstr\n    Stage-prefixed string capturing the error reason.",
  "is_public": true
}
{
  "path": "enrich/errors.py",
  "module": "enrich.errors",
  "qualname": "StageError.log_extra",
  "name": "log_extra",
  "node_type": "FunctionDef",
  "lineno": 47,
  "col": 4,
  "end_lineno": 61,
  "end_col": 21,
  "parent_qualname": "StageError",
  "decorators": [],
  "bases": [],
  "docstring": "Return structured metadata for logging.\n\nReturns\n-------\ndict[str, Any]\n    Dictionary safe for structured logging calls.",
  "is_public": true
}
{
  "path": "enrich/errors.py",
  "module": "enrich.errors",
  "qualname": "DiscoveryError",
  "name": "DiscoveryError",
  "node_type": "ClassDef",
  "lineno": 64,
  "col": 0,
  "end_lineno": 75,
  "end_col": 87,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "StageError"
  ],
  "docstring": "Raised when repository discovery/globbing fails.",
  "is_public": true
}
{
  "path": "enrich/errors.py",
  "module": "enrich.errors",
  "qualname": "DiscoveryError.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 67,
  "col": 4,
  "end_lineno": 75,
  "end_col": 87,
  "parent_qualname": "DiscoveryError",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "enrich/errors.py",
  "module": "enrich.errors",
  "qualname": "IngestError",
  "name": "IngestError",
  "node_type": "ClassDef",
  "lineno": 78,
  "col": 0,
  "end_lineno": 89,
  "end_col": 85,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "StageError"
  ],
  "docstring": "Raised when ingestion of SCIP/FS artifacts fails.",
  "is_public": true
}
{
  "path": "enrich/errors.py",
  "module": "enrich.errors",
  "qualname": "IngestError.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 81,
  "col": 4,
  "end_lineno": 89,
  "end_col": 85,
  "parent_qualname": "IngestError",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "enrich/errors.py",
  "module": "enrich.errors",
  "qualname": "IndexingError",
  "name": "IndexingError",
  "node_type": "ClassDef",
  "lineno": 92,
  "col": 0,
  "end_lineno": 103,
  "end_col": 84,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "StageError"
  ],
  "docstring": "Raised when LibCST/Tree-sitter indexing fails for a module.",
  "is_public": true
}
{
  "path": "enrich/errors.py",
  "module": "enrich.errors",
  "qualname": "IndexingError.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 95,
  "col": 4,
  "end_lineno": 103,
  "end_col": 84,
  "parent_qualname": "IndexingError",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "enrich/errors.py",
  "module": "enrich.errors",
  "qualname": "TypeSignalError",
  "name": "TypeSignalError",
  "node_type": "ClassDef",
  "lineno": 106,
  "col": 0,
  "end_lineno": 117,
  "end_col": 91,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "StageError"
  ],
  "docstring": "Raised when collecting type checker summaries fails.",
  "is_public": true
}
{
  "path": "enrich/errors.py",
  "module": "enrich.errors",
  "qualname": "TypeSignalError.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 109,
  "col": 4,
  "end_lineno": 117,
  "end_col": 91,
  "parent_qualname": "TypeSignalError",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "enrich/errors.py",
  "module": "enrich.errors",
  "qualname": "TaggingError",
  "name": "TaggingError",
  "node_type": "ClassDef",
  "lineno": 120,
  "col": 0,
  "end_lineno": 131,
  "end_col": 86,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "StageError"
  ],
  "docstring": "Raised when tagging rules fail to evaluate.",
  "is_public": true
}
{
  "path": "enrich/errors.py",
  "module": "enrich.errors",
  "qualname": "TaggingError.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 123,
  "col": 4,
  "end_lineno": 131,
  "end_col": 86,
  "parent_qualname": "TaggingError",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "enrich/errors.py",
  "module": "enrich.errors",
  "qualname": "AnalyticsError",
  "name": "AnalyticsError",
  "node_type": "ClassDef",
  "lineno": 134,
  "col": 0,
  "end_lineno": 145,
  "end_col": 88,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "StageError"
  ],
  "docstring": "Raised when analytics or derived metrics fail to compute.",
  "is_public": true
}
{
  "path": "enrich/errors.py",
  "module": "enrich.errors",
  "qualname": "AnalyticsError.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 137,
  "col": 4,
  "end_lineno": 145,
  "end_col": 88,
  "parent_qualname": "AnalyticsError",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "enrich/errors.py",
  "module": "enrich.errors",
  "qualname": "OutputError",
  "name": "OutputError",
  "node_type": "ClassDef",
  "lineno": 148,
  "col": 0,
  "end_lineno": 159,
  "end_col": 84,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "StageError"
  ],
  "docstring": "Raised when serializing enrichment outputs fails.",
  "is_public": true
}
{
  "path": "enrich/errors.py",
  "module": "enrich.errors",
  "qualname": "OutputError.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 151,
  "col": 4,
  "end_lineno": 159,
  "end_col": 84,
  "parent_qualname": "OutputError",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "enrich/graph_builder.py",
  "module": "enrich.graph_builder",
  "qualname": "enrich.graph_builder",
  "name": "enrich.graph_builder",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Re-export graph builder utilities within the enrich package.",
  "is_public": true
}
{
  "path": "enrich/libcst_bridge.py",
  "module": "enrich.libcst_bridge",
  "qualname": "enrich.libcst_bridge",
  "name": "enrich.libcst_bridge",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "LibCST-powered index utilities (imports, defs, exports, docstrings).",
  "is_public": true
}
{
  "path": "enrich/libcst_bridge.py",
  "module": "enrich.libcst_bridge",
  "qualname": "NodeHandler",
  "name": "NodeHandler",
  "node_type": "ClassDef",
  "lineno": 25,
  "col": 0,
  "end_lineno": 30,
  "end_col": 11,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "Protocol"
  ],
  "docstring": "Callable signature for node-dispatch handlers.",
  "is_public": true
}
{
  "path": "enrich/libcst_bridge.py",
  "module": "enrich.libcst_bridge",
  "qualname": "NodeHandler.__call__",
  "name": "__call__",
  "node_type": "FunctionDef",
  "lineno": 28,
  "col": 4,
  "end_lineno": 30,
  "end_col": 11,
  "parent_qualname": "NodeHandler",
  "decorators": [],
  "bases": [],
  "docstring": "Process `node` with awareness of top-level status.",
  "is_public": false
}
{
  "path": "enrich/libcst_bridge.py",
  "module": "enrich.libcst_bridge",
  "qualname": "ImportEntry",
  "name": "ImportEntry",
  "node_type": "ClassDef",
  "lineno": 34,
  "col": 0,
  "end_lineno": 41,
  "end_col": 14,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Normalized metadata for a single import statement.",
  "is_public": true
}
{
  "path": "enrich/libcst_bridge.py",
  "module": "enrich.libcst_bridge",
  "qualname": "DefEntry",
  "name": "DefEntry",
  "node_type": "ClassDef",
  "lineno": 45,
  "col": 0,
  "end_lineno": 50,
  "end_col": 15,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Top-level function/class definition summary.",
  "is_public": true
}
{
  "path": "enrich/libcst_bridge.py",
  "module": "enrich.libcst_bridge",
  "qualname": "ModuleIndex",
  "name": "ModuleIndex",
  "node_type": "ClassDef",
  "lineno": 54,
  "col": 0,
  "end_lineno": 88,
  "end_col": 51,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Aggregate module metadata returned by :func:`index_module`.",
  "is_public": true
}
{
  "path": "enrich/libcst_bridge.py",
  "module": "enrich.libcst_bridge",
  "qualname": "_extract_module_docstring",
  "name": "_extract_module_docstring",
  "node_type": "FunctionDef",
  "lineno": 91,
  "col": 0,
  "end_lineno": 118,
  "end_col": 15,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return the module docstring if present.\n\nParameters\n----------\nnode : cst.Module\n    LibCST module node to extract docstring from.\n\nReturns\n-------\nstr | None\n    Module docstring text when available, or None if no docstring exists.",
  "is_public": false
}
{
  "path": "enrich/libcst_bridge.py",
  "module": "enrich.libcst_bridge",
  "qualname": "_literal_string_values",
  "name": "_literal_string_values",
  "node_type": "FunctionDef",
  "lineno": 121,
  "col": 0,
  "end_lineno": 145,
  "end_col": 35,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Yield literal string values from constant containers.\n\nParameters\n----------\nnode : cst.BaseExpression\n    LibCST expression node (list, tuple, set, or string literal) containing\n    literal string values to extract.\n\nYields\n------\nstr\n    Literal names included in ``__all__`` definitions.",
  "is_public": false
}
{
  "path": "enrich/libcst_bridge.py",
  "module": "enrich.libcst_bridge",
  "qualname": "_string_literal_value",
  "name": "_string_literal_value",
  "node_type": "FunctionDef",
  "lineno": 148,
  "col": 0,
  "end_lineno": 157,
  "end_col": 15,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "enrich/libcst_bridge.py",
  "module": "enrich.libcst_bridge",
  "qualname": "_extract_def_docstring",
  "name": "_extract_def_docstring",
  "node_type": "FunctionDef",
  "lineno": 160,
  "col": 0,
  "end_lineno": 174,
  "end_col": 15,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "enrich/libcst_bridge.py",
  "module": "enrich.libcst_bridge",
  "qualname": "_summarize_docstring",
  "name": "_summarize_docstring",
  "node_type": "FunctionDef",
  "lineno": 177,
  "col": 0,
  "end_lineno": 186,
  "end_col": 18,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "enrich/libcst_bridge.py",
  "module": "enrich.libcst_bridge",
  "qualname": "_analyze_docstring",
  "name": "_analyze_docstring",
  "node_type": "FunctionDef",
  "lineno": 189,
  "col": 0,
  "end_lineno": 212,
  "end_col": 63,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "enrich/libcst_bridge.py",
  "module": "enrich.libcst_bridge",
  "qualname": "_iter_params",
  "name": "_iter_params",
  "node_type": "FunctionDef",
  "lineno": 215,
  "col": 0,
  "end_lineno": 227,
  "end_col": 31,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "enrich/libcst_bridge.py",
  "module": "enrich.libcst_bridge",
  "qualname": "_exception_name",
  "name": "_exception_name",
  "node_type": "FunctionDef",
  "lineno": 230,
  "col": 0,
  "end_lineno": 257,
  "end_col": 15,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Extract exception name from LibCST expression node.\n\nParameters\n----------\nexpr : cst.BaseExpression | None\n    LibCST expression node representing an exception type, or None.\n\nReturns\n-------\nstr | None\n    Dot-separated exception name (e.g., \"ValueError\" or \"kgfoundry.errors.KgFoundryError\"),\n    or None if the expression cannot be resolved to a name.",
  "is_public": false
}
{
  "path": "enrich/libcst_bridge.py",
  "module": "enrich.libcst_bridge",
  "qualname": "_infer_side_effects",
  "name": "_infer_side_effects",
  "node_type": "FunctionDef",
  "lineno": 260,
  "col": 0,
  "end_lineno": 306,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "enrich/libcst_bridge.py",
  "module": "enrich.libcst_bridge",
  "qualname": "_infer_side_effects.has_any",
  "name": "has_any",
  "node_type": "FunctionDef",
  "lineno": 263,
  "col": 4,
  "end_lineno": 291,
  "end_col": 84,
  "parent_qualname": "_infer_side_effects",
  "decorators": [],
  "bases": [],
  "docstring": "Check if any imported module matches the given prefixes.\n\nThis helper function checks whether any module in the imports set starts\nwith any of the provided prefixes. Used to detect side-effect categories\n(filesystem, network, subprocess, database) based on imported module names.\n\nParameters\n----------\nprefixes : tuple[str, ...]\n    Tuple of module name prefixes to check against (e.g., (\"os\", \"pathlib\")\n    for filesystem operations). The function checks if any imported module\n    starts with any of these prefixes.\n\nReturns\n-------\nbool\n    True if any imported module name starts with any of the provided\n    prefixes, False otherwise. Returns False if imports is empty or no\n    matches are found.\n\nNotes\n-----\nThis is a nested helper function used within _infer_side_effects() to\ncategorize side effects. Time complexity: O(n * m) where n is the number\nof imports and m is the number of prefixes, but typically very fast due\nto short module names and small prefix sets.",
  "is_public": true
}
{
  "path": "enrich/libcst_bridge.py",
  "module": "enrich.libcst_bridge",
  "qualname": "_IndexVisitor",
  "name": "_IndexVisitor",
  "node_type": "ClassDef",
  "lineno": 309,
  "col": 0,
  "end_lineno": 981,
  "end_col": 19,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "cst.CSTVisitor"
  ],
  "docstring": "Collect module metadata via a single LibCST traversal.",
  "is_public": false
}
{
  "path": "enrich/libcst_bridge.py",
  "module": "enrich.libcst_bridge",
  "qualname": "_IndexVisitor.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 319,
  "col": 4,
  "end_lineno": 352,
  "end_col": 30,
  "parent_qualname": "_IndexVisitor",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "enrich/libcst_bridge.py",
  "module": "enrich.libcst_bridge",
  "qualname": "_IndexVisitor.on_visit",
  "name": "on_visit",
  "node_type": "FunctionDef",
  "lineno": 354,
  "col": 4,
  "end_lineno": 413,
  "end_col": 19,
  "parent_qualname": "_IndexVisitor",
  "decorators": [],
  "bases": [],
  "docstring": "Visit a LibCST node during AST traversal and collect metadata.\n\nThis method is called by LibCST for each node during AST traversal. It\nhandles various node types (Module, Import, ImportFrom, FunctionDef,\nClassDef, Assign, etc.) to extract imports, definitions, exports, docstrings,\ncomplexity metrics, and exception information. The method tracks nesting\ndepth for classes and functions and increments branch counts for control\nflow nodes.\n\nParameters\n----------\nnode : cst.CSTNode\n    LibCST node being visited during AST traversal. The method handles\n    multiple node types including statements, expressions, and definitions.\n\nReturns\n-------\nbool\n    Always returns True to continue traversal of child nodes. Returning\n    False would stop traversal, which is not desired for this visitor.\n\nNotes\n-----\nThis method implements the LibCST visitor pattern and is called\nautomatically during wrapper.visit(). It mutates the visitor's internal\nstate (imports, defs, exports, complexity, etc.) as it traverses the AST.\nTime complexity: O(1) per node visit, O(n) total for n nodes in the AST.\nThe method is not thread-safe and should be used with a single visitor\ninstance per AST traversal.",
  "is_public": true
}
{
  "path": "enrich/libcst_bridge.py",
  "module": "enrich.libcst_bridge",
  "qualname": "_IndexVisitor.on_leave",
  "name": "on_leave",
  "node_type": "FunctionDef",
  "lineno": 415,
  "col": 4,
  "end_lineno": 439,
  "end_col": 61,
  "parent_qualname": "_IndexVisitor",
  "decorators": [],
  "bases": [],
  "docstring": "Leave a LibCST node after visiting its children.\n\nThis method is called by LibCST after all children of a node have been\nvisited. It decrements nesting depth counters for FunctionDef and ClassDef\nnodes to maintain accurate depth tracking for top-level detection.\n\nParameters\n----------\noriginal_node : cst.CSTNode\n    LibCST node being left after traversal of its children. The method\n    checks for FunctionDef and ClassDef nodes to update nesting depth.\n\nNotes\n-----\nThis method implements the LibCST visitor pattern and is called\nautomatically during wrapper.visit() after children are processed. It\nmaintains nesting depth state for accurate top-level definition detection.\nTime complexity: O(1) per node leave. The method is not thread-safe and\nshould be used with a single visitor instance per AST traversal.",
  "is_public": true
}
{
  "path": "enrich/libcst_bridge.py",
  "module": "enrich.libcst_bridge",
  "qualname": "_IndexVisitor._is_module_scope",
  "name": "_is_module_scope",
  "node_type": "FunctionDef",
  "lineno": 441,
  "col": 4,
  "end_lineno": 446,
  "end_col": 71,
  "parent_qualname": "_IndexVisitor",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "enrich/libcst_bridge.py",
  "module": "enrich.libcst_bridge",
  "qualname": "_IndexVisitor._qualified_name",
  "name": "_qualified_name",
  "node_type": "FunctionDef",
  "lineno": 448,
  "col": 4,
  "end_lineno": 457,
  "end_col": 44,
  "parent_qualname": "_IndexVisitor",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "enrich/libcst_bridge.py",
  "module": "enrich.libcst_bridge",
  "qualname": "_IndexVisitor.finalize",
  "name": "finalize",
  "node_type": "FunctionDef",
  "lineno": 459,
  "col": 4,
  "end_lineno": 498,
  "end_col": 50,
  "parent_qualname": "_IndexVisitor",
  "decorators": [],
  "bases": [],
  "docstring": "Finalize visitor state after AST traversal completes.\n\nThis method computes final metrics and aggregates from the collected\nvisitor state. It calculates annotation ratios (params and returns),\nfinalizes complexity metrics (branches, cyclomatic complexity, LOC),\ninfers side effects from imported modules, and sorts exception names.\nShould be called after wrapper.visit() completes to ensure all metrics\nare properly computed.\n\nNotes\n-----\nThis method mutates the visitor's state to compute final metrics:\n- annotation_ratio: percentage of annotated parameters and return types\n- complexity: final branch count, cyclomatic complexity, and LOC\n- side_effects: inferred side effects from imports and code patterns\n- raises: sorted list of exception names found in raise statements\nTime complexity: O(n) where n is the number of imports for side effect\ninference, plus O(m log m) for sorting m exception names. The method\nshould be called exactly once after traversal completes.",
  "is_public": true
}
{
  "path": "enrich/libcst_bridge.py",
  "module": "enrich.libcst_bridge",
  "qualname": "_IndexVisitor._handle_import",
  "name": "_handle_import",
  "node_type": "FunctionDef",
  "lineno": 500,
  "col": 4,
  "end_lineno": 507,
  "end_col": 9,
  "parent_qualname": "_IndexVisitor",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "enrich/libcst_bridge.py",
  "module": "enrich.libcst_bridge",
  "qualname": "_IndexVisitor._handle_import_from",
  "name": "_handle_import_from",
  "node_type": "FunctionDef",
  "lineno": 509,
  "col": 4,
  "end_lineno": 531,
  "end_col": 9,
  "parent_qualname": "_IndexVisitor",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "enrich/libcst_bridge.py",
  "module": "enrich.libcst_bridge",
  "qualname": "_IndexVisitor._handle_function_def",
  "name": "_handle_function_def",
  "node_type": "FunctionDef",
  "lineno": 533,
  "col": 4,
  "end_lineno": 536,
  "end_col": 47,
  "parent_qualname": "_IndexVisitor",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "enrich/libcst_bridge.py",
  "module": "enrich.libcst_bridge",
  "qualname": "_IndexVisitor._record_function_doc",
  "name": "_record_function_doc",
  "node_type": "FunctionDef",
  "lineno": 538,
  "col": 4,
  "end_lineno": 587,
  "end_col": 9,
  "parent_qualname": "_IndexVisitor",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "enrich/libcst_bridge.py",
  "module": "enrich.libcst_bridge",
  "qualname": "_IndexVisitor._handle_class_def",
  "name": "_handle_class_def",
  "node_type": "FunctionDef",
  "lineno": 589,
  "col": 4,
  "end_lineno": 592,
  "end_col": 44,
  "parent_qualname": "_IndexVisitor",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "enrich/libcst_bridge.py",
  "module": "enrich.libcst_bridge",
  "qualname": "_IndexVisitor._record_class_doc",
  "name": "_record_class_doc",
  "node_type": "FunctionDef",
  "lineno": 594,
  "col": 4,
  "end_lineno": 617,
  "end_col": 9,
  "parent_qualname": "_IndexVisitor",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "enrich/libcst_bridge.py",
  "module": "enrich.libcst_bridge",
  "qualname": "_IndexVisitor._handle_assign",
  "name": "_handle_assign",
  "node_type": "FunctionDef",
  "lineno": 619,
  "col": 4,
  "end_lineno": 630,
  "end_col": 85,
  "parent_qualname": "_IndexVisitor",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "enrich/libcst_bridge.py",
  "module": "enrich.libcst_bridge",
  "qualname": "_IndexVisitor._handle_ann_assign",
  "name": "_handle_ann_assign",
  "node_type": "FunctionDef",
  "lineno": 632,
  "col": 4,
  "end_lineno": 639,
  "end_col": 81,
  "parent_qualname": "_IndexVisitor",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "enrich/libcst_bridge.py",
  "module": "enrich.libcst_bridge",
  "qualname": "_IndexVisitor._extend_exports_from_node",
  "name": "_extend_exports_from_node",
  "node_type": "FunctionDef",
  "lineno": 641,
  "col": 4,
  "end_lineno": 652,
  "end_col": 37,
  "parent_qualname": "_IndexVisitor",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "enrich/libcst_bridge.py",
  "module": "enrich.libcst_bridge",
  "qualname": "_IndexVisitor.handle_module_node",
  "name": "handle_module_node",
  "node_type": "FunctionDef",
  "lineno": 655,
  "col": 4,
  "end_lineno": 693,
  "end_col": 53,
  "parent_qualname": "_IndexVisitor",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": "Handle module node during AST traversal.\n\nThis static method processes the root module node during LibCST AST traversal.\nIt extracts the module-level docstring and computes a summary for documentation\nmetrics. The module docstring is stored in the visitor state and used for\ndocumentation health analysis.\n\nParameters\n----------\nvisitor : _IndexVisitor\n    The visitor instance collecting module definitions, imports, and exports.\n    The visitor's docstring and doc_summary attributes are updated with\n    module-level documentation information.\nnode : cst.CSTNode\n    The CST node being visited, cast to cst.Module. Contains the module's\n    body including the docstring as the first statement if present.\nis_top_level : bool\n    Flag indicating module level (always True for module nodes). Unused\n    but required by the visitor pattern interface.\n\nNotes\n-----\nThis method is part of the LibCST visitor pattern and is called automatically\nduring AST traversal. It extracts module docstrings and computes summaries\nfor documentation metrics. If no docstring is present, the method returns\nearly without updating visitor state. Thread-safe if the visitor instance\nis thread-safe.",
  "is_public": true
}
{
  "path": "enrich/libcst_bridge.py",
  "module": "enrich.libcst_bridge",
  "qualname": "_IndexVisitor.handle_import_node",
  "name": "handle_import_node",
  "node_type": "FunctionDef",
  "lineno": 696,
  "col": 4,
  "end_lineno": 728,
  "end_col": 56,
  "parent_qualname": "_IndexVisitor",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": "Handle import node during AST traversal.\n\nThis static method processes import statements (e.g., `import os`) during\nLibCST AST traversal. It delegates to the visitor's internal handler to\nextract imported module names and track them in the visitor's import list.\nAll imports are processed regardless of nesting level to build a complete\nimport graph.\n\nParameters\n----------\nvisitor : _IndexVisitor\n    The visitor instance collecting module definitions, imports, and exports.\n    The visitor's imports list is updated with imported module names.\nnode : cst.CSTNode\n    The CST node being visited, cast to cst.Import. Contains import aliases\n    specifying which modules are imported.\nis_top_level : bool\n    Flag indicating whether the import is at module level (True) or nested\n    inside a function/class (False). Unused but required by the visitor\n    pattern interface.\n\nNotes\n-----\nThis method is part of the LibCST visitor pattern and is called automatically\nduring AST traversal. It processes all import statements to build a complete\nimport graph for dependency analysis. Thread-safe if the visitor instance\nis thread-safe.",
  "is_public": true
}
{
  "path": "enrich/libcst_bridge.py",
  "module": "enrich.libcst_bridge",
  "qualname": "_IndexVisitor.handle_import_from_node",
  "name": "handle_import_from_node",
  "node_type": "FunctionDef",
  "lineno": 731,
  "col": 4,
  "end_lineno": 765,
  "end_col": 65,
  "parent_qualname": "_IndexVisitor",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": "Handle import-from node during AST traversal.\n\nThis static method processes import-from statements (e.g., `from os import path`)\nduring LibCST AST traversal. It delegates to the visitor's internal handler\nto extract imported module names, imported symbols, and import levels (for\nrelative imports). All imports are processed regardless of nesting level to\nbuild a complete import graph.\n\nParameters\n----------\nvisitor : _IndexVisitor\n    The visitor instance collecting module definitions, imports, and exports.\n    The visitor's imports list is updated with imported module names and\n    symbol information.\nnode : cst.CSTNode\n    The CST node being visited, cast to cst.ImportFrom. Contains the source\n    module name, import level (for relative imports), and imported symbol\n    aliases.\nis_top_level : bool\n    Flag indicating whether the import-from is at module level (True) or\n    nested inside a function/class (False). Unused but required by the\n    visitor pattern interface.\n\nNotes\n-----\nThis method is part of the LibCST visitor pattern and is called automatically\nduring AST traversal. It processes all import-from statements to build a\ncomplete import graph for dependency analysis, including relative imports.\nThread-safe if the visitor instance is thread-safe.",
  "is_public": true
}
{
  "path": "enrich/libcst_bridge.py",
  "module": "enrich.libcst_bridge",
  "qualname": "_IndexVisitor.handle_function_node",
  "name": "handle_function_node",
  "node_type": "FunctionDef",
  "lineno": 768,
  "col": 4,
  "end_lineno": 804,
  "end_col": 36,
  "parent_qualname": "_IndexVisitor",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": "Handle function definition node during AST traversal.\n\nThis static method processes function definitions during LibCST AST traversal.\nFor top-level functions, it delegates to the visitor's internal handler to\nextract function metadata (name, parameters, return type, docstring) and\ntrack them as module-level definitions. The function depth counter is\nincremented to track nesting level for all functions.\n\nParameters\n----------\nvisitor : _IndexVisitor\n    The visitor instance collecting module definitions, imports, and exports.\n    For top-level functions, the visitor's defs list and doc_items list are\n    updated with function metadata. The function depth counter is always\n    incremented to track nesting.\nnode : cst.CSTNode\n    The CST node being visited, cast to cst.FunctionDef. Contains function\n    name, parameters, return type annotation, decorators, and body.\nis_top_level : bool\n    Flag indicating whether the function is at module level (True) or nested\n    inside a class/function (False). Only top-level functions are tracked\n    as module-level definitions.\n\nNotes\n-----\nThis method is part of the LibCST visitor pattern and is called automatically\nduring AST traversal. It processes function definitions to extract metadata\nfor top-level functions while tracking nesting depth for all functions.\nThread-safe if the visitor instance is thread-safe.",
  "is_public": true
}
{
  "path": "enrich/libcst_bridge.py",
  "module": "enrich.libcst_bridge",
  "qualname": "_IndexVisitor.handle_class_node",
  "name": "handle_class_node",
  "node_type": "FunctionDef",
  "lineno": 807,
  "col": 4,
  "end_lineno": 841,
  "end_col": 33,
  "parent_qualname": "_IndexVisitor",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": "Handle class definition node during AST traversal.\n\nThis static method processes class definitions during LibCST AST traversal.\nFor top-level classes, it delegates to the visitor's internal handler to\nextract class metadata (name, base classes, docstring) and track them as\nmodule-level definitions. The class depth counter is incremented to track\nnesting level for all classes.\n\nParameters\n----------\nvisitor : _IndexVisitor\n    The visitor instance collecting module definitions, imports, and exports.\n    For top-level classes, the visitor's defs list and doc_items list are\n    updated with class metadata. The class depth counter is always incremented\n    to track nesting.\nnode : cst.CSTNode\n    The CST node being visited, cast to cst.ClassDef. Contains class name,\n    base classes, decorators, and body including methods and class variables.\nis_top_level : bool\n    Flag indicating whether the class is at module level (True) or nested\n    inside another class/function (False). Only top-level classes are tracked\n    as module-level definitions.\n\nNotes\n-----\nThis method is part of the LibCST visitor pattern and is called automatically\nduring AST traversal. It processes class definitions to extract metadata for\ntop-level classes while tracking nesting depth for all classes. Thread-safe\nif the visitor instance is thread-safe.",
  "is_public": true
}
{
  "path": "enrich/libcst_bridge.py",
  "module": "enrich.libcst_bridge",
  "qualname": "_IndexVisitor.handle_assign_node",
  "name": "handle_assign_node",
  "node_type": "FunctionDef",
  "lineno": 844,
  "col": 4,
  "end_lineno": 878,
  "end_col": 60,
  "parent_qualname": "_IndexVisitor",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": "Handle assignment node during AST traversal.\n\nThis static method processes assignment nodes (e.g., `x = value`) during\nLibCST AST traversal. It delegates to the visitor's internal handler\nonly for top-level assignments, which are tracked as module-level variable\ndefinitions. Nested assignments (inside functions/classes) are ignored\nto focus on module-level exports and definitions.\n\nParameters\n----------\nvisitor : _IndexVisitor\n    The visitor instance collecting module definitions, imports, and exports.\n    The visitor's state is updated with variable definitions found in\n    top-level assignments.\nnode : cst.CSTNode\n    The CST node being visited, cast to cst.Assign. Contains assignment\n    targets and values used to extract variable names and __all__ exports.\nis_top_level : bool\n    Flag indicating whether the assignment is at module level (True) or\n    nested inside a function/class (False). Only top-level assignments\n    are processed to track module-level variables.\n\nNotes\n-----\nThis method is part of the LibCST visitor pattern and is called automatically\nduring AST traversal. It filters assignments to only process top-level ones,\nensuring module-level variable definitions are tracked while ignoring\nlocal variables. The method handles __all__ assignments specially to extract\nexplicit export lists. Thread-safe if the visitor instance is thread-safe.",
  "is_public": true
}
{
  "path": "enrich/libcst_bridge.py",
  "module": "enrich.libcst_bridge",
  "qualname": "_IndexVisitor.handle_ann_assign_node",
  "name": "handle_ann_assign_node",
  "node_type": "FunctionDef",
  "lineno": 881,
  "col": 4,
  "end_lineno": 915,
  "end_col": 67,
  "parent_qualname": "_IndexVisitor",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": "Handle annotated assignment node during AST traversal.\n\nThis static method processes annotated assignment nodes (e.g., `x: int = value`)\nduring LibCST AST traversal. It delegates to the visitor's internal handler\nonly for top-level annotated assignments, which are tracked as module-level\ntyped variable definitions. Nested assignments (inside functions/classes) are\nignored to focus on module-level exports and definitions.\n\nParameters\n----------\nvisitor : _IndexVisitor\n    The visitor instance collecting module definitions, imports, and exports.\n    The visitor's state is updated with typed variable definitions found in\n    top-level annotated assignments.\nnode : cst.CSTNode\n    The CST node being visited, cast to cst.AnnAssign. Contains assignment\n    target, type annotation, and optional value used to extract variable names.\nis_top_level : bool\n    Flag indicating whether the annotated assignment is at module level (True)\n    or nested inside a function/class (False). Only top-level assignments are\n    processed to track module-level typed variables.\n\nNotes\n-----\nThis method is part of the LibCST visitor pattern and is called automatically\nduring AST traversal. It filters annotated assignments to only process top-level\nones, ensuring module-level typed variable definitions are tracked while ignoring\nlocal variables. The method handles __all__ assignments specially to extract\nexplicit export lists. Thread-safe if the visitor instance is thread-safe.",
  "is_public": true
}
{
  "path": "enrich/libcst_bridge.py",
  "module": "enrich.libcst_bridge",
  "qualname": "_IndexVisitor.handle_expr_node",
  "name": "handle_expr_node",
  "node_type": "FunctionDef",
  "lineno": 918,
  "col": 4,
  "end_lineno": 931,
  "end_col": 66,
  "parent_qualname": "_IndexVisitor",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": null,
  "is_public": true
}
{
  "path": "enrich/libcst_bridge.py",
  "module": "enrich.libcst_bridge",
  "qualname": "_IndexVisitor.handle_aug_assign_node",
  "name": "handle_aug_assign_node",
  "node_type": "FunctionDef",
  "lineno": 934,
  "col": 4,
  "end_lineno": 941,
  "end_col": 56,
  "parent_qualname": "_IndexVisitor",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": null,
  "is_public": true
}
{
  "path": "enrich/libcst_bridge.py",
  "module": "enrich.libcst_bridge",
  "qualname": "_IndexVisitor._resolve_import_aliases",
  "name": "_resolve_import_aliases",
  "node_type": "FunctionDef",
  "lineno": 943,
  "col": 4,
  "end_lineno": 954,
  "end_col": 29,
  "parent_qualname": "_IndexVisitor",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "enrich/libcst_bridge.py",
  "module": "enrich.libcst_bridge",
  "qualname": "_IndexVisitor._resolve_alias_name",
  "name": "_resolve_alias_name",
  "node_type": "FunctionDef",
  "lineno": 957,
  "col": 4,
  "end_lineno": 960,
  "end_col": 19,
  "parent_qualname": "_IndexVisitor",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "enrich/libcst_bridge.py",
  "module": "enrich.libcst_bridge",
  "qualname": "_IndexVisitor._resolve_alias_target",
  "name": "_resolve_alias_target",
  "node_type": "FunctionDef",
  "lineno": 963,
  "col": 4,
  "end_lineno": 973,
  "end_col": 17,
  "parent_qualname": "_IndexVisitor",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "enrich/libcst_bridge.py",
  "module": "enrich.libcst_bridge",
  "qualname": "_IndexVisitor._resolve_module_name",
  "name": "_resolve_module_name",
  "node_type": "FunctionDef",
  "lineno": 976,
  "col": 4,
  "end_lineno": 981,
  "end_col": 19,
  "parent_qualname": "_IndexVisitor",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "enrich/libcst_bridge.py",
  "module": "enrich.libcst_bridge",
  "qualname": "index_module",
  "name": "index_module",
  "node_type": "FunctionDef",
  "lineno": 998,
  "col": 0,
  "end_lineno": 1042,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return parsed module metadata, falling back to a stub on parse failure.\n\nParameters\n----------\npath : str\n    File path of the module being indexed (used for error reporting and\n    metadata). May be absolute or relative.\ncode : str\n    Source code content of the module to parse and index.\n\nReturns\n-------\nModuleIndex\n    Parsed module metadata containing imports, defs, exports, docstring,\n    and parse status. On parse failure, returns a stub with parse_ok=False\n    and error details.",
  "is_public": true
}
{
  "path": "enrich/libcst_bridge.py",
  "module": "enrich.libcst_bridge",
  "qualname": "_lineno",
  "name": "_lineno",
  "node_type": "FunctionDef",
  "lineno": 1045,
  "col": 0,
  "end_lineno": 1065,
  "end_col": 16,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return the starting line number for ``node`` when metadata is available.\n\nParameters\n----------\nvisitor : _IndexVisitor\n    LibCST visitor instance that provides metadata access via\n    ``get_metadata()``.\nnode : cst.CSTNode\n    LibCST node to extract line number from.\n\nReturns\n-------\nint\n    1-based line number or 0 when metadata is unavailable.",
  "is_public": false
}
{
  "path": "enrich/models.py",
  "module": "enrich.models",
  "qualname": "enrich.models",
  "name": "enrich.models",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Dataclasses and helpers shared across enrichment stages.",
  "is_public": true
}
{
  "path": "enrich/models.py",
  "module": "enrich.models",
  "qualname": "_clone_dict",
  "name": "_clone_dict",
  "node_type": "FunctionDef",
  "lineno": 15,
  "col": 0,
  "end_lineno": 29,
  "end_col": 23,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return a shallow dict copy safe for JSON serialization.\n\nParameters\n----------\nvalues : dict[str, Any]\n    Dictionary to clone. The returned copy is a shallow copy, meaning nested\n    dictionaries and lists are not recursively copied.\n\nReturns\n-------\ndict[str, Any]\n    Shallow copy of ``values`` preserving the original structure.",
  "is_public": false
}
{
  "path": "enrich/models.py",
  "module": "enrich.models",
  "qualname": "_dedupe_strings",
  "name": "_dedupe_strings",
  "node_type": "FunctionDef",
  "lineno": 32,
  "col": 0,
  "end_lineno": 52,
  "end_col": 15,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return a list of unique stringified values preserving order.\n\nParameters\n----------\nvalues : Iterable[object]\n    Iterable of values to deduplicate. Each value is converted to a string\n    using ``str()`` before comparison. The first occurrence of each unique\n    string is preserved.\n\nReturns\n-------\nlist[str]\n    Deduplicated sequence maintaining the first occurrence order.",
  "is_public": false
}
{
  "path": "enrich/models.py",
  "module": "enrich.models",
  "qualname": "ModuleRecord",
  "name": "ModuleRecord",
  "node_type": "ClassDef",
  "lineno": 56,
  "col": 0,
  "end_lineno": 249,
  "end_col": 25,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True)"
  ],
  "bases": [
    "MutableMapping[str, Any]"
  ],
  "docstring": "Canonical per-module row emitted to ``modules.jsonl``.",
  "is_public": true
}
{
  "path": "enrich/models.py",
  "module": "enrich.models",
  "qualname": "ModuleRecord.__getitem__",
  "name": "__getitem__",
  "node_type": "FunctionDef",
  "lineno": 126,
  "col": 4,
  "end_lineno": 143,
  "end_col": 31,
  "parent_qualname": "ModuleRecord",
  "decorators": [],
  "bases": [],
  "docstring": "Return the stored value for ``key``.\n\nParameters\n----------\nkey : str\n    Field name to retrieve. If the key is in the canonical field order,\n    returns the dataclass field value. Otherwise, returns the value from\n    the extra fields dictionary.\n\nReturns\n-------\nobject\n    Value associated with ``key``.",
  "is_public": false
}
{
  "path": "enrich/models.py",
  "module": "enrich.models",
  "qualname": "ModuleRecord.__setitem__",
  "name": "__setitem__",
  "node_type": "FunctionDef",
  "lineno": 145,
  "col": 4,
  "end_lineno": 150,
  "end_col": 32,
  "parent_qualname": "ModuleRecord",
  "decorators": [],
  "bases": [],
  "docstring": "Update ``key`` with ``value`` in either the dataclass field or extras.",
  "is_public": false
}
{
  "path": "enrich/models.py",
  "module": "enrich.models",
  "qualname": "ModuleRecord.__delitem__",
  "name": "__delitem__",
  "node_type": "FunctionDef",
  "lineno": 152,
  "col": 4,
  "end_lineno": 170,
  "end_col": 28,
  "parent_qualname": "ModuleRecord",
  "decorators": [],
  "bases": [],
  "docstring": "Remove an extra field entry.\n\nParameters\n----------\nkey : str\n    Field name to delete. If the key is in the canonical field order,\n    deletion is not allowed and a KeyError is raised. Otherwise, the\n    key is removed from the extra fields dictionary.\n\nRaises\n------\nKeyError\n    Raised when attempting to delete a required dataclass field.",
  "is_public": false
}
{
  "path": "enrich/models.py",
  "module": "enrich.models",
  "qualname": "ModuleRecord.__iter__",
  "name": "__iter__",
  "node_type": "FunctionDef",
  "lineno": 172,
  "col": 4,
  "end_lineno": 181,
  "end_col": 30,
  "parent_qualname": "ModuleRecord",
  "decorators": [],
  "bases": [],
  "docstring": "Iterate over base field names followed by dynamic extras.\n\nYields\n------\nstr\n    Field names exposed by the record.",
  "is_public": false
}
{
  "path": "enrich/models.py",
  "module": "enrich.models",
  "qualname": "ModuleRecord.__len__",
  "name": "__len__",
  "node_type": "FunctionDef",
  "lineno": 183,
  "col": 4,
  "end_lineno": 191,
  "end_col": 56,
  "parent_qualname": "ModuleRecord",
  "decorators": [],
  "bases": [],
  "docstring": "Return the number of exposed keys.\n\nReturns\n-------\nint\n    Count of base fields plus extra keys.",
  "is_public": false
}
{
  "path": "enrich/models.py",
  "module": "enrich.models",
  "qualname": "ModuleRecord.add_error",
  "name": "add_error",
  "node_type": "FunctionDef",
  "lineno": 193,
  "col": 4,
  "end_lineno": 198,
  "end_col": 29,
  "parent_qualname": "ModuleRecord",
  "decorators": [],
  "bases": [],
  "docstring": "Append a structured error token and flag ``parse_ok`` as False.",
  "is_public": true
}
{
  "path": "enrich/models.py",
  "module": "enrich.models",
  "qualname": "ModuleRecord.as_json_row",
  "name": "as_json_row",
  "node_type": "FunctionDef",
  "lineno": 200,
  "col": 4,
  "end_lineno": 210,
  "end_col": 18,
  "parent_qualname": "ModuleRecord",
  "decorators": [],
  "bases": [],
  "docstring": "Return a JSON-friendly dictionary for downstream writers.\n\nReturns\n-------\ndict[str, Any]\n    Serializable representation of the module record.",
  "is_public": true
}
{
  "path": "enrich/models.py",
  "module": "enrich.models",
  "qualname": "ModuleRecord._serialize_field",
  "name": "_serialize_field",
  "node_type": "FunctionDef",
  "lineno": 212,
  "col": 4,
  "end_lineno": 249,
  "end_col": 25,
  "parent_qualname": "ModuleRecord",
  "decorators": [],
  "bases": [],
  "docstring": "Serialize a single dataclass field into JSON-friendly primitives.\n\nParameters\n----------\nfield_name : str\n    Name of the dataclass field to serialize. Must be one of the fields\n    defined in the ModuleRecord dataclass.\n\nReturns\n-------\nobject\n    Serialized representation of ``field_name``. Complex types (lists,\n    dicts) are cloned to ensure JSON serializability. String sequences\n    are sorted and deduplicated.",
  "is_public": false
}
{
  "path": "enrich/output_writers.py",
  "module": "enrich.output_writers",
  "qualname": "enrich.output_writers",
  "name": "enrich.output_writers",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Serialization helpers for enrichment artifacts (JSON/JSONL/Markdown).",
  "is_public": true
}
{
  "path": "enrich/output_writers.py",
  "module": "enrich.output_writers",
  "qualname": "_dump_json",
  "name": "_dump_json",
  "node_type": "FunctionDef",
  "lineno": 43,
  "col": 0,
  "end_lineno": 63,
  "end_col": 56,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Serialize arbitrary objects to UTF-8 JSON with optional orjson accel.\n\nParameters\n----------\nobj : object\n    Python object to serialize to JSON. Must be JSON-serializable (dicts,\n    lists, strings, numbers, booleans, None). Complex objects are not\n    supported.\n\nReturns\n-------\nstr\n    Pretty-printed JSON string with UTF-8 encoding.",
  "is_public": false
}
{
  "path": "enrich/output_writers.py",
  "module": "enrich.output_writers",
  "qualname": "_dump_jsonl_bytes",
  "name": "_dump_jsonl_bytes",
  "node_type": "FunctionDef",
  "lineno": 66,
  "col": 0,
  "end_lineno": 84,
  "end_col": 87,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Serialize JSON rows for JSONL outputs with deterministic ordering.\n\nParameters\n----------\nobj : object\n    Python object to serialize to JSON. The object must be JSON-serializable.\n    If orjson is available, uses orjson for faster serialization. Otherwise,\n    falls back to standard library json.\n\nReturns\n-------\nbytes\n    UTF-8 encoded JSON bytes with a trailing newline. The output uses\n    deterministic key ordering (sorted keys) for consistent serialization.",
  "is_public": false
}
{
  "path": "enrich/output_writers.py",
  "module": "enrich.output_writers",
  "qualname": "_resolve_dictionary_fields",
  "name": "_resolve_dictionary_fields",
  "node_type": "FunctionDef",
  "lineno": 87,
  "col": 0,
  "end_lineno": 110,
  "end_col": 75,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return dictionary-encoded columns present in ``table``.\n\nParameters\n----------\ntable : pa.Table\n    PyArrow table to inspect for dictionary-encoded columns. The table's\n    schema is checked to identify columns that use dictionary encoding.\nhints : Sequence[str] | None, optional\n    Optional sequence of column names to check. If provided, only these\n    columns are checked. If None, uses default dictionary field names.\n    Defaults to None.\n\nReturns\n-------\nlist[str]\n    List of column names that are dictionary-encoded in the table. Returns\n    an empty list if PyArrow is not available or if none of the hinted\n    columns use dictionary encoding.",
  "is_public": false
}
{
  "path": "enrich/output_writers.py",
  "module": "enrich.output_writers",
  "qualname": "write_json",
  "name": "write_json",
  "node_type": "FunctionDef",
  "lineno": 113,
  "col": 0,
  "end_lineno": 117,
  "end_col": 56,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Write an object as pretty-printed JSON.",
  "is_public": true
}
{
  "path": "enrich/output_writers.py",
  "module": "enrich.output_writers",
  "qualname": "write_jsonl",
  "name": "write_jsonl",
  "node_type": "FunctionDef",
  "lineno": 120,
  "col": 0,
  "end_lineno": 136,
  "end_col": 30,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Write newline-delimited JSON records.",
  "is_public": true
}
{
  "path": "enrich/output_writers.py",
  "module": "enrich.output_writers",
  "qualname": "write_parquet",
  "name": "write_parquet",
  "node_type": "FunctionDef",
  "lineno": 139,
  "col": 0,
  "end_lineno": 149,
  "end_col": 39,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Persist ``rows`` to Parquet, falling back to JSONL when PyArrow is missing.",
  "is_public": true
}
{
  "path": "enrich/output_writers.py",
  "module": "enrich.output_writers",
  "qualname": "write_parquet_dataset",
  "name": "write_parquet_dataset",
  "node_type": "FunctionDef",
  "lineno": 152,
  "col": 0,
  "end_lineno": 200,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Write records to a partitioned Parquet dataset directory.\n\nParameters\n----------\npath : str | Path\n    Output directory path for the partitioned Parquet dataset. The directory\n    will be created if it doesn't exist. If PyArrow is unavailable, falls back\n    to writing a single JSONL file at this path.\nrows : Iterable[dict[str, object]]\n    Iterable of dictionary records to write. Each dictionary represents a row\n    in the dataset. Records are converted to a PyArrow table before writing.\npartitioning : Sequence[str]\n    List of column names to use for partitioning. Each unique combination of\n    values in these columns creates a separate Parquet file in a subdirectory.\n    Must not be empty.\ndictionary_fields : Sequence[str] | None, optional\n    Optional list of column names to use dictionary encoding for. Dictionary\n    encoding can improve compression and query performance for columns with\n    repeated values. If None, uses default dictionary fields. Defaults to None.\n\nRaises\n------\nValueError\n    Raised when partitioning is empty. Partitioning columns are required\n    for dataset writes to organize data into separate files.",
  "is_public": true
}
{
  "path": "enrich/output_writers.py",
  "module": "enrich.output_writers",
  "qualname": "_write_dataset_table",
  "name": "_write_dataset_table",
  "node_type": "FunctionDef",
  "lineno": 203,
  "col": 0,
  "end_lineno": 242,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Write ``table`` to Parquet using dataset writer settings.",
  "is_public": false
}
{
  "path": "enrich/output_writers.py",
  "module": "enrich.output_writers",
  "qualname": "_append_section",
  "name": "_append_section",
  "node_type": "FunctionDef",
  "lineno": 245,
  "col": 0,
  "end_lineno": 250,
  "end_col": 23,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "enrich/output_writers.py",
  "module": "enrich.output_writers",
  "qualname": "_format_imports",
  "name": "_format_imports",
  "node_type": "FunctionDef",
  "lineno": 253,
  "col": 0,
  "end_lineno": 269,
  "end_col": 20,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "enrich/output_writers.py",
  "module": "enrich.output_writers",
  "qualname": "_format_definitions",
  "name": "_format_definitions",
  "node_type": "FunctionDef",
  "lineno": 272,
  "col": 0,
  "end_lineno": 285,
  "end_col": 20,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "enrich/output_writers.py",
  "module": "enrich.output_writers",
  "qualname": "_format_graph_metrics",
  "name": "_format_graph_metrics",
  "node_type": "FunctionDef",
  "lineno": 288,
  "col": 0,
  "end_lineno": 294,
  "end_col": 16,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "enrich/output_writers.py",
  "module": "enrich.output_writers",
  "qualname": "_format_ownership",
  "name": "_format_ownership",
  "node_type": "FunctionDef",
  "lineno": 297,
  "col": 0,
  "end_lineno": 316,
  "end_col": 16,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "enrich/output_writers.py",
  "module": "enrich.output_writers",
  "qualname": "_format_usage",
  "name": "_format_usage",
  "node_type": "FunctionDef",
  "lineno": 319,
  "col": 0,
  "end_lineno": 327,
  "end_col": 16,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "enrich/output_writers.py",
  "module": "enrich.output_writers",
  "qualname": "_format_exports",
  "name": "_format_exports",
  "node_type": "FunctionDef",
  "lineno": 330,
  "col": 0,
  "end_lineno": 335,
  "end_col": 13,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "enrich/output_writers.py",
  "module": "enrich.output_writers",
  "qualname": "_format_exports_resolved",
  "name": "_format_exports_resolved",
  "node_type": "FunctionDef",
  "lineno": 338,
  "col": 0,
  "end_lineno": 345,
  "end_col": 16,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "enrich/output_writers.py",
  "module": "enrich.output_writers",
  "qualname": "_format_reexports",
  "name": "_format_reexports",
  "node_type": "FunctionDef",
  "lineno": 348,
  "col": 0,
  "end_lineno": 359,
  "end_col": 16,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "enrich/output_writers.py",
  "module": "enrich.output_writers",
  "qualname": "_format_doc_metrics",
  "name": "_format_doc_metrics",
  "node_type": "FunctionDef",
  "lineno": 362,
  "col": 0,
  "end_lineno": 374,
  "end_col": 16,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "enrich/output_writers.py",
  "module": "enrich.output_writers",
  "qualname": "_format_typedness",
  "name": "_format_typedness",
  "node_type": "FunctionDef",
  "lineno": 377,
  "col": 0,
  "end_lineno": 393,
  "end_col": 16,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "enrich/output_writers.py",
  "module": "enrich.output_writers",
  "qualname": "_format_side_effects",
  "name": "_format_side_effects",
  "node_type": "FunctionDef",
  "lineno": 396,
  "col": 0,
  "end_lineno": 403,
  "end_col": 69,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "enrich/output_writers.py",
  "module": "enrich.output_writers",
  "qualname": "_format_raises",
  "name": "_format_raises",
  "node_type": "FunctionDef",
  "lineno": 406,
  "col": 0,
  "end_lineno": 412,
  "end_col": 13,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "enrich/output_writers.py",
  "module": "enrich.output_writers",
  "qualname": "_format_complexity",
  "name": "_format_complexity",
  "node_type": "FunctionDef",
  "lineno": 415,
  "col": 0,
  "end_lineno": 424,
  "end_col": 16,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "enrich/output_writers.py",
  "module": "enrich.output_writers",
  "qualname": "_format_doc_items",
  "name": "_format_doc_items",
  "node_type": "FunctionDef",
  "lineno": 427,
  "col": 0,
  "end_lineno": 451,
  "end_col": 16,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "enrich/output_writers.py",
  "module": "enrich.output_writers",
  "qualname": "_format_coverage",
  "name": "_format_coverage",
  "node_type": "FunctionDef",
  "lineno": 454,
  "col": 0,
  "end_lineno": 462,
  "end_col": 16,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "enrich/output_writers.py",
  "module": "enrich.output_writers",
  "qualname": "_format_config_refs",
  "name": "_format_config_refs",
  "node_type": "FunctionDef",
  "lineno": 465,
  "col": 0,
  "end_lineno": 469,
  "end_col": 63,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "enrich/output_writers.py",
  "module": "enrich.output_writers",
  "qualname": "_format_hotspot",
  "name": "_format_hotspot",
  "node_type": "FunctionDef",
  "lineno": 472,
  "col": 0,
  "end_lineno": 476,
  "end_col": 36,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "enrich/output_writers.py",
  "module": "enrich.output_writers",
  "qualname": "write_markdown_module",
  "name": "write_markdown_module",
  "node_type": "FunctionDef",
  "lineno": 479,
  "col": 0,
  "end_lineno": 513,
  "end_col": 60,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Emit a human-friendly Markdown summary for a module record.",
  "is_public": true
}
{
  "path": "enrich/ownership.py",
  "module": "enrich.ownership",
  "qualname": "enrich.ownership",
  "name": "enrich.ownership",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Ownership, churn, and bus-factor analytics sourced from Git history.",
  "is_public": true
}
{
  "path": "enrich/ownership.py",
  "module": "enrich.ownership",
  "qualname": "GitRepo",
  "name": "GitRepo",
  "node_type": "ClassDef",
  "lineno": 27,
  "col": 4,
  "end_lineno": 28,
  "end_col": 68,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Runtime placeholder for optional GitPython dependency.",
  "is_public": true
}
{
  "path": "enrich/ownership.py",
  "module": "enrich.ownership",
  "qualname": "FileOwnership",
  "name": "FileOwnership",
  "node_type": "ClassDef",
  "lineno": 38,
  "col": 0,
  "end_lineno": 45,
  "end_col": 65,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Aggregated ownership metadata for a single file.",
  "is_public": true
}
{
  "path": "enrich/ownership.py",
  "module": "enrich.ownership",
  "qualname": "OwnershipIndex",
  "name": "OwnershipIndex",
  "node_type": "ClassDef",
  "lineno": 49,
  "col": 0,
  "end_lineno": 53,
  "end_col": 76,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Collection of :class:`FileOwnership` entries keyed by relative path.",
  "is_public": true
}
{
  "path": "enrich/ownership.py",
  "module": "enrich.ownership",
  "qualname": "compute_ownership",
  "name": "compute_ownership",
  "node_type": "FunctionDef",
  "lineno": 56,
  "col": 0,
  "end_lineno": 113,
  "end_col": 65,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return ownership metrics for ``rel_paths`` relative to ``repo_root``.\n\nThis function computes code ownership and churn metrics for a set of files\nby analyzing Git commit history. The function extracts commit statistics,\nauthor information, and churn metrics over specified time windows. Metrics\nare computed using GitPython when available, or returns an empty index if\nGit is unavailable.\n\nParameters\n----------\nrepo_root : Path\n    Root directory of the Git repository. Used to locate the .git directory\n    and initialize GitPython repository access. The path is resolved to an\n    absolute path before processing.\nrel_paths : Sequence[str]\n    Sequence of repository-relative file paths to compute ownership for.\n    Paths are normalized, deduplicated, and sorted before processing. Empty\n    sequences return an OwnershipIndex with empty by_file mapping.\ncommits_window : int, optional\n    Number of recent commits to analyze for ownership metrics (default: 50).\n    Used to limit Git history traversal for performance. Larger windows\n    provide more comprehensive ownership data but take longer to compute.\nchurn_windows : Sequence[int], optional\n    Time windows in days for churn metric computation (default: (30, 90)).\n    Each window specifies a period over which to compute churn statistics.\n    Windows are normalized and sorted before use.\n\nReturns\n-------\nOwnershipIndex\n    Aggregated ownership/churn signals keyed by repo-relative path. The index\n    contains ownership records for each file with commit counts, author\n    information, and churn metrics. Returns an empty index (with churn_windows\n    set) when Git is unavailable, paths are empty, or repository access fails.",
  "is_public": true
}
{
  "path": "enrich/ownership.py",
  "module": "enrich.ownership",
  "qualname": "_normalize_windows",
  "name": "_normalize_windows",
  "node_type": "FunctionDef",
  "lineno": 116,
  "col": 0,
  "end_lineno": 120,
  "end_col": 35,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "enrich/ownership.py",
  "module": "enrich.ownership",
  "qualname": "_try_open_repo",
  "name": "_try_open_repo",
  "node_type": "FunctionDef",
  "lineno": 123,
  "col": 0,
  "end_lineno": 129,
  "end_col": 19,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "enrich/ownership.py",
  "module": "enrich.ownership",
  "qualname": "_stats_via_gitpython",
  "name": "_stats_via_gitpython",
  "node_type": "FunctionDef",
  "lineno": 132,
  "col": 0,
  "end_lineno": 168,
  "end_col": 15,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "enrich/ownership.py",
  "module": "enrich.ownership",
  "qualname": "_author_name",
  "name": "_author_name",
  "node_type": "FunctionDef",
  "lineno": 171,
  "col": 0,
  "end_lineno": 176,
  "end_col": 15,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "enrich/ownership.py",
  "module": "enrich.ownership",
  "qualname": "_top_k",
  "name": "_top_k",
  "node_type": "FunctionDef",
  "lineno": 179,
  "col": 0,
  "end_lineno": 181,
  "end_col": 60,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "enrich/ownership.py",
  "module": "enrich.ownership",
  "qualname": "_bus_factor",
  "name": "_bus_factor",
  "node_type": "FunctionDef",
  "lineno": 184,
  "col": 0,
  "end_lineno": 188,
  "end_col": 74,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "enrich/ownership.py",
  "module": "enrich.ownership",
  "qualname": "_codeowners_lookup",
  "name": "_codeowners_lookup",
  "node_type": "FunctionDef",
  "lineno": 191,
  "col": 0,
  "end_lineno": 208,
  "end_col": 15,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "enrich/ownership.py",
  "module": "enrich.ownership",
  "qualname": "_glob_like_match",
  "name": "_glob_like_match",
  "node_type": "FunctionDef",
  "lineno": 211,
  "col": 0,
  "end_lineno": 217,
  "end_col": 88,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "enrich/pathnorm.py",
  "module": "enrich.pathnorm",
  "qualname": "enrich.pathnorm",
  "name": "enrich.pathnorm",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Helpers for repo-relative path normalization and stable identifiers.",
  "is_public": true
}
{
  "path": "enrich/pathnorm.py",
  "module": "enrich.pathnorm",
  "qualname": "detect_repo_root",
  "name": "detect_repo_root",
  "node_type": "FunctionDef",
  "lineno": 17,
  "col": 0,
  "end_lineno": 43,
  "end_col": 20,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return the closest ancestor containing a ``.git`` directory.\n\nThis function traverses up the directory tree from the starting path to find\nthe repository root (directory containing .git). The function resolves the\nstarting path to an absolute path and checks each parent directory until\na .git directory is found or the filesystem root is reached.\n\nParameters\n----------\nstart : Path\n    Starting directory path to begin the search. The path is resolved to\n    an absolute path, and the search proceeds upward through parent directories.\n    Can be any path within the repository (file or directory).\n\nReturns\n-------\nPath\n    Resolved repository root directory containing .git, or the resolved\n    starting path when no .git directory is found in any ancestor. The path\n    is always absolute and resolved.",
  "is_public": true
}
{
  "path": "enrich/pathnorm.py",
  "module": "enrich.pathnorm",
  "qualname": "to_repo_relative",
  "name": "to_repo_relative",
  "node_type": "FunctionDef",
  "lineno": 46,
  "col": 0,
  "end_lineno": 74,
  "end_col": 25,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return a POSIX path for ``path`` relative to ``repo_root``.\n\nThis function converts an absolute or relative file path into a normalized\nPOSIX-style path relative to the repository root. The function resolves both\npaths to absolute paths, computes the relative path, and normalizes it to\nuse forward slashes (POSIX style) regardless of the platform.\n\nParameters\n----------\npath : Path\n    File path to convert to repository-relative format. The path is resolved\n    to an absolute path before computing the relative path from repo_root.\nrepo_root : Path\n    Root directory of the repository used for path normalization. The path\n    is resolved to an absolute path before computing the relative path.\n\nReturns\n-------\nstr\n    Normalized POSIX path relative to the repository root, using forward\n    slashes as path separators. If path is not within repo_root, returns\n    the absolute path as a POSIX string (defensive fallback).",
  "is_public": true
}
{
  "path": "enrich/pathnorm.py",
  "module": "enrich.pathnorm",
  "qualname": "module_name_from_path",
  "name": "module_name_from_path",
  "node_type": "FunctionDef",
  "lineno": 77,
  "col": 0,
  "end_lineno": 124,
  "end_col": 69,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Derive a dotted module name for ``path`` relative to ``repo_root``.\n\nThis function converts a file path into a dotted module name by computing\nthe repository-relative path, removing .py extension, handling __init__.py\nfiles, and converting path separators to dots. The function optionally\nprepends a package prefix when provided.\n\nParameters\n----------\nrepo_root : Path\n    Root directory of the repository used for path normalization. The path\n    is resolved to an absolute path before computing the relative path.\npath : Path\n    File path to convert to a module name. The path is converted to\n    repository-relative format, .py extension is stripped, and __init__.py\n    is handled specially (removed from the path).\npackage_prefix : str | None, optional\n    Optional package prefix to prepend to the module name (default: None).\n    When provided, the prefix is prepended with a dot separator. Used to\n    handle packages that are not at the repository root.\n\nReturns\n-------\nstr\n    Dotted module name derived from the path (e.g., \"src.pkg.module\").\n    Empty string when path is outside repo_root and no package_prefix is\n    provided. Path separators are converted to dots, .py extension is\n    stripped, and __init__.py is removed from package paths.",
  "is_public": true
}
{
  "path": "enrich/pathnorm.py",
  "module": "enrich.pathnorm",
  "qualname": "stable_id_for_path",
  "name": "stable_id_for_path",
  "node_type": "FunctionDef",
  "lineno": 127,
  "col": 0,
  "end_lineno": 150,
  "end_col": 34,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return a truncated BLAKE2s digest for ``rel_posix``.\n\nThis function computes a stable, deterministic identifier for a POSIX path\nby hashing it with BLAKE2s and returning the first 12 hexadecimal characters.\nThe function provides a short, collision-resistant identifier suitable for\nuse in joins and lookups where full paths are too long.\n\nParameters\n----------\nrel_posix : str\n    POSIX-style relative path string to hash (e.g., \"src/pkg/module.py\").\n    The path is encoded as UTF-8 before hashing. Used to generate a stable\n    identifier that is consistent across runs.\n\nReturns\n-------\nstr\n    First 12 hexadecimal characters of the BLAKE2s hash digest. The identifier\n    is deterministic for the same input path and suitable for use in database\n    joins or lookups. Example: \"a1b2c3d4e5f6\" for a typical path.",
  "is_public": true
}
{
  "path": "enrich/scip_reader.py",
  "module": "enrich.scip_reader",
  "qualname": "enrich.scip_reader",
  "name": "enrich.scip_reader",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Lightweight helpers for loading and querying SCIP JSON indices.",
  "is_public": true
}
{
  "path": "enrich/scip_reader.py",
  "module": "enrich.scip_reader",
  "qualname": "Occurrence",
  "name": "Occurrence",
  "node_type": "ClassDef",
  "lineno": 12,
  "col": 0,
  "end_lineno": 17,
  "end_col": 58,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "msgspec.Struct"
  ],
  "docstring": "Symbol occurrence entry extracted from the SCIP schema.",
  "is_public": true
}
{
  "path": "enrich/scip_reader.py",
  "module": "enrich.scip_reader",
  "qualname": "SymbolInfo",
  "name": "SymbolInfo",
  "node_type": "ClassDef",
  "lineno": 20,
  "col": 0,
  "end_lineno": 26,
  "end_col": 77,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "msgspec.Struct"
  ],
  "docstring": "Symbol metadata bundled with a document.",
  "is_public": true
}
{
  "path": "enrich/scip_reader.py",
  "module": "enrich.scip_reader",
  "qualname": "Document",
  "name": "Document",
  "node_type": "ClassDef",
  "lineno": 29,
  "col": 0,
  "end_lineno": 34,
  "end_col": 67,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "msgspec.Struct"
  ],
  "docstring": "SCIP document entry (per source file).",
  "is_public": true
}
{
  "path": "enrich/scip_reader.py",
  "module": "enrich.scip_reader",
  "qualname": "_SCIPPayload",
  "name": "_SCIPPayload",
  "node_type": "ClassDef",
  "lineno": 37,
  "col": 0,
  "end_lineno": 41,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "msgspec.Struct"
  ],
  "docstring": null,
  "is_public": false
}
{
  "path": "enrich/scip_reader.py",
  "module": "enrich.scip_reader",
  "qualname": "SCIPIndex",
  "name": "SCIPIndex",
  "node_type": "ClassDef",
  "lineno": 44,
  "col": 0,
  "end_lineno": 135,
  "end_col": 21,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "In-memory representation of a SCIP dataset.",
  "is_public": true
}
{
  "path": "enrich/scip_reader.py",
  "module": "enrich.scip_reader",
  "qualname": "SCIPIndex.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 49,
  "col": 4,
  "end_lineno": 56,
  "end_col": 62,
  "parent_qualname": "SCIPIndex",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "enrich/scip_reader.py",
  "module": "enrich.scip_reader",
  "qualname": "SCIPIndex.documents",
  "name": "documents",
  "node_type": "FunctionDef",
  "lineno": 59,
  "col": 4,
  "end_lineno": 60,
  "end_col": 30,
  "parent_qualname": "SCIPIndex",
  "decorators": [
    "property"
  ],
  "bases": [],
  "docstring": null,
  "is_public": true
}
{
  "path": "enrich/scip_reader.py",
  "module": "enrich.scip_reader",
  "qualname": "SCIPIndex.external_symbols",
  "name": "external_symbols",
  "node_type": "FunctionDef",
  "lineno": 63,
  "col": 4,
  "end_lineno": 64,
  "end_col": 37,
  "parent_qualname": "SCIPIndex",
  "decorators": [
    "property"
  ],
  "bases": [],
  "docstring": null,
  "is_public": true
}
{
  "path": "enrich/scip_reader.py",
  "module": "enrich.scip_reader",
  "qualname": "SCIPIndex.load",
  "name": "load",
  "node_type": "FunctionDef",
  "lineno": 67,
  "col": 4,
  "end_lineno": 84,
  "end_col": 78,
  "parent_qualname": "SCIPIndex",
  "decorators": [
    "classmethod"
  ],
  "bases": [],
  "docstring": "Load the index from ``path`` (JSON file).\n\nParameters\n----------\npath : str | Path\n    File system path to the SCIP JSON index file. May be absolute\n    or relative to the current working directory.\n\nReturns\n-------\nSCIPIndex\n    Parsed index containing documents and external symbols.",
  "is_public": true
}
{
  "path": "enrich/scip_reader.py",
  "module": "enrich.scip_reader",
  "qualname": "SCIPIndex.by_file",
  "name": "by_file",
  "node_type": "FunctionDef",
  "lineno": 86,
  "col": 4,
  "end_lineno": 98,
  "end_col": 34,
  "parent_qualname": "SCIPIndex",
  "decorators": [],
  "bases": [],
  "docstring": "Return a mapping of relative path  SCIP document.\n\nReturns\n-------\ndict[str, Document]\n    Mapping of file paths to SCIP documents.",
  "is_public": true
}
{
  "path": "enrich/scip_reader.py",
  "module": "enrich.scip_reader",
  "qualname": "SCIPIndex.symbol_to_files",
  "name": "symbol_to_files",
  "node_type": "FunctionDef",
  "lineno": 100,
  "col": 4,
  "end_lineno": 115,
  "end_col": 22,
  "parent_qualname": "SCIPIndex",
  "decorators": [],
  "bases": [],
  "docstring": "Return occurrences grouped by symbol.\n\nReturns\n-------\ndict[str, list[str]]\n    Mapping of symbol identifiers to file paths.",
  "is_public": true
}
{
  "path": "enrich/scip_reader.py",
  "module": "enrich.scip_reader",
  "qualname": "SCIPIndex.file_symbol_kinds",
  "name": "file_symbol_kinds",
  "node_type": "FunctionDef",
  "lineno": 117,
  "col": 4,
  "end_lineno": 135,
  "end_col": 21,
  "parent_qualname": "SCIPIndex",
  "decorators": [],
  "bases": [],
  "docstring": "Return symbol-kind maps per file.\n\nReturns\n-------\ndict[str, dict[str, str]]\n    Mapping of file paths to symbol-kind dictionaries.",
  "is_public": true
}
{
  "path": "enrich/slices_builder.py",
  "module": "enrich.slices_builder",
  "qualname": "enrich.slices_builder",
  "name": "enrich.slices_builder",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Utilities for generating opt-in LLM slice packs.",
  "is_public": true
}
{
  "path": "enrich/slices_builder.py",
  "module": "enrich.slices_builder",
  "qualname": "SliceRecord",
  "name": "SliceRecord",
  "node_type": "ClassDef",
  "lineno": 19,
  "col": 0,
  "end_lineno": 36,
  "end_col": 71,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Serializable context packet describing a module and its surroundings.",
  "is_public": true
}
{
  "path": "enrich/slices_builder.py",
  "module": "enrich.slices_builder",
  "qualname": "_slice_id",
  "name": "_slice_id",
  "node_type": "FunctionDef",
  "lineno": 39,
  "col": 0,
  "end_lineno": 44,
  "end_col": 34,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "enrich/slices_builder.py",
  "module": "enrich.slices_builder",
  "qualname": "build_slice_record",
  "name": "build_slice_record",
  "node_type": "FunctionDef",
  "lineno": 47,
  "col": 0,
  "end_lineno": 114,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Build a :class:`SliceRecord` from a module row dictionary.\n\nThis function constructs a SliceRecord from a module row dictionary containing\npath, module name, coverage metrics, and ownership information. The function\nextracts and validates fields from the dictionary, computes a slice ID, and\nbuilds a structured record suitable for serialization.\n\nParameters\n----------\nmodule_row : Mapping[str, Any]\n    Dictionary containing module metadata with keys such as \"path\", \"module_name\",\n    \"covered_lines_ratio\", \"covered_defs_ratio\", \"owner\", \"primary_authors\", etc.\n    The dictionary is expected to contain module information from enrichment\n    artifacts or database queries.\n\nReturns\n-------\nSliceRecord\n    Structured slice description derived from module_row. The record includes\n    path, module name, slice ID, coverage metrics (lines and definitions ratios),\n    and ownership information (owner, primary authors). Missing or invalid\n    values are handled gracefully with defaults (empty strings, zero ratios,\n    empty lists).",
  "is_public": true
}
{
  "path": "enrich/slices_builder.py",
  "module": "enrich.slices_builder",
  "qualname": "write_slice",
  "name": "write_slice",
  "node_type": "FunctionDef",
  "lineno": 117,
  "col": 0,
  "end_lineno": 143,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Persist a slice pack (JSON + Markdown) under ``out_root/slices``.",
  "is_public": true
}
{
  "path": "enrich/stubs_overlay.py",
  "module": "enrich.stubs_overlay",
  "qualname": "enrich.stubs_overlay",
  "name": "enrich.stubs_overlay",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Targeted overlay generation with opt-in activation.",
  "is_public": true
}
{
  "path": "enrich/stubs_overlay.py",
  "module": "enrich.stubs_overlay",
  "qualname": "OverlayPolicy",
  "name": "OverlayPolicy",
  "node_type": "ClassDef",
  "lineno": 20,
  "col": 0,
  "end_lineno": 31,
  "end_col": 39,
  "parent_qualname": null,
  "decorators": [
    "dataclass(frozen=True, slots=True)"
  ],
  "bases": [],
  "docstring": "Controls when an overlay is generated and how it is written.",
  "is_public": true
}
{
  "path": "enrich/stubs_overlay.py",
  "module": "enrich.stubs_overlay",
  "qualname": "OverlayResult",
  "name": "OverlayResult",
  "node_type": "ClassDef",
  "lineno": 35,
  "col": 0,
  "end_lineno": 41,
  "end_col": 44,
  "parent_qualname": null,
  "decorators": [
    "dataclass(frozen=True, slots=True)"
  ],
  "bases": [],
  "docstring": "Summary of overlay creation for a single module.",
  "is_public": true
}
{
  "path": "enrich/stubs_overlay.py",
  "module": "enrich.stubs_overlay",
  "qualname": "OverlayInputs",
  "name": "OverlayInputs",
  "node_type": "ClassDef",
  "lineno": 45,
  "col": 0,
  "end_lineno": 51,
  "end_col": 54,
  "parent_qualname": null,
  "decorators": [
    "dataclass(frozen=True, slots=True)"
  ],
  "bases": [],
  "docstring": "Runtime inputs influencing overlay generation.",
  "is_public": true
}
{
  "path": "enrich/stubs_overlay.py",
  "module": "enrich.stubs_overlay",
  "qualname": "OverlayRenderContext",
  "name": "OverlayRenderContext",
  "node_type": "ClassDef",
  "lineno": 55,
  "col": 0,
  "end_lineno": 63,
  "end_col": 28,
  "parent_qualname": null,
  "decorators": [
    "dataclass(frozen=True, slots=True)"
  ],
  "bases": [],
  "docstring": "Bundle of values required to render overlay text.",
  "is_public": true
}
{
  "path": "enrich/stubs_overlay.py",
  "module": "enrich.stubs_overlay",
  "qualname": "generate_overlay_for_file",
  "name": "generate_overlay_for_file",
  "node_type": "FunctionDef",
  "lineno": 66,
  "col": 0,
  "end_lineno": 191,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Generate a .pyi overlay for ``py_file`` when it meets the policy gates.\n\nThis function generates a type stub overlay (.pyi file) for a Python source\nfile when it meets the configured policy requirements (e.g., star re-exports,\nlarge ``__all__`` hubs, explicit overlay-needed tags, or type error thresholds).\nThe function analyzes the source file, checks policy gates, and generates the\noverlay if conditions are met.\n\nParameters\n----------\npy_file : Path\n    Path to the Python source file for which to generate an overlay.\n    May be absolute or relative to package_root. The file must exist and\n    be readable for overlay generation.\npackage_root : Path\n    Root directory of the package containing py_file. Used to compute\n    relative module paths and determine overlay destination paths. The\n    overlay is written relative to this root.\npolicy : OverlayPolicy\n    Policy controlling when overlays are generated and how they are written.\n    Includes gates for star imports, export hubs, overlay-needed tags, and\n    optional type error thresholds. The policy determines whether an overlay\n    should be generated for the file.\ninputs : OverlayInputs | None, optional\n    Optional bundle containing SCIP index, cached type error counts, and\n    override flags (such as force). When omitted, defaults to OverlayInputs()\n    with empty SCIP index and zero error counts. Used to provide symbol\n    definitions and type error information for overlay generation.\n\nReturns\n-------\nOverlayResult\n    Metadata describing whether an overlay was created, including\n    the destination path, creation reason, and resolved exports.",
  "is_public": true
}
{
  "path": "enrich/stubs_overlay.py",
  "module": "enrich.stubs_overlay",
  "qualname": "activate_overlays",
  "name": "activate_overlays",
  "node_type": "FunctionDef",
  "lineno": 194,
  "col": 0,
  "end_lineno": 240,
  "end_col": 20,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Activate overlays by linking or copying into ``stubs_root``.\n\nParameters\n----------\nmodules : Sequence[str]\n    Sequence of module names (dotted paths) to activate. Each module\n    name is converted to a relative path under ``overlays_root``.\noverlays_root : Path\n    Root directory containing generated overlay files (.pyi).\nstubs_root : Path, optional\n    Destination directory for activated overlays. Overlays are linked\n    (or copied on Windows) into this directory. Defaults to Path(\"stubs\").\ncopy_on_windows : bool, optional\n    When True (default), copies overlay files on Windows instead of\n    creating symlinks. On Unix systems, symlinks are always used.\n\nReturns\n-------\nint\n    Number of overlays that were successfully activated.",
  "is_public": true
}
{
  "path": "enrich/stubs_overlay.py",
  "module": "enrich.stubs_overlay",
  "qualname": "deactivate_all",
  "name": "deactivate_all",
  "node_type": "FunctionDef",
  "lineno": 243,
  "col": 0,
  "end_lineno": 278,
  "end_col": 18,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Remove overlays under ``stubs_root`` that originated from ``overlays_root``.\n\nParameters\n----------\noverlays_root : Path\n    Root directory containing source overlay files. Only overlays that\n    match files in this directory are removed from ``stubs_root``.\nstubs_root : Path, optional\n    Directory containing activated overlays to remove. Defaults to\n    Path(\"stubs\").\n\nReturns\n-------\nint\n    Number of overlays removed from ``stubs_root``.",
  "is_public": true
}
{
  "path": "enrich/stubs_overlay.py",
  "module": "enrich.stubs_overlay",
  "qualname": "_overlay_path",
  "name": "_overlay_path",
  "node_type": "FunctionDef",
  "lineno": 281,
  "col": 0,
  "end_lineno": 302,
  "end_col": 41,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return the overlay destination path for ``py_file``.\n\nParameters\n----------\noverlays_root : Path\n    Root directory for overlay files.\npackage_root : Path\n    Root directory of the package containing ``py_file``.\npy_file : Path\n    Python source file path (may be absolute or relative to ``package_root``).\n\nReturns\n-------\nPath\n    Target .pyi path under ``overlays_root``, preserving the relative\n    structure from ``package_root``.",
  "is_public": false
}
{
  "path": "enrich/stubs_overlay.py",
  "module": "enrich.stubs_overlay",
  "qualname": "_normalized_module_key",
  "name": "_normalized_module_key",
  "node_type": "FunctionDef",
  "lineno": 305,
  "col": 0,
  "end_lineno": 322,
  "end_col": 64,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return a normalized module key used for lookups.\n\nParameters\n----------\npackage_root : Path\n    Root directory of the package.\npy_file : Path\n    Python source file path (may be absolute or relative to ``package_root``).\n\nReturns\n-------\nstr\n    Forward-slash separated path relative to ``package_root``, normalized\n    for use as a lookup key in type error mappings.",
  "is_public": false
}
{
  "path": "enrich/stubs_overlay.py",
  "module": "enrich.stubs_overlay",
  "qualname": "_module_name_from_path",
  "name": "_module_name_from_path",
  "node_type": "FunctionDef",
  "lineno": 325,
  "col": 0,
  "end_lineno": 346,
  "end_col": 51,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return the dotted module name for ``py_file``.\n\nParameters\n----------\npackage_root : Path\n    Root directory of the package.\npy_file : Path\n    Python source file path (may be absolute or relative to ``package_root``).\n\nReturns\n-------\nstr\n    Dotted module name (e.g., \"package.submodule\") derived from the\n    relative path from ``package_root`` to ``py_file``.",
  "is_public": false
}
{
  "path": "enrich/stubs_overlay.py",
  "module": "enrich.stubs_overlay",
  "qualname": "_collect_star_reexports",
  "name": "_collect_star_reexports",
  "node_type": "FunctionDef",
  "lineno": 349,
  "col": 0,
  "end_lineno": 377,
  "end_col": 16,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return candidate names that a star import might re-export.\n\nParameters\n----------\nscip : SCIPIndex\n    SCIP index containing symbol information for resolving re-exports.\nentry : ImportEntry\n    Import entry representing a star import (``from module import *``).\n    The ``module`` attribute must be set to the target module name.\n\nReturns\n-------\nset[str]\n    Names resolved from the SCIP index that may be re-exported by the\n    star import.",
  "is_public": false
}
{
  "path": "enrich/stubs_overlay.py",
  "module": "enrich.stubs_overlay",
  "qualname": "_extract_simple_name",
  "name": "_extract_simple_name",
  "node_type": "FunctionDef",
  "lineno": 380,
  "col": 0,
  "end_lineno": 404,
  "end_col": 15,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Extract a plausible leaf identifier from a SCIP symbol string.\n\nParameters\n----------\nsymbol : str\n    SCIP symbol string (e.g., \"package/module#Class.method()\") from\n    which to extract the leaf identifier.\n\nReturns\n-------\nstr | None\n    Leaf identifier (e.g., \"method\") if one can be inferred from\n    ``symbol``, or None if extraction fails.",
  "is_public": false
}
{
  "path": "enrich/stubs_overlay.py",
  "module": "enrich.stubs_overlay",
  "qualname": "_build_overlay_text",
  "name": "_build_overlay_text",
  "node_type": "FunctionDef",
  "lineno": 407,
  "col": 0,
  "end_lineno": 451,
  "end_col": 43,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Render overlay text from the collected module metadata.\n\nParameters\n----------\ncontext : OverlayRenderContext\n    Rendering context bundling module metadata, expansion targets, and\n    overlay feature flags.\n\nReturns\n-------\nstr\n    Completed overlay text content (Python stub file format) ready\n    to write to a .pyi file.",
  "is_public": false
}
{
  "path": "enrich/stubs_overlay.py",
  "module": "enrich.stubs_overlay",
  "qualname": "_render_star_exports",
  "name": "_render_star_exports",
  "node_type": "FunctionDef",
  "lineno": 454,
  "col": 0,
  "end_lineno": 476,
  "end_col": 16,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return overlay lines for expanded star imports.\n\nParameters\n----------\nstar_targets : Mapping[str, list[str]]\n    Mapping of imported module names to lists of resolved re-export names.\n    Used to generate ``from module import name as name`` lines in the overlay.\n\nReturns\n-------\nlist[str]\n    Lines to embed into the overlay (may be empty when nothing resolved).",
  "is_public": false
}
{
  "path": "enrich/stubs_overlay.py",
  "module": "enrich.stubs_overlay",
  "qualname": "_render_public_defs",
  "name": "_render_public_defs",
  "node_type": "FunctionDef",
  "lineno": 479,
  "col": 0,
  "end_lineno": 507,
  "end_col": 19,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return overlay lines for public defs when requested.\n\nParameters\n----------\ndefs : Sequence[DefEntry]\n    Sequence of definition entries (functions and classes) to render as\n    stub definitions in the overlay.\n\nReturns\n-------\nlist[str]\n    Minimal definitions representing the module's public API (function\n    and class stubs with ``Any`` types).",
  "is_public": false
}
{
  "path": "enrich/stubs_overlay.py",
  "module": "enrich.stubs_overlay",
  "qualname": "_collect_import_reexports",
  "name": "_collect_import_reexports",
  "node_type": "FunctionDef",
  "lineno": 510,
  "col": 0,
  "end_lineno": 538,
  "end_col": 16,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return re-export lines for explicit imports that are listed in ``__all__``.\n\nParameters\n----------\nmodule : ModuleIndex\n    Parsed module metadata containing imports and exports. The function\n    checks which imported names are listed in ``module.exports`` (``__all__``)\n    and generates re-export lines for them.\n\nReturns\n-------\nlist[str]\n    ``from module import name as alias`` lines to include in the overlay.\n    Returns an empty list if the module has no exports or no matching imports.",
  "is_public": false
}
{
  "path": "enrich/stubs_overlay.py",
  "module": "enrich.stubs_overlay",
  "qualname": "_is_windows",
  "name": "_is_windows",
  "node_type": "FunctionDef",
  "lineno": 541,
  "col": 0,
  "end_lineno": 549,
  "end_col": 54,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return True when running on Windows.\n\nReturns\n-------\nbool\n    True when the current platform is Windows.",
  "is_public": false
}
{
  "path": "enrich/tagging.py",
  "module": "enrich.tagging",
  "qualname": "enrich.tagging",
  "name": "enrich.tagging",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Rule-based tagging helpers for enrichment outputs.",
  "is_public": true
}
{
  "path": "enrich/tagging.py",
  "module": "enrich.tagging",
  "qualname": "TagResult",
  "name": "TagResult",
  "node_type": "ClassDef",
  "lineno": 16,
  "col": 0,
  "end_lineno": 21,
  "end_col": 57,
  "parent_qualname": null,
  "decorators": [
    "dataclass(frozen=True)"
  ],
  "bases": [],
  "docstring": "Result of running :func:`infer_tags`.",
  "is_public": true
}
{
  "path": "enrich/tagging.py",
  "module": "enrich.tagging",
  "qualname": "ModuleTraits",
  "name": "ModuleTraits",
  "node_type": "ClassDef",
  "lineno": 25,
  "col": 0,
  "end_lineno": 37,
  "end_col": 33,
  "parent_qualname": null,
  "decorators": [
    "dataclass(frozen=True)"
  ],
  "bases": [],
  "docstring": "Traits derived from a module used for tagging.",
  "is_public": true
}
{
  "path": "enrich/tagging.py",
  "module": "enrich.tagging",
  "qualname": "load_rules",
  "name": "load_rules",
  "node_type": "FunctionDef",
  "lineno": 55,
  "col": 0,
  "end_lineno": 82,
  "end_col": 25,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Load tagging rules from ``path`` or fall back to the defaults.\n\nParameters\n----------\npath : str | None\n    File system path to a YAML file containing tagging rules. When None\n    or when the file does not exist, returns the default rules dictionary.\n\nReturns\n-------\ndict[str, Any]\n    Rules dictionary for tag inference. Keys are tag names, values are\n    rule dictionaries containing matching criteria (imports, path regex,\n    traits, etc.).",
  "is_public": true
}
{
  "path": "enrich/tagging.py",
  "module": "enrich.tagging",
  "qualname": "infer_tags",
  "name": "infer_tags",
  "node_type": "FunctionDef",
  "lineno": 85,
  "col": 0,
  "end_lineno": 121,
  "end_col": 59,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Infer tags based on module metadata.\n\nParameters\n----------\npath : str\n    File system path of the module being tagged. Used for path-based\n    matching rules (e.g., test detection via regex).\ntraits : ModuleTraits\n    Module traits (imported modules, ``__all__`` presence, re-export\n    status, type error count) used for rule matching.\nrules : Mapping[str, Any] | None, optional\n    Tagging rules dictionary. When None, uses the default rules.\n    Each rule maps a tag name to matching criteria (imports, path regex,\n    trait checks, etc.). Defaults to None.\n\nReturns\n-------\nTagResult\n    Inferred tags and associated reasons. Contains the module path,\n    set of matched tags, and a dictionary mapping tags to their\n    matching reasons.",
  "is_public": true
}
{
  "path": "enrich/tagging.py",
  "module": "enrich.tagging",
  "qualname": "_rule_matches",
  "name": "_rule_matches",
  "node_type": "FunctionDef",
  "lineno": 124,
  "col": 0,
  "end_lineno": 165,
  "end_col": 26,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "enrich/tree_sitter_bridge.py",
  "module": "enrich.tree_sitter_bridge",
  "qualname": "enrich.tree_sitter_bridge",
  "name": "enrich.tree_sitter_bridge",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Tree-sitter outline helpers used for enrichment artifacts.",
  "is_public": true
}
{
  "path": "enrich/tree_sitter_bridge.py",
  "module": "enrich.tree_sitter_bridge",
  "qualname": "_lang_for_ext",
  "name": "_lang_for_ext",
  "node_type": "FunctionDef",
  "lineno": 40,
  "col": 0,
  "end_lineno": 74,
  "end_col": 15,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Resolve a Tree-sitter language for ``ext``.\n\nParameters\n----------\next : str\n    File extension (e.g., \".py\", \".json\") to resolve a language for.\n    The extension is normalized to lowercase before lookup.\n\nReturns\n-------\ntuple[str, Language] | None\n    Language name paired with the Tree-sitter language object when available, or None if no language\n    binding exists for the extension.",
  "is_public": false
}
{
  "path": "enrich/tree_sitter_bridge.py",
  "module": "enrich.tree_sitter_bridge",
  "qualname": "OutlineNode",
  "name": "OutlineNode",
  "node_type": "ClassDef",
  "lineno": 78,
  "col": 0,
  "end_lineno": 84,
  "end_col": 17,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Serializable view of a function/class definition.",
  "is_public": true
}
{
  "path": "enrich/tree_sitter_bridge.py",
  "module": "enrich.tree_sitter_bridge",
  "qualname": "TSOutline",
  "name": "TSOutline",
  "node_type": "ClassDef",
  "lineno": 88,
  "col": 0,
  "end_lineno": 92,
  "end_col": 58,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Bundle of outline nodes plus the originating Tree-sitter language.",
  "is_public": true
}
{
  "path": "enrich/tree_sitter_bridge.py",
  "module": "enrich.tree_sitter_bridge",
  "qualname": "build_outline",
  "name": "build_outline",
  "node_type": "FunctionDef",
  "lineno": 95,
  "col": 0,
  "end_lineno": 127,
  "end_col": 57,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Produce a best-effort outline for ``path``'s contents.\n\nParameters\n----------\npath : str | Path\n    File system path used to determine the language (via extension).\n    The path itself is not read; only the extension is used.\ncontent : bytes\n    Source code content to parse and extract outline from. Must be\n    valid UTF-8 encoded text.\n\nReturns\n-------\nTSOutline | None\n    Outline description when a language binding exists, containing\n    function and class definitions with byte offsets. Returns None\n    if no language binding is available for the file extension.",
  "is_public": true
}
{
  "path": "enrich/tree_sitter_bridge.py",
  "module": "enrich.tree_sitter_bridge",
  "qualname": "_extract_identifier",
  "name": "_extract_identifier",
  "node_type": "FunctionDef",
  "lineno": 130,
  "col": 0,
  "end_lineno": 153,
  "end_col": 13,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return the identifier name for ``node`` if available.\n\nParameters\n----------\ncontent : bytes\n    Source code bytes containing the identifier text.\nnode : Node | None\n    Tree-sitter node to extract identifier from. When None, returns\n    an empty string.\n\nReturns\n-------\nstr\n    Identifier name or an empty string when not found.",
  "is_public": false
}
{
  "path": "enrich/tree_sitter_bridge.py",
  "module": "enrich.tree_sitter_bridge",
  "qualname": "_outline_with_query",
  "name": "_outline_with_query",
  "node_type": "FunctionDef",
  "lineno": 156,
  "col": 0,
  "end_lineno": 186,
  "end_col": 24,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "enrich/tree_sitter_bridge.py",
  "module": "enrich.tree_sitter_bridge",
  "qualname": "_outline_with_dfs",
  "name": "_outline_with_dfs",
  "node_type": "FunctionDef",
  "lineno": 189,
  "col": 0,
  "end_lineno": 208,
  "end_col": 16,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "enrich/tree_sitter_bridge.py",
  "module": "enrich.tree_sitter_bridge",
  "qualname": "_get_outline_query",
  "name": "_get_outline_query",
  "node_type": "FunctionDef",
  "lineno": 211,
  "col": 0,
  "end_lineno": 225,
  "end_col": 16,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "enrich/tree_sitter_bridge.py",
  "module": "enrich.tree_sitter_bridge",
  "qualname": "_node_text",
  "name": "_node_text",
  "node_type": "FunctionDef",
  "lineno": 228,
  "col": 0,
  "end_lineno": 231,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "enrich/type_integration.py",
  "module": "enrich.type_integration",
  "qualname": "enrich.type_integration",
  "name": "enrich.type_integration",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Helpers for collecting Pyright/Pyrefly error summaries.",
  "is_public": true
}
{
  "path": "enrich/type_integration.py",
  "module": "enrich.type_integration",
  "qualname": "TypeFileSummary",
  "name": "TypeFileSummary",
  "node_type": "ClassDef",
  "lineno": 14,
  "col": 0,
  "end_lineno": 19,
  "end_col": 50,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Aggregated type-checker results for a single file.",
  "is_public": true
}
{
  "path": "enrich/type_integration.py",
  "module": "enrich.type_integration",
  "qualname": "TypeSummary",
  "name": "TypeSummary",
  "node_type": "ClassDef",
  "lineno": 23,
  "col": 0,
  "end_lineno": 26,
  "end_col": 69,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Mapping of file path  :class:`TypeFileSummary`.",
  "is_public": true
}
{
  "path": "enrich/type_integration.py",
  "module": "enrich.type_integration",
  "qualname": "_run_command_async",
  "name": "_run_command_async",
  "node_type": "AsyncFunctionDef",
  "lineno": 29,
  "col": 0,
  "end_lineno": 71,
  "end_col": 38,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Run a command asynchronously and capture stdout/stderr.\n\nParameters\n----------\ncmd : Sequence[str]\n    Command to execute as a sequence of strings (program name followed\n    by arguments). No shell expansion is performed.\ncwd : str | None\n    Working directory for the command execution. When None, uses the\n    current working directory.\ntime_limit : int\n    Maximum execution time in seconds. Commands exceeding this limit\n    are killed and return a timeout error.\n\nReturns\n-------\ntuple[int, str, str]\n    Return code, stdout, and stderr content. Return code is 1 on timeout\n    or when the process return code is None.",
  "is_public": false
}
{
  "path": "enrich/type_integration.py",
  "module": "enrich.type_integration",
  "qualname": "_try_run",
  "name": "_try_run",
  "node_type": "FunctionDef",
  "lineno": 74,
  "col": 0,
  "end_lineno": 101,
  "end_col": 32,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Run the asynchronous helper in a synchronous context.\n\nParameters\n----------\ncmd : Sequence[str]\n    Command to execute as a sequence of strings (program name followed\n    by arguments). No shell expansion is performed.\ncwd : str | None, optional\n    Working directory for the command execution. When None, uses the\n    current working directory. Defaults to None.\ntime_limit : int, optional\n    Maximum execution time in seconds. Defaults to 300 (5 minutes).\n\nReturns\n-------\ntuple[int, str, str]\n    Execution result triple (code, stdout, stderr). Return code is 127\n    on process launch failures (OSError, RuntimeError).",
  "is_public": false
}
{
  "path": "enrich/type_integration.py",
  "module": "enrich.type_integration",
  "qualname": "collect_pyright",
  "name": "collect_pyright",
  "node_type": "FunctionDef",
  "lineno": 104,
  "col": 0,
  "end_lineno": 140,
  "end_col": 15,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Run Pyright (or BasedPyright) and summarize diagnostics.\n\nParameters\n----------\npath : str | None, optional\n    Working directory for running Pyright. When None, uses the current\n    working directory. Defaults to None.\n\nReturns\n-------\nTypeSummary | None\n    Summary of diagnostics, if any were produced. Returns None if\n    Pyright/BasedPyright is not available, execution fails, or no\n    diagnostics are found.",
  "is_public": true
}
{
  "path": "enrich/type_integration.py",
  "module": "enrich.type_integration",
  "qualname": "collect_pyrefly",
  "name": "collect_pyrefly",
  "node_type": "FunctionDef",
  "lineno": 143,
  "col": 0,
  "end_lineno": 171,
  "end_col": 18,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Parse a Pyrefly JSON/JSONL report produced by CI.\n\nParameters\n----------\nreport_path : str | None\n    File system path to the Pyrefly report file (JSON or JSONL format).\n    When None or when the file does not exist, returns None.\n\nReturns\n-------\nTypeSummary | None\n    Parsed summary when the report exists and can be parsed. Returns None\n    if the path is None, the file does not exist, or parsing fails.",
  "is_public": true
}
{
  "path": "enrich/type_integration.py",
  "module": "enrich.type_integration",
  "qualname": "_parse_pyrefly_jsonl",
  "name": "_parse_pyrefly_jsonl",
  "node_type": "FunctionDef",
  "lineno": 174,
  "col": 0,
  "end_lineno": 180,
  "end_col": 46,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Apply Pyrefly records from a JSONL file to the summary.",
  "is_public": false
}
{
  "path": "enrich/type_integration.py",
  "module": "enrich.type_integration",
  "qualname": "_parse_pyrefly_json",
  "name": "_parse_pyrefly_json",
  "node_type": "FunctionDef",
  "lineno": 183,
  "col": 0,
  "end_lineno": 187,
  "end_col": 46,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Apply Pyrefly records from a JSON file to the summary.",
  "is_public": false
}
{
  "path": "enrich/type_integration.py",
  "module": "enrich.type_integration",
  "qualname": "_apply_pyrefly_record",
  "name": "_apply_pyrefly_record",
  "node_type": "FunctionDef",
  "lineno": 190,
  "col": 0,
  "end_lineno": 200,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Merge a single Pyrefly record into the summary.",
  "is_public": false
}
{
  "path": "enrich/validators.py",
  "module": "enrich.validators",
  "qualname": "enrich.validators",
  "name": "enrich.validators",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Schema validation helpers for enrichment rows.",
  "is_public": true
}
{
  "path": "enrich/validators.py",
  "module": "enrich.validators",
  "qualname": "ModuleRecordModel",
  "name": "ModuleRecordModel",
  "node_type": "ClassDef",
  "lineno": 13,
  "col": 0,
  "end_lineno": 48,
  "end_col": 32,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "BaseModel"
  ],
  "docstring": "Lightweight schema used to validate modules.jsonl rows.",
  "is_public": true
}
{
  "path": "errors.py",
  "module": "errors",
  "qualname": "errors",
  "name": "errors",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "CodeIntel-specific exception hierarchy with Problem Details support.\n\nThis module defines domain-specific exceptions for CodeIntel MCP server operations.\nAll exceptions inherit from ``KgFoundryError`` and include automatic RFC 9457\nProblem Details mapping with appropriate HTTP status codes and structured context.\n\nThe exception hierarchy is organized by operation category:\n\n- **File Operations**: ``FileOperationError``, ``FileReadError``, ``InvalidLineRangeError``\n- **Git Operations**: ``GitOperationError``\n- **Search Operations**: Use ``VectorSearchError``, ``EmbeddingError`` from kgfoundry_common\n\nExamples\n--------\nRaising file operation error:\n\n>>> raise FileReadError(\"Binary file or encoding error\", path=\"binary_file.png\")\n\nRaising invalid line range error with context:\n\n>>> raise InvalidLineRangeError(\n...     \"start_line must be positive\", path=\"src/main.py\", line_range=(0, 10)\n... )\n\nRaising Git operation error:\n\n>>> try:\n...     git_client.blame_range(path, start, end)\n... except git.exc.GitCommandError as exc:\n...     raise GitOperationError(\"Git blame failed\", path=path, git_command=\"blame\") from exc",
  "is_public": true
}
{
  "path": "errors.py",
  "module": "errors",
  "qualname": "FileOperationError",
  "name": "FileOperationError",
  "node_type": "ClassDef",
  "lineno": 42,
  "col": 0,
  "end_lineno": 94,
  "end_col": 9,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "KgFoundryError"
  ],
  "docstring": "Base exception for file operation errors.\n\nRaised when file operations fail (read, validation, path resolution, etc.).\nSubclass this for specific file operation error types.\n\nThis exception is appropriate for **user errors** (bad input, file not found,\ninvalid parameters) and maps to 400 Bad Request.\n\nParameters\n----------\nmessage : str\n    Human-readable error message explaining what went wrong.\npath : str\n    File path that caused the error. Included in context for debugging.\ncause : Exception | None, optional\n    Underlying exception that caused the file operation failure. Use\n    ``raise ... from cause`` to preserve exception chain. Defaults to None.\n\nExamples\n--------\n>>> raise FileOperationError(\"Invalid file path\", path=\"/etc/passwd\")\nTraceback (most recent call last):\n    ...\nFileOperationError[file-operation-error]: Invalid file path\n\nWith cause chain:\n\n>>> try:\n...     path.resolve(strict=True)\n... except FileNotFoundError as exc:\n...     raise FileOperationError(\"Path resolution failed\", path=str(path)) from exc\n\nNotes\n-----\nHTTP Status: 400 Bad Request (user error)\nError Code: \"file-operation-error\"\nContext: ``{\"path\": \"<file_path>\"}``",
  "is_public": true
}
{
  "path": "errors.py",
  "module": "errors",
  "qualname": "FileOperationError.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 82,
  "col": 4,
  "end_lineno": 94,
  "end_col": 9,
  "parent_qualname": "FileOperationError",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "errors.py",
  "module": "errors",
  "qualname": "FileReadError",
  "name": "FileReadError",
  "node_type": "ClassDef",
  "lineno": 97,
  "col": 0,
  "end_lineno": 141,
  "end_col": 7,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "FileOperationError"
  ],
  "docstring": "Raised when file cannot be read due to encoding or binary content.\n\nThis exception is raised when attempting to read a file that is binary\n(non-text) or has an unsupported encoding. It's appropriate for files that\nexist and are accessible, but cannot be decoded as UTF-8 text.\n\nCommon causes:\n\n- Binary files (images, executables, archives)\n- Files with non-UTF-8 encoding (e.g., Latin-1, UTF-16)\n- Corrupted text files with invalid byte sequences\n\nParameters\n----------\nmessage : str\n    Human-readable error message (e.g., \"Binary file or encoding error\").\npath : str\n    File path that couldn't be read.\ncause : Exception | None, optional\n    Underlying exception (typically ``UnicodeDecodeError``). Defaults to None.\n\nExamples\n--------\nWrap UnicodeDecodeError:\n\n>>> try:\n...     content = path.read_text(encoding=\"utf-8\")\n... except UnicodeDecodeError as exc:\n...     raise FileReadError(\"Binary file or encoding error\", path=str(path)) from exc\n\nDirect raise:\n\n>>> if path.suffix in {\".png\", \".jpg\", \".pdf\"}:\n...     raise FileReadError(\"Binary file type not supported\", path=str(path))\n\nNotes\n-----\nHTTP Status: 400 Bad Request (inherited from FileOperationError)\nError Code: \"file-operation-error\" (inherited)\nContext: ``{\"path\": \"<file_path>\"}``\n\nThe error handling decorator will map this to Problem Details with\nappropriate status and error code.",
  "is_public": true
}
{
  "path": "errors.py",
  "module": "errors",
  "qualname": "InvalidLineRangeError",
  "name": "InvalidLineRangeError",
  "node_type": "ClassDef",
  "lineno": 144,
  "col": 0,
  "end_lineno": 213,
  "end_col": 9,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "FileOperationError"
  ],
  "docstring": "Raised when line range parameters are invalid.\n\nThis exception is raised when line range validation fails (negative line\nnumbers, start > end, etc.). It provides structured context including the\ninvalid line range for debugging.\n\nParameters\n----------\nmessage : str\n    Human-readable error message explaining constraint violation.\n    Examples: \"start_line must be a positive integer\",\n    \"end_line must be a positive integer\",\n    \"start_line must be less than or equal to end_line\".\npath : str\n    File path being accessed.\nline_range : tuple[int | None, int | None] | None, optional\n    Requested line range (start_line, end_line) for error context. Either\n    or both values may be None if not provided. Defaults to None.\n\nExamples\n--------\nNegative start_line:\n\n>>> if start_line is not None and start_line <= 0:\n...     raise InvalidLineRangeError(\n...         \"start_line must be a positive integer\",\n...         path=\"src/main.py\",\n...         line_range=(start_line, end_line),\n...     )\n\nStart > end:\n\n>>> if start_line > end_line:\n...     raise InvalidLineRangeError(\n...         \"start_line must be less than or equal to end_line\",\n...         path=\"src/main.py\",\n...         line_range=(start_line, end_line),\n...     )\n\nNotes\n-----\nHTTP Status: 400 Bad Request (user error)\nError Code: \"invalid-parameter\"\nContext: ``{\"path\": \"<file_path>\", \"start_line\": 0, \"end_line\": 10}``\n\nThe line_range context is included in Problem Details extensions for\ndebugging and client error messages.",
  "is_public": true
}
{
  "path": "errors.py",
  "module": "errors",
  "qualname": "InvalidLineRangeError.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 194,
  "col": 4,
  "end_lineno": 213,
  "end_col": 9,
  "parent_qualname": "InvalidLineRangeError",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "errors.py",
  "module": "errors",
  "qualname": "CatalogConsistencyError",
  "name": "CatalogConsistencyError",
  "node_type": "ClassDef",
  "lineno": 216,
  "col": 0,
  "end_lineno": 230,
  "end_col": 9,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "KgFoundryError"
  ],
  "docstring": "Raised when catalog state does not match expected invariants.",
  "is_public": true
}
{
  "path": "errors.py",
  "module": "errors",
  "qualname": "CatalogConsistencyError.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 219,
  "col": 4,
  "end_lineno": 230,
  "end_col": 9,
  "parent_qualname": "CatalogConsistencyError",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "errors.py",
  "module": "errors",
  "qualname": "PathNotFoundError",
  "name": "PathNotFoundError",
  "node_type": "ClassDef",
  "lineno": 233,
  "col": 0,
  "end_lineno": 249,
  "end_col": 9,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "KgFoundryError"
  ],
  "docstring": "Raised when a requested repository path does not exist.",
  "is_public": true
}
{
  "path": "errors.py",
  "module": "errors",
  "qualname": "PathNotFoundError.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 236,
  "col": 4,
  "end_lineno": 249,
  "end_col": 9,
  "parent_qualname": "PathNotFoundError",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "errors.py",
  "module": "errors",
  "qualname": "PathNotDirectoryError",
  "name": "PathNotDirectoryError",
  "node_type": "ClassDef",
  "lineno": 252,
  "col": 0,
  "end_lineno": 268,
  "end_col": 9,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "KgFoundryError"
  ],
  "docstring": "Raised when a repository path is expected to be a directory but is not.",
  "is_public": true
}
{
  "path": "errors.py",
  "module": "errors",
  "qualname": "PathNotDirectoryError.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 255,
  "col": 4,
  "end_lineno": 268,
  "end_col": 9,
  "parent_qualname": "PathNotDirectoryError",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "errors.py",
  "module": "errors",
  "qualname": "GitOperationError",
  "name": "GitOperationError",
  "node_type": "ClassDef",
  "lineno": 274,
  "col": 0,
  "end_lineno": 350,
  "end_col": 9,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "KgFoundryError"
  ],
  "docstring": "Base exception for Git operation errors.\n\nRaised when Git operations fail (blame, history, log, etc.). This is\nappropriate for **system errors** (Git command failed, repository corrupted,\nGit binary not found) and maps to 500 Internal Server Error.\n\nThe exception includes optional path and Git command context for debugging.\n\nParameters\n----------\nmessage : str\n    Human-readable error message explaining what went wrong.\npath : str | None, optional\n    File path that was being operated on. Include this when the error is\n    related to a specific file. Defaults to None.\ngit_command : str | None, optional\n    Git command that failed (e.g., \"blame\", \"log\", \"show\"). Helps identify\n    which Git operation failed. Defaults to None.\ncause : Exception | None, optional\n    Underlying exception (typically ``git.exc.GitCommandError``). Use\n    ``raise ... from cause`` to preserve exception chain. Defaults to None.\n\nExamples\n--------\nWrap GitCommandError from blame:\n\n>>> try:\n...     git_client.blame_range(path, 1, 10)\n... except git.exc.GitCommandError as exc:\n...     raise GitOperationError(\n...         \"Git blame failed\", path=\"src/main.py\", git_command=\"blame\"\n...     ) from exc\n\nWrap GitCommandError from log:\n\n>>> try:\n...     git_client.file_history(path, limit=50)\n... except git.exc.GitCommandError as exc:\n...     raise GitOperationError(\n...         \"Git log failed\", path=\"src/main.py\", git_command=\"log\"\n...     ) from exc\n\nRepository-level error (no specific file):\n\n>>> if not repo_path.exists():\n...     raise GitOperationError(\"Repository not found\", path=None, git_command=None)\n\nNotes\n-----\nHTTP Status: 500 Internal Server Error (system error)\nError Code: \"git-operation-error\"\nContext: ``{\"path\": \"<file_path>\", \"git_command\": \"blame\"}``\n\nBoth path and git_command are optional in context (only included if provided).",
  "is_public": true
}
{
  "path": "errors.py",
  "module": "errors",
  "qualname": "GitOperationError.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 331,
  "col": 4,
  "end_lineno": 350,
  "end_col": 9,
  "parent_qualname": "GitOperationError",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "errors.py",
  "module": "errors",
  "qualname": "RuntimeLifecycleError",
  "name": "RuntimeLifecycleError",
  "node_type": "ClassDef",
  "lineno": 353,
  "col": 0,
  "end_lineno": 369,
  "end_col": 9,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "KgFoundryError"
  ],
  "docstring": "Raised when a runtime fails to initialize or shut down.",
  "is_public": true
}
{
  "path": "errors.py",
  "module": "errors",
  "qualname": "RuntimeLifecycleError.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 356,
  "col": 4,
  "end_lineno": 369,
  "end_col": 9,
  "parent_qualname": "RuntimeLifecycleError",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "errors.py",
  "module": "errors",
  "qualname": "RuntimeUnavailableError",
  "name": "RuntimeUnavailableError",
  "node_type": "ClassDef",
  "lineno": 372,
  "col": 0,
  "end_lineno": 392,
  "end_col": 9,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "KgFoundryError"
  ],
  "docstring": "Raised when a runtime dependency is missing or disabled.",
  "is_public": true
}
{
  "path": "errors.py",
  "module": "errors",
  "qualname": "RuntimeUnavailableError.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 375,
  "col": 4,
  "end_lineno": 392,
  "end_col": 9,
  "parent_qualname": "RuntimeUnavailableError",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "errors.py",
  "module": "errors",
  "qualname": "VectorIndexStateError",
  "name": "VectorIndexStateError",
  "node_type": "ClassDef",
  "lineno": 395,
  "col": 0,
  "end_lineno": 414,
  "end_col": 9,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "KgFoundryError"
  ],
  "docstring": "Raised when a FAISS index is missing or not ready.",
  "is_public": true
}
{
  "path": "errors.py",
  "module": "errors",
  "qualname": "VectorIndexStateError.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 398,
  "col": 4,
  "end_lineno": 414,
  "end_col": 9,
  "parent_qualname": "VectorIndexStateError",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "errors.py",
  "module": "errors",
  "qualname": "VectorIndexIncompatibleError",
  "name": "VectorIndexIncompatibleError",
  "node_type": "ClassDef",
  "lineno": 417,
  "col": 0,
  "end_lineno": 436,
  "end_col": 9,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "KgFoundryError"
  ],
  "docstring": "Raised when FAISS assets (dimension, factory) are incompatible.",
  "is_public": true
}
{
  "path": "errors.py",
  "module": "errors",
  "qualname": "VectorIndexIncompatibleError.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 420,
  "col": 4,
  "end_lineno": 436,
  "end_col": 9,
  "parent_qualname": "VectorIndexIncompatibleError",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "errors.py",
  "module": "errors",
  "qualname": "CatalogJoinError",
  "name": "CatalogJoinError",
  "node_type": "ClassDef",
  "lineno": 439,
  "col": 0,
  "end_lineno": 458,
  "end_col": 9,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "KgFoundryError"
  ],
  "docstring": "Raised when DuckDB catalog joins or idmap materialization fails.",
  "is_public": true
}
{
  "path": "errors.py",
  "module": "errors",
  "qualname": "CatalogJoinError.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 442,
  "col": 4,
  "end_lineno": 458,
  "end_col": 9,
  "parent_qualname": "CatalogJoinError",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "eval/__init__.py",
  "module": "eval",
  "qualname": "eval",
  "name": "eval",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Evaluation utilities for offline recall diagnostics.",
  "is_public": true
}
{
  "path": "eval/hybrid_evaluator.py",
  "module": "eval.hybrid_evaluator",
  "qualname": "eval.hybrid_evaluator",
  "name": "eval.hybrid_evaluator",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Offline hybrid evaluator with oracle reranking and pool exports.",
  "is_public": true
}
{
  "path": "eval/hybrid_evaluator.py",
  "module": "eval.hybrid_evaluator",
  "qualname": "XTRIndex",
  "name": "XTRIndex",
  "node_type": "ClassDef",
  "lineno": 23,
  "col": 4,
  "end_lineno": 24,
  "end_col": 62,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Runtime placeholder for optional XTR dependency.",
  "is_public": true
}
{
  "path": "eval/hybrid_evaluator.py",
  "module": "eval.hybrid_evaluator",
  "qualname": "EvalConfig",
  "name": "EvalConfig",
  "node_type": "ClassDef",
  "lineno": 31,
  "col": 0,
  "end_lineno": 40,
  "end_col": 32,
  "parent_qualname": null,
  "decorators": [
    "dataclass(frozen=True)"
  ],
  "bases": [],
  "docstring": "Evaluator configuration.",
  "is_public": true
}
{
  "path": "eval/hybrid_evaluator.py",
  "module": "eval.hybrid_evaluator",
  "qualname": "EvalReport",
  "name": "EvalReport",
  "node_type": "ClassDef",
  "lineno": 44,
  "col": 0,
  "end_lineno": 54,
  "end_col": 20,
  "parent_qualname": null,
  "decorators": [
    "dataclass(frozen=True)"
  ],
  "bases": [],
  "docstring": "Summary for an offline ANN vs oracle comparison.",
  "is_public": true
}
{
  "path": "eval/hybrid_evaluator.py",
  "module": "eval.hybrid_evaluator",
  "qualname": "_EvalState",
  "name": "_EvalState",
  "node_type": "ClassDef",
  "lineno": 58,
  "col": 0,
  "end_lineno": 65,
  "end_col": 21,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=False)"
  ],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "eval/hybrid_evaluator.py",
  "module": "eval.hybrid_evaluator",
  "qualname": "HybridPoolEvaluator",
  "name": "HybridPoolEvaluator",
  "node_type": "ClassDef",
  "lineno": 68,
  "col": 0,
  "end_lineno": 333,
  "end_col": 79,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Compare ANN retrieval against Flat and optional XTR oracles, persisting pools.",
  "is_public": true
}
{
  "path": "eval/hybrid_evaluator.py",
  "module": "eval.hybrid_evaluator",
  "qualname": "HybridPoolEvaluator.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 71,
  "col": 4,
  "end_lineno": 82,
  "end_col": 67,
  "parent_qualname": "HybridPoolEvaluator",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "eval/hybrid_evaluator.py",
  "module": "eval.hybrid_evaluator",
  "qualname": "HybridPoolEvaluator.run",
  "name": "run",
  "node_type": "FunctionDef",
  "lineno": 84,
  "col": 4,
  "end_lineno": 158,
  "end_col": 21,
  "parent_qualname": "HybridPoolEvaluator",
  "decorators": [],
  "bases": [],
  "docstring": "Execute the evaluation and persist per-query pools + metrics.\n\nThis method runs hybrid evaluation by sampling query vectors from the catalog,\nperforming FAISS searches with the configured parameters, comparing results\nagainst brute-force and optional XTR oracles, and persisting evaluation\nartifacts (pool rows, metrics) to disk. The method computes recall metrics\nand generates an evaluation report.\n\nParameters\n----------\nconfig : EvalConfig\n    Evaluation configuration containing search parameters (k, k_factor, nprobe),\n    query limits (max_queries), and output paths (pool_path, metrics_path).\n    The configuration determines how many queries to evaluate and where to\n    persist results.\n\nReturns\n-------\nEvalReport\n    Structured summary containing query counts, recall metrics, and oracle\n    statistics. The report includes queries evaluated, recall_at_k, oracle_matches,\n    ann_hits, and xtr_records. Returns an empty report if no query vectors\n    are available.",
  "is_public": true
}
{
  "path": "eval/hybrid_evaluator.py",
  "module": "eval.hybrid_evaluator",
  "qualname": "HybridPoolEvaluator._evaluate_queries",
  "name": "_evaluate_queries",
  "node_type": "FunctionDef",
  "lineno": 160,
  "col": 4,
  "end_lineno": 216,
  "end_col": 84,
  "parent_qualname": "HybridPoolEvaluator",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "eval/hybrid_evaluator.py",
  "module": "eval.hybrid_evaluator",
  "qualname": "HybridPoolEvaluator._build_eval_state",
  "name": "_build_eval_state",
  "node_type": "FunctionDef",
  "lineno": 218,
  "col": 4,
  "end_lineno": 235,
  "end_col": 9,
  "parent_qualname": "HybridPoolEvaluator",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "eval/hybrid_evaluator.py",
  "module": "eval.hybrid_evaluator",
  "qualname": "HybridPoolEvaluator._ensure_structure_cache",
  "name": "_ensure_structure_cache",
  "node_type": "FunctionDef",
  "lineno": 237,
  "col": 4,
  "end_lineno": 243,
  "end_col": 49,
  "parent_qualname": "HybridPoolEvaluator",
  "decorators": [],
  "bases": [],
  "docstring": "Populate structure annotations for ``chunk_ids``.",
  "is_public": false
}
{
  "path": "eval/hybrid_evaluator.py",
  "module": "eval.hybrid_evaluator",
  "qualname": "HybridPoolEvaluator._flat_rerank",
  "name": "_flat_rerank",
  "node_type": "FunctionDef",
  "lineno": 245,
  "col": 4,
  "end_lineno": 263,
  "end_col": 44,
  "parent_qualname": "HybridPoolEvaluator",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "eval/hybrid_evaluator.py",
  "module": "eval.hybrid_evaluator",
  "qualname": "HybridPoolEvaluator._extend_pool",
  "name": "_extend_pool",
  "node_type": "FunctionDef",
  "lineno": 265,
  "col": 4,
  "end_lineno": 293,
  "end_col": 13,
  "parent_qualname": "HybridPoolEvaluator",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "eval/hybrid_evaluator.py",
  "module": "eval.hybrid_evaluator",
  "qualname": "HybridPoolEvaluator._score_with_xtr",
  "name": "_score_with_xtr",
  "node_type": "FunctionDef",
  "lineno": 295,
  "col": 4,
  "end_lineno": 307,
  "end_col": 26,
  "parent_qualname": "HybridPoolEvaluator",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "eval/hybrid_evaluator.py",
  "module": "eval.hybrid_evaluator",
  "qualname": "HybridPoolEvaluator._get_query_text",
  "name": "_get_query_text",
  "node_type": "FunctionDef",
  "lineno": 309,
  "col": 4,
  "end_lineno": 318,
  "end_col": 19,
  "parent_qualname": "HybridPoolEvaluator",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "eval/hybrid_evaluator.py",
  "module": "eval.hybrid_evaluator",
  "qualname": "HybridPoolEvaluator._write_metrics",
  "name": "_write_metrics",
  "node_type": "FunctionDef",
  "lineno": 321,
  "col": 4,
  "end_lineno": 333,
  "end_col": 79,
  "parent_qualname": "HybridPoolEvaluator",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "eval/pool_writer.py",
  "module": "eval.pool_writer",
  "qualname": "eval.pool_writer",
  "name": "eval.pool_writer",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Lightweight Parquet writer for evaluator pools.",
  "is_public": true
}
{
  "path": "eval/pool_writer.py",
  "module": "eval.pool_writer",
  "qualname": "_SupportsToList",
  "name": "_SupportsToList",
  "node_type": "ClassDef",
  "lineno": 42,
  "col": 0,
  "end_lineno": 59,
  "end_col": 11,
  "parent_qualname": null,
  "decorators": [
    "runtime_checkable"
  ],
  "bases": [
    "Protocol"
  ],
  "docstring": "Protocol describing array-like objects exposing ``tolist``.",
  "is_public": false
}
{
  "path": "eval/pool_writer.py",
  "module": "eval.pool_writer",
  "qualname": "_SupportsToList.tolist",
  "name": "tolist",
  "node_type": "FunctionDef",
  "lineno": 45,
  "col": 4,
  "end_lineno": 59,
  "end_col": 11,
  "parent_qualname": "_SupportsToList",
  "decorators": [],
  "bases": [],
  "docstring": "Convert the array-like object to a Python list.\n\nThis method is part of the Protocol interface for array-like objects\nthat can be converted to lists. Implementations should return a nested\nlist structure representing the array's contents.\n\nReturns\n-------\nobject\n    A Python list (or nested list structure) representing the array's\n    contents. The exact structure depends on the array's dimensionality\n    and element types.",
  "is_public": true
}
{
  "path": "eval/pool_writer.py",
  "module": "eval.pool_writer",
  "qualname": "_empty_table",
  "name": "_empty_table",
  "node_type": "FunctionDef",
  "lineno": 62,
  "col": 0,
  "end_lineno": 99,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return an empty evaluator table with the expected schema.\n\nReturns\n-------\npa.Table\n    Empty table with the evaluator schema.\n\nRaises\n------\nRuntimeError\n    If pyarrow is not available.",
  "is_public": false
}
{
  "path": "eval/pool_writer.py",
  "module": "eval.pool_writer",
  "qualname": "_normalize_meta",
  "name": "_normalize_meta",
  "node_type": "FunctionDef",
  "lineno": 102,
  "col": 0,
  "end_lineno": 137,
  "end_col": 64,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return a JSON-serialisable copy of ``meta``.\n\nParameters\n----------\nmeta : Mapping[str, object]\n    Metadata dictionary to normalize. Values are coerced to JSON-serializable\n    types (str, int, float, bool, None, dict, list). Non-serializable types\n    are converted to strings.\n\nReturns\n-------\ndict[str, object]\n    Normalized metadata ready for JSON serialization. All values are\n    JSON-serializable types.",
  "is_public": false
}
{
  "path": "eval/pool_writer.py",
  "module": "eval.pool_writer",
  "qualname": "_normalize_meta._coerce",
  "name": "_coerce",
  "node_type": "FunctionDef",
  "lineno": 119,
  "col": 4,
  "end_lineno": 135,
  "end_col": 21,
  "parent_qualname": "_normalize_meta",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "eval/pool_writer.py",
  "module": "eval.pool_writer",
  "qualname": "write_pool",
  "name": "write_pool",
  "node_type": "FunctionDef",
  "lineno": 140,
  "col": 0,
  "end_lineno": 211,
  "end_col": 28,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Write `(query_id, channel, rank, chunk_id, score, uri, ...)` rows to Parquet.\n\nParameters\n----------\nrows : Iterable[SearchPoolRow]\n    Pool rows to persist.\nout_path : Path\n    Destination Parquet file.\noverwrite : bool, optional\n    When True (default) any existing file is replaced.\n\nReturns\n-------\nint\n    Number of rows written.\n\nRaises\n------\nRuntimeError\n    If pyarrow is not available.",
  "is_public": true
}
{
  "path": "evaluation/__init__.py",
  "module": "evaluation",
  "qualname": "evaluation",
  "name": "evaluation",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Evaluation helpers package.",
  "is_public": true
}
{
  "path": "evaluation/hybrid_pool.py",
  "module": "evaluation.hybrid_pool",
  "qualname": "evaluation.hybrid_pool",
  "name": "evaluation.hybrid_pool",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Feature-normalized hybrid pooling utilities.",
  "is_public": true
}
{
  "path": "evaluation/hybrid_pool.py",
  "module": "evaluation.hybrid_pool",
  "qualname": "Hit",
  "name": "Hit",
  "node_type": "ClassDef",
  "lineno": 32,
  "col": 0,
  "end_lineno": 38,
  "end_col": 30,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Individual retrieval hit provided to the hybrid pool.",
  "is_public": true
}
{
  "path": "evaluation/hybrid_pool.py",
  "module": "evaluation.hybrid_pool",
  "qualname": "PooledHit",
  "name": "PooledHit",
  "node_type": "ClassDef",
  "lineno": 42,
  "col": 0,
  "end_lineno": 48,
  "end_col": 30,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Result after pooling with per-source component scores.",
  "is_public": true
}
{
  "path": "evaluation/hybrid_pool.py",
  "module": "evaluation.hybrid_pool",
  "qualname": "_minmax_norm",
  "name": "_minmax_norm",
  "node_type": "FunctionDef",
  "lineno": 51,
  "col": 0,
  "end_lineno": 59,
  "end_col": 48,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "evaluation/hybrid_pool.py",
  "module": "evaluation.hybrid_pool",
  "qualname": "_softmax_norm",
  "name": "_softmax_norm",
  "node_type": "FunctionDef",
  "lineno": 62,
  "col": 0,
  "end_lineno": 68,
  "end_col": 40,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "evaluation/hybrid_pool.py",
  "module": "evaluation.hybrid_pool",
  "qualname": "HybridPoolEvaluator",
  "name": "HybridPoolEvaluator",
  "node_type": "ClassDef",
  "lineno": 71,
  "col": 0,
  "end_lineno": 173,
  "end_col": 59,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Blend multi-channel hits with configurable normalization and weights.",
  "is_public": true
}
{
  "path": "evaluation/hybrid_pool.py",
  "module": "evaluation.hybrid_pool",
  "qualname": "HybridPoolEvaluator.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 74,
  "col": 4,
  "end_lineno": 83,
  "end_col": 43,
  "parent_qualname": "HybridPoolEvaluator",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "evaluation/hybrid_pool.py",
  "module": "evaluation.hybrid_pool",
  "qualname": "HybridPoolEvaluator.pool",
  "name": "pool",
  "node_type": "FunctionDef",
  "lineno": 85,
  "col": 4,
  "end_lineno": 156,
  "end_col": 23,
  "parent_qualname": "HybridPoolEvaluator",
  "decorators": [],
  "bases": [],
  "docstring": "Pool hits across channels using feature normalization.\n\nExtended Summary\n----------------\nThis method performs hybrid search result fusion by normalizing scores\nacross retrieval channels (BM25, SPLADE, FAISS) and blending them using\nconfigured weights. It groups hits by document ID, normalizes scores\nwithin each channel (using softmax or min-max normalization), applies\nchannel weights, and ranks documents by blended scores. Used by the\nhybrid search engine to combine results from multiple retrieval methods.\n\nParameters\n----------\nhits : Iterable[Hit]\n    Hits from multiple retrieval channels (BM25, SPLADE, FAISS). Each hit\n    contains source channel, document ID, score, and metadata.\nk : int\n    Number of top-ranked documents to return after pooling. Documents\n    are ranked by blended scores (weighted sum of normalized channel scores).\n\nReturns\n-------\nlist[PooledHit]\n    Ranked hits with blended scores and per-channel contributions. Each\n    PooledHit contains the document ID, blended score, and normalized\n    scores per channel. Results are sorted by blended score (descending).\n\nNotes\n-----\nThis method implements hybrid search fusion with configurable normalization\n(softmax or min-max) and channel weights. Documents appearing in multiple\nchannels have their scores blended; documents appearing in only one channel\nstill receive weighted scores. Time complexity: O(n * m) where n is the\nnumber of hits and m is the number of channels.",
  "is_public": true
}
{
  "path": "evaluation/hybrid_pool.py",
  "module": "evaluation.hybrid_pool",
  "qualname": "HybridPoolEvaluator._record_pool_metrics",
  "name": "_record_pool_metrics",
  "node_type": "FunctionDef",
  "lineno": 158,
  "col": 4,
  "end_lineno": 173,
  "end_col": 59,
  "parent_qualname": "HybridPoolEvaluator",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "evaluation/offline_recall.py",
  "module": "evaluation.offline_recall",
  "qualname": "evaluation.offline_recall",
  "name": "evaluation.offline_recall",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Offline recall evaluator leveraging FAISS + DuckDB catalogs.",
  "is_public": true
}
{
  "path": "evaluation/offline_recall.py",
  "module": "evaluation.offline_recall",
  "qualname": "EvalQuery",
  "name": "EvalQuery",
  "node_type": "ClassDef",
  "lineno": 31,
  "col": 0,
  "end_lineno": 37,
  "end_col": 45,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Single offline evaluation query with known positives.",
  "is_public": true
}
{
  "path": "evaluation/offline_recall.py",
  "module": "evaluation.offline_recall",
  "qualname": "OfflineRecallEvaluator",
  "name": "OfflineRecallEvaluator",
  "node_type": "ClassDef",
  "lineno": 40,
  "col": 0,
  "end_lineno": 255,
  "end_col": 35,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Compute recall@K for FAISS retrieval using curated or synthesized queries.",
  "is_public": true
}
{
  "path": "evaluation/offline_recall.py",
  "module": "evaluation.offline_recall",
  "qualname": "OfflineRecallEvaluator.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 43,
  "col": 4,
  "end_lineno": 56,
  "end_col": 60,
  "parent_qualname": "OfflineRecallEvaluator",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "evaluation/offline_recall.py",
  "module": "evaluation.offline_recall",
  "qualname": "OfflineRecallEvaluator.run",
  "name": "run",
  "node_type": "FunctionDef",
  "lineno": 58,
  "col": 4,
  "end_lineno": 130,
  "end_col": 53,
  "parent_qualname": "OfflineRecallEvaluator",
  "decorators": [],
  "bases": [],
  "docstring": "Execute offline evaluation and persist artifacts.\n\nExtended Summary\n----------------\nThis method runs offline recall evaluation by loading queries (from file\nor synthesizing from symbol catalog), performing FAISS searches for each\nquery, computing recall metrics at multiple k values against ground truth\n(symbol definitions), and persisting evaluation artifacts (per-query results,\naggregate recall statistics) to the output directory. Used for validating\nindex quality and tuning search parameters.\n\nParameters\n----------\nqueries_path : Path | None, optional\n    Path to JSONL file containing queries ({qid, text, positives}). If None,\n    queries are synthesized from symbol catalog using configured strategy.\noutput_dir : Path | None, optional\n    Directory for evaluation artifacts (per-query results, aggregate stats).\n    If None, uses `settings.eval.output_dir`.\n\nReturns\n-------\ndict[str, object]\n    Dictionary containing:\n    - \"queries\": int, number of queries evaluated\n    - \"summary\": dict[int, float], aggregate recall at each k value\n    Returns {\"queries\": 0, \"summary\": {}} if no queries available.\n\nNotes\n-----\nThis method performs offline evaluation by iterating over queries and\ncomputing recall metrics. Evaluation artifacts are written to the output\ndirectory for analysis. Time complexity: O(n_queries * search_time) where\nsearch_time depends on index size and k values.",
  "is_public": true
}
{
  "path": "evaluation/offline_recall.py",
  "module": "evaluation.offline_recall",
  "qualname": "OfflineRecallEvaluator._resolve_output_dir",
  "name": "_resolve_output_dir",
  "node_type": "FunctionDef",
  "lineno": 132,
  "col": 4,
  "end_lineno": 137,
  "end_col": 19,
  "parent_qualname": "OfflineRecallEvaluator",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "evaluation/offline_recall.py",
  "module": "evaluation.offline_recall",
  "qualname": "OfflineRecallEvaluator._load_queries",
  "name": "_load_queries",
  "node_type": "FunctionDef",
  "lineno": 140,
  "col": 4,
  "end_lineno": 163,
  "end_col": 22,
  "parent_qualname": "OfflineRecallEvaluator",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "evaluation/offline_recall.py",
  "module": "evaluation.offline_recall",
  "qualname": "OfflineRecallEvaluator._synthesize_queries",
  "name": "_synthesize_queries",
  "node_type": "FunctionDef",
  "lineno": 165,
  "col": 4,
  "end_lineno": 181,
  "end_col": 13,
  "parent_qualname": "OfflineRecallEvaluator",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "evaluation/offline_recall.py",
  "module": "evaluation.offline_recall",
  "qualname": "OfflineRecallEvaluator._build_question",
  "name": "_build_question",
  "node_type": "FunctionDef",
  "lineno": 184,
  "col": 4,
  "end_lineno": 189,
  "end_col": 19,
  "parent_qualname": "OfflineRecallEvaluator",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "evaluation/offline_recall.py",
  "module": "evaluation.offline_recall",
  "qualname": "OfflineRecallEvaluator._embed_query",
  "name": "_embed_query",
  "node_type": "FunctionDef",
  "lineno": 191,
  "col": 4,
  "end_lineno": 193,
  "end_col": 66,
  "parent_qualname": "OfflineRecallEvaluator",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "evaluation/offline_recall.py",
  "module": "evaluation.offline_recall",
  "qualname": "OfflineRecallEvaluator._write_artifacts",
  "name": "_write_artifacts",
  "node_type": "FunctionDef",
  "lineno": 196,
  "col": 4,
  "end_lineno": 212,
  "end_col": 34,
  "parent_qualname": "OfflineRecallEvaluator",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "evaluation/offline_recall.py",
  "module": "evaluation.offline_recall",
  "qualname": "OfflineRecallEvaluator._record_metrics",
  "name": "_record_metrics",
  "node_type": "FunctionDef",
  "lineno": 215,
  "col": 4,
  "end_lineno": 218,
  "end_col": 71,
  "parent_qualname": "OfflineRecallEvaluator",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "evaluation/offline_recall.py",
  "module": "evaluation.offline_recall",
  "qualname": "OfflineRecallEvaluator._prepare_queries",
  "name": "_prepare_queries",
  "node_type": "FunctionDef",
  "lineno": 220,
  "col": 4,
  "end_lineno": 228,
  "end_col": 44,
  "parent_qualname": "OfflineRecallEvaluator",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "evaluation/offline_recall.py",
  "module": "evaluation.offline_recall",
  "qualname": "OfflineRecallEvaluator._evaluate_query",
  "name": "_evaluate_query",
  "node_type": "FunctionDef",
  "lineno": 230,
  "col": 4,
  "end_lineno": 255,
  "end_col": 35,
  "parent_qualname": "OfflineRecallEvaluator",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "evaluation/scip_coverage.py",
  "module": "evaluation.scip_coverage",
  "qualname": "evaluation.scip_coverage",
  "name": "evaluation.scip_coverage",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "SCIP symbol coverage evaluator.",
  "is_public": true
}
{
  "path": "evaluation/scip_coverage.py",
  "module": "evaluation.scip_coverage",
  "qualname": "SupportsFaissSearch",
  "name": "SupportsFaissSearch",
  "node_type": "ClassDef",
  "lineno": 27,
  "col": 0,
  "end_lineno": 39,
  "end_col": 11,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "Protocol"
  ],
  "docstring": "Protocol capturing the subset of FAISS search methods required here.",
  "is_public": true
}
{
  "path": "evaluation/scip_coverage.py",
  "module": "evaluation.scip_coverage",
  "qualname": "SupportsFaissSearch.search",
  "name": "search",
  "node_type": "FunctionDef",
  "lineno": 30,
  "col": 4,
  "end_lineno": 39,
  "end_col": 11,
  "parent_qualname": "SupportsFaissSearch",
  "decorators": [],
  "bases": [],
  "docstring": "Return distances and ids for ``query``.",
  "is_public": true
}
{
  "path": "evaluation/scip_coverage.py",
  "module": "evaluation.scip_coverage",
  "qualname": "SupportsEmbedSingle",
  "name": "SupportsEmbedSingle",
  "node_type": "ClassDef",
  "lineno": 42,
  "col": 0,
  "end_lineno": 47,
  "end_col": 11,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "Protocol"
  ],
  "docstring": "Protocol describing embedder behaviour used by the evaluator.",
  "is_public": true
}
{
  "path": "evaluation/scip_coverage.py",
  "module": "evaluation.scip_coverage",
  "qualname": "SupportsEmbedSingle.embed_single",
  "name": "embed_single",
  "node_type": "FunctionDef",
  "lineno": 45,
  "col": 4,
  "end_lineno": 47,
  "end_col": 11,
  "parent_qualname": "SupportsEmbedSingle",
  "decorators": [],
  "bases": [],
  "docstring": "Return an embedding vector for ``text``.",
  "is_public": true
}
{
  "path": "evaluation/scip_coverage.py",
  "module": "evaluation.scip_coverage",
  "qualname": "CoverageResult",
  "name": "CoverageResult",
  "node_type": "ClassDef",
  "lineno": 51,
  "col": 0,
  "end_lineno": 58,
  "end_col": 19,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Container for per-symbol coverage evaluation.",
  "is_public": true
}
{
  "path": "evaluation/scip_coverage.py",
  "module": "evaluation.scip_coverage",
  "qualname": "CoverageSummary",
  "name": "CoverageSummary",
  "node_type": "ClassDef",
  "lineno": 61,
  "col": 0,
  "end_lineno": 68,
  "end_col": 10,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "TypedDict"
  ],
  "docstring": "Typed summary payload returned by ``SCIPCoverageEvaluator``.",
  "is_public": true
}
{
  "path": "evaluation/scip_coverage.py",
  "module": "evaluation.scip_coverage",
  "qualname": "SCIPCoverageEvaluator",
  "name": "SCIPCoverageEvaluator",
  "node_type": "ClassDef",
  "lineno": 71,
  "col": 0,
  "end_lineno": 260,
  "end_col": 9,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Evaluate chunk/index/retrieval coverage across SCIP function definitions.",
  "is_public": true
}
{
  "path": "evaluation/scip_coverage.py",
  "module": "evaluation.scip_coverage",
  "qualname": "SCIPCoverageEvaluator.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 74,
  "col": 4,
  "end_lineno": 88,
  "end_col": 60,
  "parent_qualname": "SCIPCoverageEvaluator",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "evaluation/scip_coverage.py",
  "module": "evaluation.scip_coverage",
  "qualname": "SCIPCoverageEvaluator.run",
  "name": "run",
  "node_type": "FunctionDef",
  "lineno": 90,
  "col": 4,
  "end_lineno": 176,
  "end_col": 22,
  "parent_qualname": "SCIPCoverageEvaluator",
  "decorators": [],
  "bases": [],
  "docstring": "Execute the coverage evaluation and return summary metrics.\n\nExtended Summary\n----------------\nThis method runs SCIP function coverage evaluation by fetching symbol\ndefinitions from the DuckDB catalog, performing FAISS searches for each\nsymbol's embedding, and computing coverage metrics (how many symbols are\nretrievable at top-k). Results are written to the output directory as JSON\nreports. Used for validating that symbol definitions are searchable in\nthe FAISS index.\n\nParameters\n----------\nk : int, optional\n    Top-k value for retrieval evaluation (default: 10). Coverage is computed\n    as the fraction of symbols that appear in the top-k FAISS results for\n    their own embeddings.\nlimit : int | None, optional\n    Optional limit on the number of symbols to evaluate. If None, evaluates\n    all symbols in the catalog. Useful for quick validation runs.\noutput_dir : Path | None, optional\n    Directory for coverage artifacts (JSON reports). If None, uses\n    `settings.eval.output_dir`.\n\nReturns\n-------\nCoverageSummary\n    Summary dataclass with coverage metrics including total symbol count,\n    coverage percentage, and per-symbol retrieval results.\n\nNotes\n-----\nThis method performs coverage evaluation by iterating over symbol definitions\nand checking if they appear in FAISS search results. Coverage artifacts are\nwritten to the output directory for analysis. Time complexity: O(n_symbols * search_time)\nwhere search_time depends on index size and k.",
  "is_public": true
}
{
  "path": "evaluation/scip_coverage.py",
  "module": "evaluation.scip_coverage",
  "qualname": "SCIPCoverageEvaluator._lookup_chunk_ids",
  "name": "_lookup_chunk_ids",
  "node_type": "FunctionDef",
  "lineno": 178,
  "col": 4,
  "end_lineno": 191,
  "end_col": 44,
  "parent_qualname": "SCIPCoverageEvaluator",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "evaluation/scip_coverage.py",
  "module": "evaluation.scip_coverage",
  "qualname": "SCIPCoverageEvaluator._embed",
  "name": "_embed",
  "node_type": "FunctionDef",
  "lineno": 193,
  "col": 4,
  "end_lineno": 195,
  "end_col": 69,
  "parent_qualname": "SCIPCoverageEvaluator",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "evaluation/scip_coverage.py",
  "module": "evaluation.scip_coverage",
  "qualname": "SCIPCoverageEvaluator._question_for",
  "name": "_question_for",
  "node_type": "FunctionDef",
  "lineno": 198,
  "col": 4,
  "end_lineno": 203,
  "end_col": 19,
  "parent_qualname": "SCIPCoverageEvaluator",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "evaluation/scip_coverage.py",
  "module": "evaluation.scip_coverage",
  "qualname": "SCIPCoverageEvaluator._record_metrics",
  "name": "_record_metrics",
  "node_type": "FunctionDef",
  "lineno": 206,
  "col": 4,
  "end_lineno": 209,
  "end_col": 100,
  "parent_qualname": "SCIPCoverageEvaluator",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "evaluation/scip_coverage.py",
  "module": "evaluation.scip_coverage",
  "qualname": "SCIPCoverageEvaluator._write_artifacts",
  "name": "_write_artifacts",
  "node_type": "FunctionDef",
  "lineno": 211,
  "col": 4,
  "end_lineno": 236,
  "end_col": 34,
  "parent_qualname": "SCIPCoverageEvaluator",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "evaluation/scip_coverage.py",
  "module": "evaluation.scip_coverage",
  "qualname": "SCIPCoverageEvaluator._evaluate_symbol",
  "name": "_evaluate_symbol",
  "node_type": "FunctionDef",
  "lineno": 238,
  "col": 4,
  "end_lineno": 260,
  "end_col": 9,
  "parent_qualname": "SCIPCoverageEvaluator",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "export_resolver.py",
  "module": "export_resolver",
  "qualname": "export_resolver",
  "name": "export_resolver",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Resolve exports and re-exports for module records.",
  "is_public": true
}
{
  "path": "export_resolver.py",
  "module": "export_resolver",
  "qualname": "build_module_name_map",
  "name": "build_module_name_map",
  "node_type": "FunctionDef",
  "lineno": 18,
  "col": 0,
  "end_lineno": 41,
  "end_col": 18,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return mapping of module name  module row for quick lookup.\n\nParameters\n----------\nrows : list[dict[str, Any]]\n    Module metadata rows to index by module name.\npackage_prefix : str | None, optional\n    Optional package prefix for module name normalization.\n\nReturns\n-------\ndict[str, dict[str, Any]]\n    Mapping of dotted module names to the associated row dictionaries.",
  "is_public": true
}
{
  "path": "export_resolver.py",
  "module": "export_resolver",
  "qualname": "resolve_exports",
  "name": "resolve_exports",
  "node_type": "FunctionDef",
  "lineno": 44,
  "col": 0,
  "end_lineno": 94,
  "end_col": 30,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return exports resolved from star-imports and re-export metadata.\n\nParameters\n----------\nrow : Mapping[str, Any]\n    Module row containing imports and definitions.\nmodules_by_name : Mapping[str, Mapping[str, Any]]\n    Mapping of module names to their row dictionaries.\npackage_prefix : str | None, optional\n    Optional package prefix for module name resolution.\n\nReturns\n-------\ntuple[dict[str, list[str]], dict[str, dict[str, str]]]\n    Pair of ``exports_resolved`` mapping and ``reexports`` metadata.",
  "is_public": true
}
{
  "path": "export_resolver.py",
  "module": "export_resolver",
  "qualname": "is_reexport_hub",
  "name": "is_reexport_hub",
  "node_type": "FunctionDef",
  "lineno": 97,
  "col": 0,
  "end_lineno": 113,
  "end_col": 97,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return True when a module behaves like a re-export hub.\n\nParameters\n----------\nrow : Mapping[str, Any]\n    Module row containing exports and imports metadata.\n\nReturns\n-------\nbool\n    True when the module is considered a re-export hub.",
  "is_public": true
}
{
  "path": "export_resolver.py",
  "module": "export_resolver",
  "qualname": "_public_names",
  "name": "_public_names",
  "node_type": "FunctionDef",
  "lineno": 116,
  "col": 0,
  "end_lineno": 133,
  "end_col": 16,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "graph_builder.py",
  "module": "graph_builder",
  "qualname": "graph_builder",
  "name": "graph_builder",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Import graph builder utilities.",
  "is_public": true
}
{
  "path": "graph_builder.py",
  "module": "graph_builder",
  "qualname": "ImportGraph",
  "name": "ImportGraph",
  "node_type": "ClassDef",
  "lineno": 21,
  "col": 0,
  "end_lineno": 27,
  "end_col": 31,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Graph representation of intra-repo imports.",
  "is_public": true
}
{
  "path": "graph_builder.py",
  "module": "graph_builder",
  "qualname": "build_import_graph",
  "name": "build_import_graph",
  "node_type": "FunctionDef",
  "lineno": 30,
  "col": 0,
  "end_lineno": 82,
  "end_col": 92,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Build an import graph across repo modules.\n\nParameters\n----------\nrows : Sequence[Mapping[str, Any]]\n    Module metadata rows containing import information.\npackage_prefix : str | None, optional\n    Optional package prefix for module name normalization.\n\nReturns\n-------\nImportGraph\n    Data structure containing edges and per-module metrics.",
  "is_public": true
}
{
  "path": "graph_builder.py",
  "module": "graph_builder",
  "qualname": "write_import_graph",
  "name": "write_import_graph",
  "node_type": "FunctionDef",
  "lineno": 85,
  "col": 0,
  "end_lineno": 99,
  "end_col": 39,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Write import edges to Parquet (or JSONL fallback).",
  "is_public": true
}
{
  "path": "graph_builder.py",
  "module": "graph_builder",
  "qualname": "_tarjan_scc",
  "name": "_tarjan_scc",
  "node_type": "FunctionDef",
  "lineno": 102,
  "col": 0,
  "end_lineno": 161,
  "end_col": 21,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "graph_builder.py",
  "module": "graph_builder",
  "qualname": "_tarjan_scc.strongconnect",
  "name": "strongconnect",
  "node_type": "FunctionDef",
  "lineno": 111,
  "col": 4,
  "end_lineno": 156,
  "end_col": 26,
  "parent_qualname": "_tarjan_scc",
  "decorators": [],
  "bases": [],
  "docstring": "Perform depth-first search to find strongly connected components.\n\nThis nested function implements Tarjan's algorithm for finding strongly\nconnected components (SCCs) in a directed graph. It performs a depth-first\nsearch, tracking discovery order and lowlink values to identify cycles.\nWhen a root node of an SCC is found (lowlink == order), all nodes on the\nstack up to that root are assigned to the same component.\n\nParameters\n----------\nnode : str\n    The current node being processed. Represents a module path in the import\n    graph. The function recursively processes all neighbors (imported modules)\n    to discover SCCs.\n\nNotes\n-----\nThis function is part of Tarjan's SCC algorithm implementation. It uses\nclosure variables (order, lowlink, stack, on_stack, assignment, component)\nto maintain algorithm state across recursive calls. Time complexity:\nO(V + E) where V is the number of nodes and E is the number of edges.\nThe function modifies closure variables and is not thread-safe. It assigns\ncomponent IDs to nodes that form cycles in the import graph, enabling\ncycle detection and grouping for dependency analysis.",
  "is_public": true
}
{
  "path": "graph_builder.py",
  "module": "graph_builder",
  "qualname": "_write_parquet",
  "name": "_write_parquet",
  "node_type": "FunctionDef",
  "lineno": 164,
  "col": 0,
  "end_lineno": 188,
  "end_col": 15,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Persist records to Parquet via polars when available.\n\nParameters\n----------\nrecords : list[dict[str, str]]\n    List of dictionary records to write.\ntarget : Path\n    File system path for the output Parquet file.\n\nReturns\n-------\nbool\n    True if polars is available and write succeeded, False otherwise.",
  "is_public": false
}
{
  "path": "indexing/__init__.py",
  "module": "indexing",
  "qualname": "indexing",
  "name": "indexing",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Indexing utilities (SCIP parsing, lifecycle helpers, chunking).",
  "is_public": true
}
{
  "path": "indexing/cast_chunker.py",
  "module": "indexing.cast_chunker",
  "qualname": "indexing.cast_chunker",
  "name": "indexing.cast_chunker",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "cAST chunking using SCIP symbol ranges.\n\nImplements structure-aware chunking using symbol boundaries from SCIP\nrather than tree-sitter parsing. Greedily packs top-level symbols up to\nthe character budget, splitting large symbols on blank lines.",
  "is_public": true
}
{
  "path": "indexing/cast_chunker.py",
  "module": "indexing.cast_chunker",
  "qualname": "Chunk",
  "name": "Chunk",
  "node_type": "ClassDef",
  "lineno": 21,
  "col": 0,
  "end_lineno": 77,
  "end_col": 17,
  "parent_qualname": null,
  "decorators": [
    "dataclass(frozen=True)"
  ],
  "bases": [],
  "docstring": "Code chunk with precise byte and line bounds.\n\nA Chunk represents a contiguous region of source code that has been extracted\nfor indexing. Chunks are created by the cAST chunker using SCIP symbol boundaries\nto ensure that chunks respect semantic structure (functions, classes, etc.) rather\nthan arbitrary text splits.\n\nEach chunk includes precise byte offsets (for exact text extraction) and line\nnumbers (for human-readable display). The chunk also tracks which SCIP symbols\nit contains, enabling symbol-aware search and navigation.\n\nChunks are immutable (frozen dataclass) to ensure thread safety and prevent\naccidental modification. They are designed to be stored in Parquet files with\ntheir embeddings for efficient retrieval.\n\nAttributes\n----------\nuri : str\n    File path or URI identifying the source file. This is typically a relative\n    path from the repository root, matching the SCIP index format. Used for\n    filtering and grouping chunks by file.\nstart_byte : int\n    Starting byte offset (0-indexed) of the chunk within the source file.\n    Used for precise text extraction without re-parsing the file. Byte offsets\n    are more reliable than character offsets for multi-byte encodings.\nend_byte : int\n    Ending byte offset (exclusive, 0-indexed) of the chunk. The chunk text\n    spans from start_byte to end_byte (exclusive).\nstart_line : int\n    Starting line number (0-indexed) for human-readable display. Used in search\n    results and code navigation. Line numbers are computed from byte offsets\n    using line start positions.\nend_line : int\n    Ending line number (0-indexed, inclusive). The chunk spans from start_line\n    to end_line (inclusive). Used for displaying code ranges in search results.\ntext : str\n    The actual source code text of the chunk. This is the substring of the\n    source file from start_byte to end_byte. Stored explicitly for fast\n    retrieval without re-reading files.\nsymbols : tuple[str, ...]\n    Tuple of SCIP symbol strings that are defined or referenced within this\n    chunk. Symbols are in SCIP format (e.g., \"python kgfoundry.core#Function.main\").\n    Used for symbol-aware search and filtering. Empty tuple if no symbols.\nlanguage : str\n    Programming language of the source file containing this chunk. Used for\n    filtering results by language scope and derived from SCIP metadata.",
  "is_public": true
}
{
  "path": "indexing/cast_chunker.py",
  "module": "indexing.cast_chunker",
  "qualname": "LineIndex",
  "name": "LineIndex",
  "node_type": "ClassDef",
  "lineno": 81,
  "col": 0,
  "end_lineno": 91,
  "end_col": 41,
  "parent_qualname": null,
  "decorators": [
    "dataclass(frozen=True)"
  ],
  "bases": [],
  "docstring": "Line start bookkeeping for both character and byte positions.",
  "is_public": true
}
{
  "path": "indexing/cast_chunker.py",
  "module": "indexing.cast_chunker",
  "qualname": "LineIndex.text_length",
  "name": "text_length",
  "node_type": "FunctionDef",
  "lineno": 89,
  "col": 4,
  "end_lineno": 91,
  "end_col": 41,
  "parent_qualname": "LineIndex",
  "decorators": [
    "property"
  ],
  "bases": [],
  "docstring": "Return the decoded text length in characters.",
  "is_public": true
}
{
  "path": "indexing/cast_chunker.py",
  "module": "indexing.cast_chunker",
  "qualname": "_utf8_length",
  "name": "_utf8_length",
  "node_type": "FunctionDef",
  "lineno": 99,
  "col": 0,
  "end_lineno": 119,
  "end_col": 12,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return the UTF-8 encoded length for ``ch``.\n\nParameters\n----------\nch : str\n    Single character to measure.\n\nReturns\n-------\nint\n    Number of bytes required to encode the character in UTF-8 (1-4).",
  "is_public": false
}
{
  "path": "indexing/cast_chunker.py",
  "module": "indexing.cast_chunker",
  "qualname": "line_starts",
  "name": "line_starts",
  "node_type": "FunctionDef",
  "lineno": 122,
  "col": 0,
  "end_lineno": 147,
  "end_col": 97,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Compute character and byte offsets for each line start.\n\nParameters\n----------\ntext : str\n    Input text to index.\n\nReturns\n-------\nLineIndex\n    Index containing character starts, byte starts, and character-to-byte mapping.",
  "is_public": true
}
{
  "path": "indexing/cast_chunker.py",
  "module": "indexing.cast_chunker",
  "qualname": "_line_index_from_byte",
  "name": "_line_index_from_byte",
  "node_type": "FunctionDef",
  "lineno": 150,
  "col": 0,
  "end_lineno": 168,
  "end_col": 38,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return the zero-based line index containing ``byte_offset``.\n\nParameters\n----------\nstarts : Sequence[int]\n    Offsets for the beginning of each line.\nbyte_offset : int\n    Absolute byte offset within the text.\n\nReturns\n-------\nint\n    Zero-based line index best matching the offset.",
  "is_public": false
}
{
  "path": "indexing/cast_chunker.py",
  "module": "indexing.cast_chunker",
  "qualname": "_char_index_for_line",
  "name": "_char_index_for_line",
  "node_type": "FunctionDef",
  "lineno": 171,
  "col": 0,
  "end_lineno": 195,
  "end_col": 20,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Map a line/character pair to an absolute character index.\n\nParameters\n----------\nline_index : LineIndex\n    Line index containing character start positions.\nline : int\n    Zero-based line number.\ncharacter : int\n    Zero-based character offset within the line.\n\nReturns\n-------\nint\n    Absolute character index in the text, clamped to valid range.",
  "is_public": false
}
{
  "path": "indexing/cast_chunker.py",
  "module": "indexing.cast_chunker",
  "qualname": "range_to_bytes",
  "name": "range_to_bytes",
  "node_type": "FunctionDef",
  "lineno": 198,
  "col": 0,
  "end_lineno": 222,
  "end_col": 31,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Convert line/character range to byte offsets.\n\nParameters\n----------\ntext : str\n    Source text (unused, retained for backward compatibility).\nline_index : LineIndex\n    Line index for character-to-byte conversion.\nrng : Range\n    Range with start and end line/character positions.\n\nReturns\n-------\ntuple[int, int]\n    Tuple of (start_byte, end_byte) offsets.",
  "is_public": true
}
{
  "path": "indexing/cast_chunker.py",
  "module": "indexing.cast_chunker",
  "qualname": "_ChunkAccumulator",
  "name": "_ChunkAccumulator",
  "node_type": "ClassDef",
  "lineno": 226,
  "col": 0,
  "end_lineno": 275,
  "end_col": 33,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Immutable accumulator configuration; delegates mutation to a builder.",
  "is_public": false
}
{
  "path": "indexing/cast_chunker.py",
  "module": "indexing.cast_chunker",
  "qualname": "_ChunkAccumulator.build_chunks",
  "name": "build_chunks",
  "node_type": "FunctionDef",
  "lineno": 236,
  "col": 4,
  "end_lineno": 275,
  "end_col": 33,
  "parent_qualname": "_ChunkAccumulator",
  "decorators": [],
  "bases": [],
  "docstring": "Build chunks from sorted symbol definitions using greedy packing.\n\nThis method orchestrates the chunking process by creating a mutable\nbuilder instance and iteratively adding symbols to it. The builder\ngreedily packs symbols up to the configured character budget, splitting\nlarge symbols on blank lines when necessary. After all symbols are\nprocessed, the builder finalizes and returns the complete list of chunks.\n\nParameters\n----------\nsymbols_with_positions : Sequence[tuple[SymbolDef, int, int]]\n    Sequence of (symbol definition, start character offset, end character\n    offset) tuples. Symbols should be pre-sorted by start position to\n    ensure correct chunk ordering. Character offsets are absolute positions\n    within the source file text.\n\nReturns\n-------\nlist[Chunk]\n    List of chunks generated from the symbol definitions. Chunks are\n    ordered by their position in the source file and respect symbol\n    boundaries. Each chunk includes precise byte offsets, line numbers,\n    text content, and associated symbol identifiers.\n\nNotes\n-----\nThis method delegates the actual chunking logic to `_ChunkBuilder`, which\nhandles greedy packing, budget management, and large symbol splitting.\nTime complexity: O(n) where n is the number of symbols, assuming symbol\naddition is O(1) amortized. The method performs no I/O operations and\nis thread-safe if called with distinct accumulator instances.",
  "is_public": true
}
{
  "path": "indexing/cast_chunker.py",
  "module": "indexing.cast_chunker",
  "qualname": "_ChunkBuilder",
  "name": "_ChunkBuilder",
  "node_type": "ClassDef",
  "lineno": 278,
  "col": 0,
  "end_lineno": 444,
  "end_col": 34,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Mutable helper that performs chunk assembly for a fixed configuration.",
  "is_public": false
}
{
  "path": "indexing/cast_chunker.py",
  "module": "indexing.cast_chunker",
  "qualname": "_ChunkBuilder.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 289,
  "col": 4,
  "end_lineno": 294,
  "end_col": 45,
  "parent_qualname": "_ChunkBuilder",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "indexing/cast_chunker.py",
  "module": "indexing.cast_chunker",
  "qualname": "_ChunkBuilder.add_symbol",
  "name": "add_symbol",
  "node_type": "FunctionDef",
  "lineno": 296,
  "col": 4,
  "end_lineno": 345,
  "end_col": 52,
  "parent_qualname": "_ChunkBuilder",
  "decorators": [],
  "bases": [],
  "docstring": "Add a symbol to the current chunk or start a new chunk if needed.\n\nThis method implements greedy chunk packing by attempting to merge the\nnew symbol into the current chunk if it fits within the character budget.\nIf merging would exceed the budget, the current chunk is finalized and\na new chunk is started. Large symbols that exceed the budget alone are\nsplit across multiple chunks on blank line boundaries.\n\nParameters\n----------\nsymbol : SymbolDef\n    SCIP symbol definition to add. The symbol's range (start, end) is\n    used to determine chunk boundaries and the symbol identifier is stored\n    in the chunk's symbols tuple.\nstart : int\n    Starting character offset (0-indexed) of the symbol within the\n    source file. Used to compute chunk boundaries and byte offsets.\nend : int\n    Ending character offset (exclusive, 0-indexed) of the symbol. Used\n    to compute chunk boundaries and determine if the symbol fits in the\n    current chunk.\n\nNotes\n-----\nThe method mutates the builder's internal state (_current_start_char,\n_current_end_char, _current_symbols) and may trigger chunk finalization\n(_flush_current) or large symbol splitting (_split_large_symbol). Time\ncomplexity: O(1) for normal symbol addition, O(n) for large symbol\nsplitting where n is the number of blank-line-separated segments. The\nmethod performs no I/O operations and is not thread-safe (designed for\nsingle-threaded use within a single builder instance).",
  "is_public": true
}
{
  "path": "indexing/cast_chunker.py",
  "module": "indexing.cast_chunker",
  "qualname": "_ChunkBuilder.finalize",
  "name": "finalize",
  "node_type": "FunctionDef",
  "lineno": 347,
  "col": 4,
  "end_lineno": 374,
  "end_col": 27,
  "parent_qualname": "_ChunkBuilder",
  "decorators": [],
  "bases": [],
  "docstring": "Finalize chunk building and return the complete list of chunks.\n\nThis method completes the chunking process by flushing any remaining\nin-progress chunk (if one exists) and returning the accumulated list\nof chunks. After finalization, the builder's internal state is cleared\nand the chunks list is ready for use in indexing or search operations.\n\nReturns\n-------\nlist[Chunk]\n    Complete list of chunks generated during the building process. Chunks\n    are ordered by their position in the source file and include all\n    symbols that were added via add_symbol(). The list may be empty if\n    no symbols were added, but typically contains at least one chunk per\n    file with symbol definitions.\n\nNotes\n-----\nThis method should be called exactly once after all symbols have been\nadded. Calling finalize() multiple times will flush the current chunk\nmultiple times, potentially creating duplicate chunks. Time complexity:\nO(1) amortized if the current chunk is already finalized, O(k) where k\nis the number of symbols in the current chunk if flushing is needed.\nThe method performs no I/O operations and is not thread-safe.",
  "is_public": true
}
{
  "path": "indexing/cast_chunker.py",
  "module": "indexing.cast_chunker",
  "qualname": "_ChunkBuilder._start_chunk",
  "name": "_start_chunk",
  "node_type": "FunctionDef",
  "lineno": 376,
  "col": 4,
  "end_lineno": 379,
  "end_col": 40,
  "parent_qualname": "_ChunkBuilder",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "indexing/cast_chunker.py",
  "module": "indexing.cast_chunker",
  "qualname": "_ChunkBuilder._flush_current",
  "name": "_flush_current",
  "node_type": "FunctionDef",
  "lineno": 381,
  "col": 4,
  "end_lineno": 389,
  "end_col": 21,
  "parent_qualname": "_ChunkBuilder",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "indexing/cast_chunker.py",
  "module": "indexing.cast_chunker",
  "qualname": "_ChunkBuilder._append_chunk",
  "name": "_append_chunk",
  "node_type": "FunctionDef",
  "lineno": 391,
  "col": 4,
  "end_lineno": 417,
  "end_col": 9,
  "parent_qualname": "_ChunkBuilder",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "indexing/cast_chunker.py",
  "module": "indexing.cast_chunker",
  "qualname": "_ChunkBuilder._split_large_symbol",
  "name": "_split_large_symbol",
  "node_type": "FunctionDef",
  "lineno": 419,
  "col": 4,
  "end_lineno": 439,
  "end_col": 36,
  "parent_qualname": "_ChunkBuilder",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "indexing/cast_chunker.py",
  "module": "indexing.cast_chunker",
  "qualname": "_ChunkBuilder._reset",
  "name": "_reset",
  "node_type": "FunctionDef",
  "lineno": 441,
  "col": 4,
  "end_lineno": 444,
  "end_col": 34,
  "parent_qualname": "_ChunkBuilder",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "indexing/cast_chunker.py",
  "module": "indexing.cast_chunker",
  "qualname": "chunk_file",
  "name": "chunk_file",
  "node_type": "FunctionDef",
  "lineno": 447,
  "col": 0,
  "end_lineno": 524,
  "end_col": 17,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Chunk file using SCIP symbol boundaries.\n\nGreedily packs top-level symbols up to a budget while optionally adding\nrelated-symbol overlap snippets for better context.\n\nParameters\n----------\npath : Path\n    File path for the source code being chunked.\ntext : str\n    Complete file content as a string.\ndefinitions : list[SymbolDef]\n    List of SCIP symbol definitions extracted from the file.\noptions : ChunkOptions | None, optional\n    Chunk generation configuration. If None, uses default options.\nbudget : int | None, optional\n    Override for the character budget applied during chunk assembly.\n\nReturns\n-------\nlist[Chunk]\n    List of generated chunks in source order.",
  "is_public": true
}
{
  "path": "indexing/cast_chunker.py",
  "module": "indexing.cast_chunker",
  "qualname": "ChunkOverlapOptions",
  "name": "ChunkOverlapOptions",
  "node_type": "ClassDef",
  "lineno": 528,
  "col": 0,
  "end_lineno": 534,
  "end_col": 26,
  "parent_qualname": null,
  "decorators": [
    "dataclass(frozen=True)"
  ],
  "bases": [],
  "docstring": "Configuration for adding call-site overlap snippets.",
  "is_public": true
}
{
  "path": "indexing/cast_chunker.py",
  "module": "indexing.cast_chunker",
  "qualname": "ChunkOptions",
  "name": "ChunkOptions",
  "node_type": "ClassDef",
  "lineno": 538,
  "col": 0,
  "end_lineno": 543,
  "end_col": 46,
  "parent_qualname": null,
  "decorators": [
    "dataclass(frozen=True)"
  ],
  "bases": [],
  "docstring": "Chunk generation configuration.",
  "is_public": true
}
{
  "path": "indexing/cast_chunker.py",
  "module": "indexing.cast_chunker",
  "qualname": "_apply_call_site_overlap",
  "name": "_apply_call_site_overlap",
  "node_type": "FunctionDef",
  "lineno": 546,
  "col": 0,
  "end_lineno": 613,
  "end_col": 18,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Add call-site overlap snippets to chunks.\n\nParameters\n----------\nchunks : list[Chunk]\n    Initial chunks to enhance with overlap snippets.\nencoded : bytes\n    UTF-8 encoded file content.\nbyte_starts : list[int]\n    Byte offsets for each line start.\noptions : ChunkOverlapOptions\n    Overlap configuration including file occurrences and chunk lookup.\n\nReturns\n-------\nlist[Chunk]\n    Modified chunks with call-site overlap snippets added.",
  "is_public": false
}
{
  "path": "indexing/cast_chunker.py",
  "module": "indexing.cast_chunker",
  "qualname": "_apply_call_site_overlap._slice_lines",
  "name": "_slice_lines",
  "node_type": "FunctionDef",
  "lineno": 572,
  "col": 4,
  "end_lineno": 577,
  "end_col": 76,
  "parent_qualname": "_apply_call_site_overlap",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "indexing/chunk_ids.py",
  "module": "indexing.chunk_ids",
  "qualname": "indexing.chunk_ids",
  "name": "indexing.chunk_ids",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Deterministic chunk identifier helpers.",
  "is_public": true
}
{
  "path": "indexing/chunk_ids.py",
  "module": "indexing.chunk_ids",
  "qualname": "stable_chunk_id",
  "name": "stable_chunk_id",
  "node_type": "FunctionDef",
  "lineno": 12,
  "col": 0,
  "end_lineno": 49,
  "end_col": 16,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return a deterministic signed 64-bit chunk identifier.\n\nParameters\n----------\nuri : str\n    Normalized path/URI for the chunk (see :mod:`codeintel_rev.indexing.cast_chunker`).\nstart_byte : int\n    Inclusive starting byte offset of the chunk.\nend_byte : int\n    Exclusive ending byte offset of the chunk.\nsalt : str, optional\n    Extra differentiator for multi-tenant deployments. Defaults to ``\"\"``.\n\nReturns\n-------\nint\n    Signed 64-bit integer suitable for FAISS ``add_with_ids`` and Arrow\n    ``int64`` columns.",
  "is_public": true
}
{
  "path": "indexing/index_lifecycle.py",
  "module": "indexing.index_lifecycle",
  "qualname": "indexing.index_lifecycle",
  "name": "indexing.index_lifecycle",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Index lifecycle management for FAISS/DuckDB/SCIP artifacts.\n\nThis module provides a small, platform-agnostic manager that stages new index\nversions, publishes them atomically, and exposes helpers used by the FastAPI\napp, CLI, and admin endpoints. Versions are stored under a common ``base_dir``\nwith the following layout::\n\n    base_dir/\n        versions/<version>/...\n        versions/<version>.staging/...\n        CURRENT          # text file with the active version id\n        current -> versions/<version>  (best-effort symlink)\n\nThe manager does not mutate the application configuration; instead it flips the\n``CURRENT`` pointer (and optional ``current`` symlink). Runtime components read\nthrough stable paths such as ``.../current/faiss.index`` and reload when\n``ApplicationContext.reload_indices()`` closes their runtime cells.",
  "is_public": true
}
{
  "path": "indexing/index_lifecycle.py",
  "module": "indexing.index_lifecycle",
  "qualname": "LuceneAssets",
  "name": "LuceneAssets",
  "node_type": "ClassDef",
  "lineno": 46,
  "col": 0,
  "end_lineno": 63,
  "end_col": 45,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Lucene index directories that should flip atomically.",
  "is_public": true
}
{
  "path": "indexing/index_lifecycle.py",
  "module": "indexing.index_lifecycle",
  "qualname": "LuceneAssets.iter_dirs",
  "name": "iter_dirs",
  "node_type": "FunctionDef",
  "lineno": 52,
  "col": 4,
  "end_lineno": 63,
  "end_col": 45,
  "parent_qualname": "LuceneAssets",
  "decorators": [],
  "bases": [],
  "docstring": "Yield component name/path pairs for present Lucene assets.\n\nYields\n------\ntuple[str, Path]\n    Component identifier and source directory.",
  "is_public": true
}
{
  "path": "indexing/index_lifecycle.py",
  "module": "indexing.index_lifecycle",
  "qualname": "link_current_lucene",
  "name": "link_current_lucene",
  "node_type": "FunctionDef",
  "lineno": 66,
  "col": 0,
  "end_lineno": 75,
  "end_col": 47,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Copy Lucene assets into a version directory and flip the CURRENT pointer.\n\nNotes\n-----\nThis helper delegates to :meth:`IndexLifecycleManager.link_lucene_assets` and\nwill surface any lifecycle errors raised by that method.",
  "is_public": true
}
{
  "path": "indexing/index_lifecycle.py",
  "module": "indexing.index_lifecycle",
  "qualname": "IndexAssets",
  "name": "IndexAssets",
  "node_type": "ClassDef",
  "lineno": 79,
  "col": 0,
  "end_lineno": 118,
  "end_col": 70,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "File-system assets that must advance together for one index version.",
  "is_public": true
}
{
  "path": "indexing/index_lifecycle.py",
  "module": "indexing.index_lifecycle",
  "qualname": "IndexAssets.ensure_exists",
  "name": "ensure_exists",
  "node_type": "FunctionDef",
  "lineno": 91,
  "col": 4,
  "end_lineno": 118,
  "end_col": 70,
  "parent_qualname": "IndexAssets",
  "decorators": [],
  "bases": [],
  "docstring": "Validate that all required files and directories are present.\n\nRaises\n------\nRuntimeLifecycleError\n    If a required path is missing.",
  "is_public": true
}
{
  "path": "indexing/index_lifecycle.py",
  "module": "indexing.index_lifecycle",
  "qualname": "_file_checksum",
  "name": "_file_checksum",
  "node_type": "FunctionDef",
  "lineno": 121,
  "col": 0,
  "end_lineno": 128,
  "end_col": 29,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "indexing/index_lifecycle.py",
  "module": "indexing.index_lifecycle",
  "qualname": "_read_json",
  "name": "_read_json",
  "node_type": "FunctionDef",
  "lineno": 131,
  "col": 0,
  "end_lineno": 135,
  "end_col": 17,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "indexing/index_lifecycle.py",
  "module": "indexing.index_lifecycle",
  "qualname": "collect_asset_attrs",
  "name": "collect_asset_attrs",
  "node_type": "FunctionDef",
  "lineno": 138,
  "col": 0,
  "end_lineno": 169,
  "end_col": 16,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return manifest attributes derived from staged asset sidecars.\n\nThis function aggregates metadata from staged index assets (FAISS index, ID map,\ntuning profile) and builds a dictionary of attributes suitable for inclusion in\nthe version manifest. The function extracts factory strings, parameter spaces,\nand tuning information from asset sidecar files.\n\nParameters\n----------\nassets : IndexAssets\n    Staged index assets containing paths to FAISS index, ID map, and tuning\n    profile files. The function reads metadata from .meta.json files and\n    extracts attributes from ID map and tuning profile sidecars.\n\nReturns\n-------\ndict[str, object]\n    Aggregated FAISS metadata dictionary containing factory string, parameter\n    space, tuning parameters, and other index configuration attributes. The\n    dictionary is suitable for serialization in version.json manifests.",
  "is_public": true
}
{
  "path": "indexing/index_lifecycle.py",
  "module": "indexing.index_lifecycle",
  "qualname": "_attrs_from_meta",
  "name": "_attrs_from_meta",
  "node_type": "FunctionDef",
  "lineno": 172,
  "col": 0,
  "end_lineno": 192,
  "end_col": 16,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "indexing/index_lifecycle.py",
  "module": "indexing.index_lifecycle",
  "qualname": "_attrs_from_idmap",
  "name": "_attrs_from_idmap",
  "node_type": "FunctionDef",
  "lineno": 195,
  "col": 0,
  "end_lineno": 198,
  "end_col": 63,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "indexing/index_lifecycle.py",
  "module": "indexing.index_lifecycle",
  "qualname": "_attrs_from_tuning",
  "name": "_attrs_from_tuning",
  "node_type": "FunctionDef",
  "lineno": 201,
  "col": 0,
  "end_lineno": 218,
  "end_col": 16,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "indexing/index_lifecycle.py",
  "module": "indexing.index_lifecycle",
  "qualname": "VersionMeta",
  "name": "VersionMeta",
  "node_type": "ClassDef",
  "lineno": 222,
  "col": 0,
  "end_lineno": 244,
  "end_col": 9,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Metadata recorded for each version directory.",
  "is_public": true
}
{
  "path": "indexing/index_lifecycle.py",
  "module": "indexing.index_lifecycle",
  "qualname": "VersionMeta.to_json",
  "name": "to_json",
  "node_type": "FunctionDef",
  "lineno": 229,
  "col": 4,
  "end_lineno": 244,
  "end_col": 9,
  "parent_qualname": "VersionMeta",
  "decorators": [],
  "bases": [],
  "docstring": "Return a JSON payload suitable for writing to disk.\n\nReturns\n-------\nstr\n    JSON representation of the manifest.",
  "is_public": true
}
{
  "path": "indexing/index_lifecycle.py",
  "module": "indexing.index_lifecycle",
  "qualname": "IndexLifecycleManager",
  "name": "IndexLifecycleManager",
  "node_type": "ClassDef",
  "lineno": 247,
  "col": 0,
  "end_lineno": 750,
  "end_col": 19,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Manage staged/published index versions under a base directory.",
  "is_public": true
}
{
  "path": "indexing/index_lifecycle.py",
  "module": "indexing.index_lifecycle",
  "qualname": "IndexLifecycleManager.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 250,
  "col": 4,
  "end_lineno": 255,
  "end_col": 60,
  "parent_qualname": "IndexLifecycleManager",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "indexing/index_lifecycle.py",
  "module": "indexing.index_lifecycle",
  "qualname": "IndexLifecycleManager.current_version",
  "name": "current_version",
  "node_type": "FunctionDef",
  "lineno": 258,
  "col": 4,
  "end_lineno": 270,
  "end_col": 30,
  "parent_qualname": "IndexLifecycleManager",
  "decorators": [],
  "bases": [],
  "docstring": "Return the currently published version identifier.\n\nReturns\n-------\nstr | None\n    Version identifier or ``None`` when unset.",
  "is_public": true
}
{
  "path": "indexing/index_lifecycle.py",
  "module": "indexing.index_lifecycle",
  "qualname": "IndexLifecycleManager.current_dir",
  "name": "current_dir",
  "node_type": "FunctionDef",
  "lineno": 272,
  "col": 4,
  "end_lineno": 286,
  "end_col": 19,
  "parent_qualname": "IndexLifecycleManager",
  "decorators": [],
  "bases": [],
  "docstring": "Return the directory backing the active version.\n\nReturns\n-------\nPath | None\n    Directory containing the current manifest, if present.",
  "is_public": true
}
{
  "path": "indexing/index_lifecycle.py",
  "module": "indexing.index_lifecycle",
  "qualname": "IndexLifecycleManager.open_current",
  "name": "open_current",
  "node_type": "FunctionDef",
  "lineno": 288,
  "col": 4,
  "end_lineno": 312,
  "end_col": 25,
  "parent_qualname": "IndexLifecycleManager",
  "decorators": [],
  "bases": [],
  "docstring": "Return the active version directory, validating manifest presence.\n\nThis method resolves the currently active index version directory and ensures\nthat a valid manifest file exists at that location. It is used by index\nmanagement operations that require access to the active version's assets.\n\nReturns\n-------\nPath\n    Path to the active version directory containing validated manifest and\n    index assets.\n\nRaises\n------\nRuntimeLifecycleError\n    If no CURRENT version is set or if the manifest file cannot be resolved\n    at the active directory path.",
  "is_public": true
}
{
  "path": "indexing/index_lifecycle.py",
  "module": "indexing.index_lifecycle",
  "qualname": "IndexLifecycleManager.list_versions",
  "name": "list_versions",
  "node_type": "FunctionDef",
  "lineno": 314,
  "col": 4,
  "end_lineno": 328,
  "end_col": 23,
  "parent_qualname": "IndexLifecycleManager",
  "decorators": [],
  "bases": [],
  "docstring": "Return the list of committed versions (excludes staging dirs).\n\nReturns\n-------\nlist[str]\n    Sorted set of published version identifiers.",
  "is_public": true
}
{
  "path": "indexing/index_lifecycle.py",
  "module": "indexing.index_lifecycle",
  "qualname": "IndexLifecycleManager.read_assets",
  "name": "read_assets",
  "node_type": "FunctionDef",
  "lineno": 330,
  "col": 4,
  "end_lineno": 376,
  "end_col": 21,
  "parent_qualname": "IndexLifecycleManager",
  "decorators": [],
  "bases": [],
  "docstring": "Return paths for active assets or ``None`` when unset.\n\nThis method reads the manifest file from the active version directory and\nconstructs an IndexAssets object containing paths to FAISS index, DuckDB\ncatalog, and SCIP index files. Used by runtime components to locate index\nassets when loading or reloading indices.\n\nReturns\n-------\nIndexAssets | None\n    Asset set for the active version containing paths to FAISS index,\n    DuckDB catalog, and SCIP index files, or ``None`` if no active version\n    is set.\n\nNotes\n-----\nThe method does not raise RuntimeLifecycleError directly, but\n``_resolve_manifest_path`` may raise it if the manifest is missing or\ninconsistent. This is documented for completeness, though the exception\nis not explicitly raised in this method's body.",
  "is_public": true
}
{
  "path": "indexing/index_lifecycle.py",
  "module": "indexing.index_lifecycle",
  "qualname": "IndexLifecycleManager.write_embedding_metadata",
  "name": "write_embedding_metadata",
  "node_type": "FunctionDef",
  "lineno": 378,
  "col": 4,
  "end_lineno": 417,
  "end_col": 19,
  "parent_qualname": "IndexLifecycleManager",
  "decorators": [],
  "bases": [],
  "docstring": "Persist ``embedding_meta.json`` into the requested version directory.\n\nParameters\n----------\npayload : Mapping[str, object]\n    JSON-serialisable metadata describing the embeddings.\nversion : str | None, optional\n    Version identifier to target. When omitted, writes to the current\n    version directory.\n\nReturns\n-------\nPath\n    Filesystem path to the written metadata file.\n\nRaises\n------\nRuntimeLifecycleError\n    If no suitable version directory exists.",
  "is_public": true
}
{
  "path": "indexing/index_lifecycle.py",
  "module": "indexing.index_lifecycle",
  "qualname": "IndexLifecycleManager.prepare",
  "name": "prepare",
  "node_type": "FunctionDef",
  "lineno": 420,
  "col": 4,
  "end_lineno": 504,
  "end_col": 26,
  "parent_qualname": "IndexLifecycleManager",
  "decorators": [],
  "bases": [],
  "docstring": "Copy assets into a staging directory for ``version``.\n\nExtended Summary\n----------------\nThis method stages index assets for a new version by copying FAISS index,\nDuckDB catalog, SCIP index, and optional sparse indexes (BM25, SPLADE, XTR)\ninto a versioned staging directory. It validates asset existence, creates\nversion metadata, and prepares the staging area for atomic publication.\nUsed as the first step in the index publication workflow.\n\nParameters\n----------\nversion : str\n    Version identifier (e.g., \"v1.2.3\") for the staged assets. Must be\n    non-empty and unique (staging directory must not exist).\nassets : IndexAssets\n    Index assets to stage, including paths to FAISS index, DuckDB catalog,\n    SCIP index, and optional sparse index directories. All required assets\n    must exist on the filesystem.\nattrs : Mapping[str, Any] | None, optional\n    Optional metadata attributes to include in version metadata. If None,\n    uses empty dict. Attributes are persisted in version.json.\n\nReturns\n-------\nPath\n    Directory containing the staged assets. The directory name follows\n    the pattern \"{version}.staging\" and contains all copied assets plus\n    version.json metadata.\n\nRaises\n------\nRuntimeLifecycleError\n    If validation fails (empty version, missing assets) or staging already\n    exists (concurrent staging attempt).\n\nNotes\n-----\nThis method performs atomic staging by creating the staging directory and\ncopying all assets. If any copy operation fails, the staging directory\nmay be left in an incomplete state. The staging directory must be published\nor cleaned up manually. Time complexity: O(asset_count * file_size) for\nfile copy operations.",
  "is_public": true
}
{
  "path": "indexing/index_lifecycle.py",
  "module": "indexing.index_lifecycle",
  "qualname": "IndexLifecycleManager.write_attrs",
  "name": "write_attrs",
  "node_type": "FunctionDef",
  "lineno": 506,
  "col": 4,
  "end_lineno": 548,
  "end_col": 28,
  "parent_qualname": "IndexLifecycleManager",
  "decorators": [],
  "bases": [],
  "docstring": "Merge additional attributes into the lifecycle manifest.\n\nThis method updates the version manifest file by merging additional\nattributes into the existing attrs dictionary. The method reads the\ncurrent manifest, merges the provided attributes, and writes the\nupdated manifest back to disk. Used to add metadata to staged or\npublished versions.\n\nParameters\n----------\nversion : str\n    Version identifier for the manifest to update (e.g., \"v1.0.0\").\n    The version must exist in the versions directory and have a\n    manifest file.\n**attrs : object\n    Additional attributes to merge into the manifest's attrs dictionary.\n    Attributes are merged using dict.update(), with new values overriding\n    existing ones. All attributes must be JSON-serializable.\n\nReturns\n-------\nPath\n    Path to the updated manifest file (versions_dir / version / MANIFEST_FILE).\n    The manifest has been updated with merged attributes and written to disk.\n\nRaises\n------\nRuntimeLifecycleError\n    Raised when the manifest file is missing for the specified version.\n    The error includes the expected manifest path for debugging.",
  "is_public": true
}
{
  "path": "indexing/index_lifecycle.py",
  "module": "indexing.index_lifecycle",
  "qualname": "IndexLifecycleManager.publish",
  "name": "publish",
  "node_type": "FunctionDef",
  "lineno": 550,
  "col": 4,
  "end_lineno": 599,
  "end_col": 24,
  "parent_qualname": "IndexLifecycleManager",
  "decorators": [],
  "bases": [],
  "docstring": "Atomically promote a staged directory to active ``version``.\n\nExtended Summary\n----------------\nThis method atomically publishes a staged index version by creating a\nversioned directory, moving staged assets, updating the CURRENT symlink,\nand updating the lifecycle manifest. The operation is atomic: if any step\nfails, the previous version remains active. Used to deploy new index versions\nin production after staging completes.\n\nParameters\n----------\nversion : str\n    Version identifier of the staged directory to publish (e.g., \"v1.2.3\").\n    The staging directory \"{version}.staging\" must exist and contain valid\n    assets.\n\nReturns\n-------\nPath\n    Directory containing the published assets. The directory name follows\n    the pattern \"{version}\" and becomes the active version via CURRENT symlink.\n\nRaises\n------\nRuntimeLifecycleError\n    If the requested staging area is missing, symlink creation fails, or\n    manifest update fails.\n\nNotes\n-----\nThis method performs atomic publication by creating the version directory,\nmoving staged assets, updating CURRENT symlink, and updating the manifest.\nThe operation is designed to be safe for concurrent access. Time complexity:\nO(1) for directory operations plus I/O time for symlink and manifest updates.",
  "is_public": true
}
{
  "path": "indexing/index_lifecycle.py",
  "module": "indexing.index_lifecycle",
  "qualname": "IndexLifecycleManager.rollback",
  "name": "rollback",
  "node_type": "FunctionDef",
  "lineno": 601,
  "col": 4,
  "end_lineno": 636,
  "end_col": 74,
  "parent_qualname": "IndexLifecycleManager",
  "decorators": [],
  "bases": [],
  "docstring": "Point the ``CURRENT`` pointer at an existing version.\n\nExtended Summary\n----------------\nThis method performs a rollback operation by updating the CURRENT symlink\nto point to a previously published version. It validates that the target\nversion exists, updates the symlink atomically, and updates the lifecycle\nmanifest. Used for rapid recovery from problematic index deployments without\nrequiring full re-publication.\n\nParameters\n----------\nversion : str\n    Version identifier to rollback to (e.g., \"v1.2.0\"). Must exist in the\n    published versions list (version directory must exist).\n\nRaises\n------\nRuntimeLifecycleError\n    If the requested version cannot be located (version directory missing),\n    symlink update fails, or manifest update fails.\n\nNotes\n-----\nThis method performs atomic rollback by updating the CURRENT symlink and\nmanifest. The operation is fast (O(1) symlink update) but requires the\ntarget version to exist. Time complexity: O(1) for symlink operations\nplus I/O time for manifest updates.",
  "is_public": true
}
{
  "path": "indexing/index_lifecycle.py",
  "module": "indexing.index_lifecycle",
  "qualname": "IndexLifecycleManager.link_lucene_assets",
  "name": "link_lucene_assets",
  "node_type": "FunctionDef",
  "lineno": 638,
  "col": 4,
  "end_lineno": 675,
  "end_col": 25,
  "parent_qualname": "IndexLifecycleManager",
  "decorators": [],
  "bases": [],
  "docstring": "Publish Lucene-only assets under ``version`` and flip CURRENT pointer.\n\nParameters\n----------\nversion : str\n    Version identifier that should become active.\nassets : LuceneAssets\n    Collection of Lucene directories to copy into the lifecycle root.\n\nReturns\n-------\nPath\n    Path to the published version directory.\n\nRaises\n------\nRuntimeLifecycleError\n    If any of the source directories are missing.",
  "is_public": true
}
{
  "path": "indexing/index_lifecycle.py",
  "module": "indexing.index_lifecycle",
  "qualname": "IndexLifecycleManager._write_current_pointer",
  "name": "_write_current_pointer",
  "node_type": "FunctionDef",
  "lineno": 678,
  "col": 4,
  "end_lineno": 685,
  "end_col": 78,
  "parent_qualname": "IndexLifecycleManager",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "indexing/index_lifecycle.py",
  "module": "indexing.index_lifecycle",
  "qualname": "IndexLifecycleManager._maybe_dir",
  "name": "_maybe_dir",
  "node_type": "FunctionDef",
  "lineno": 688,
  "col": 4,
  "end_lineno": 689,
  "end_col": 46,
  "parent_qualname": "IndexLifecycleManager",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "indexing/index_lifecycle.py",
  "module": "indexing.index_lifecycle",
  "qualname": "IndexLifecycleManager._maybe_file",
  "name": "_maybe_file",
  "node_type": "FunctionDef",
  "lineno": 692,
  "col": 4,
  "end_lineno": 693,
  "end_col": 46,
  "parent_qualname": "IndexLifecycleManager",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "indexing/index_lifecycle.py",
  "module": "indexing.index_lifecycle",
  "qualname": "IndexLifecycleManager._copy_file",
  "name": "_copy_file",
  "node_type": "FunctionDef",
  "lineno": 696,
  "col": 4,
  "end_lineno": 698,
  "end_col": 30,
  "parent_qualname": "IndexLifecycleManager",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "indexing/index_lifecycle.py",
  "module": "indexing.index_lifecycle",
  "qualname": "IndexLifecycleManager._copy_tree",
  "name": "_copy_tree",
  "node_type": "FunctionDef",
  "lineno": 701,
  "col": 4,
  "end_lineno": 706,
  "end_col": 54,
  "parent_qualname": "IndexLifecycleManager",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "indexing/index_lifecycle.py",
  "module": "indexing.index_lifecycle",
  "qualname": "IndexLifecycleManager._copy_optional_file",
  "name": "_copy_optional_file",
  "node_type": "FunctionDef",
  "lineno": 709,
  "col": 4,
  "end_lineno": 715,
  "end_col": 30,
  "parent_qualname": "IndexLifecycleManager",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "indexing/index_lifecycle.py",
  "module": "indexing.index_lifecycle",
  "qualname": "IndexLifecycleManager._resolve_manifest_path",
  "name": "_resolve_manifest_path",
  "node_type": "FunctionDef",
  "lineno": 718,
  "col": 4,
  "end_lineno": 731,
  "end_col": 62,
  "parent_qualname": "IndexLifecycleManager",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "indexing/index_lifecycle.py",
  "module": "indexing.index_lifecycle",
  "qualname": "IndexLifecycleManager._locate_sidecar",
  "name": "_locate_sidecar",
  "node_type": "FunctionDef",
  "lineno": 734,
  "col": 4,
  "end_lineno": 750,
  "end_col": 19,
  "parent_qualname": "IndexLifecycleManager",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "indexing/scip_reader.py",
  "module": "indexing.scip_reader",
  "qualname": "indexing.scip_reader",
  "name": "indexing.scip_reader",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "SCIP index reader for extracting symbol definitions and ranges.\n\nParses index.scip (protobuf) or index.scip.json and extracts symbol definitions\nwith precise ranges for chunking and code intelligence.",
  "is_public": true
}
{
  "path": "indexing/scip_reader.py",
  "module": "indexing.scip_reader",
  "qualname": "_range_from_list",
  "name": "_range_from_list",
  "node_type": "FunctionDef",
  "lineno": 24,
  "col": 0,
  "end_lineno": 33,
  "end_col": 27,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "indexing/scip_reader.py",
  "module": "indexing.scip_reader",
  "qualname": "_parse_occurrence",
  "name": "_parse_occurrence",
  "node_type": "FunctionDef",
  "lineno": 36,
  "col": 0,
  "end_lineno": 62,
  "end_col": 42,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "indexing/scip_reader.py",
  "module": "indexing.scip_reader",
  "qualname": "Range",
  "name": "Range",
  "node_type": "ClassDef",
  "lineno": 66,
  "col": 0,
  "end_lineno": 98,
  "end_col": 22,
  "parent_qualname": null,
  "decorators": [
    "dataclass(frozen=True)"
  ],
  "bases": [],
  "docstring": "Source code range with line and character positions.\n\nRepresents a contiguous region of source code using line and character\ncoordinates. This matches the SCIP/LSP range format, which uses 0-indexed\nlines and characters (columns).\n\nRanges are used to precisely identify symbol definitions and occurrences\nin source files. They can be converted to byte offsets for text extraction\nusing the line_starts() helper function.\n\nAttributes\n----------\nstart_line : int\n    Starting line number (0-indexed). The first line of a file is line 0.\n    Used with start_character to identify the start position.\nstart_character : int\n    Starting character/column position (0-indexed) within start_line.\n    Character 0 is the first character on the line. Used for precise\n    positioning within a line.\nend_line : int\n    Ending line number (0-indexed, inclusive). The range spans from\n    start_line to end_line (inclusive).\nend_character : int\n    Ending character/column position (0-indexed, exclusive) within end_line.\n    The range includes characters from start_character up to (but not\n    including) end_character. This matches LSP/SCIP convention.",
  "is_public": true
}
{
  "path": "indexing/scip_reader.py",
  "module": "indexing.scip_reader",
  "qualname": "Occurrence",
  "name": "Occurrence",
  "node_type": "ClassDef",
  "lineno": 101,
  "col": 0,
  "end_lineno": 131,
  "end_col": 18,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "msgspec.Struct"
  ],
  "docstring": "Symbol occurrence in source code.\n\nRepresents a single occurrence of a symbol (definition, reference, etc.)\nwithin a source file. Occurrences are extracted from SCIP indexes and\nused to build symbol-to-location mappings.\n\nThe range is stored as a tuple for efficient serialization, matching the\nSCIP JSON format. The roles field uses bit flags to indicate the type\nof occurrence (definition, reference, etc.).\n\nAttributes\n----------\nsymbol : str\n    SCIP symbol identifier string. Format depends on language (e.g.,\n    \"python kgfoundry.core#Function.main\" for Python). Used to link\n    occurrences to symbol definitions.\nrange : tuple[int, int, int, int]\n    Source code range as (start_line, start_character, end_line, end_character).\n    All values are 0-indexed. The range is inclusive at start, exclusive\n    at end (matching LSP convention). Stored as tuple for JSON compatibility.\nroles : int\n    Role bitmask indicating the type of occurrence. Bit 0 (LSB) = Definition,\n    other bits indicate references, implementations, etc. Defaults to 0\n    (unknown/unspecified role). Use bitwise AND to check roles:\n    `(occ.roles & 1) != 0` checks for definition.",
  "is_public": true
}
{
  "path": "indexing/scip_reader.py",
  "module": "indexing.scip_reader",
  "qualname": "Document",
  "name": "Document",
  "node_type": "ClassDef",
  "lineno": 134,
  "col": 0,
  "end_lineno": 163,
  "end_col": 44,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "msgspec.Struct"
  ],
  "docstring": "SCIP document representing a source file.\n\nA Document represents a single source file that has been indexed by SCIP.\nIt contains all symbol occurrences (definitions and references) found in\nthat file, along with metadata about the file's language and path.\n\nDocuments are immutable and designed for efficient serialization to/from\nJSON. They are the building blocks of a SCIPIndex.\n\nAttributes\n----------\nrelative_path : str\n    File path relative to the repository root. This matches the path format\n    used in SCIP indexes and is used to locate files during indexing and\n    search. Should use forward slashes even on Windows.\nlanguage : str\n    Programming language identifier (e.g., \"python\", \"typescript\", \"go\").\n    Used to filter files by language and apply language-specific processing.\n    Matches SCIP language identifiers.\noccurrences : tuple[Occurrence, ...]\n    All symbol occurrences found in this document. Includes both definitions\n    (where symbols are defined) and references (where symbols are used).\n    Empty tuple if no symbols found. Stored as tuple for immutability and\n    efficient serialization.",
  "is_public": true
}
{
  "path": "indexing/scip_reader.py",
  "module": "indexing.scip_reader",
  "qualname": "SCIPIndex",
  "name": "SCIPIndex",
  "node_type": "ClassDef",
  "lineno": 166,
  "col": 0,
  "end_lineno": 185,
  "end_col": 40,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "msgspec.Struct"
  ],
  "docstring": "SCIP index containing all indexed documents.\n\nThe root structure of a SCIP index, containing all documents (source files)\nthat have been indexed. This is the top-level object returned by parse_scip_json()\nand is used to extract symbol definitions and build the code intelligence index.\n\nThe index is immutable and can be safely shared across threads. It's designed\nfor efficient serialization to/from JSON format.\n\nAttributes\n----------\ndocuments : tuple[Document, ...]\n    All indexed documents (source files) in the repository. Each document\n    contains symbol occurrences for one file. Empty tuple if no documents\n    indexed. Documents are typically sorted by relative_path for consistent\n    ordering.",
  "is_public": true
}
{
  "path": "indexing/scip_reader.py",
  "module": "indexing.scip_reader",
  "qualname": "SymbolDef",
  "name": "SymbolDef",
  "node_type": "ClassDef",
  "lineno": 189,
  "col": 0,
  "end_lineno": 222,
  "end_col": 17,
  "parent_qualname": null,
  "decorators": [
    "dataclass(frozen=True)"
  ],
  "bases": [],
  "docstring": "Extracted symbol definition with location information.\n\nRepresents a single symbol definition extracted from a SCIP index. This is\nthe processed form of an Occurrence with role=Definition, converted to\na more convenient format for chunking and indexing.\n\nSymbolDef objects are used by the cAST chunker to create structure-aware\nchunks that respect symbol boundaries. They're also used for symbol search\nand \"go to definition\" functionality.\n\nAttributes\n----------\nsymbol : str\n    SCIP symbol identifier string (e.g., \"python kgfoundry.core#Function.main\").\n    Uniquely identifies the symbol across the entire codebase. Used for\n    cross-references and symbol search.\npath : str\n    File path where this symbol is defined. Typically a relative path from\n    the repository root, matching the Document.relative_path format.\nrange : Range\n    Precise source code range where the symbol is defined. Includes start\n    and end line/character positions. Used for exact location navigation\n    and text extraction.\nlanguage : str\n    Programming language of the file containing this symbol (e.g., \"python\").\n    Used for language-specific processing and filtering. Matches the\n    Document.language value.",
  "is_public": true
}
{
  "path": "indexing/scip_reader.py",
  "module": "indexing.scip_reader",
  "qualname": "parse_scip_json",
  "name": "parse_scip_json",
  "node_type": "FunctionDef",
  "lineno": 225,
  "col": 0,
  "end_lineno": 286,
  "end_col": 48,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Parse SCIP index from JSON export.\n\nReads and parses a SCIP index that has been exported to JSON format.\nThe JSON format is more convenient than the binary protobuf format for\nPython processing and debugging.\n\nThe function handles various SCIP JSON formats (different versions may have\nslightly different field names) and converts them to the canonical SCIPIndex\nstructure. It extracts documents and their occurrences, converting range\nformats (array vs object) to the standard tuple format.\n\nParameters\n----------\njson_path : Path\n    Path to the index.scip.json file. This is typically generated by\n    exporting a binary SCIP index using the SCIP CLI tool.\n\nReturns\n-------\nSCIPIndex\n    Parsed SCIP index containing all documents and their symbol occurrences.\n    The index is ready for use with extract_definitions() and other processing\n    functions.\n\nNotes\n-----\nThe function gracefully handles missing or malformed data:\n- Documents without relative_path are skipped\n- Occurrences without symbols are skipped\n- Invalid range formats are skipped\n- Missing fields use empty defaults\n\nThe function does not raise exceptions for parsing errors - it silently\nskips invalid entries to ensure robust processing of partial indexes.",
  "is_public": true
}
{
  "path": "indexing/scip_reader.py",
  "module": "indexing.scip_reader",
  "qualname": "extract_definitions",
  "name": "extract_definitions",
  "node_type": "FunctionDef",
  "lineno": 289,
  "col": 0,
  "end_lineno": 336,
  "end_col": 17,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Extract symbol definitions from SCIP index.\n\nYields definition occurrences (roles & 1 != 0) or first occurrence per symbol\nas fallback.\n\nParameters\n----------\nindex : SCIPIndex\n    Parsed SCIP index.\n\nYields\n------\nSymbolDef\n    Symbol definition with range.",
  "is_public": true
}
{
  "path": "indexing/scip_reader.py",
  "module": "indexing.scip_reader",
  "qualname": "get_top_level_definitions",
  "name": "get_top_level_definitions",
  "node_type": "FunctionDef",
  "lineno": 339,
  "col": 0,
  "end_lineno": 409,
  "end_col": 89,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Filter to top-level definitions (not nested inside others).\n\nParameters\n----------\ndefinitions : list[SymbolDef]\n    All symbol definitions for a file.\n\nReturns\n-------\nlist[SymbolDef]\n    Top-level definitions only.",
  "is_public": true
}
{
  "path": "indexing/scip_reader.py",
  "module": "indexing.scip_reader",
  "qualname": "get_top_level_definitions.contains",
  "name": "contains",
  "node_type": "FunctionDef",
  "lineno": 354,
  "col": 4,
  "end_lineno": 401,
  "end_col": 9,
  "parent_qualname": "get_top_level_definitions",
  "decorators": [],
  "bases": [],
  "docstring": "Check if def1's range contains def2's range (proper containment).\n\nExtended Summary\n----------------\nDetermines whether def1's source code range properly contains def2's range,\nmeaning def2 is nested inside def1. This is used to filter out nested\ndefinitions (e.g., methods inside classes, inner functions) to identify\nonly top-level definitions. Proper containment means def1's range encloses\ndef2's range but they are not identical.\n\nParameters\n----------\ndef1 : SymbolDef\n    Outer symbol definition candidate. Its range is checked to see if it\n    contains def2's range.\ndef2 : SymbolDef\n    Inner symbol definition candidate. Its range is checked to see if it\n    is contained within def1's range.\n\nReturns\n-------\nbool\n    True if def1's range properly contains def2's range (def2 is nested\n    inside def1), False otherwise. Returns False if ranges are identical\n    or def2 is not contained.\n\nNotes\n-----\nTime complexity O(1) - simple range comparison. Space complexity O(1).\nNo I/O or side effects. Proper containment means:\n- def1.start_line <= def2.start_line\n- def1.end_line >= def2.end_line\n- Ranges are not identical (different start/end positions)\nThis ensures nested definitions (methods, inner functions) are filtered\nout, leaving only top-level definitions.",
  "is_public": true
}
{
  "path": "indexing/xtr_build.py",
  "module": "indexing.xtr_build",
  "qualname": "indexing.xtr_build",
  "name": "indexing.xtr_build",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Utilities for building and verifying XTR token indexes.",
  "is_public": true
}
{
  "path": "indexing/xtr_build.py",
  "module": "indexing.xtr_build",
  "qualname": "XTRBuildSummary",
  "name": "XTRBuildSummary",
  "node_type": "ClassDef",
  "lineno": 28,
  "col": 0,
  "end_lineno": 36,
  "end_col": 18,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Metadata describing a freshly built XTR token index.",
  "is_public": true
}
{
  "path": "indexing/xtr_build.py",
  "module": "indexing.xtr_build",
  "qualname": "_iter_chunk_text",
  "name": "_iter_chunk_text",
  "node_type": "FunctionDef",
  "lineno": 39,
  "col": 0,
  "end_lineno": 83,
  "end_col": 55,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Yield (chunk_id, content) pairs from the DuckDB catalog.\n\nExtended Summary\n----------------\nThis generator function efficiently streams chunk data from the DuckDB catalog\nin batches to minimize memory usage. It queries the chunks table ordered by ID,\nfetches rows in configurable batch sizes, and yields (chunk_id, content) tuples.\nThis is used during XTR index building to process chunks incrementally without\nloading the entire catalog into memory.\n\nParameters\n----------\ncatalog : DuckDBCatalog\n    DuckDB catalog instance containing the chunks table. The catalog connection\n    is opened within this function and closed when iteration completes.\nbatch_size : int, optional\n    Number of rows to fetch per database query. Larger batches reduce query\n    overhead but increase memory usage. Defaults to 1024.\n\nYields\n------\ntuple[int, str]\n    Chunk identifier and raw content string. Chunks with None IDs are skipped.\n    Empty content strings are converted to empty strings.\n\nNotes\n-----\nTime complexity O(N) where N is total chunk count, amortized across batch queries.\nSpace complexity O(batch_size) for temporary row storage. The function performs\ndatabase I/O and manages catalog connection lifecycle. Thread-safe if catalog\nconnection is thread-safe. Chunks are yielded in ID order.",
  "is_public": false
}
{
  "path": "indexing/xtr_build.py",
  "module": "indexing.xtr_build",
  "qualname": "_gather_chunk_vectors",
  "name": "_gather_chunk_vectors",
  "node_type": "FunctionDef",
  "lineno": 86,
  "col": 0,
  "end_lineno": 154,
  "end_col": 61,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Collect encoded vectors and offsets for all chunks.\n\nExtended Summary\n----------------\nThis function processes all chunks from the catalog, encodes their text content\ninto token-level embeddings using the XTR index encoder, and collects the\nresulting vectors along with metadata (chunk IDs, offsets, lengths). The vectors\nare converted to the specified dtype for memory efficiency. This is a core step\nin XTR index building, transforming raw chunk text into the token embeddings\nthat will be stored in the memory-mapped index.\n\nParameters\n----------\nindex : XTRIndex\n    XTR index instance used for encoding chunk text into token embeddings.\n    The index's encode_query_tokens method is called for each chunk.\ncatalog : DuckDBCatalog\n    DuckDB catalog containing chunks to encode. Chunks are iterated via\n    _iter_chunk_text helper.\ndtype : np.dtype[Any]\n    NumPy dtype for the encoded vectors (typically float32 or float16).\n    Vectors are cast to this dtype after encoding to reduce memory usage.\n\nReturns\n-------\ntuple[list[NDArrayAny], list[int], list[int], list[int], int]\n    Five-element tuple containing:\n    - List of token embedding arrays, one per chunk\n    - List of chunk IDs corresponding to each buffer\n    - List of token offsets (cumulative token count before each chunk)\n    - List of token lengths (number of tokens per chunk)\n    - Total token count across all chunks\n\nNotes\n-----\nTime complexity O(N * T * D) where N is chunk count, T is average tokens per\nchunk, and D is embedding dimension. Space complexity O(N * T * D) for all\nbuffers. The function performs I/O to read chunks from catalog and GPU/CPU\ncomputation for encoding. Thread-safe if index encoder is thread-safe.\nDimension mismatches are logged as warnings but processing continues.",
  "is_public": false
}
{
  "path": "indexing/xtr_build.py",
  "module": "indexing.xtr_build",
  "qualname": "_write_token_matrix",
  "name": "_write_token_matrix",
  "node_type": "FunctionDef",
  "lineno": 157,
  "col": 0,
  "end_lineno": 224,
  "end_col": 21,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Persist buffered token vectors to memmap storage.\n\nExtended Summary\n----------------\nThis function writes token embedding vectors to a memory-mapped NumPy array file\nfor efficient random access during XTR search. It creates a memmap file with the\nspecified shape and dtype, then copies vectors from the input buffers into the\nmemmap in order. Vectors are truncated or zero-padded to match the target dimension.\nThe resulting file can be memory-mapped read-only for fast access during search\noperations without loading the entire index into RAM.\n\nParameters\n----------\nbuffers : Sequence[NDArrayAny]\n    Sequence of token embedding arrays, one per chunk. Each array has shape\n    (tokens_per_chunk, embedding_dim). Arrays are concatenated in order.\ndtype : np.dtype[Any]\n    NumPy dtype for the memmap file (typically float32 or float16). Determines\n    file size and precision trade-off.\ndim : int\n    Target embedding dimension for the memmap. Vectors are truncated or\n    zero-padded to this dimension. Must match the XTR index configuration.\nroot : Path\n    Directory path where the token matrix file will be written. The directory\n    must exist or be creatable.\ntotal_tokens : int\n    Total number of tokens across all buffers. Used to allocate the memmap\n    shape as (total_tokens, dim).\n\nReturns\n-------\nPath\n    Path to the persisted token matrix file. Filename is \"tokens.f32\" for\n    float32 or \"tokens.f16\" for float16, based on dtype.\n\nNotes\n-----\nTime complexity O(N * D) where N is total_tokens and D is dim, due to memmap\nwrites. Space complexity O(N * D) for the memmap file on disk. The function\nperforms file I/O and flushes the memmap to ensure data is persisted. Thread-safe\nif buffers are not modified concurrently. Vectors shorter than dim are zero-padded;\nvectors longer than dim are truncated.",
  "is_public": false
}
{
  "path": "indexing/xtr_build.py",
  "module": "indexing.xtr_build",
  "qualname": "build_xtr_index",
  "name": "build_xtr_index",
  "node_type": "FunctionDef",
  "lineno": 227,
  "col": 0,
  "end_lineno": 327,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Build XTR token artifacts from DuckDB chunks.\n\nExtended Summary\n----------------\nThis function orchestrates the complete XTR index building process, reading chunks\nfrom the DuckDB catalog, encoding them into token-level embeddings, and persisting\nthe results as memory-mapped files. It creates the XTR index directory structure,\nencodes all chunks using the configured XTR model, writes token embeddings and\nmetadata, and returns a summary of the generated artifacts. This is the primary\nentry point for building XTR indexes from existing chunk data.\n\nParameters\n----------\nsettings : Settings | None, optional\n    Application settings containing XTR configuration, paths, and model settings.\n    If None, settings are loaded from the default location. Defaults to None.\n\nReturns\n-------\nXTRBuildSummary\n    Summary describing the generated artifacts, including chunk count, token count,\n    embedding dimension, dtype, and file paths for the token matrix and metadata.\n\nRaises\n------\nRuntimeError\n    If no chunks are available to encode in the catalog. This indicates the\n    catalog is empty or chunks table is missing, and index building cannot proceed.\n\nNotes\n-----\nTime complexity O(N * T * D) where N is chunk count, T is average tokens per\nchunk, and D is embedding dimension. Space complexity O(N * T * D) for buffers\nand memmap files. The function performs database I/O, GPU/CPU encoding computation,\nand file I/O. Not thread-safe due to catalog and file system operations.\nThe function creates the XTR directory if it doesn't exist.",
  "is_public": true
}
{
  "path": "indexing/xtr_build.py",
  "module": "indexing.xtr_build",
  "qualname": "main",
  "name": "main",
  "node_type": "FunctionDef",
  "lineno": 330,
  "col": 0,
  "end_lineno": 341,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Entry point allowing ``python -m codeintel_rev.indexing.xtr_build``.",
  "is_public": true
}
{
  "path": "io/__init__.py",
  "module": "io",
  "qualname": "io",
  "name": "io",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Storage and external service adapters for CodeIntel MCP.",
  "is_public": true
}
{
  "path": "io/__init__.py",
  "module": "io",
  "qualname": "__getattr__",
  "name": "__getattr__",
  "node_type": "FunctionDef",
  "lineno": 80,
  "col": 0,
  "end_lineno": 106,
  "end_col": 16,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Resolve exports lazily to avoid importing heavy adapter modules at import time.\n\nParameters\n----------\nname : str\n    Export requested by the caller.\n\nReturns\n-------\nobject\n    Attribute resolved from the target adapter module.\n\nRaises\n------\nAttributeError\n    If the requested export is unknown.",
  "is_public": false
}
{
  "path": "io/__init__.py",
  "module": "io",
  "qualname": "__dir__",
  "name": "__dir__",
  "node_type": "FunctionDef",
  "lineno": 109,
  "col": 0,
  "end_lineno": 110,
  "end_col": 48,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/bm25_manager.py",
  "module": "io.bm25_manager",
  "qualname": "io.bm25_manager",
  "name": "io.bm25_manager",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "BM25 indexing workflow helpers.",
  "is_public": true
}
{
  "path": "io/bm25_manager.py",
  "module": "io.bm25_manager",
  "qualname": "BM25CorpusMetadata",
  "name": "BM25CorpusMetadata",
  "node_type": "ClassDef",
  "lineno": 30,
  "col": 0,
  "end_lineno": 37,
  "end_col": 18,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "msgspec.Struct"
  ],
  "docstring": "Metadata describing a prepared BM25 corpus.",
  "is_public": true
}
{
  "path": "io/bm25_manager.py",
  "module": "io.bm25_manager",
  "qualname": "BM25CorpusSummary",
  "name": "BM25CorpusSummary",
  "node_type": "ClassDef",
  "lineno": 40,
  "col": 0,
  "end_lineno": 46,
  "end_col": 29,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "msgspec.Struct"
  ],
  "docstring": "Summary information returned after preparing a corpus.",
  "is_public": true
}
{
  "path": "io/bm25_manager.py",
  "module": "io.bm25_manager",
  "qualname": "BM25IndexMetadata",
  "name": "BM25IndexMetadata",
  "node_type": "ClassDef",
  "lineno": 49,
  "col": 0,
  "end_lineno": 60,
  "end_col": 18,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "msgspec.Struct"
  ],
  "docstring": "Metadata describing a built BM25 index.",
  "is_public": true
}
{
  "path": "io/bm25_manager.py",
  "module": "io.bm25_manager",
  "qualname": "BM25BuildOptions",
  "name": "BM25BuildOptions",
  "node_type": "ClassDef",
  "lineno": 63,
  "col": 0,
  "end_lineno": 72,
  "end_col": 26,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "msgspec.Struct"
  ],
  "docstring": "Options controlling BM25 index builds.",
  "is_public": true
}
{
  "path": "io/bm25_manager.py",
  "module": "io.bm25_manager",
  "qualname": "BM25IndexManager",
  "name": "BM25IndexManager",
  "node_type": "ClassDef",
  "lineno": 75,
  "col": 0,
  "end_lineno": 304,
  "end_col": 23,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Manage BM25 corpus preparation and Lucene index builds.",
  "is_public": true
}
{
  "path": "io/bm25_manager.py",
  "module": "io.bm25_manager",
  "qualname": "BM25IndexManager.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 78,
  "col": 4,
  "end_lineno": 82,
  "end_col": 36,
  "parent_qualname": "BM25IndexManager",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/bm25_manager.py",
  "module": "io.bm25_manager",
  "qualname": "BM25IndexManager.corpus_dir",
  "name": "corpus_dir",
  "node_type": "FunctionDef",
  "lineno": 85,
  "col": 4,
  "end_lineno": 87,
  "end_col": 81,
  "parent_qualname": "BM25IndexManager",
  "decorators": [
    "property"
  ],
  "bases": [],
  "docstring": "Return the resolved corpus JsonCollection directory.",
  "is_public": true
}
{
  "path": "io/bm25_manager.py",
  "module": "io.bm25_manager",
  "qualname": "BM25IndexManager.index_dir",
  "name": "index_dir",
  "node_type": "FunctionDef",
  "lineno": 90,
  "col": 4,
  "end_lineno": 92,
  "end_col": 75,
  "parent_qualname": "BM25IndexManager",
  "decorators": [
    "property"
  ],
  "bases": [],
  "docstring": "Return the resolved Lucene index directory.",
  "is_public": true
}
{
  "path": "io/bm25_manager.py",
  "module": "io.bm25_manager",
  "qualname": "BM25IndexManager.prepare_corpus",
  "name": "prepare_corpus",
  "node_type": "FunctionDef",
  "lineno": 94,
  "col": 4,
  "end_lineno": 204,
  "end_col": 9,
  "parent_qualname": "BM25IndexManager",
  "decorators": [],
  "bases": [],
  "docstring": "Materialize a Pyserini JsonCollection directory from a JSONL source.\n\nParameters\n----------\nsource : str | Path\n    Path to the JSONL corpus containing ``{\"id\": \"...\", \"contents\": ...}`` rows.\noutput_dir : str | Path | None, optional\n    Override the configured JsonCollection directory. If None, uses the\n    default corpus directory from configuration. The directory will be\n    created if it doesn't exist. Defaults to None.\noverwrite : bool, optional\n    When ``True`` (default) existing documents in the output directory are removed.\n\nReturns\n-------\nBM25CorpusSummary\n    Summary describing the prepared corpus and metadata location.\n\nRaises\n------\nFileNotFoundError\n    If ``source`` does not exist.\nValueError\n    If a document is missing required fields or duplicated.\nFileExistsError\n    If ``overwrite`` is ``False`` and the output directory already contains documents.",
  "is_public": true
}
{
  "path": "io/bm25_manager.py",
  "module": "io.bm25_manager",
  "qualname": "BM25IndexManager.build_index",
  "name": "build_index",
  "node_type": "FunctionDef",
  "lineno": 206,
  "col": 4,
  "end_lineno": 304,
  "end_col": 23,
  "parent_qualname": "BM25IndexManager",
  "decorators": [],
  "bases": [],
  "docstring": "Invoke Pyserini to build a Lucene BM25 index.\n\nParameters\n----------\noptions : BM25BuildOptions | None, optional\n    Build options. When omitted, defaults from configuration are used.\n\nReturns\n-------\nBM25IndexMetadata\n    Structured metadata describing the resulting Lucene index.\n\nRaises\n------\nFileNotFoundError\n    If the JsonCollection directory does not exist.\nFileExistsError\n    If ``overwrite`` is ``False`` and the index directory already contains data.",
  "is_public": true
}
{
  "path": "io/bm25_manager.py",
  "module": "io.bm25_manager",
  "qualname": "_write_struct",
  "name": "_write_struct",
  "node_type": "FunctionDef",
  "lineno": 307,
  "col": 0,
  "end_lineno": 311,
  "end_col": 65,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Write a msgspec struct to JSON with UTF-8 encoding.",
  "is_public": false
}
{
  "path": "io/bm25_manager.py",
  "module": "io.bm25_manager",
  "qualname": "_read_corpus_metadata",
  "name": "_read_corpus_metadata",
  "node_type": "FunctionDef",
  "lineno": 314,
  "col": 0,
  "end_lineno": 343,
  "end_col": 74,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Read corpus metadata from JSON file.\n\nThis helper function deserializes BM25 corpus metadata from a JSON file\ncreated during corpus preparation. The metadata contains information about\ndocument count, source path, content digest, preparation timestamp, and\ngenerator identifier.\n\nParameters\n----------\npath : Path\n    File path to the JSON metadata file. The file must exist and contain\n    valid BM25CorpusMetadata JSON serialized data.\n\nReturns\n-------\nBM25CorpusMetadata\n    Decoded metadata structure containing corpus statistics and provenance\n    information. Includes document count, source path, SHA-256 digest of\n    corpus content, ISO 8601 timestamp, and generator name.\n\nNotes\n-----\nException Propagation:\n    This function may propagate exceptions from underlying operations:\n    - FileNotFoundError: If the metadata file does not exist (from path.read_bytes())\n    - msgspec.DecodeError: If the file contains invalid JSON or data that doesn't\n      match the BM25CorpusMetadata schema (from msgspec.json.decode())",
  "is_public": false
}
{
  "path": "io/bm25_manager.py",
  "module": "io.bm25_manager",
  "qualname": "_parse_corpus_line",
  "name": "_parse_corpus_line",
  "node_type": "FunctionDef",
  "lineno": 346,
  "col": 0,
  "end_lineno": 420,
  "end_col": 31,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Parse and validate a JSONL line from the corpus source.\n\nThis function parses a single line from a JSONL corpus file, validates that\nit contains required fields (id and contents/text), checks for duplicate\ndocument IDs, and returns the parsed document identifier and content. Empty\nlines are skipped by returning None.\n\nThe function maintains a set of seen document IDs to detect duplicates within\nthe corpus, which is important for ensuring corpus integrity and preventing\nindexing errors.\n\nParameters\n----------\nraw_line : str\n    Raw line from the JSONL file, including any trailing whitespace or\n    newline characters. Will be stripped before parsing.\nline_number : int\n    One-based line number in the source file. Used for error messages to\n    help identify problematic lines during corpus preparation.\nseen_ids : set[str]\n    Set of document IDs that have been encountered in previous lines. This\n    set is mutated by adding the current document ID if parsing succeeds.\n    Used to detect duplicate document IDs within the corpus.\nsource_path : Path\n    Path to the source JSONL file. Used in error messages to provide context\n    about which file contains the problematic line.\n\nReturns\n-------\ntuple[str, str] | None\n    Tuple of (doc_id, contents) if the line was successfully parsed and\n    validated. Returns None if the line is empty (after stripping) or should\n    be skipped for any reason.\n\nRaises\n------\nValueError\n    Raised in the following cases:\n    - Line contains invalid JSON (JSONDecodeError)\n    - Document object is missing the 'id' field\n    - Document ID has already been seen (duplicate)\n    - Document is missing both 'contents' and 'text' fields, or the content\n      field is empty or not a string",
  "is_public": false
}
{
  "path": "io/bm25_manager.py",
  "module": "io.bm25_manager",
  "qualname": "_run_pyserini_index",
  "name": "_run_pyserini_index",
  "node_type": "FunctionDef",
  "lineno": 423,
  "col": 0,
  "end_lineno": 425,
  "end_col": 23,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Execute the Pyserini index command and raise for failures.",
  "is_public": false
}
{
  "path": "io/bm25_manager.py",
  "module": "io.bm25_manager",
  "qualname": "_detect_pyserini_version",
  "name": "_detect_pyserini_version",
  "node_type": "FunctionDef",
  "lineno": 428,
  "col": 0,
  "end_lineno": 441,
  "end_col": 61,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return the installed Pyserini version or ``'unknown'`` if unavailable.\n\nReturns\n-------\nstr\n    The Pyserini version string, or ``'unknown'`` if the package is not installed.",
  "is_public": false
}
{
  "path": "io/bm25_manager.py",
  "module": "io.bm25_manager",
  "qualname": "_directory_size",
  "name": "_directory_size",
  "node_type": "FunctionDef",
  "lineno": 444,
  "col": 0,
  "end_lineno": 469,
  "end_col": 16,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Compute total size in bytes for all files beneath a directory.\n\nThis utility function recursively traverses a directory tree and sums the\nsizes of all regular files found. It's used to calculate index sizes for\nmetadata purposes. Symbolic links are followed, but directories themselves\ndon't contribute to the size.\n\nParameters\n----------\npath : Path\n    Root directory path to measure. The function recursively traverses all\n    subdirectories and sums file sizes. The path must exist and be a directory.\n\nReturns\n-------\nint\n    Total size in bytes for all regular files contained within the directory\n    tree. Returns 0 if the directory is empty or contains no files. The\n    size is calculated using file system stat information (st_size).",
  "is_public": false
}
{
  "path": "io/coderank_embedder.py",
  "module": "io.coderank_embedder",
  "qualname": "io.coderank_embedder",
  "name": "io.coderank_embedder",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Pooled wrapper around the CodeRank embedding SentenceTransformer.",
  "is_public": true
}
{
  "path": "io/coderank_embedder.py",
  "module": "io.coderank_embedder",
  "qualname": "SupportsCodeRankSettings",
  "name": "SupportsCodeRankSettings",
  "node_type": "ClassDef",
  "lineno": 21,
  "col": 0,
  "end_lineno": 52,
  "end_col": 11,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "Protocol"
  ],
  "docstring": "Protocol describing the minimal settings required by the embedder.",
  "is_public": true
}
{
  "path": "io/coderank_embedder.py",
  "module": "io.coderank_embedder",
  "qualname": "SupportsCodeRankSettings.model_id",
  "name": "model_id",
  "node_type": "FunctionDef",
  "lineno": 25,
  "col": 4,
  "end_lineno": 27,
  "end_col": 11,
  "parent_qualname": "SupportsCodeRankSettings",
  "decorators": [
    "property"
  ],
  "bases": [],
  "docstring": "CodeRank model identifier.",
  "is_public": true
}
{
  "path": "io/coderank_embedder.py",
  "module": "io.coderank_embedder",
  "qualname": "SupportsCodeRankSettings.device",
  "name": "device",
  "node_type": "FunctionDef",
  "lineno": 30,
  "col": 4,
  "end_lineno": 32,
  "end_col": 11,
  "parent_qualname": "SupportsCodeRankSettings",
  "decorators": [
    "property"
  ],
  "bases": [],
  "docstring": "Target device for inference.",
  "is_public": true
}
{
  "path": "io/coderank_embedder.py",
  "module": "io.coderank_embedder",
  "qualname": "SupportsCodeRankSettings.trust_remote_code",
  "name": "trust_remote_code",
  "node_type": "FunctionDef",
  "lineno": 35,
  "col": 4,
  "end_lineno": 37,
  "end_col": 11,
  "parent_qualname": "SupportsCodeRankSettings",
  "decorators": [
    "property"
  ],
  "bases": [],
  "docstring": "Whether to trust remote code when loading the model.",
  "is_public": true
}
{
  "path": "io/coderank_embedder.py",
  "module": "io.coderank_embedder",
  "qualname": "SupportsCodeRankSettings.query_prefix",
  "name": "query_prefix",
  "node_type": "FunctionDef",
  "lineno": 40,
  "col": 4,
  "end_lineno": 42,
  "end_col": 11,
  "parent_qualname": "SupportsCodeRankSettings",
  "decorators": [
    "property"
  ],
  "bases": [],
  "docstring": "Instruction prefix required by the model.",
  "is_public": true
}
{
  "path": "io/coderank_embedder.py",
  "module": "io.coderank_embedder",
  "qualname": "SupportsCodeRankSettings.normalize",
  "name": "normalize",
  "node_type": "FunctionDef",
  "lineno": 45,
  "col": 4,
  "end_lineno": 47,
  "end_col": 11,
  "parent_qualname": "SupportsCodeRankSettings",
  "decorators": [
    "property"
  ],
  "bases": [],
  "docstring": "Whether embeddings should be normalized.",
  "is_public": true
}
{
  "path": "io/coderank_embedder.py",
  "module": "io.coderank_embedder",
  "qualname": "SupportsCodeRankSettings.batch_size",
  "name": "batch_size",
  "node_type": "FunctionDef",
  "lineno": 50,
  "col": 4,
  "end_lineno": 52,
  "end_col": 11,
  "parent_qualname": "SupportsCodeRankSettings",
  "decorators": [
    "property"
  ],
  "bases": [],
  "docstring": "Batch size used when encoding queries.",
  "is_public": true
}
{
  "path": "io/coderank_embedder.py",
  "module": "io.coderank_embedder",
  "qualname": "CodeRankEmbedder",
  "name": "CodeRankEmbedder",
  "node_type": "ClassDef",
  "lineno": 58,
  "col": 0,
  "end_lineno": 176,
  "end_col": 24,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Encode queries or code snippets with the CodeRank bi-encoder.\n\nThis wrapper enforces the instruction prefix required by the CodeRankEmbed\nmodel card and caches the loaded ``SentenceTransformer`` per ``(model_id,\ndevice)`` tuple to avoid repeated initialization overhead.",
  "is_public": true
}
{
  "path": "io/coderank_embedder.py",
  "module": "io.coderank_embedder",
  "qualname": "CodeRankEmbedder.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 69,
  "col": 4,
  "end_lineno": 75,
  "end_col": 45,
  "parent_qualname": "CodeRankEmbedder",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/coderank_embedder.py",
  "module": "io.coderank_embedder",
  "qualname": "CodeRankEmbedder.encode_queries",
  "name": "encode_queries",
  "node_type": "FunctionDef",
  "lineno": 77,
  "col": 4,
  "end_lineno": 106,
  "end_col": 81,
  "parent_qualname": "CodeRankEmbedder",
  "decorators": [],
  "bases": [],
  "docstring": "Return CodeRank embeddings for queries with prefix applied.\n\nParameters\n----------\nqueries : Iterable[str]\n    Iterable of query strings. Each query will have the configured\n    query_prefix prepended before encoding.\n\nReturns\n-------\nNDArrayF32\n    Array of query embeddings with shape (num_queries, embedding_dim).\n\nRaises\n------\nValueError\n    If queries is empty or contains no valid query strings.",
  "is_public": true
}
{
  "path": "io/coderank_embedder.py",
  "module": "io.coderank_embedder",
  "qualname": "CodeRankEmbedder.encode_codes",
  "name": "encode_codes",
  "node_type": "FunctionDef",
  "lineno": 108,
  "col": 4,
  "end_lineno": 137,
  "end_col": 83,
  "parent_qualname": "CodeRankEmbedder",
  "decorators": [],
  "bases": [],
  "docstring": "Return embeddings for code snippets (used during indexing).\n\nParameters\n----------\nsnippets : Iterable[str]\n    Iterable of code snippet strings to embed. Used during indexing\n    to create document embeddings.\n\nReturns\n-------\nNDArrayF32\n    Array of code embeddings with shape (num_snippets, embedding_dim).\n\nRaises\n------\nValueError\n    If snippets is empty or contains no valid code snippets.",
  "is_public": true
}
{
  "path": "io/coderank_embedder.py",
  "module": "io.coderank_embedder",
  "qualname": "CodeRankEmbedder._ensure_model",
  "name": "_ensure_model",
  "node_type": "FunctionDef",
  "lineno": 139,
  "col": 4,
  "end_lineno": 176,
  "end_col": 24,
  "parent_qualname": "CodeRankEmbedder",
  "decorators": [],
  "bases": [],
  "docstring": "Load the underlying SentenceTransformer lazily.\n\nReturns\n-------\nSentenceTransformer\n    Cached or newly loaded SentenceTransformer model instance.\n\nRaises\n------\nRuntimeError\n    If model loading fails or the model cannot be initialized.",
  "is_public": false
}
{
  "path": "io/duckdb_catalog.py",
  "module": "io.duckdb_catalog",
  "qualname": "io.duckdb_catalog",
  "name": "io.duckdb_catalog",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "DuckDB catalog for querying Parquet chunks.\n\nProvides SQL views over Parquet directories and query helpers for fast\nchunk retrieval and joins.",
  "is_public": true
}
{
  "path": "io/duckdb_catalog.py",
  "module": "io.duckdb_catalog",
  "qualname": "IdMapMeta",
  "name": "IdMapMeta",
  "node_type": "ClassDef",
  "lineno": 52,
  "col": 0,
  "end_lineno": 58,
  "end_col": 19,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Metadata describing a materialized FAISS ID map join.",
  "is_public": true
}
{
  "path": "io/duckdb_catalog.py",
  "module": "io.duckdb_catalog",
  "qualname": "_ScopeFilterLogInfo",
  "name": "_ScopeFilterLogInfo",
  "node_type": "ClassDef",
  "lineno": 62,
  "col": 0,
  "end_lineno": 68,
  "end_col": 25,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Container for scope filter logging inputs.",
  "is_public": false
}
{
  "path": "io/duckdb_catalog.py",
  "module": "io.duckdb_catalog",
  "qualname": "_log_extra",
  "name": "_log_extra",
  "node_type": "FunctionDef",
  "lineno": 71,
  "col": 0,
  "end_lineno": 92,
  "end_col": 52,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return structured log extras for catalog events.\n\nThis function creates a structured logging payload by combining a component\nidentifier (\"duckdb_catalog\") with additional keyword arguments. The function\nis used to create consistent log context for DuckDB catalog operations.\n\nParameters\n----------\n**kwargs : object\n    Additional keyword arguments to include in the logging payload. All arguments\n    are merged into the returned dictionary with the component identifier.\n    Values must be JSON-serializable for structured logging.\n\nReturns\n-------\ndict[str, object]\n    Structured logging payload dictionary containing \"component\": \"duckdb_catalog\"\n    and all provided keyword arguments. The dictionary is suitable for use with\n    Python's logging module's extra parameter.",
  "is_public": false
}
{
  "path": "io/duckdb_catalog.py",
  "module": "io.duckdb_catalog",
  "qualname": "_ScopeFilterSpec",
  "name": "_ScopeFilterSpec",
  "node_type": "ClassDef",
  "lineno": 145,
  "col": 0,
  "end_lineno": 158,
  "end_col": 83,
  "parent_qualname": null,
  "decorators": [
    "dataclass(frozen=True)"
  ],
  "bases": [],
  "docstring": "Structured scope filter metadata used during scoped queries.",
  "is_public": false
}
{
  "path": "io/duckdb_catalog.py",
  "module": "io.duckdb_catalog",
  "qualname": "_ScopeFilterSpec.has_complex_globs",
  "name": "has_complex_globs",
  "node_type": "FunctionDef",
  "lineno": 156,
  "col": 4,
  "end_lineno": 158,
  "end_col": 83,
  "parent_qualname": "_ScopeFilterSpec",
  "decorators": [
    "property"
  ],
  "bases": [],
  "docstring": "Return ``True`` when complex include/exclude patterns exist.",
  "is_public": true
}
{
  "path": "io/duckdb_catalog.py",
  "module": "io.duckdb_catalog",
  "qualname": "StructureAnnotations",
  "name": "StructureAnnotations",
  "node_type": "ClassDef",
  "lineno": 162,
  "col": 0,
  "end_lineno": 168,
  "end_col": 32,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Structure-aware metadata joined onto explainability pools.",
  "is_public": true
}
{
  "path": "io/duckdb_catalog.py",
  "module": "io.duckdb_catalog",
  "qualname": "DuckDBCatalogOptions",
  "name": "DuckDBCatalogOptions",
  "node_type": "ClassDef",
  "lineno": 172,
  "col": 0,
  "end_lineno": 178,
  "end_col": 33,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Optional configuration bundle for DuckDB catalog instantiation.",
  "is_public": true
}
{
  "path": "io/duckdb_catalog.py",
  "module": "io.duckdb_catalog",
  "qualname": "_DuckDBQueryMixin",
  "name": "_DuckDBQueryMixin",
  "node_type": "ClassDef",
  "lineno": 181,
  "col": 0,
  "end_lineno": 453,
  "end_col": 21,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Chunk-level query helpers shared by :class:`DuckDBCatalog`.",
  "is_public": false
}
{
  "path": "io/duckdb_catalog.py",
  "module": "io.duckdb_catalog",
  "qualname": "_DuckDBQueryMixin.query_by_ids",
  "name": "query_by_ids",
  "node_type": "FunctionDef",
  "lineno": 184,
  "col": 4,
  "end_lineno": 281,
  "end_col": 22,
  "parent_qualname": "_DuckDBQueryMixin",
  "decorators": [],
  "bases": [],
  "docstring": "Query chunks by their unique IDs.\n\nThis method retrieves chunk records from the DuckDB catalog for the\nspecified chunk identifiers. It performs a SQL query to fetch chunk\nmetadata (URI, start/end lines, symbols, etc.) and returns the results\nas a list of dictionaries. The method handles empty input gracefully\nand records telemetry for observability.\n\nParameters\n----------\nids : Sequence[int]\n    Sequence of chunk identifiers to query. Empty sequences return an\n    empty list. Duplicate IDs may result in duplicate records depending\n    on database constraints.\n\nReturns\n-------\nlist[dict]\n    List of chunk record dictionaries, each containing chunk metadata\n    fields (e.g., id, uri, start_line, end_line, symbols). The list\n    may be shorter than the input if some IDs don't exist in the catalog.\n    Empty list when no IDs are provided or no matching chunks are found.\n    Records are ordered to match the input ID sequence when possible.",
  "is_public": true
}
{
  "path": "io/duckdb_catalog.py",
  "module": "io.duckdb_catalog",
  "qualname": "_DuckDBQueryMixin.get_structure_annotations",
  "name": "get_structure_annotations",
  "node_type": "FunctionDef",
  "lineno": 283,
  "col": 4,
  "end_lineno": 314,
  "end_col": 71,
  "parent_qualname": "_DuckDBQueryMixin",
  "decorators": [],
  "bases": [],
  "docstring": "Return structural overlays (symbols/AST/CST) for chunk ``ids``.\n\nParameters\n----------\nids : Sequence[int]\n    Chunk identifiers to hydrate with structural metadata.\n\nReturns\n-------\ndict[int, StructureAnnotations]\n    Mapping of chunk ID to :class:`StructureAnnotations` describing URI,\n    symbol hits, AST node kinds, and CST matches.",
  "is_public": true
}
{
  "path": "io/duckdb_catalog.py",
  "module": "io.duckdb_catalog",
  "qualname": "_DuckDBQueryMixin._fetch_annotation_rows",
  "name": "_fetch_annotation_rows",
  "node_type": "FunctionDef",
  "lineno": 317,
  "col": 4,
  "end_lineno": 333,
  "end_col": 20,
  "parent_qualname": "_DuckDBQueryMixin",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/duckdb_catalog.py",
  "module": "io.duckdb_catalog",
  "qualname": "_DuckDBQueryMixin._initialize_annotation_maps",
  "name": "_initialize_annotation_maps",
  "node_type": "FunctionDef",
  "lineno": 336,
  "col": 4,
  "end_lineno": 349,
  "end_col": 38,
  "parent_qualname": "_DuckDBQueryMixin",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/duckdb_catalog.py",
  "module": "io.duckdb_catalog",
  "qualname": "_DuckDBQueryMixin._attach_chunk_symbols",
  "name": "_attach_chunk_symbols",
  "node_type": "FunctionDef",
  "lineno": 352,
  "col": 4,
  "end_lineno": 369,
  "end_col": 61,
  "parent_qualname": "_DuckDBQueryMixin",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/duckdb_catalog.py",
  "module": "io.duckdb_catalog",
  "qualname": "_DuckDBQueryMixin._attach_ast_nodes",
  "name": "_attach_ast_nodes",
  "node_type": "FunctionDef",
  "lineno": 372,
  "col": 4,
  "end_lineno": 392,
  "end_col": 98,
  "parent_qualname": "_DuckDBQueryMixin",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/duckdb_catalog.py",
  "module": "io.duckdb_catalog",
  "qualname": "_DuckDBQueryMixin._resolve_cst_path_column",
  "name": "_resolve_cst_path_column",
  "node_type": "FunctionDef",
  "lineno": 395,
  "col": 4,
  "end_lineno": 406,
  "end_col": 20,
  "parent_qualname": "_DuckDBQueryMixin",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/duckdb_catalog.py",
  "module": "io.duckdb_catalog",
  "qualname": "_DuckDBQueryMixin._attach_cst_nodes",
  "name": "_attach_cst_nodes",
  "node_type": "FunctionDef",
  "lineno": 409,
  "col": 4,
  "end_lineno": 432,
  "end_col": 13,
  "parent_qualname": "_DuckDBQueryMixin",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/duckdb_catalog.py",
  "module": "io.duckdb_catalog",
  "qualname": "_DuckDBQueryMixin._coerce_annotation_payload",
  "name": "_coerce_annotation_payload",
  "node_type": "FunctionDef",
  "lineno": 435,
  "col": 4,
  "end_lineno": 453,
  "end_col": 21,
  "parent_qualname": "_DuckDBQueryMixin",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/duckdb_catalog.py",
  "module": "io.duckdb_catalog",
  "qualname": "_LegacyOptions",
  "name": "_LegacyOptions",
  "node_type": "ClassDef",
  "lineno": 456,
  "col": 0,
  "end_lineno": 460,
  "end_col": 19,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "TypedDict"
  ],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/duckdb_catalog.py",
  "module": "io.duckdb_catalog",
  "qualname": "DuckDBCatalog",
  "name": "DuckDBCatalog",
  "node_type": "ClassDef",
  "lineno": 463,
  "col": 0,
  "end_lineno": 1722,
  "end_col": 40,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "_DuckDBQueryMixin"
  ],
  "docstring": "DuckDB catalog for querying chunks.\n\nThis class provides a high-level interface for querying chunk metadata and\nembeddings stored in DuckDB. The catalog can operate in two modes: view-based\n(zero-copy queries from Parquet files) or materialized (persisted tables with\nindexes). The catalog manages DuckDB connections, builds query views, and\nprovides methods for fetching embeddings and metadata by IDs.\n\nAttributes\n----------\nrelation_exists : ClassVar[Callable[[duckdb.DuckDBPyConnection, str], bool]]\n    Class variable referencing the module-level ``relation_exists()`` function.\n    Used to check if a table or view exists in the DuckDB catalog. Accepts a\n    DuckDB connection and relation name, returns ``True`` if the relation exists.\n\nParameters\n----------\ndb_path : Path\n    Path to the DuckDB database file. The database is created if it doesn't\n    exist. Used for storing catalog metadata and materialized tables when\n    materialize is True.\nvectors_dir : Path\n    Directory containing Parquet files with chunk embeddings and metadata.\n    The catalog reads from this directory to build views or materialize tables.\n    The directory structure is expected to match the standard layout.\noptions : DuckDBCatalogOptions | None, optional\n    Configuration options dataclass containing materialize, manager, log_queries,\n    and repo_root settings. When None, uses default options. Cannot be mixed\n    with legacy_kwargs. Defaults to None.\n**legacy_kwargs : Unpack[_LegacyOptions]\n    Legacy keyword arguments for backward compatibility. Supported keys:\n    materialize (bool), manager (DuckDBManager | None), log_queries (bool),\n    repo_root (Path). Cannot be used when options is provided. Raises TypeError\n    for unknown keys. The type is Unpack[_LegacyOptions] where _LegacyOptions\n    is a TypedDict defining the allowed keyword arguments.\n\nRaises\n------\nValueError\n    Raised when both options and legacy_kwargs are provided (mixing is not allowed).\nTypeError\n    Raised when legacy_kwargs contains unsupported keyword arguments.",
  "is_public": true
}
{
  "path": "io/duckdb_catalog.py",
  "module": "io.duckdb_catalog",
  "qualname": "DuckDBCatalog.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 510,
  "col": 4,
  "end_lineno": 547,
  "end_col": 40,
  "parent_qualname": "DuckDBCatalog",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/duckdb_catalog.py",
  "module": "io.duckdb_catalog",
  "qualname": "DuckDBCatalog.open",
  "name": "open",
  "node_type": "FunctionDef",
  "lineno": 549,
  "col": 4,
  "end_lineno": 551,
  "end_col": 28,
  "parent_qualname": "DuckDBCatalog",
  "decorators": [],
  "bases": [],
  "docstring": "Ensure catalog views are initialized.",
  "is_public": true
}
{
  "path": "io/duckdb_catalog.py",
  "module": "io.duckdb_catalog",
  "qualname": "DuckDBCatalog.close",
  "name": "close",
  "node_type": "FunctionDef",
  "lineno": 553,
  "col": 4,
  "end_lineno": 555,
  "end_col": 40,
  "parent_qualname": "DuckDBCatalog",
  "decorators": [],
  "bases": [],
  "docstring": "No-op for compatibility; connections are per-use via the manager.",
  "is_public": true
}
{
  "path": "io/duckdb_catalog.py",
  "module": "io.duckdb_catalog",
  "qualname": "DuckDBCatalog.__enter__",
  "name": "__enter__",
  "node_type": "FunctionDef",
  "lineno": 557,
  "col": 4,
  "end_lineno": 566,
  "end_col": 19,
  "parent_qualname": "DuckDBCatalog",
  "decorators": [],
  "bases": [],
  "docstring": "Enter context manager.\n\nReturns\n-------\nSelf\n    The catalog instance with an active DuckDB connection.",
  "is_public": false
}
{
  "path": "io/duckdb_catalog.py",
  "module": "io.duckdb_catalog",
  "qualname": "DuckDBCatalog.__exit__",
  "name": "__exit__",
  "node_type": "FunctionDef",
  "lineno": 568,
  "col": 4,
  "end_lineno": 570,
  "end_col": 20,
  "parent_qualname": "DuckDBCatalog",
  "decorators": [],
  "bases": [],
  "docstring": "Exit context manager.",
  "is_public": false
}
{
  "path": "io/duckdb_catalog.py",
  "module": "io.duckdb_catalog",
  "qualname": "DuckDBCatalog.manager",
  "name": "manager",
  "node_type": "FunctionDef",
  "lineno": 573,
  "col": 4,
  "end_lineno": 575,
  "end_col": 28,
  "parent_qualname": "DuckDBCatalog",
  "decorators": [
    "property"
  ],
  "bases": [],
  "docstring": "Return the underlying DuckDB manager.",
  "is_public": true
}
{
  "path": "io/duckdb_catalog.py",
  "module": "io.duckdb_catalog",
  "qualname": "DuckDBCatalog._ensure_ready",
  "name": "_ensure_ready",
  "node_type": "FunctionDef",
  "lineno": 577,
  "col": 4,
  "end_lineno": 586,
  "end_col": 36,
  "parent_qualname": "DuckDBCatalog",
  "decorators": [],
  "bases": [],
  "docstring": "Initialize catalog views once in a threadsafe manner.",
  "is_public": false
}
{
  "path": "io/duckdb_catalog.py",
  "module": "io.duckdb_catalog",
  "qualname": "DuckDBCatalog.connection",
  "name": "connection",
  "node_type": "FunctionDef",
  "lineno": 589,
  "col": 4,
  "end_lineno": 599,
  "end_col": 22,
  "parent_qualname": "DuckDBCatalog",
  "decorators": [
    "contextmanager"
  ],
  "bases": [],
  "docstring": "Yield a configured DuckDB connection.\n\nYields\n------\nduckdb.DuckDBPyConnection\n    Connection configured with catalog pragmas and ready for queries.",
  "is_public": true
}
{
  "path": "io/duckdb_catalog.py",
  "module": "io.duckdb_catalog",
  "qualname": "DuckDBCatalog._readonly_connection",
  "name": "_readonly_connection",
  "node_type": "FunctionDef",
  "lineno": 602,
  "col": 4,
  "end_lineno": 612,
  "end_col": 22,
  "parent_qualname": "DuckDBCatalog",
  "decorators": [
    "contextmanager"
  ],
  "bases": [],
  "docstring": "Yield a read-only DuckDB connection for hydration queries.\n\nYields\n------\nduckdb.DuckDBPyConnection\n    Connection opened in read-only mode for catalog reads.",
  "is_public": false
}
{
  "path": "io/duckdb_catalog.py",
  "module": "io.duckdb_catalog",
  "qualname": "DuckDBCatalog._log_query",
  "name": "_log_query",
  "node_type": "FunctionDef",
  "lineno": 614,
  "col": 4,
  "end_lineno": 625,
  "end_col": 9,
  "parent_qualname": "DuckDBCatalog",
  "decorators": [],
  "bases": [],
  "docstring": "Emit debug log for executed DuckDB statement when enabled.",
  "is_public": false
}
{
  "path": "io/duckdb_catalog.py",
  "module": "io.duckdb_catalog",
  "qualname": "DuckDBCatalog._ensure_views",
  "name": "_ensure_views",
  "node_type": "FunctionDef",
  "lineno": 627,
  "col": 4,
  "end_lineno": 637,
  "end_col": 85,
  "parent_qualname": "DuckDBCatalog",
  "decorators": [],
  "bases": [],
  "docstring": "Create required views and tables to hydrate chunk metadata.",
  "is_public": false
}
{
  "path": "io/duckdb_catalog.py",
  "module": "io.duckdb_catalog",
  "qualname": "DuckDBCatalog._install_chunks_view",
  "name": "_install_chunks_view",
  "node_type": "FunctionDef",
  "lineno": 639,
  "col": 4,
  "end_lineno": 694,
  "end_col": 9,
  "parent_qualname": "DuckDBCatalog",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/duckdb_catalog.py",
  "module": "io.duckdb_catalog",
  "qualname": "DuckDBCatalog._install_optional_views",
  "name": "_install_optional_views",
  "node_type": "FunctionDef",
  "lineno": 696,
  "col": 4,
  "end_lineno": 710,
  "end_col": 46,
  "parent_qualname": "DuckDBCatalog",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/duckdb_catalog.py",
  "module": "io.duckdb_catalog",
  "qualname": "DuckDBCatalog._install_parquet_view",
  "name": "_install_parquet_view",
  "node_type": "FunctionDef",
  "lineno": 712,
  "col": 4,
  "end_lineno": 729,
  "end_col": 19,
  "parent_qualname": "DuckDBCatalog",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/duckdb_catalog.py",
  "module": "io.duckdb_catalog",
  "qualname": "DuckDBCatalog._install_json_view",
  "name": "_install_json_view",
  "node_type": "FunctionDef",
  "lineno": 731,
  "col": 4,
  "end_lineno": 748,
  "end_col": 19,
  "parent_qualname": "DuckDBCatalog",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/duckdb_catalog.py",
  "module": "io.duckdb_catalog",
  "qualname": "DuckDBCatalog._install_chunk_symbols_view",
  "name": "_install_chunk_symbols_view",
  "node_type": "FunctionDef",
  "lineno": 751,
  "col": 4,
  "end_lineno": 770,
  "end_col": 13,
  "parent_qualname": "DuckDBCatalog",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/duckdb_catalog.py",
  "module": "io.duckdb_catalog",
  "qualname": "DuckDBCatalog._ensure_idmap_tables",
  "name": "_ensure_idmap_tables",
  "node_type": "FunctionDef",
  "lineno": 773,
  "col": 4,
  "end_lineno": 798,
  "end_col": 95,
  "parent_qualname": "DuckDBCatalog",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": "Ensure IDMap materialization tables exist for joins and checksums.",
  "is_public": false
}
{
  "path": "io/duckdb_catalog.py",
  "module": "io.duckdb_catalog",
  "qualname": "DuckDBCatalog._ensure_faiss_join_view",
  "name": "_ensure_faiss_join_view",
  "node_type": "FunctionDef",
  "lineno": 801,
  "col": 4,
  "end_lineno": 813,
  "end_col": 9,
  "parent_qualname": "DuckDBCatalog",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": "Expose chunks joined with FAISS ID map for deterministic hydration.",
  "is_public": false
}
{
  "path": "io/duckdb_catalog.py",
  "module": "io.duckdb_catalog",
  "qualname": "DuckDBCatalog._ensure_faiss_idmap_view",
  "name": "_ensure_faiss_idmap_view",
  "node_type": "FunctionDef",
  "lineno": 815,
  "col": 4,
  "end_lineno": 865,
  "end_col": 9,
  "parent_qualname": "DuckDBCatalog",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/duckdb_catalog.py",
  "module": "io.duckdb_catalog",
  "qualname": "DuckDBCatalog.ensure_faiss_idmap_views",
  "name": "ensure_faiss_idmap_views",
  "node_type": "FunctionDef",
  "lineno": 867,
  "col": 4,
  "end_lineno": 871,
  "end_col": 46,
  "parent_qualname": "DuckDBCatalog",
  "decorators": [],
  "bases": [],
  "docstring": "Install/refresh FAISS id map views from a specific Parquet file.",
  "is_public": true
}
{
  "path": "io/duckdb_catalog.py",
  "module": "io.duckdb_catalog",
  "qualname": "DuckDBCatalog.materialize_faiss_join",
  "name": "materialize_faiss_join",
  "node_type": "FunctionDef",
  "lineno": 873,
  "col": 4,
  "end_lineno": 886,
  "end_col": 13,
  "parent_qualname": "DuckDBCatalog",
  "decorators": [],
  "bases": [],
  "docstring": "Persist ``v_faiss_join`` into ``faiss_join_mat`` for BI workloads.",
  "is_public": true
}
{
  "path": "io/duckdb_catalog.py",
  "module": "io.duckdb_catalog",
  "qualname": "DuckDBCatalog.set_idmap_path",
  "name": "set_idmap_path",
  "node_type": "FunctionDef",
  "lineno": 888,
  "col": 4,
  "end_lineno": 890,
  "end_col": 41,
  "parent_qualname": "DuckDBCatalog",
  "decorators": [],
  "bases": [],
  "docstring": "Override the FAISS id map path used for view installation.",
  "is_public": true
}
{
  "path": "io/duckdb_catalog.py",
  "module": "io.duckdb_catalog",
  "qualname": "DuckDBCatalog.register_idmap_parquet",
  "name": "register_idmap_parquet",
  "node_type": "FunctionDef",
  "lineno": 892,
  "col": 4,
  "end_lineno": 921,
  "end_col": 20,
  "parent_qualname": "DuckDBCatalog",
  "decorators": [],
  "bases": [],
  "docstring": "Register a FAISS id map Parquet file and refresh views/materialized joins.\n\nParameters\n----------\npath : Path\n    Path to the Parquet file containing the FAISS ID map. The path is\n    expanded (resolving ~) and resolved to an absolute path before use.\nmaterialize : bool, optional\n    If True, materializes the FAISS join table instead of creating views\n    (default: False). Materialization improves query performance but\n    requires more storage and must be refreshed when the ID map changes.\n\nReturns\n-------\ndict[str, Any]\n    Statistics dictionary from refresh_faiss_idmap_mat_if_changed(),\n    containing information about the materialized table refresh operation\n    (e.g., row counts, refresh status). The dictionary includes keys\n    such as \"rows\", \"checksum\", and \"refreshed\" indicating the state\n    of the materialized table.",
  "is_public": true
}
{
  "path": "io/duckdb_catalog.py",
  "module": "io.duckdb_catalog",
  "qualname": "DuckDBCatalog.ensure_pool_views",
  "name": "ensure_pool_views",
  "node_type": "FunctionDef",
  "lineno": 923,
  "col": 4,
  "end_lineno": 964,
  "end_col": 13,
  "parent_qualname": "DuckDBCatalog",
  "decorators": [],
  "bases": [],
  "docstring": "Expose the latest evaluator pool and coverage join as DuckDB views.",
  "is_public": true
}
{
  "path": "io/duckdb_catalog.py",
  "module": "io.duckdb_catalog",
  "qualname": "DuckDBCatalog.refresh_faiss_idmap_mat_if_changed",
  "name": "refresh_faiss_idmap_mat_if_changed",
  "node_type": "FunctionDef",
  "lineno": 966,
  "col": 4,
  "end_lineno": 996,
  "end_col": 20,
  "parent_qualname": "DuckDBCatalog",
  "decorators": [],
  "bases": [],
  "docstring": "Materialize FAISS ID map when the Parquet sidecar content changes.\n\nParameters\n----------\nidmap_parquet : Path\n    Parquet file containing ``faiss_row`` and ``external_id`` columns.\n\nReturns\n-------\ndict[str, Any]\n    Summary dictionary with ``refreshed``, ``checksum``, and ``rows`` keys.",
  "is_public": true
}
{
  "path": "io/duckdb_catalog.py",
  "module": "io.duckdb_catalog",
  "qualname": "DuckDBCatalog.sample_query_vectors",
  "name": "sample_query_vectors",
  "node_type": "FunctionDef",
  "lineno": 998,
  "col": 4,
  "end_lineno": 1035,
  "end_col": 22,
  "parent_qualname": "DuckDBCatalog",
  "decorators": [],
  "bases": [],
  "docstring": "Return (chunk_id, vector) samples for offline evaluation.\n\nParameters\n----------\nlimit : int, optional\n    Maximum number of vectors to return, by default 64.\n\nReturns\n-------\nlist[tuple[int, np.ndarray]]\n    Chunk identifiers paired with embedding vectors. Each tuple contains\n    a chunk ID (int) and its corresponding embedding vector as a NumPy\n    array (np.ndarray).",
  "is_public": true
}
{
  "path": "io/duckdb_catalog.py",
  "module": "io.duckdb_catalog",
  "qualname": "DuckDBCatalog.query_by_filters",
  "name": "query_by_filters",
  "node_type": "FunctionDef",
  "lineno": 1037,
  "col": 4,
  "end_lineno": 1209,
  "end_col": 22,
  "parent_qualname": "DuckDBCatalog",
  "decorators": [],
  "bases": [],
  "docstring": "Query chunks by IDs with path and language filtering.\n\nRetrieves chunk metadata for a list of chunk IDs, applying optional filters\nfor path patterns (include/exclude globs) and programming languages. This\nmethod is used after FAISS search to filter results by scope constraints.\n\nFiltering Strategy:\n- Simple globs (e.g., `*.py`, `src/**`) are converted to SQL `LIKE` patterns\n  for efficient database-side filtering.\n- Complex globs (e.g., `src/**/test_*.py`) fall back to Python `fnmatch`\n  post-filtering after SQL query execution.\n- Language filtering uses file extension mapping (e.g., `python`  `.py`, `.pyi`).\n\nParameters\n----------\nids : Sequence[int]\n    Sequence of chunk IDs to retrieve. Empty sequence returns empty list.\ninclude_globs : list[str] | None, optional\n    Glob patterns to include. Chunks must match at least one pattern.\n    Empty list means \"include all\" (no filtering). Defaults to None.\nexclude_globs : list[str] | None, optional\n    Glob patterns to exclude. Chunks matching any pattern are removed.\n    Empty list means \"exclude none\". Defaults to None.\nlanguages : list[str] | None, optional\n    Programming language names (e.g., [\"python\", \"typescript\"]).\n    Filters chunks by file extension. Defaults to None.\n\nReturns\n-------\nlist[dict]\n    List of filtered chunk records as dictionaries. Each dict contains all\n    columns from the chunks Parquet file. Results preserve input ID order\n    (via JOIN with UNNEST ordinality). Returns empty list if no IDs provided\n    or all chunks filtered out.\n\nExamples\n--------\nFilter by language:\n\n>>> catalog.query_by_filters([1, 2, 3], languages=[\"python\"])\n[{'id': 1, 'uri': 'src/main.py', ...}, {'id': 2, 'uri': 'src/utils.py', ...}]\n\nFilter by include globs:\n\n>>> catalog.query_by_filters([1, 2, 3], include_globs=[\"src/**/*.py\"])\n[{'id': 1, 'uri': 'src/main.py', ...}]\n\nCombined filters:\n\n>>> catalog.query_by_filters(\n...     [1, 2, 3],\n...     include_globs=[\"**/*.py\"],\n...     exclude_globs=[\"**/test_*.py\"],\n...     languages=[\"python\"],\n... )\n[{'id': 1, 'uri': 'src/main.py', ...}]\n\nNotes\n-----\nSQL LIKE Pattern Conversion:\n- `**/*.py`  `%.py` (matches any path ending in .py)\n- `src/**`  `src/%` (matches paths starting with src/)\n- `*.py`  `%.py` (same as **/*.py in our implementation)\n\nComplex Glob Detection:\n- Patterns with `**` in the middle (e.g., `src/**/test_*.py`) are detected\n  as complex and use Python post-filtering.\n- Patterns with bracket expressions `[...]` or `[!...]` use Python filtering.\n- Simple prefix/suffix patterns use SQL LIKE for performance.\n\nLanguage Extension Mapping:\n- Uses `LANGUAGE_EXTENSIONS` from `scope_utils` module.\n- Unknown languages are silently ignored (no error raised).\n- Extension matching is case-insensitive (normalizes to lowercase).\n\nPerformance:\n- SQL filtering is preferred for large result sets (avoids transferring\n  filtered-out chunks from database).\n- Python post-filtering adds ~1-2ms overhead per 1000 chunks.\n- Consider adding index on `uri` column for faster LIKE queries (see Task 14).",
  "is_public": true
}
{
  "path": "io/duckdb_catalog.py",
  "module": "io.duckdb_catalog",
  "qualname": "DuckDBCatalog._build_scope_filter_spec",
  "name": "_build_scope_filter_spec",
  "node_type": "FunctionDef",
  "lineno": 1211,
  "col": 4,
  "end_lineno": 1269,
  "end_col": 9,
  "parent_qualname": "DuckDBCatalog",
  "decorators": [],
  "bases": [],
  "docstring": "Categorize scope filters and language extensions for later processing.\n\nParameters\n----------\nids : Sequence[int]\n    Chunk identifiers provided by FAISS.\ninclude_globs : list[str] | None\n    Glob patterns to include via SQL LIKE.\nexclude_globs : list[str] | None\n    Glob patterns to exclude via SQL LIKE.\nlanguages : list[str] | None\n    Language names for extension-based filtering.\n\nReturns\n-------\n_ScopeFilterSpec\n    Structured metadata describing how to materialize the query.",
  "is_public": false
}
{
  "path": "io/duckdb_catalog.py",
  "module": "io.duckdb_catalog",
  "qualname": "DuckDBCatalog._apply_complex_glob_filters",
  "name": "_apply_complex_glob_filters",
  "node_type": "FunctionDef",
  "lineno": 1272,
  "col": 4,
  "end_lineno": 1322,
  "end_col": 31,
  "parent_qualname": "DuckDBCatalog",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": "Run Python filtering for complex glob patterns not expressible in SQL.\n\nThis method filters results by applying include and exclude glob patterns\nto the URI field of each result dictionary. Patterns that cannot be\nefficiently expressed in SQL (e.g., complex wildcards, multiple patterns)\nare handled here using Python's path matching logic.\n\nParameters\n----------\nresults : list[dict]\n    List of result dictionaries, each containing at least a \"uri\" key.\ninclude_patterns : tuple[str, ...]\n    Glob patterns that URIs must match to be included. Empty tuple means\n    no inclusion filter is applied.\nexclude_patterns : tuple[str, ...]\n    Glob patterns that URIs must not match to be included. Empty tuple\n    means no exclusion filter is applied.\n\nReturns\n-------\nlist[dict]\n    Filtered results matching include/exclude glob patterns. Results\n    matching exclude patterns or not matching include patterns are removed.",
  "is_public": false
}
{
  "path": "io/duckdb_catalog.py",
  "module": "io.duckdb_catalog",
  "qualname": "DuckDBCatalog._apply_language_filters",
  "name": "_apply_language_filters",
  "node_type": "FunctionDef",
  "lineno": 1325,
  "col": 4,
  "end_lineno": 1361,
  "end_col": 31,
  "parent_qualname": "DuckDBCatalog",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": "Filter results by normalized file extensions.\n\nThis method filters results to include only those whose URI ends with\none of the specified language extensions. Extensions are matched\ncase-insensitively against the lowercase URI.\n\nParameters\n----------\nresults : list[dict]\n    List of result dictionaries, each containing at least a \"uri\" key.\nlanguage_extensions : frozenset[str]\n    Set of normalized file extensions (e.g., {\".py\", \".js\", \".ts\"}).\n    Extensions should include the leading dot. Empty set means no\n    language filter is applied.\n\nReturns\n-------\nlist[dict]\n    Filtered results matching language extensions. Only results whose\n    URI ends with one of the specified extensions are included.",
  "is_public": false
}
{
  "path": "io/duckdb_catalog.py",
  "module": "io.duckdb_catalog",
  "qualname": "DuckDBCatalog._observe_scope_filter_duration",
  "name": "_observe_scope_filter_duration",
  "node_type": "FunctionDef",
  "lineno": 1363,
  "col": 4,
  "end_lineno": 1374,
  "end_col": 92,
  "parent_qualname": "DuckDBCatalog",
  "decorators": [],
  "bases": [],
  "docstring": "Record how long scope filtering took for observability.",
  "is_public": false
}
{
  "path": "io/duckdb_catalog.py",
  "module": "io.duckdb_catalog",
  "qualname": "DuckDBCatalog._log_scope_filter_results",
  "name": "_log_scope_filter_results",
  "node_type": "FunctionDef",
  "lineno": 1377,
  "col": 4,
  "end_lineno": 1412,
  "end_col": 13,
  "parent_qualname": "DuckDBCatalog",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": "Emit structured logs and timeline events for scope filtering outcomes.",
  "is_public": false
}
{
  "path": "io/duckdb_catalog.py",
  "module": "io.duckdb_catalog",
  "qualname": "DuckDBCatalog._determine_filter_type",
  "name": "_determine_filter_type",
  "node_type": "FunctionDef",
  "lineno": 1415,
  "col": 4,
  "end_lineno": 1446,
  "end_col": 21,
  "parent_qualname": "DuckDBCatalog",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": "Format the filter type label used for Prometheus metrics.\n\nDetermines the type of scope filtering being applied based on the\npresence of glob patterns and language filters. Used to label metrics\nfor observability.\n\nParameters\n----------\ninclude_globs : list[str] | None\n    List of include glob patterns, or None if not specified.\nexclude_globs : list[str] | None\n    List of exclude glob patterns, or None if not specified.\nlanguages : list[str] | None\n    List of language filters, or None if not specified.\n\nReturns\n-------\nstr\n    Filter type label: \"combined\" (both globs and languages),\n    \"glob\" (only glob patterns), \"language\" (only language filters),\n    or \"none\" (no filters).",
  "is_public": false
}
{
  "path": "io/duckdb_catalog.py",
  "module": "io.duckdb_catalog",
  "qualname": "DuckDBCatalog._is_simple_glob",
  "name": "_is_simple_glob",
  "node_type": "FunctionDef",
  "lineno": 1449,
  "col": 4,
  "end_lineno": 1490,
  "end_col": 19,
  "parent_qualname": "DuckDBCatalog",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": "Check if glob pattern can be converted to SQL LIKE.\n\nSimple patterns:\n- `*.py` (suffix match)\n- `**/*.py` (suffix match, equivalent to `*.py`)\n- `src/**` (prefix match)\n- `src/*.py` (prefix + suffix)\n\nComplex patterns (require Python filtering):\n- `src/**/test_*.py` (recursive in middle)\n- `src/[abc]/*.py` (bracket expressions)\n- `src/{a,b}/*.py` (brace expansion)\n\nParameters\n----------\npattern : str\n    Glob pattern to check.\n\nReturns\n-------\nbool\n    True if pattern can be converted to SQL LIKE, False otherwise.",
  "is_public": false
}
{
  "path": "io/duckdb_catalog.py",
  "module": "io.duckdb_catalog",
  "qualname": "DuckDBCatalog.get_chunk_by_id",
  "name": "get_chunk_by_id",
  "node_type": "FunctionDef",
  "lineno": 1492,
  "col": 4,
  "end_lineno": 1508,
  "end_col": 25,
  "parent_qualname": "DuckDBCatalog",
  "decorators": [],
  "bases": [],
  "docstring": "Return a single chunk record by ID.\n\nParameters\n----------\nchunk_id : int\n    Chunk identifier to retrieve from the catalog.\n\nReturns\n-------\ndict | None\n    Chunk metadata dictionary when the ID exists, otherwise ``None``.",
  "is_public": true
}
{
  "path": "io/duckdb_catalog.py",
  "module": "io.duckdb_catalog",
  "qualname": "DuckDBCatalog.get_symbols_for_chunk",
  "name": "get_symbols_for_chunk",
  "node_type": "FunctionDef",
  "lineno": 1510,
  "col": 4,
  "end_lineno": 1531,
  "end_col": 39,
  "parent_qualname": "DuckDBCatalog",
  "decorators": [],
  "bases": [],
  "docstring": "Return all symbols associated with a chunk.\n\nParameters\n----------\nchunk_id : int\n    Chunk ID to query symbols for.\n\nReturns\n-------\nlist[str]\n    List of symbol identifiers associated with the chunk. Returns empty\n    list if chunk has no symbols or chunk_id doesn't exist.",
  "is_public": true
}
{
  "path": "io/duckdb_catalog.py",
  "module": "io.duckdb_catalog",
  "qualname": "DuckDBCatalog.query_by_uri",
  "name": "query_by_uri",
  "node_type": "FunctionDef",
  "lineno": 1533,
  "col": 4,
  "end_lineno": 1596,
  "end_col": 22,
  "parent_qualname": "DuckDBCatalog",
  "decorators": [],
  "bases": [],
  "docstring": "Query chunks by file URI/path.\n\nRetrieves all chunks from a specific file. Useful for file-level operations\nlike displaying all chunks in a file or filtering search results by file.\n\nThe query uses parameterized SQL to prevent injection and efficiently\nfilters by URI. Results are limited to prevent excessive memory usage\nfor large files. Pass ``limit <= 0`` to disable the limit entirely\nwhile still preserving deterministic ordering by chunk ID.\n\nParameters\n----------\nuri : str\n    File URI or path to query. Should match the uri field in the chunks\n    table (typically a relative path from repo root).\nlimit : int, optional\n    Maximum number of chunks to return. Defaults to 100. Set higher for\n    large files, but be aware of memory usage. Pass 0 or a negative value\n    to disable the limit (not recommended for production).\n\nReturns\n-------\nlist[dict]\n    List of chunk records from the specified file. Each dict contains\n    all chunk columns. Results are ordered by chunk ID (which typically\n    corresponds to file order). Returns empty list if file not found or\n    no chunks in file.",
  "is_public": true
}
{
  "path": "io/duckdb_catalog.py",
  "module": "io.duckdb_catalog",
  "qualname": "DuckDBCatalog.get_embeddings_by_ids",
  "name": "get_embeddings_by_ids",
  "node_type": "FunctionDef",
  "lineno": 1598,
  "col": 4,
  "end_lineno": 1684,
  "end_col": 35,
  "parent_qualname": "DuckDBCatalog",
  "decorators": [],
  "bases": [],
  "docstring": "Extract embedding vectors for given chunk IDs.\n\nRetrieves the pre-computed embedding vectors for chunks, typically used\nafter a FAISS search to get the actual vectors for re-ranking or analysis.\nThe embeddings are stored in Parquet as FixedSizeList arrays and are\nconverted to NumPy arrays for efficient computation.\n\nThe function preserves the order of input IDs in the output array. If\nan ID is not found, it's silently skipped (the output will have fewer\nrows than input IDs).\n\nParameters\n----------\nids : Sequence[int]\n    Sequence of chunk IDs to retrieve embeddings for. IDs must exist\n    in the chunks table. Empty sequence returns empty array.\n\nReturns\n-------\ntuple[list[int], NDArrayF32]\n    Tuple of (resolved_ids, vectors) ordered by the input ID sequence.\n    ``resolved_ids`` contains the chunk IDs that were found. The vectors\n    array has shape ``(len(resolved_ids), vec_dim)`` and dtype float32.",
  "is_public": true
}
{
  "path": "io/duckdb_catalog.py",
  "module": "io.duckdb_catalog",
  "qualname": "DuckDBCatalog.count_chunks",
  "name": "count_chunks",
  "node_type": "FunctionDef",
  "lineno": 1686,
  "col": 4,
  "end_lineno": 1704,
  "end_col": 41,
  "parent_qualname": "DuckDBCatalog",
  "decorators": [],
  "bases": [],
  "docstring": "Count total number of chunks in the index.\n\nReturns the total number of chunks across all files. Useful for monitoring\nindex size and validating that indexing completed successfully.\n\nThe count is computed efficiently using DuckDB's COUNT aggregation over\nthe chunks view, which reads directly from Parquet files.\n\nReturns\n-------\nint\n    Total number of chunks in the index. Returns 0 if the chunks view\n    is empty or no Parquet files exist.",
  "is_public": true
}
{
  "path": "io/duckdb_catalog.py",
  "module": "io.duckdb_catalog",
  "qualname": "DuckDBCatalog._embedding_dim",
  "name": "_embedding_dim",
  "node_type": "FunctionDef",
  "lineno": 1706,
  "col": 4,
  "end_lineno": 1722,
  "end_col": 40,
  "parent_qualname": "DuckDBCatalog",
  "decorators": [],
  "bases": [],
  "docstring": "Return the embedding dimension, caching when possible.\n\nReturns\n-------\nint\n    Embedding dimension for the chunks table, or ``0`` when no rows exist.",
  "is_public": false
}
{
  "path": "io/duckdb_catalog.py",
  "module": "io.duckdb_catalog",
  "qualname": "_relation_exists",
  "name": "_relation_exists",
  "node_type": "FunctionDef",
  "lineno": 1725,
  "col": 0,
  "end_lineno": 1756,
  "end_col": 31,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return True when a table or view with ``name`` exists in the main schema.\n\nParameters\n----------\nconn : duckdb.DuckDBPyConnection\n    Active DuckDB connection to query.\nname : str\n    Name of the table or view to check for existence.\n\nReturns\n-------\nbool\n    ``True`` when the relation exists, otherwise ``False``.",
  "is_public": false
}
{
  "path": "io/duckdb_catalog.py",
  "module": "io.duckdb_catalog",
  "qualname": "relation_exists",
  "name": "relation_exists",
  "node_type": "FunctionDef",
  "lineno": 1759,
  "col": 0,
  "end_lineno": 1774,
  "end_col": 39,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Public helper returning True when a DuckDB relation exists.\n\nParameters\n----------\nconn : duckdb.DuckDBPyConnection\n    Active DuckDB connection to query.\nname : str\n    Name of the table or view to check for existence.\n\nReturns\n-------\nbool\n    ``True`` when the relation exists, otherwise ``False``.",
  "is_public": true
}
{
  "path": "io/duckdb_catalog.py",
  "module": "io.duckdb_catalog",
  "qualname": "_file_checksum",
  "name": "_file_checksum",
  "node_type": "FunctionDef",
  "lineno": 1777,
  "col": 0,
  "end_lineno": 1796,
  "end_col": 29,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return SHA-256 checksum for ``path``.\n\nParameters\n----------\npath : Path\n    File path to compute checksum for.\n\nReturns\n-------\nstr\n    Hex digest string representing the file contents.",
  "is_public": false
}
{
  "path": "io/duckdb_catalog.py",
  "module": "io.duckdb_catalog",
  "qualname": "_parquet_hash",
  "name": "_parquet_hash",
  "node_type": "FunctionDef",
  "lineno": 1799,
  "col": 0,
  "end_lineno": 1824,
  "end_col": 29,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return SHA256 checksum for the Parquet file at ``path``.\n\nThis function computes a SHA256 hash of a Parquet file's contents for\nintegrity verification. It is used by catalog operations to detect changes\nin FAISS ID map or chunk metadata files, enabling cache invalidation when\ndata files are updated.\n\nParameters\n----------\npath : str | Path\n    Path to the Parquet file to hash.\n\nReturns\n-------\nstr\n    Hexadecimal SHA256 digest representing the Parquet file contents.",
  "is_public": false
}
{
  "path": "io/duckdb_catalog.py",
  "module": "io.duckdb_catalog",
  "qualname": "ensure_faiss_idmap_view",
  "name": "ensure_faiss_idmap_view",
  "node_type": "FunctionDef",
  "lineno": 1827,
  "col": 0,
  "end_lineno": 1871,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Register ``v_faiss_join`` by joining FAISS ID map and chunk metadata.",
  "is_public": true
}
{
  "path": "io/duckdb_catalog.py",
  "module": "io.duckdb_catalog",
  "qualname": "refresh_faiss_idmap_materialized",
  "name": "refresh_faiss_idmap_materialized",
  "node_type": "FunctionDef",
  "lineno": 1874,
  "col": 0,
  "end_lineno": 1962,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Materialize ``v_faiss_join`` into ``faiss_idmap_mat`` with checksum guard.\n\nThis function refreshes the materialized FAISS ID map table by computing checksums\nof the source Parquet files and comparing them to cached values. If the checksums\ndiffer, the materialized table is rebuilt from the view. Used by catalog\noperations to ensure ID map queries remain fast while staying synchronized with\nupdated index files.\n\nParameters\n----------\nconn : duckdb.DuckDBPyConnection\n    DuckDB connection to use for executing SQL operations.\nidmap_parquet : str\n    Path to the FAISS ID map Parquet file containing faiss_row to external_id\n    mappings.\nchunks_parquet : str\n    Path to the chunks Parquet file containing chunk metadata (uri, lines,\n    language, text).\n\nReturns\n-------\nIdMapMeta\n    Metadata describing the materialized table including checksum, row count,\n    and whether a refresh occurred.",
  "is_public": true
}
{
  "path": "io/duckdb_manager.py",
  "module": "io.duckdb_manager",
  "qualname": "io.duckdb_manager",
  "name": "io.duckdb_manager",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Thread-safe DuckDB connection manager.",
  "is_public": true
}
{
  "path": "io/duckdb_manager.py",
  "module": "io.duckdb_manager",
  "qualname": "DuckDBConfig",
  "name": "DuckDBConfig",
  "node_type": "ClassDef",
  "lineno": 29,
  "col": 0,
  "end_lineno": 54,
  "end_col": 32,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Configuration parameters controlling DuckDB connections.\n\nAttributes\n----------\nthreads : int\n    Number of DuckDB worker threads to use for queries executed on the\n    returned connection. Defaults to ``4`` which offers good parallelism for\n    local development while remaining conservative for CI environments.\nenable_object_cache : bool\n    Enable DuckDB's object cache to reuse parsed query plans and cached\n    Parquet metadata across connections. Enabled by default for repeated\n    catalog queries.\nlog_queries : bool\n    Emit debug-level logs for every executed SQL statement. Disabled by\n    default to avoid noise in production environments.\npool_size : int | None\n    Maximum number of DuckDB connections to keep in the optional connection\n    pool. ``None`` or ``0`` disables pooling (default). When enabled,\n    connections are reused across requests up to the configured limit.",
  "is_public": true
}
{
  "path": "io/duckdb_manager.py",
  "module": "io.duckdb_manager",
  "qualname": "_InstrumentedDuckDBConnection",
  "name": "_InstrumentedDuckDBConnection",
  "node_type": "ClassDef",
  "lineno": 57,
  "col": 0,
  "end_lineno": 172,
  "end_col": 40,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Proxy connection that instruments DuckDB execute calls.",
  "is_public": false
}
{
  "path": "io/duckdb_manager.py",
  "module": "io.duckdb_manager",
  "qualname": "_InstrumentedDuckDBConnection.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 62,
  "col": 4,
  "end_lineno": 64,
  "end_col": 29,
  "parent_qualname": "_InstrumentedDuckDBConnection",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/duckdb_manager.py",
  "module": "io.duckdb_manager",
  "qualname": "_InstrumentedDuckDBConnection.execute",
  "name": "execute",
  "node_type": "FunctionDef",
  "lineno": 66,
  "col": 4,
  "end_lineno": 144,
  "end_col": 54,
  "parent_qualname": "_InstrumentedDuckDBConnection",
  "decorators": [],
  "bases": [],
  "docstring": "Execute a SQL query with instrumentation and telemetry.\n\nThis method wraps DuckDB connection execution with telemetry tracking,\nrecording query execution time, SQL length, and optionally the SQL\ntext itself. It creates timeline steps and OpenTelemetry spans for\nobservability.\n\nParameters\n----------\nquery : object\n    SQL query to execute. Accepts raw SQL strings or DuckDB ``Statement``\n    objects that expose precompiled statements.\nparameters : object | None, optional\n    Optional parameter payload bound to the statement before execution.\n\nReturns\n-------\nduckdb.DuckDBPyConnection\n    Instrumented connection (self) to support chaining follow-up calls\n    such as ``fetchall()`` without breaking existing code.\n\nNotes\n-----\nThis method instruments SQL execution with:\n- Timeline step (\"sql.exec\") with SQL length and optionally SQL text\n- OpenTelemetry span (\"duckdb.exec\") with query metadata\n- Timeline event (\"sql.exec.done\") with execution duration\n- Span event (\"duckdb.exec.complete\") with completion metadata\n\nThe method tracks execution time and records it in milliseconds. When\nlog_queries is enabled in the config, the SQL text (truncated to 5000\ncharacters) is included in telemetry attributes.",
  "is_public": true
}
{
  "path": "io/duckdb_manager.py",
  "module": "io.duckdb_manager",
  "qualname": "_InstrumentedDuckDBConnection.__getattr__",
  "name": "__getattr__",
  "node_type": "FunctionDef",
  "lineno": 146,
  "col": 4,
  "end_lineno": 172,
  "end_col": 40,
  "parent_qualname": "_InstrumentedDuckDBConnection",
  "decorators": [],
  "bases": [],
  "docstring": "Delegate attribute access to the underlying DuckDB connection.\n\nThis method allows transparent access to DuckDB connection methods\nand attributes that are not explicitly wrapped by this class.\n\nParameters\n----------\nname : str\n    Name of the attribute or method to access from the underlying\n    DuckDB connection.\n\nReturns\n-------\nobject\n    The requested attribute or method from the underlying connection.\n    Can be any attribute or method available on the DuckDB connection\n    object.\n\nNotes\n-----\nThis method enables transparent delegation to the underlying DuckDB\nconnection, allowing callers to use DuckDB-specific methods and\nattributes without explicit wrapper methods. Used for methods like\nfetchone(), fetchall(), etc. that are not explicitly wrapped.",
  "is_public": false
}
{
  "path": "io/duckdb_manager.py",
  "module": "io.duckdb_manager",
  "qualname": "DuckDBManager",
  "name": "DuckDBManager",
  "node_type": "ClassDef",
  "lineno": 175,
  "col": 0,
  "end_lineno": 309,
  "end_col": 85,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Factory for DuckDB connections with consistent pragmas.\n\nParameters\n----------\ndb_path : Path\n    Path to the DuckDB catalog database file.\nconfig : DuckDBConfig | None, optional\n    Connection configuration controlling threading and caching pragmas.\n    If ``None``, uses default configuration. Defaults to ``None``.",
  "is_public": true
}
{
  "path": "io/duckdb_manager.py",
  "module": "io.duckdb_manager",
  "qualname": "DuckDBManager.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 187,
  "col": 4,
  "end_lineno": 196,
  "end_col": 37,
  "parent_qualname": "DuckDBManager",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/duckdb_manager.py",
  "module": "io.duckdb_manager",
  "qualname": "DuckDBManager.connection",
  "name": "connection",
  "node_type": "FunctionDef",
  "lineno": 199,
  "col": 4,
  "end_lineno": 220,
  "end_col": 42,
  "parent_qualname": "DuckDBManager",
  "decorators": [
    "contextmanager"
  ],
  "bases": [],
  "docstring": "Yield a configured DuckDB connection.\n\nYields\n------\nduckdb.DuckDBPyConnection\n    Connection configured with requested pragmas and telemetry hooks.\n    The underlying DuckDB connection is automatically released when the\n    context manager exits.\n\nNotes\n-----\nWhen ``DuckDBConfig.pool_size`` is greater than zero, connections are\ntaken from and returned to an in-process pool, ensuring bounded\nconcurrency without reopening the database file for every request.",
  "is_public": true
}
{
  "path": "io/duckdb_manager.py",
  "module": "io.duckdb_manager",
  "qualname": "DuckDBManager.readonly_connection",
  "name": "readonly_connection",
  "node_type": "FunctionDef",
  "lineno": 223,
  "col": 4,
  "end_lineno": 236,
  "end_col": 24,
  "parent_qualname": "DuckDBManager",
  "decorators": [
    "contextmanager"
  ],
  "bases": [],
  "docstring": "Yield a dedicated read-only DuckDB connection (non pooled).\n\nYields\n------\nduckdb.DuckDBPyConnection\n    Instrumented connection opened in read-only mode.",
  "is_public": true
}
{
  "path": "io/duckdb_manager.py",
  "module": "io.duckdb_manager",
  "qualname": "DuckDBManager.config",
  "name": "config",
  "node_type": "FunctionDef",
  "lineno": 239,
  "col": 4,
  "end_lineno": 241,
  "end_col": 27,
  "parent_qualname": "DuckDBManager",
  "decorators": [
    "property"
  ],
  "bases": [],
  "docstring": "Return the active DuckDB configuration.",
  "is_public": true
}
{
  "path": "io/duckdb_manager.py",
  "module": "io.duckdb_manager",
  "qualname": "DuckDBManager.connections_created",
  "name": "connections_created",
  "node_type": "FunctionDef",
  "lineno": 244,
  "col": 4,
  "end_lineno": 249,
  "end_col": 40,
  "parent_qualname": "DuckDBManager",
  "decorators": [
    "property"
  ],
  "bases": [],
  "docstring": "Return the number of pooled connections created.",
  "is_public": true
}
{
  "path": "io/duckdb_manager.py",
  "module": "io.duckdb_manager",
  "qualname": "DuckDBManager.close",
  "name": "close",
  "node_type": "FunctionDef",
  "lineno": 251,
  "col": 4,
  "end_lineno": 264,
  "end_col": 45,
  "parent_qualname": "DuckDBManager",
  "decorators": [],
  "bases": [],
  "docstring": "Close all pooled connections and reset pool counters.",
  "is_public": true
}
{
  "path": "io/duckdb_manager.py",
  "module": "io.duckdb_manager",
  "qualname": "DuckDBManager.__del__",
  "name": "__del__",
  "node_type": "FunctionDef",
  "lineno": 266,
  "col": 4,
  "end_lineno": 269,
  "end_col": 24,
  "parent_qualname": "DuckDBManager",
  "decorators": [],
  "bases": [],
  "docstring": "Ensure pooled connections are released during garbage collection.",
  "is_public": false
}
{
  "path": "io/duckdb_manager.py",
  "module": "io.duckdb_manager",
  "qualname": "DuckDBManager._create_connection",
  "name": "_create_connection",
  "node_type": "FunctionDef",
  "lineno": 271,
  "col": 4,
  "end_lineno": 276,
  "end_col": 19,
  "parent_qualname": "DuckDBManager",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/duckdb_manager.py",
  "module": "io.duckdb_manager",
  "qualname": "DuckDBManager._acquire_connection",
  "name": "_acquire_connection",
  "node_type": "FunctionDef",
  "lineno": 278,
  "col": 4,
  "end_lineno": 296,
  "end_col": 31,
  "parent_qualname": "DuckDBManager",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/duckdb_manager.py",
  "module": "io.duckdb_manager",
  "qualname": "DuckDBManager._release_connection",
  "name": "_release_connection",
  "node_type": "FunctionDef",
  "lineno": 298,
  "col": 4,
  "end_lineno": 309,
  "end_col": 85,
  "parent_qualname": "DuckDBManager",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/duckdb_manager.py",
  "module": "io.duckdb_manager",
  "qualname": "DuckDBQueryOptions",
  "name": "DuckDBQueryOptions",
  "node_type": "ClassDef",
  "lineno": 313,
  "col": 0,
  "end_lineno": 325,
  "end_col": 26,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Options controlling DuckDB query generation.",
  "is_public": true
}
{
  "path": "io/duckdb_manager.py",
  "module": "io.duckdb_manager",
  "qualname": "DuckDBQueryBuilder",
  "name": "DuckDBQueryBuilder",
  "node_type": "ClassDef",
  "lineno": 328,
  "col": 0,
  "end_lineno": 519,
  "end_col": 84,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Helper for building parameterized DuckDB queries with scope filters.",
  "is_public": true
}
{
  "path": "io/duckdb_manager.py",
  "module": "io.duckdb_manager",
  "qualname": "DuckDBQueryBuilder.build_filter_query",
  "name": "build_filter_query",
  "node_type": "FunctionDef",
  "lineno": 331,
  "col": 4,
  "end_lineno": 421,
  "end_col": 26,
  "parent_qualname": "DuckDBQueryBuilder",
  "decorators": [],
  "bases": [],
  "docstring": "Return SQL and parameters for scoped chunk retrieval.\n\nParameters\n----------\nchunk_ids : Sequence[int]\n    Chunk identifiers to hydrate. Must not be empty.\noptions : DuckDBQueryOptions | None, optional\n    Query generation options including include/exclude globs, language\n    filters, select columns, and ordering behavior.\n\nReturns\n-------\ntuple[str, dict[str, list[int] | list[str] | str]]\n    SQL query string and mapping of named parameters to values.\n\nRaises\n------\nValueError\n    If ``chunk_ids`` is empty.",
  "is_public": true
}
{
  "path": "io/duckdb_manager.py",
  "module": "io.duckdb_manager",
  "qualname": "DuckDBQueryBuilder._build_join_clauses",
  "name": "_build_join_clauses",
  "node_type": "FunctionDef",
  "lineno": 424,
  "col": 4,
  "end_lineno": 446,
  "end_col": 20,
  "parent_qualname": "DuckDBQueryBuilder",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/duckdb_manager.py",
  "module": "io.duckdb_manager",
  "qualname": "DuckDBQueryBuilder._build_where_clauses",
  "name": "_build_where_clauses",
  "node_type": "FunctionDef",
  "lineno": 448,
  "col": 4,
  "end_lineno": 494,
  "end_col": 22,
  "parent_qualname": "DuckDBQueryBuilder",
  "decorators": [],
  "bases": [],
  "docstring": "Build WHERE clauses and populate params based on filters.\n\nParameters\n----------\nparams : dict[str, list[int] | list[str] | str]\n    Dictionary to populate with parameter values for SQL placeholders.\ninclude_globs : Sequence[str]\n    Glob patterns for paths to include in the query.\nexclude_globs : Sequence[str]\n    Glob patterns for paths to exclude from the query.\nlanguages : Sequence[str]\n    Language codes to filter by.\n\nReturns\n-------\nlist[str]\n    SQL fragments that should be combined with ``AND`` in the final query.",
  "is_public": false
}
{
  "path": "io/duckdb_manager.py",
  "module": "io.duckdb_manager",
  "qualname": "DuckDBQueryBuilder._glob_to_like",
  "name": "_glob_to_like",
  "node_type": "FunctionDef",
  "lineno": 497,
  "col": 4,
  "end_lineno": 515,
  "end_col": 22,
  "parent_qualname": "DuckDBQueryBuilder",
  "decorators": [
    "classmethod"
  ],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/duckdb_manager.py",
  "module": "io.duckdb_manager",
  "qualname": "DuckDBQueryBuilder._escape_like_wildcards",
  "name": "_escape_like_wildcards",
  "node_type": "FunctionDef",
  "lineno": 518,
  "col": 4,
  "end_lineno": 519,
  "end_col": 84,
  "parent_qualname": "DuckDBQueryBuilder",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/faiss_dual_index.py",
  "module": "io.faiss_dual_index",
  "qualname": "io.faiss_dual_index",
  "name": "io.faiss_dual_index",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "FAISS dual-index utilities and metadata helpers.",
  "is_public": true
}
{
  "path": "io/faiss_dual_index.py",
  "module": "io.faiss_dual_index",
  "qualname": "IndexManifest",
  "name": "IndexManifest",
  "node_type": "ClassDef",
  "lineno": 32,
  "col": 0,
  "end_lineno": 86,
  "end_col": 30,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Persisted metadata for FAISS dual-index deployments.",
  "is_public": true
}
{
  "path": "io/faiss_dual_index.py",
  "module": "io.faiss_dual_index",
  "qualname": "IndexManifest.from_file",
  "name": "from_file",
  "node_type": "FunctionDef",
  "lineno": 49,
  "col": 4,
  "end_lineno": 80,
  "end_col": 42,
  "parent_qualname": "IndexManifest",
  "decorators": [
    "classmethod"
  ],
  "bases": [],
  "docstring": "Load manifest metadata from a JSON document.\n\nParameters\n----------\npath : Path\n    Filesystem path to the manifest JSON file.\n\nReturns\n-------\nIndexManifest\n    Parsed manifest instance populated with the JSON payload.\n\nRaises\n------\nTypeError\n    If the JSON payload is not a mapping object.\nValueError\n    If required fields are missing or have incompatible types.",
  "is_public": true
}
{
  "path": "io/faiss_dual_index.py",
  "module": "io.faiss_dual_index",
  "qualname": "IndexManifest.to_file",
  "name": "to_file",
  "node_type": "FunctionDef",
  "lineno": 82,
  "col": 4,
  "end_lineno": 86,
  "end_col": 30,
  "parent_qualname": "IndexManifest",
  "decorators": [],
  "bases": [],
  "docstring": "Serialize the manifest to ``path`` as formatted JSON.",
  "is_public": true
}
{
  "path": "io/faiss_dual_index.py",
  "module": "io.faiss_dual_index",
  "qualname": "FAISSDualIndexManager",
  "name": "FAISSDualIndexManager",
  "node_type": "ClassDef",
  "lineno": 89,
  "col": 0,
  "end_lineno": 644,
  "end_col": 34,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Manage dual FAISS indexes with CPU/GPU coordination.",
  "is_public": true
}
{
  "path": "io/faiss_dual_index.py",
  "module": "io.faiss_dual_index",
  "qualname": "FAISSDualIndexManager.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 92,
  "col": 4,
  "end_lineno": 106,
  "end_col": 52,
  "parent_qualname": "FAISSDualIndexManager",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/faiss_dual_index.py",
  "module": "io.faiss_dual_index",
  "qualname": "FAISSDualIndexManager.set_test_indexes",
  "name": "set_test_indexes",
  "node_type": "FunctionDef",
  "lineno": 108,
  "col": 4,
  "end_lineno": 127,
  "end_col": 76,
  "parent_qualname": "FAISSDualIndexManager",
  "decorators": [],
  "bases": [],
  "docstring": "Set CPU indexes for testing purposes.\n\nThis method allows tests to inject CPU indexes directly, bypassing\nthe normal loading mechanism. It is public for testing purposes only.\n\nParameters\n----------\nprimary : faiss.Index | None\n    Primary CPU index to set.\nsecondary : faiss.Index | None\n    Secondary CPU index to set.",
  "is_public": true
}
{
  "path": "io/faiss_dual_index.py",
  "module": "io.faiss_dual_index",
  "qualname": "FAISSDualIndexManager.gpu_enabled",
  "name": "gpu_enabled",
  "node_type": "FunctionDef",
  "lineno": 130,
  "col": 4,
  "end_lineno": 132,
  "end_col": 32,
  "parent_qualname": "FAISSDualIndexManager",
  "decorators": [
    "property"
  ],
  "bases": [],
  "docstring": "Return ``True`` when GPU acceleration is enabled.",
  "is_public": true
}
{
  "path": "io/faiss_dual_index.py",
  "module": "io.faiss_dual_index",
  "qualname": "FAISSDualIndexManager.gpu_disabled_reason",
  "name": "gpu_disabled_reason",
  "node_type": "FunctionDef",
  "lineno": 135,
  "col": 4,
  "end_lineno": 137,
  "end_col": 40,
  "parent_qualname": "FAISSDualIndexManager",
  "decorators": [
    "property"
  ],
  "bases": [],
  "docstring": "Explain why GPU acceleration is disabled, if applicable.",
  "is_public": true
}
{
  "path": "io/faiss_dual_index.py",
  "module": "io.faiss_dual_index",
  "qualname": "FAISSDualIndexManager.primary_index",
  "name": "primary_index",
  "node_type": "FunctionDef",
  "lineno": 140,
  "col": 4,
  "end_lineno": 142,
  "end_col": 32,
  "parent_qualname": "FAISSDualIndexManager",
  "decorators": [
    "property"
  ],
  "bases": [],
  "docstring": "Return the loaded primary FAISS index, if available.",
  "is_public": true
}
{
  "path": "io/faiss_dual_index.py",
  "module": "io.faiss_dual_index",
  "qualname": "FAISSDualIndexManager.secondary_index",
  "name": "secondary_index",
  "node_type": "FunctionDef",
  "lineno": 145,
  "col": 4,
  "end_lineno": 147,
  "end_col": 34,
  "parent_qualname": "FAISSDualIndexManager",
  "decorators": [
    "property"
  ],
  "bases": [],
  "docstring": "Return the loaded secondary FAISS index, if available.",
  "is_public": true
}
{
  "path": "io/faiss_dual_index.py",
  "module": "io.faiss_dual_index",
  "qualname": "FAISSDualIndexManager.manifest",
  "name": "manifest",
  "node_type": "FunctionDef",
  "lineno": 150,
  "col": 4,
  "end_lineno": 152,
  "end_col": 29,
  "parent_qualname": "FAISSDualIndexManager",
  "decorators": [
    "property"
  ],
  "bases": [],
  "docstring": "Return the cached index manifest metadata, if one was loaded.",
  "is_public": true
}
{
  "path": "io/faiss_dual_index.py",
  "module": "io.faiss_dual_index",
  "qualname": "FAISSDualIndexManager.ensure_ready",
  "name": "ensure_ready",
  "node_type": "AsyncFunctionDef",
  "lineno": 154,
  "col": 4,
  "end_lineno": 195,
  "end_col": 46,
  "parent_qualname": "FAISSDualIndexManager",
  "decorators": [],
  "bases": [],
  "docstring": "Load FAISS artifacts from disk and prepare GPU state.\n\nReturns\n-------\ntuple[bool, str | None]\n    ``(ready, reason)`` where ``ready`` indicates whether CPU indexes are\n    available. ``reason`` carries a degradation message when GPU cloning\n    fails or prerequisites are missing.",
  "is_public": true
}
{
  "path": "io/faiss_dual_index.py",
  "module": "io.faiss_dual_index",
  "qualname": "FAISSDualIndexManager.close",
  "name": "close",
  "node_type": "FunctionDef",
  "lineno": 197,
  "col": 4,
  "end_lineno": 206,
  "end_col": 90,
  "parent_qualname": "FAISSDualIndexManager",
  "decorators": [],
  "bases": [],
  "docstring": "Release FAISS handles and GPU resources.",
  "is_public": true
}
{
  "path": "io/faiss_dual_index.py",
  "module": "io.faiss_dual_index",
  "qualname": "FAISSDualIndexManager.search",
  "name": "search",
  "node_type": "FunctionDef",
  "lineno": 208,
  "col": 4,
  "end_lineno": 283,
  "end_col": 33,
  "parent_qualname": "FAISSDualIndexManager",
  "decorators": [],
  "bases": [],
  "docstring": "Search primary and secondary indexes and merge results.\n\nParameters\n----------\nquery_vec : NDArrayF32\n    Query vector with shape ``(vec_dim,)`` or ``(1, vec_dim)``.\nk : int, optional\n    Number of results to return. Defaults to ``10``.\nnprobe : int | None, optional\n    IVF probe count for the primary index. When ``None`` uses the\n    configured ``IndexConfig.faiss_nprobe`` value.\n\nReturns\n-------\nlist[tuple[int, float]]\n    Top-``k`` ``(chunk_id, score)`` pairs sorted by decreasing score.\n\nRaises\n------\nRuntimeError\n    If the primary index has not been loaded via :meth:`ensure_ready`.\nValueError\n    If the query contains multiple vectors. Batch search support will be\n    added in a future task.",
  "is_public": true
}
{
  "path": "io/faiss_dual_index.py",
  "module": "io.faiss_dual_index",
  "qualname": "FAISSDualIndexManager.add_incremental",
  "name": "add_incremental",
  "node_type": "AsyncFunctionDef",
  "lineno": 285,
  "col": 4,
  "end_lineno": 374,
  "end_col": 9,
  "parent_qualname": "FAISSDualIndexManager",
  "decorators": [],
  "bases": [],
  "docstring": "Append vectors to the secondary index and persist them to disk.\n\nParameters\n----------\nvectors : NDArrayF32\n    2-D array of shape ``(n, vec_dim)`` containing the vectors to add. The\n    vectors are L2-normalized before insertion.\nchunk_ids : NDArrayI64\n    1-D array of shape ``(n,)`` containing the chunk identifiers to bind to\n    the provided vectors. IDs are coerced to ``int64``.\n\nRaises\n------\nRuntimeError\n    If :meth:`ensure_ready` has not been called yet.\nValueError\n    If the vectors do not match the configured embedding dimension or if\n    the number of vectors differs from the number of chunk IDs.",
  "is_public": true
}
{
  "path": "io/faiss_dual_index.py",
  "module": "io.faiss_dual_index",
  "qualname": "FAISSDualIndexManager.needs_compaction",
  "name": "needs_compaction",
  "node_type": "FunctionDef",
  "lineno": 376,
  "col": 4,
  "end_lineno": 396,
  "end_col": 32,
  "parent_qualname": "FAISSDualIndexManager",
  "decorators": [],
  "bases": [],
  "docstring": "Return ``True`` when the secondary index exceeds the compaction threshold.\n\nReturns\n-------\nbool\n    ``True`` when ``secondary.ntotal / primary.ntotal`` is greater than the\n    configured compaction threshold; otherwise ``False``.",
  "is_public": true
}
{
  "path": "io/faiss_dual_index.py",
  "module": "io.faiss_dual_index",
  "qualname": "FAISSDualIndexManager._reset_gpu_state",
  "name": "_reset_gpu_state",
  "node_type": "FunctionDef",
  "lineno": 398,
  "col": 4,
  "end_lineno": 403,
  "end_col": 40,
  "parent_qualname": "FAISSDualIndexManager",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/faiss_dual_index.py",
  "module": "io.faiss_dual_index",
  "qualname": "FAISSDualIndexManager._import_faiss",
  "name": "_import_faiss",
  "node_type": "FunctionDef",
  "lineno": 405,
  "col": 4,
  "end_lineno": 414,
  "end_col": 31,
  "parent_qualname": "FAISSDualIndexManager",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/faiss_dual_index.py",
  "module": "io.faiss_dual_index",
  "qualname": "FAISSDualIndexManager._load_primary_index",
  "name": "_load_primary_index",
  "node_type": "AsyncFunctionDef",
  "lineno": 416,
  "col": 4,
  "end_lineno": 453,
  "end_col": 32,
  "parent_qualname": "FAISSDualIndexManager",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/faiss_dual_index.py",
  "module": "io.faiss_dual_index",
  "qualname": "FAISSDualIndexManager._load_secondary_index",
  "name": "_load_secondary_index",
  "node_type": "AsyncFunctionDef",
  "lineno": 455,
  "col": 4,
  "end_lineno": 467,
  "end_col": 91,
  "parent_qualname": "FAISSDualIndexManager",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/faiss_dual_index.py",
  "module": "io.faiss_dual_index",
  "qualname": "FAISSDualIndexManager._wrap_with_idmap",
  "name": "_wrap_with_idmap",
  "node_type": "FunctionDef",
  "lineno": 469,
  "col": 4,
  "end_lineno": 475,
  "end_col": 22,
  "parent_qualname": "FAISSDualIndexManager",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/faiss_dual_index.py",
  "module": "io.faiss_dual_index",
  "qualname": "FAISSDualIndexManager._configure_direct_map",
  "name": "_configure_direct_map",
  "node_type": "FunctionDef",
  "lineno": 478,
  "col": 4,
  "end_lineno": 499,
  "end_col": 81,
  "parent_qualname": "FAISSDualIndexManager",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/faiss_dual_index.py",
  "module": "io.faiss_dual_index",
  "qualname": "FAISSDualIndexManager._load_manifest",
  "name": "_load_manifest",
  "node_type": "FunctionDef",
  "lineno": 501,
  "col": 4,
  "end_lineno": 514,
  "end_col": 33,
  "parent_qualname": "FAISSDualIndexManager",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/faiss_dual_index.py",
  "module": "io.faiss_dual_index",
  "qualname": "FAISSDualIndexManager.try_gpu_clone",
  "name": "try_gpu_clone",
  "node_type": "AsyncFunctionDef",
  "lineno": 516,
  "col": 4,
  "end_lineno": 574,
  "end_col": 9,
  "parent_qualname": "FAISSDualIndexManager",
  "decorators": [],
  "bases": [],
  "docstring": "Attempt to clone CPU indexes to GPU for acceleration.\n\nThis method is public for testing purposes. It attempts to clone\nboth primary and secondary CPU indexes to GPU if CUDA is available.\n\nParameters\n----------\nfaiss_module : ModuleType\n    FAISS module instance to use for GPU operations.",
  "is_public": true
}
{
  "path": "io/faiss_dual_index.py",
  "module": "io.faiss_dual_index",
  "qualname": "FAISSDualIndexManager._build_gpu_cloner_options",
  "name": "_build_gpu_cloner_options",
  "node_type": "FunctionDef",
  "lineno": 576,
  "col": 4,
  "end_lineno": 593,
  "end_col": 29,
  "parent_qualname": "FAISSDualIndexManager",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/faiss_dual_index.py",
  "module": "io.faiss_dual_index",
  "qualname": "FAISSDualIndexManager._clone_index_to_gpu",
  "name": "_clone_index_to_gpu",
  "node_type": "FunctionDef",
  "lineno": 595,
  "col": 4,
  "end_lineno": 629,
  "end_col": 17,
  "parent_qualname": "FAISSDualIndexManager",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/faiss_dual_index.py",
  "module": "io.faiss_dual_index",
  "qualname": "FAISSDualIndexManager._select_primary_index",
  "name": "_select_primary_index",
  "node_type": "FunctionDef",
  "lineno": 631,
  "col": 4,
  "end_lineno": 637,
  "end_col": 32,
  "parent_qualname": "FAISSDualIndexManager",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/faiss_dual_index.py",
  "module": "io.faiss_dual_index",
  "qualname": "FAISSDualIndexManager._select_secondary_index",
  "name": "_select_secondary_index",
  "node_type": "FunctionDef",
  "lineno": 639,
  "col": 4,
  "end_lineno": 644,
  "end_col": 34,
  "parent_qualname": "FAISSDualIndexManager",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "io.faiss_manager",
  "name": "io.faiss_manager",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "FAISS manager for GPU-accelerated vector search.\n\nManages adaptive FAISS indexes (Flat, IVFFlat, or IVF-PQ) with cuVS acceleration,\nCPU persistence, and GPU cloning. Index type is automatically selected based on\ncorpus size for optimal performance.",
  "is_public": true
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "_LazyFaissProxy",
  "name": "_LazyFaissProxy",
  "node_type": "ClassDef",
  "lineno": 81,
  "col": 0,
  "end_lineno": 121,
  "end_col": 43,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Deferred FAISS module loader to avoid import-time side effects.",
  "is_public": false
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "_LazyFaissProxy.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 86,
  "col": 4,
  "end_lineno": 87,
  "end_col": 46,
  "parent_qualname": "_LazyFaissProxy",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "_LazyFaissProxy.module",
  "name": "module",
  "node_type": "FunctionDef",
  "lineno": 89,
  "col": 4,
  "end_lineno": 100,
  "end_col": 27,
  "parent_qualname": "_LazyFaissProxy",
  "decorators": [],
  "bases": [],
  "docstring": "Return the cached FAISS module, importing it on demand.\n\nReturns\n-------\nModuleType\n    Materialized FAISS module.",
  "is_public": true
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "_LazyFaissProxy.__getattr__",
  "name": "__getattr__",
  "node_type": "FunctionDef",
  "lineno": 102,
  "col": 4,
  "end_lineno": 121,
  "end_col": 43,
  "parent_qualname": "_LazyFaissProxy",
  "decorators": [],
  "bases": [],
  "docstring": "Proxy attribute access to the underlying FAISS module.\n\nParameters\n----------\nname : str\n    Attribute name to resolve from the proxied FAISS module.\n\nReturns\n-------\nobject\n    Attribute resolved from the proxied FAISS module.\n\nNotes\n-----\nThis method enables transparent attribute access to FAISS module\nsymbols without eagerly importing the module. The first access triggers\nlazy import via `gate_import()`.",
  "is_public": false
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "_faiss_module",
  "name": "_faiss_module",
  "node_type": "FunctionDef",
  "lineno": 128,
  "col": 0,
  "end_lineno": 136,
  "end_col": 32,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return the lazily imported FAISS module.\n\nReturns\n-------\nModuleType\n    Cached FAISS module instance.",
  "is_public": false
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "_has_faiss_gpu_support",
  "name": "_has_faiss_gpu_support",
  "node_type": "FunctionDef",
  "lineno": 139,
  "col": 0,
  "end_lineno": 152,
  "end_col": 64,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return ``True`` when FAISS exposes GPU bindings, otherwise ``False``.\n\nReturns\n-------\nbool\n    ``True`` when GPU capabilities are available, otherwise ``False``.",
  "is_public": false
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "apply_parameters",
  "name": "apply_parameters",
  "node_type": "FunctionDef",
  "lineno": 155,
  "col": 0,
  "end_lineno": 202,
  "end_col": 38,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Apply a FAISS ParameterSpace string to ``index``.\n\nThis function applies runtime tuning parameters to a FAISS index using the\nParameterSpace API. The parameter string specifies index-specific tuning\nknobs (e.g., nprobe for IVF indices, efSearch for HNSW indices) that control\nsearch behavior and performance. The parameters are applied in-place to the\nindex object, modifying its runtime behavior for subsequent search operations.\n\nParameters\n----------\nindex : FaissIndex\n    FAISS index object to apply parameters to. Must support the ParameterSpace\n    API (typically IVF, HNSW, or other tunable index types). The index is\n    modified in-place with the new parameter values.\nparam_str : str\n    Parameter string specifying tuning parameters in FAISS ParameterSpace format\n    (e.g., \"nprobe=32,efSearch=64\"). Must be non-empty and contain valid\n    parameter specifications for the index type.\n\nRaises\n------\nValueError\n    Raised in the following cases:\n    - ``param_str`` is empty or whitespace-only: parameter string must be\n      non-empty to apply valid tuning parameters\n    - Parameter application fails: FAISS ParameterSpace API raises\n      AttributeError, RuntimeError, or ValueError when the parameter string\n      is invalid, incompatible with the index type, or contains unsupported\n      parameters\n\nNotes\n-----\nThis function wraps the FAISS ParameterSpace API to provide a convenient\ninterface for applying runtime tuning parameters. The function validates input\nand provides clear error messages when parameter application fails. Time\ncomplexity: O(1) for parameter parsing and application. The function modifies\nthe index object in-place and is not thread-safe if the index is being used\nconcurrently. Parameters persist for the lifetime of the index object.",
  "is_public": true
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "_log_extra",
  "name": "_log_extra",
  "node_type": "FunctionDef",
  "lineno": 212,
  "col": 0,
  "end_lineno": 226,
  "end_col": 40,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Build structured logging extras for FAISS manager events.\n\nParameters\n----------\n**kwargs : object\n    Additional key-value pairs to include in logging extras. These are\n    merged with the base component name.\n\nReturns\n-------\ndict[str, object]\n    Merged dictionary with component name and provided kwargs.",
  "is_public": false
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "FAISSRuntimeOptions",
  "name": "FAISSRuntimeOptions",
  "node_type": "ClassDef",
  "lineno": 230,
  "col": 0,
  "end_lineno": 247,
  "end_col": 35,
  "parent_qualname": null,
  "decorators": [
    "dataclass(frozen=True, slots=True)"
  ],
  "bases": [],
  "docstring": "Runtime tuning options passed to :class:`FAISSManager`.",
  "is_public": true
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "SearchRuntimeOverrides",
  "name": "SearchRuntimeOverrides",
  "node_type": "ClassDef",
  "lineno": 251,
  "col": 0,
  "end_lineno": 256,
  "end_col": 33,
  "parent_qualname": null,
  "decorators": [
    "dataclass(frozen=True, slots=True)"
  ],
  "bases": [],
  "docstring": "Per-search overrides for HNSW/quantizer parameters.",
  "is_public": true
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "RefineSearchConfig",
  "name": "RefineSearchConfig",
  "node_type": "ClassDef",
  "lineno": 260,
  "col": 0,
  "end_lineno": 265,
  "end_col": 25,
  "parent_qualname": null,
  "decorators": [
    "dataclass(frozen=True, slots=True)"
  ],
  "bases": [],
  "docstring": "Configuration bundle for refine searches.",
  "is_public": true
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "_TuningOverrides",
  "name": "_TuningOverrides",
  "node_type": "ClassDef",
  "lineno": 269,
  "col": 0,
  "end_lineno": 276,
  "end_col": 26,
  "parent_qualname": null,
  "decorators": [
    "dataclass(frozen=True, slots=True)"
  ],
  "bases": [],
  "docstring": "Normalized tuning overrides extracted from a profile payload.",
  "is_public": false
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "_SearchExecutionParams",
  "name": "_SearchExecutionParams",
  "node_type": "ClassDef",
  "lineno": 280,
  "col": 0,
  "end_lineno": 286,
  "end_col": 17,
  "parent_qualname": null,
  "decorators": [
    "dataclass(frozen=True, slots=True)"
  ],
  "bases": [],
  "docstring": "Runtime parameters applied during dual search execution.",
  "is_public": false
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "_SearchPlan",
  "name": "_SearchPlan",
  "node_type": "ClassDef",
  "lineno": 290,
  "col": 0,
  "end_lineno": 297,
  "end_col": 29,
  "parent_qualname": null,
  "decorators": [
    "dataclass(frozen=True, slots=True)"
  ],
  "bases": [],
  "docstring": "Resolved parameters, query buffer, and timeline metadata for a search.",
  "is_public": false
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "_FAISSIdMapMixin",
  "name": "_FAISSIdMapMixin",
  "node_type": "ClassDef",
  "lineno": 300,
  "col": 0,
  "end_lineno": 474,
  "end_col": 22,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Mixin providing ID map export helpers.",
  "is_public": false
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "_FAISSIdMapMixin.get_idmap_array",
  "name": "get_idmap_array",
  "node_type": "FunctionDef",
  "lineno": 303,
  "col": 4,
  "end_lineno": 340,
  "end_col": 18,
  "parent_qualname": "_FAISSIdMapMixin",
  "decorators": [],
  "bases": [],
  "docstring": "Return the mapping from FAISS row IDs to external chunk IDs.\n\nReturns\n-------\nNDArrayI64\n    Array where ``array[row]`` equals the external chunk ID.\n\nRaises\n------\nRuntimeError\n    If the primary index is not wrapped with IndexIDMap2.\nTypeError\n    If the ID map interface is invalid.",
  "is_public": true
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "_FAISSIdMapMixin.export_idmap",
  "name": "export_idmap",
  "node_type": "FunctionDef",
  "lineno": 342,
  "col": 4,
  "end_lineno": 378,
  "end_col": 34,
  "parent_qualname": "_FAISSIdMapMixin",
  "decorators": [],
  "bases": [],
  "docstring": "Persist ``{faiss_row -> external_id}`` to Parquet and return row count.\n\nParameters\n----------\nout_path : Path\n    Destination path for the Parquet sidecar.\n\nReturns\n-------\nint\n    Number of ID rows exported.\n\nRaises\n------\nRuntimeError\n    If pyarrow is not available at runtime.",
  "is_public": true
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "_FAISSIdMapMixin.hydrate_by_ids",
  "name": "hydrate_by_ids",
  "node_type": "FunctionDef",
  "lineno": 380,
  "col": 4,
  "end_lineno": 421,
  "end_col": 46,
  "parent_qualname": "_FAISSIdMapMixin",
  "decorators": [],
  "bases": [],
  "docstring": "Hydrate chunk metadata for ``ids`` via the provided DuckDB catalog.\n\nThis method queries the DuckDB catalog to retrieve full chunk metadata\n(file paths, line numbers, text content, etc.) for a batch of chunk IDs.\nThe IDs correspond to external chunk identifiers stored in the FAISS index,\nenabling retrieval of complete chunk information after vector search.\n\nParameters\n----------\ncatalog : DuckDBCatalog\n    DuckDB catalog instance providing query_by_ids() method for batch\n    chunk metadata retrieval. The catalog must be initialized and connected\n    to the same database containing chunk metadata.\nids : Sequence[int]\n    Sequence of external chunk IDs to hydrate. These IDs should match\n    the IDs stored in the FAISS index (from add_vectors() or update_index()).\n    Empty sequences return an empty list without querying the catalog.\n\nReturns\n-------\nlist[dict]\n    List of hydrated chunk metadata dictionaries, one per ID. Each dictionary\n    contains chunk fields (id, uri, start_line, end_line, text, symbols, etc.)\n    as defined by the DuckDB catalog schema. The list may be shorter than\n    the input sequence if some IDs are not found in the catalog.\n\nNotes\n-----\nThis method performs database queries via the DuckDB catalog. Time complexity:\nO(n) where n is the number of IDs, plus database query overhead. The method\nlogs debug information including the count of IDs and index path for\nobservability. Thread-safe if the catalog instance is thread-safe.",
  "is_public": true
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "_FAISSIdMapMixin.reconstruct_batch",
  "name": "reconstruct_batch",
  "node_type": "FunctionDef",
  "lineno": 423,
  "col": 4,
  "end_lineno": 474,
  "end_col": 22,
  "parent_qualname": "_FAISSIdMapMixin",
  "decorators": [],
  "bases": [],
  "docstring": "Reconstruct vectors for a batch of external chunk IDs.\n\nThis method reconstructs the original embedding vectors for a batch of\nchunk IDs by querying the FAISS index. For quantized indexes (IVF-PQ),\nreconstruction returns approximate vectors (dequantized from the codebook).\nFor flat indexes, reconstruction returns exact vectors. The method requires\nthat the index supports direct map access for reconstruction.\n\nParameters\n----------\nids : Sequence[int]\n    Sequence of external chunk IDs to reconstruct vectors for. These IDs\n    should match the IDs stored in the FAISS index. Empty sequences return\n    an empty array with shape (0, vec_dim).\n\nReturns\n-------\nNDArrayF32\n    Array of reconstructed vectors with shape ``(len(ids), vec_dim)``.\n    Each row corresponds to one input ID. Vectors are float32 dtype and\n    normalized for cosine similarity (L2-normalized). For quantized indexes,\n    vectors are approximate reconstructions.\n\nRaises\n------\nRuntimeError\n    If the index does not support vector reconstruction (e.g., missing\n    direct map, unsupported index type, or reconstruction fails for a\n    specific ID). The error message includes the failing chunk ID for\n    debugging.\n\nNotes\n-----\nThis method requires that _configure_direct_map() has been called on\nthe index to enable reconstruction. Time complexity: O(len(ids) * vec_dim)\nfor reconstruction, plus index lookup overhead. The method performs no\nI/O operations and is thread-safe if the FAISS index is thread-safe.",
  "is_public": true
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "FAISSManager",
  "name": "FAISSManager",
  "node_type": "ClassDef",
  "lineno": 477,
  "col": 0,
  "end_lineno": 3714,
  "end_col": 31,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "_FAISSIdMapMixin"
  ],
  "docstring": "FAISS index manager with adaptive indexing, GPU support, and incremental updates.\n\nUses a dual-index architecture for fast incremental updates.\n\n**Primary Index** (built via `build_index()`):\n- Adaptive type selection based on corpus size\n- Small (<5K vectors): Flat index for exact search\n- Medium (5K-50K vectors): IVFFlat with dynamic nlist\n- Large (>50K vectors): IVF-PQ with dynamic nlist\n- Trained on initial corpus, expensive to rebuild\n\n**Secondary Index** (updated via `update_index()`):\n- Flat index (IndexFlatIP) for fast incremental additions\n- No training required - instant updates (seconds)\n- Used for new vectors added after initial build\n- Automatically searched alongside primary index\n\n**Architecture Diagram**:\n```\nSearch Query\n    |\n    > Primary Index (IVF-PQ/IVFFlat/Flat)\n    |       > Returns top-k results\n    |\n    > Secondary Index (Flat) [if exists]\n            > Returns top-k results\n    |\n    > Merge Results by Score\n            > Return top-k combined results\n```\n\nThe secondary index is optional and controlled by usage of `update_index()`.\nWhen `update_index()` is called, the secondary index is automatically created\nif it doesn't exist.     Use `merge_indexes()` periodically to merge secondary\ninto primary and rebuild for optimal performance.\n\nParameters\n----------\nindex_path : Path\n    Path to CPU index file.\nvec_dim : int\n    Vector dimension.\nnlist : int\n    Number of IVF centroids (used as fallback for large corpora if dynamic\n    calculation yields smaller value). For adaptive indexing, this parameter\n    is typically overridden by dynamic nlist calculation.\nuse_cuvs : bool\n    Enable cuVS acceleration.\nruntime : FAISSRuntimeOptions | None, optional\n    Runtime configuration overrides for FAISS index behavior, including\n    GPU settings, quantization parameters, and search tuning. If None,\n    uses default options from `FAISSRuntimeOptions()`.",
  "is_public": true
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "FAISSManager.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 534,
  "col": 4,
  "end_lineno": 582,
  "end_col": 35,
  "parent_qualname": "FAISSManager",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "FAISSManager._write_profile",
  "name": "_write_profile",
  "node_type": "FunctionDef",
  "lineno": 584,
  "col": 4,
  "end_lineno": 599,
  "end_col": 90,
  "parent_qualname": "FAISSManager",
  "decorators": [],
  "bases": [],
  "docstring": "Persist a minimal profile snapshot describing the active CPU index.",
  "is_public": false
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "FAISSManager.build_index",
  "name": "build_index",
  "node_type": "FunctionDef",
  "lineno": 601,
  "col": 4,
  "end_lineno": 691,
  "end_col": 66,
  "parent_qualname": "FAISSManager",
  "decorators": [],
  "bases": [],
  "docstring": "Build and train FAISS index with adaptive type selection.\n\nChooses the optimal index type based on corpus size:\n- Small corpus (<5K vectors): IndexFlatIP (exact search, no training)\n- Medium corpus (5K-50K vectors): IVFFlat with dynamic nlist\n- Large corpus (>50K vectors): IVF-PQ with dynamic nlist\n\nThis adaptive selection provides 10-100x faster training for small/medium\ncorpora while maintaining high recall (>95%) and search performance.\n\nParameters\n----------\nvectors : NDArrayF32\n    Training vectors of shape (n, vec_dim). Vectors are automatically\n    L2-normalized for cosine similarity.\n\nfamily : str | None, optional\n    Override the configured FAISS family when building the index. When\n    ``None`` the manager uses the configured family (or adaptive mode).\n\nNotes\n-----\nThe index type is selected automatically based on the number of vectors.\nSmall corpora use flat indexes (exact search) for simplicity and speed.\nMedium corpora use IVFFlat for balanced training time and recall.\nLarge corpora use IVF-PQ for memory efficiency and fast search.\n\nExamples\n--------\n>>> manager = FAISSManager(index_path=Path(\"index.faiss\"), vec_dim=2560)\n>>> vectors = np.random.randn(1000, 2560).astype(np.float32)\n>>> manager.build_index(vectors)\n>>> # Uses IndexFlatIP for 1000 vectors (small corpus)",
  "is_public": true
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "FAISSManager.estimate_memory_usage",
  "name": "estimate_memory_usage",
  "node_type": "FunctionDef",
  "lineno": 693,
  "col": 4,
  "end_lineno": 755,
  "end_col": 9,
  "parent_qualname": "FAISSManager",
  "decorators": [],
  "bases": [],
  "docstring": "Estimate memory usage in bytes for a given number of vectors.\n\nProvides memory estimates for CPU and GPU indexes based on the adaptive\nindex type that would be selected for the given corpus size. This is useful\nfor capacity planning and resource allocation.\n\nParameters\n----------\nn_vectors : int\n    Number of vectors to estimate memory for.\n\nReturns\n-------\ndict[str, int]\n    Dictionary with memory estimates in bytes:\n    - ``cpu_index_bytes``: Estimated CPU index memory usage\n    - ``gpu_index_bytes``: Estimated GPU index memory usage (includes ~20% overhead)\n    - ``total_bytes``: Total estimated memory (CPU + GPU)\n\nExamples\n--------\n>>> manager = FAISSManager(index_path=Path(\"index.faiss\"), vec_dim=2560)\n>>> estimates = manager.estimate_memory_usage(10000)\n>>> print(f\"CPU index: {estimates['cpu_index_bytes'] / 1e9:.2f} GB\")\nCPU index: 0.26 GB\n>>> print(f\"Total: {estimates['total_bytes'] / 1e9:.2f} GB\")\nTotal: 0.57 GB\n\nNotes\n-----\nMemory estimates are approximate and may vary based on:\n- Actual index type selected (flat vs IVFFlat vs IVF-PQ)\n- FAISS internal overhead\n- GPU memory fragmentation\n- Operating system memory management\n\nEstimates are typically within 20% of actual usage for most workloads.",
  "is_public": true
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "FAISSManager.add_vectors",
  "name": "add_vectors",
  "node_type": "FunctionDef",
  "lineno": 757,
  "col": 4,
  "end_lineno": 793,
  "end_col": 66,
  "parent_qualname": "FAISSManager",
  "decorators": [],
  "bases": [],
  "docstring": "Add vectors with IDs to the index.\n\nAdds a batch of vectors to the FAISS index with their associated IDs.\nThe vectors are normalized for cosine similarity (L2 normalization) before\nbeing added. IDs are used for retrieval - they should match the chunk IDs\nstored in DuckDB.\n\nThis method requires that build_index() has been called first to create\nand train the index structure.\n\nParameters\n----------\nvectors : NDArrayF32\n    Vectors to add, shape (n, vec_dim) where n is the number of vectors\n    and vec_dim matches the index dimension. Dtype should be float32.\nids : NDArrayI64\n    Unique IDs for each vector, shape (n,). IDs are stored as int64 in\n    FAISS. These should correspond to chunk IDs from the indexing pipeline.\n\nRaises\n------\nRuntimeError\n    If the index has not been built yet. Call build_index() first.",
  "is_public": true
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "FAISSManager.update_index",
  "name": "update_index",
  "node_type": "FunctionDef",
  "lineno": 795,
  "col": 4,
  "end_lineno": 861,
  "end_col": 9,
  "parent_qualname": "FAISSManager",
  "decorators": [],
  "bases": [],
  "docstring": "Add new vectors to secondary index for fast incremental updates.\n\nExtended Summary\n----------------\nThis method adds new vectors to a secondary flat index (IndexFlatIP) which\nrequires no training and provides instant updates. This enables fast incremental\nindexing without rebuilding the primary index. The method filters out vectors\nthat already exist in the primary index to avoid duplicates, then adds only\nunique vectors to the secondary index. This is used for real-time index updates\nduring active codebase indexing workflows.\n\nParameters\n----------\nnew_vectors : NDArrayF32\n    Array of new embedding vectors to add, shape (N, dim) where N is the number\n    of vectors and dim matches the index dimensionality. Must be float32 and\n    normalized if the index uses cosine similarity.\nnew_ids : NDArrayI64\n    Array of document/chunk IDs corresponding to new_vectors, shape (N,).\n    Must be integer type. IDs that already exist in the primary index will be\n    filtered out before adding to the secondary index.\n\nRaises\n------\nRuntimeError\n    If the secondary index is unexpectedly missing during the update. This\n    indicates a configuration or initialization error that should be resolved\n    before attempting updates.\n\nNotes\n-----\nTime complexity O(N * log(M)) where N is new_vectors count and M is existing\nindex size, due to duplicate checking. Space complexity O(N) for temporary\nstorage. The method performs I/O to update the FAISS index on disk. Thread-safe\nif called sequentially; concurrent updates may cause race conditions.",
  "is_public": true
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "FAISSManager._ensure_secondary_index",
  "name": "_ensure_secondary_index",
  "node_type": "FunctionDef",
  "lineno": 863,
  "col": 4,
  "end_lineno": 893,
  "end_col": 9,
  "parent_qualname": "FAISSManager",
  "decorators": [],
  "bases": [],
  "docstring": "Ensure the secondary flat index exists, creating it if necessary.\n\nThis method lazily initializes the secondary index used for fast incremental\nupdates. The secondary index is a flat (IndexFlatIP) index wrapped with\nIndexIDMap2 for ID management. It requires no training and enables instant\nvector additions without rebuilding the primary index.\n\nThe secondary index is created only once per manager instance. Subsequent\ncalls to this method are no-ops if the index already exists. The index is\nconfigured with direct map support to enable vector reconstruction.\n\nNotes\n-----\nThe secondary index uses IndexFlatIP (inner product) for exact search over\nnewly added vectors. This provides fast incremental updates at the cost of\nlinear search time. The index is automatically searched alongside the primary\nindex during dual-index search operations. Time complexity: O(1) if index\nexists, O(1) for creation (no training required). The method performs no I/O\noperations and is idempotent.",
  "is_public": false
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "FAISSManager._build_primary_contains",
  "name": "_build_primary_contains",
  "node_type": "FunctionDef",
  "lineno": 895,
  "col": 4,
  "end_lineno": 941,
  "end_col": 57,
  "parent_qualname": "FAISSManager",
  "decorators": [],
  "bases": [],
  "docstring": "Build a function to check if chunk IDs exist in the primary index.\n\nThis method constructs a callable that checks whether a given chunk ID exists\nin the primary FAISS index. It attempts multiple strategies in order of\nefficiency: (1) use native contains() method if available, (2) use search()\nor find() methods that return index positions, (3) fall back to building a\nset of all existing IDs for O(1) lookup. The method handles cases where the\nindex is unavailable or lacks ID mapping support.\n\nReturns\n-------\nCallable[[int], bool]\n    Function that accepts a chunk ID (int) and returns True if the ID exists\n    in the primary index, False otherwise. The function is optimized for the\n    available FAISS ID map interface. Returns a no-op function (always False)\n    if the primary index is unavailable or lacks ID mapping support.\n\nNotes\n-----\nThis method is used by update_index() to filter out duplicate IDs before\nadding vectors to the secondary index. The returned function is thread-safe\nif the underlying FAISS index is thread-safe. Time complexity of the returned\nfunction depends on the strategy: O(1) for native contains() or set lookup,\nO(log n) for search-based methods. The method itself is O(1) if native\nmethods are available, O(n) if building an ID set is required.",
  "is_public": false
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "FAISSManager._build_existing_ids_set",
  "name": "_build_existing_ids_set",
  "node_type": "FunctionDef",
  "lineno": 944,
  "col": 4,
  "end_lineno": 992,
  "end_col": 24,
  "parent_qualname": "FAISSManager",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": "Build a set of all existing chunk IDs from the FAISS index.\n\nThis helper method extracts all chunk IDs stored in the FAISS index by\niterating through the ID map and collecting external IDs. It uses the\nid_map.at() method to retrieve the external ID for each internal index\nposition. This set is used as a fallback for duplicate checking when\nnative contains() methods are unavailable.\n\nParameters\n----------\ncpu_index : _faiss.Index\n    FAISS CPU index to extract IDs from. Must have an ntotal attribute\n    indicating the number of vectors in the index.\nid_map_obj : object\n    ID map object from the FAISS index (typically from index.id_map).\n    Must expose an at() method that accepts an index position and returns\n    the external chunk ID.\n\nReturns\n-------\nset[int]\n    Set containing all external chunk IDs stored in the index. Returns an\n    empty set if the index has no vectors, lacks ID mapping support, or\n    if extraction fails (e.g., missing at() method, type errors).\n\nNotes\n-----\nThis method is used as a fallback strategy when native contains() methods\nare unavailable. Building the set requires O(n) time and O(n) space where\nn is the number of vectors. The set enables O(1) ID lookups for duplicate\nchecking. The method handles errors gracefully, returning an empty set\nwhen extraction is not possible.",
  "is_public": false
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "FAISSManager._collect_unique_indices",
  "name": "_collect_unique_indices",
  "node_type": "FunctionDef",
  "lineno": 994,
  "col": 4,
  "end_lineno": 1049,
  "end_col": 29,
  "parent_qualname": "FAISSManager",
  "decorators": [],
  "bases": [],
  "docstring": "Collect indices of unique IDs that should be added to the secondary index.\n\nThis method filters the input ID array to identify which IDs are truly new\nand should be added to the secondary index. An ID is considered unique if\nit (1) appears only once in the current batch (no duplicates within batch),\n(2) is not already in the secondary index (not in incremental_ids), and\n(3) is not already in the primary index (checked via primary_contains).\n\nParameters\n----------\nnew_ids : NDArrayI64\n    Array of chunk IDs to check for uniqueness, shape (n,) or (n, 1).\n    The array is flattened before processing. IDs are converted to integers\n    for comparison.\nprimary_contains : Callable[[int], bool]\n    Function that checks if a chunk ID exists in the primary index. Returns\n    True if the ID exists, False otherwise. Used to filter out IDs that are\n    already indexed in the primary index.\n\nReturns\n-------\nlist[int]\n    List of array indices (offsets) corresponding to unique IDs that should\n    be added to the secondary index. The indices can be used to slice the\n    corresponding vectors array to extract only unique vectors. Returns an\n    empty list if all IDs are duplicates or already indexed.\n\nNotes\n-----\nThis method is used by update_index() to filter vectors before adding them\nto the secondary index. It performs three levels of deduplication: within\nbatch, against secondary index, and against primary index. Time complexity:\nO(n) where n is the number of IDs, plus O(k) for primary_contains checks\nwhere k is the number of unique IDs in the batch. Space complexity: O(n) for\nthe seen_in_batch set. The method is deterministic and preserves the order\nof first occurrence for unique IDs.",
  "is_public": false
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "FAISSManager._log_secondary_added",
  "name": "_log_secondary_added",
  "node_type": "FunctionDef",
  "lineno": 1052,
  "col": 4,
  "end_lineno": 1096,
  "end_col": 9,
  "parent_qualname": "FAISSManager",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": "Emit structured log event for secondary index vector additions.\n\nThis helper method logs information about vectors added to the secondary\nindex, including the number of vectors added in the current operation,\nthe total number of vectors in the secondary index after the addition,\nand the number of duplicate IDs that were skipped. Used for observability\nand debugging of incremental update operations.\n\nParameters\n----------\nadded : int\n    Number of vectors successfully added to the secondary index in the\n    current operation. Must be non-negative. Represents the count of\n    unique vectors that passed duplicate filtering.\ntotal_secondary_vectors : int\n    Total number of vectors in the secondary index after the current\n    addition. Must be >= added. Used to track the size of the secondary\n    index over time.\nskipped_duplicates : int\n    Number of duplicate IDs that were filtered out and not added to the\n    secondary index. Must be non-negative. Includes IDs that were already\n    in the primary index, already in the secondary index, or duplicated\n    within the current batch.\n\nNotes\n-----\nThis method emits structured logs with component=\"faiss_manager\" for\nconsistent log filtering and analysis. The log event is emitted at INFO\nlevel and includes all three metrics for comprehensive observability.\nTime complexity: O(1). The method performs no I/O operations beyond logging.",
  "is_public": false
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "FAISSManager.save_cpu_index",
  "name": "save_cpu_index",
  "node_type": "FunctionDef",
  "lineno": 1098,
  "col": 4,
  "end_lineno": 1120,
  "end_col": 58,
  "parent_qualname": "FAISSManager",
  "decorators": [],
  "bases": [],
  "docstring": "Save CPU index to disk for persistence.\n\nWrites the current CPU index to the file specified by index_path. The\nindex can be loaded later with load_cpu_index() to avoid rebuilding.\nThe parent directory is created if it doesn't exist.\n\nThe saved index includes all vectors and IDs that have been added. This\nis the CPU version - GPU indexes are cloned on-demand and not persisted.\n\nRaises\n------\nRuntimeError\n    If the index has not been built yet. Call build_index() first.",
  "is_public": true
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "FAISSManager.load_cpu_index",
  "name": "load_cpu_index",
  "node_type": "FunctionDef",
  "lineno": 1122,
  "col": 4,
  "end_lineno": 1187,
  "end_col": 17,
  "parent_qualname": "FAISSManager",
  "decorators": [],
  "bases": [],
  "docstring": "Load CPU index from disk.\n\nReads a previously saved FAISS index from index_path and loads it into\nmemory. This allows reusing an index without rebuilding it, which is much\nfaster for large indexes. Optionally exports the ID map and writes tuning\nprofile files for debugging and performance analysis.\n\nAfter loading, you can call clone_to_gpu() to create a GPU version for\nfaster search, or use search() directly with the CPU index.\n\nParameters\n----------\nexport_idmap : Path | None\n    Optional path to export the FAISS ID map as a Parquet file. If provided,\n    the ID map is written to this location. Defaults to None.\nprofile_path : Path | None\n    Optional path to write the autotune profile JSON. If provided, the\n    current tuning profile is persisted. If None, uses autotune_profile_path.\n    Defaults to None.\n\nRaises\n------\nFileNotFoundError\n    If the index file does not exist at index_path. Ensure the index was\n    saved with save_cpu_index() or that the path is correct.",
  "is_public": true
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "FAISSManager.save_secondary_index",
  "name": "save_secondary_index",
  "node_type": "FunctionDef",
  "lineno": 1189,
  "col": 4,
  "end_lineno": 1215,
  "end_col": 9,
  "parent_qualname": "FAISSManager",
  "decorators": [],
  "bases": [],
  "docstring": "Save secondary index to disk.\n\nWrites the current secondary index (if it exists) to a separate file\nalongside the primary index. The secondary index file uses the same\nname as the primary index with a `.secondary` suffix.\n\nThis allows persisting incremental updates so they can be restored\nafter restart. The secondary index is saved independently from the\nprimary index.\n\nRaises\n------\nRuntimeError\n    If the secondary index has not been created yet. Call update_index()\n    first to create the secondary index.",
  "is_public": true
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "FAISSManager.load_secondary_index",
  "name": "load_secondary_index",
  "node_type": "FunctionDef",
  "lineno": 1217,
  "col": 4,
  "end_lineno": 1258,
  "end_col": 9,
  "parent_qualname": "FAISSManager",
  "decorators": [],
  "bases": [],
  "docstring": "Load secondary index from disk.\n\nReads a previously saved secondary FAISS index from disk and loads it\ninto memory. This restores incremental updates that were made in a\nprevious session.\n\nAfter loading, the secondary index will be automatically searched\nalongside the primary index when using search(). The incremental_ids\nset is restored from the index contents.\n\nRaises\n------\nFileNotFoundError\n    If the secondary index file does not exist. This is normal if no\n    incremental updates have been made yet.",
  "is_public": true
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "FAISSManager.clone_to_gpu",
  "name": "clone_to_gpu",
  "node_type": "FunctionDef",
  "lineno": 1260,
  "col": 4,
  "end_lineno": 1353,
  "end_col": 19,
  "parent_qualname": "FAISSManager",
  "decorators": [],
  "bases": [],
  "docstring": "Clone CPU index to GPU for accelerated search.\n\nCreates a GPU-resident copy of the CPU index for faster search operations.\nThe GPU index uses the same structure (IVF-PQ) but runs on GPU hardware\nfor 10-100x speedup on large indexes.\n\nIf cuVS acceleration is enabled (use_cuvs=True), the function attempts to\nuse optimized cuVS kernels. If cuVS is unavailable, it falls back to\nstandard FAISS GPU operations.\n\nThe GPU index is kept in memory alongside the CPU index. Both can be\nused for search, but GPU is preferred when available.\n\nParameters\n----------\ndevice : int, optional\n    CUDA device ID to use (default: 0). Use device 0 for single-GPU systems.\n    For multi-GPU, specify the device ID (0, 1, 2, etc.).\n\nReturns\n-------\nbool\n    ``True`` when GPU acceleration is available. ``False`` when GPU\n    initialization fails and the manager falls back to the CPU index.\n\nRaises\n------\nRuntimeError\n    If the CPU index has not been loaded yet. Call load_cpu_index() or\n    build_index() first.",
  "is_public": true
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "FAISSManager.search",
  "name": "search",
  "node_type": "FunctionDef",
  "lineno": 1355,
  "col": 4,
  "end_lineno": 1552,
  "end_col": 21,
  "parent_qualname": "FAISSManager",
  "decorators": [],
  "bases": [],
  "docstring": "Search for nearest neighbors using cosine similarity with dual-index support.\n\nPerforms approximate nearest neighbor search using the FAISS index(es).\nWhen a secondary index exists (from incremental updates), searches both\nthe primary and secondary indexes, then merges results by score to return\nthe top-k most similar vectors overall.\n\nThe function automatically uses the GPU index if available (faster),\notherwise falls back to CPU. The nprobe parameter controls the trade-off\nbetween search speed and recall - higher values search more cells and\nimprove recall but slow down search.\n\nParameters\n----------\nquery : NDArrayF32\n    Query vector(s) of shape (n_queries, vec_dim) or (vec_dim,) for\n    single query. Dtype should be float32. Vectors are automatically\n    normalized for cosine similarity.\nk : int | None, optional\n    Number of nearest neighbors to return per query. If None, uses\n    `default_k` from runtime options (default: 50). Higher k improves\n    recall but increases computation and memory usage.\nnprobe : int | None, optional\n    Number of IVF cells to probe during search. If None, uses\n    `default_nprobe` from runtime options. Higher values improve recall\n    but slow down search. Should match or be less than the nlist parameter\n    used during index construction. Only applies to IVF-family indexes.\nruntime : SearchRuntimeOverrides | None, optional\n    Optional overrides controlling HNSW and refinement parameters.\ncatalog : object | None, optional\n    Optional catalog object (typically DuckDBCatalog) for candidate hydration\n    and exact reranking. When provided and ``refine_k_factor`` > 1, candidate\n    embeddings are hydrated from the catalog and reranked exactly before\n    returning results. The catalog must expose get_embeddings_by_ids() or\n    similar methods for embedding retrieval. When None, reranking is skipped.\n\nReturns\n-------\ntuple[NDArrayF32, NDArrayI64]\n    Tuple of (distances, ids) arrays:\n    - distances: shape (n_queries, k), cosine similarity scores (higher\n      is more similar, range typically 0-1 after normalization)\n    - ids: shape (n_queries, k), chunk IDs of the nearest neighbors.\n      IDs correspond to the ids passed to add_vectors() or update_index().\n\nRaises\n------\nVectorSearchError\n    If the FAISS search fails on CPU or GPU (e.g., index unavailable,\n    GPU failure, invalid parameters). The error contains context about\n    the index path and GPU usage for observability.\n\nNotes\n-----\nWhen both primary and secondary indexes exist, the method:\n1. Searches primary index with nprobe parameter\n2. Searches secondary index (flat, no nprobe)\n3. Merges results by score (inner product distance)\n4. Returns top-k combined results\n\nThis ensures incremental updates are immediately searchable without\nrebuilding the primary index. Time complexity depends on index type:\nO(n) for Flat, O(nprobe * k) for IVF-family, O(log n * ef_search) for HNSW.",
  "is_public": true
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "FAISSManager.search_with_refine",
  "name": "search_with_refine",
  "node_type": "FunctionDef",
  "lineno": 1554,
  "col": 4,
  "end_lineno": 1621,
  "end_col": 19,
  "parent_qualname": "FAISSManager",
  "decorators": [],
  "bases": [],
  "docstring": "Return structured hits with ANN search + exact rerank metadata.\n\nParameters\n----------\nquery : NDArrayF32\n    Query vector for ANN search. Must match the index dimension.\nk : int\n    Number of results to return after reranking.\ncatalog : DuckDBCatalog\n    DuckDB catalog for fetching chunk metadata and embeddings for\n    reranking. Used to hydrate candidate IDs into full chunk records.\nconfig : RefineSearchConfig | None, optional\n    Optional configuration bundle controlling nprobe, runtime overrides,\n    and telemetry source. When None, uses default settings (nprobe from\n    manager configuration, telemetry source ``faiss``).\n\nReturns\n-------\nlist[SearchHit]\n    List of SearchHit objects containing chunk metadata, scores, and\n    rerank information. Results are sorted by rerank score (descending)\n    when reranking is enabled, or by ANN distance (ascending) otherwise.",
  "is_public": true
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "FAISSManager._prepare_search_plan",
  "name": "_prepare_search_plan",
  "node_type": "FunctionDef",
  "lineno": 1623,
  "col": 4,
  "end_lineno": 1694,
  "end_col": 9,
  "parent_qualname": "FAISSManager",
  "decorators": [],
  "bases": [],
  "docstring": "Normalize query and resolve runtime knobs for a FAISS search.\n\nExtended Summary\n----------------\nThis helper method prepares a search plan by normalizing the query vector\n(L2 normalization), resolving effective k and search_k values, and applying\nruntime tuning overrides. It consolidates all search parameters into a\n_SearchPlan dataclass for consistent execution. Used internally by search()\nto prepare search parameters before executing FAISS queries.\n\nParameters\n----------\nquery : NDArrayF32\n    Query vector(s) to normalize and search. Shape (n_queries, vec_dim) or\n    (vec_dim,). Normalized to unit length using L2 normalization.\nk : int | None\n    Requested number of results. If None, uses default_k from settings.\nnprobe : int | None\n    Optional override for number of IVF cells to probe. If None, uses\n    default_nprobe or runtime overrides.\nruntime : SearchRuntimeOverrides | None\n    Optional runtime tuning overrides (ef_search, quantizer_ef_search, k_factor).\n    Applied to resolve final search parameters.\n\nReturns\n-------\n_SearchPlan\n    Search plan containing normalized queries, effective k, search_k (with\n    k_factor applied), and execution parameters (nprobe, ef_search, GPU flag).\n    The plan is ready for use in FAISS search execution.\n\nNotes\n-----\nThis method performs L2 normalization on query vectors and resolves all\nsearch parameters including k_factor expansion. Time complexity: O(n_queries * vec_dim)\nfor normalization plus O(1) for parameter resolution.",
  "is_public": false
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "FAISSManager.get_runtime_tuning",
  "name": "get_runtime_tuning",
  "node_type": "FunctionDef",
  "lineno": 1696,
  "col": 4,
  "end_lineno": 1721,
  "end_col": 9,
  "parent_qualname": "FAISSManager",
  "decorators": [],
  "bases": [],
  "docstring": "Return the effective runtime tuning parameters and overrides.\n\nReturns\n-------\ndict[str, object]\n    Dictionary with keys:\n    - \"active\": dict with current effective parameters (nprobe, efSearch,\n      quantizer_efSearch, k_factor)\n    - \"overrides\": dict with runtime override parameters\n    - \"autotune_profile\": dict with persisted autotune profile or empty dict",
  "is_public": true
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "FAISSManager.apply_runtime_tuning",
  "name": "apply_runtime_tuning",
  "node_type": "FunctionDef",
  "lineno": 1723,
  "col": 4,
  "end_lineno": 1770,
  "end_col": 40,
  "parent_qualname": "FAISSManager",
  "decorators": [],
  "bases": [],
  "docstring": "Apply runtime overrides (nprobe/efSearch/k_factor) to the active index.\n\nParameters\n----------\nnprobe : int | None, optional\n    Override for IVF nprobe parameter. If None, uses current value.\nef_search : int | None, optional\n    Override for HNSW ef_search parameter. If None, uses current value.\nquantizer_ef_search : int | None, optional\n    Override for IVF quantizer ef_search parameter. If None, uses current value.\nk_factor : float | None, optional\n    Override for search k factor (multiplier for candidate retrieval).\n    If None, uses current value.\n\nReturns\n-------\ndict[str, object]\n    Updated runtime tuning dictionary (same format as `get_runtime_tuning()`).\n\nRaises\n------\nValueError\n    If no tuning parameters are provided (all parameters are None).",
  "is_public": true
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "FAISSManager.reset_runtime_tuning",
  "name": "reset_runtime_tuning",
  "node_type": "FunctionDef",
  "lineno": 1772,
  "col": 4,
  "end_lineno": 1789,
  "end_col": 40,
  "parent_qualname": "FAISSManager",
  "decorators": [],
  "bases": [],
  "docstring": "Clear runtime overrides and revert to default (or autotuned) parameters.\n\nReturns\n-------\ndict[str, object]\n    Updated runtime tuning dictionary with cleared overrides (same format\n    as `get_runtime_tuning()`).",
  "is_public": true
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "FAISSManager.apply_tuning_profile",
  "name": "apply_tuning_profile",
  "node_type": "FunctionDef",
  "lineno": 1791,
  "col": 4,
  "end_lineno": 1842,
  "end_col": 23,
  "parent_qualname": "FAISSManager",
  "decorators": [],
  "bases": [],
  "docstring": "Apply a persisted tuning profile (typically from ``tuning.json``).\n\nParameters\n----------\nprofile : Mapping[str, Any]\n    Tuning profile dictionary containing runtime parameter overrides.\n    Expected keys include \"param_str\", \"nprobe\", \"efSearch\", \"k_factor\",\n    etc. The profile is typically loaded from a tuning.json file created\n    by the tuning process.\n\nReturns\n-------\ndict[str, object]\n    Current runtime tuning parameters after applying the profile. Returns\n    the same dictionary as get_runtime_tuning(), containing all active\n    runtime parameter overrides.\n\nRaises\n------\nVectorIndexIncompatibleError\n    Raised when the profile is empty or invalid. Profiles must contain\n    at least one valid parameter override.",
  "is_public": true
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "FAISSManager._search_primary",
  "name": "_search_primary",
  "node_type": "FunctionDef",
  "lineno": 1844,
  "col": 4,
  "end_lineno": 1894,
  "end_col": 42,
  "parent_qualname": "FAISSManager",
  "decorators": [],
  "bases": [],
  "docstring": "Search the primary index (adaptive type: Flat/IVFFlat/IVF-PQ).\n\nParameters\n----------\nquery : NDArrayF32\n    Query vector(s), shape (n_queries, vec_dim) or (vec_dim,).\nk : int\n    Number of nearest neighbors to return.\nnprobe : int\n    Number of IVF cells to probe (for IVF indexes).\n\nReturns\n-------\ntuple[NDArrayF32, NDArrayI64]\n    Tuple of (distances, ids) from primary index search.\n\nNotes\n-----\nFlat indexes (``IndexFlat*``) do not expose the ``nprobe`` attribute.\nThe method checks for attribute support before assigning so that flat\nindexes skip the IVF-only parameter while IVF indexes continue to use\n``nprobe`` for recall control.\n\nRaises\n------\nRuntimeError\n    If primary index is not available.",
  "is_public": false
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "FAISSManager._execute_dual_search",
  "name": "_execute_dual_search",
  "node_type": "FunctionDef",
  "lineno": 1896,
  "col": 4,
  "end_lineno": 1997,
  "end_col": 43,
  "parent_qualname": "FAISSManager",
  "decorators": [],
  "bases": [],
  "docstring": "Run primary + optional secondary search with tracing.\n\nParameters\n----------\nquery : NDArrayF32\n    Query vector(s) of shape (n_queries, vec_dim) or (vec_dim,).\n    Automatically normalized for cosine similarity.\nsearch_k : int\n    Number of candidates to retrieve from each index before merging.\n    Typically larger than final k to improve recall after merging.\nparams : _SearchExecutionParams\n    Runtime parameters describing IVF/HNSW traversal (nprobe, ef_search,\n    quantizer efSearch) and whether GPU search is used.\n\nReturns\n-------\ntuple[NDArrayF32, NDArrayI64]\n    Result set prior to top-k truncation. Distances and IDs from\n    merged primary and secondary searches.\n\nNotes\n-----\nThis is an internal method that orchestrates dual-index search with\nOpenTelemetry tracing. It applies runtime parameters, searches both\nindexes if secondary exists, merges results by score, and returns\nthe combined candidate set. Time complexity: O(search_k * log n)\nfor HNSW, O(nprobe * search_k) for IVF-family indexes.",
  "is_public": false
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "FAISSManager._maybe_refine_results",
  "name": "_maybe_refine_results",
  "node_type": "FunctionDef",
  "lineno": 1999,
  "col": 4,
  "end_lineno": 2081,
  "end_col": 40,
  "parent_qualname": "FAISSManager",
  "decorators": [],
  "bases": [],
  "docstring": "Optionally refine ANN candidates with exact similarity search.\n\nThis method performs optional refinement of approximate nearest neighbor\n(ANN) search results by computing exact similarity scores using the original\nembeddings from the catalog. Refinement improves recall by reranking\ncandidates based on exact inner product or cosine similarity rather than\napproximate distances from the FAISS index.\n\nRefinement is only performed when all conditions are met:\n- Catalog is available for embedding retrieval\n- Requested k is positive\n- Search k (with k_factor expansion) is greater than requested k\n- Refine k_factor is greater than 1.0\n\nParameters\n----------\ncatalog : DuckDBCatalog | None\n    DuckDB catalog instance providing embedding retrieval via\n    get_embeddings_by_ids(). If None, refinement is skipped.\nplan : _SearchPlan\n    Search plan containing normalized queries, effective k, search_k\n    (with k_factor applied), and execution parameters. Used to determine\n    refinement parameters and query vectors.\nidentifiers : NDArrayI64\n    Candidate chunk IDs from ANN search, shape (n_queries, search_k).\n    These IDs are used to retrieve embeddings for exact similarity computation.\nmetric_labels : Mapping[str, str] | None, optional\n    Prometheus metric labels applied when recording refinement latency.\n    When None, falls back to the unlabeled histogram variant.\n\nReturns\n-------\ntuple[NDArrayF32, NDArrayI64] | None\n    Tuple of (refined_scores, refined_ids) when refinement is performed\n    and successful, both with shape (n_queries, k). Returns None when\n    refinement is skipped (conditions not met), exact rerank is unavailable,\n    or refinement fails (falls back to ANN ordering). Refined scores are\n    exact similarity scores (inner product or cosine similarity); refined\n    IDs are the top-k chunk identifiers after reranking.\n\nNotes\n-----\nThis method uses exact_rerank() from codeintel_rev.retrieval.rerank_flat\nto compute exact similarities. Refinement is best-effort - if it fails,\nthe method returns None and the caller falls back to ANN ordering. Time\ncomplexity: O(n_queries * search_k * vec_dim) for exact similarity computation\nplus O(n_queries * search_k * log(search_k)) for sorting. The method\nrecords metrics (FAISS_REFINE_KEPT_RATIO, FAISS_REFINE_LATENCY_SECONDS)\nfor observability. Thread-safe if the catalog instance is thread-safe.",
  "is_public": false
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "FAISSManager._log_refine_delta",
  "name": "_log_refine_delta",
  "node_type": "FunctionDef",
  "lineno": 2084,
  "col": 4,
  "end_lineno": 2108,
  "end_col": 9,
  "parent_qualname": "FAISSManager",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": "Emit structured logs describing differences between ANN and refined hits.",
  "is_public": false
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "FAISSManager._search_secondary",
  "name": "_search_secondary",
  "node_type": "FunctionDef",
  "lineno": 2110,
  "col": 4,
  "end_lineno": 2147,
  "end_col": 57,
  "parent_qualname": "FAISSManager",
  "decorators": [],
  "bases": [],
  "docstring": "Search the secondary index (flat, no training required).\n\nThis method is public for testing and advanced use cases where\nseparate primary/secondary search results are needed.\n\nParameters\n----------\nquery : NDArrayF32\n    Query vector(s), shape (n_queries, vec_dim) or (vec_dim,).\nk : int\n    Number of nearest neighbors to return.\n\nReturns\n-------\ntuple[NDArrayF32, NDArrayI64]\n    Tuple of (distances, ids) from secondary index search.\n\nRaises\n------\nRuntimeError\n    If secondary index is not available (should not happen if called\n    from search() after checking existence).",
  "is_public": false
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "FAISSManager._primary_index_impl",
  "name": "_primary_index_impl",
  "node_type": "FunctionDef",
  "lineno": 2149,
  "col": 4,
  "end_lineno": 2159,
  "end_col": 41,
  "parent_qualname": "FAISSManager",
  "decorators": [],
  "bases": [],
  "docstring": "Return the underlying FAISS index implementation for primary CPU index.\n\nReturns\n-------\n_faiss.Index\n    Downcast FAISS index representing the current primary structure.",
  "is_public": false
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "FAISSManager._merge_results",
  "name": "_merge_results",
  "node_type": "FunctionDef",
  "lineno": 2162,
  "col": 4,
  "end_lineno": 2225,
  "end_col": 39,
  "parent_qualname": "FAISSManager",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": "Merge search results from two indexes by score.\n\nCombines results from primary and secondary indexes, sorts by distance\n(inner product, higher is better), and returns the top-k combined results.\n\nParameters\n----------\ndists1 : NDArrayF32\n    Distances from first index, shape (n_queries, k1).\nids1 : NDArrayI64\n    IDs from first index, shape (n_queries, k1).\ndists2 : NDArrayF32\n    Distances from second index, shape (n_queries, k2).\nids2 : NDArrayI64\n    IDs from second index, shape (n_queries, k2).\nk : int\n    Number of top results to return after merging.\n\nReturns\n-------\ntuple[NDArrayF32, NDArrayI64]\n    Tuple of (merged_distances, merged_ids), both shape (n_queries, k).\n    Results are sorted by distance (descending for inner product).\n\nNotes\n-----\nUses inner product distance (cosine similarity after normalization),\nwhere higher values indicate better matches. Results are sorted in\ndescending order and top-k is selected.",
  "is_public": false
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "FAISSManager.merge_indexes",
  "name": "merge_indexes",
  "node_type": "FunctionDef",
  "lineno": 2227,
  "col": 4,
  "end_lineno": 2317,
  "end_col": 9,
  "parent_qualname": "FAISSManager",
  "decorators": [],
  "bases": [],
  "docstring": "Merge secondary index into primary index (periodic rebuild).\n\nRebuilds the primary index to include all vectors from both the primary\nand secondary indexes. After merging, the secondary index is cleared,\nallowing for a fresh start for future incremental updates.\n\nThis operation is expensive (requires rebuilding the primary index) but\nshould be performed periodically to maintain optimal search performance.\nAfter merging, search operations will only query the primary index,\nwhich is faster than dual-index search.\n\nThe merge process:\n1. Extracts all vectors and IDs from both primary and secondary indexes\n2. Combines them into a single dataset\n3. Rebuilds the primary index with adaptive type selection\n4. Adds all vectors to the rebuilt primary index\n5. Clears the secondary index and incremental IDs\n\nNotes\n-----\nThis method requires that vectors can be reconstructed from the indexes.\nFor IVF-PQ indexes, reconstruction may be approximate (quantized).\nThe method will raise RuntimeError if reconstruction is not supported.\n\nExamples\n--------\n>>> manager = FAISSManager(index_path=Path(\"index.faiss\"), vec_dim=2560)\n>>> manager.build_index(initial_vectors)\n>>> manager.update_index(new_vectors, new_ids)  # Add incrementally\n>>> # Periodically merge to optimize performance\n>>> manager.merge_indexes()  # Rebuilds primary with all vectors\n\nRaises\n------\nRuntimeError\n    If the primary index is not available, or if vector extraction fails\n    (e.g., index does not support reconstruction or ID mapping).",
  "is_public": true
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "FAISSManager._extract_all_vectors",
  "name": "_extract_all_vectors",
  "node_type": "FunctionDef",
  "lineno": 2319,
  "col": 4,
  "end_lineno": 2382,
  "end_col": 27,
  "parent_qualname": "FAISSManager",
  "decorators": [],
  "bases": [],
  "docstring": "Extract all vectors and IDs from a FAISS index.\n\nReconstructs vectors from the index and retrieves their associated IDs.\nFor quantized indexes (e.g., IVF-PQ), reconstruction returns approximate\nvectors (dequantized from the codebook).\n\nParameters\n----------\nindex : _faiss.Index\n    FAISS index to extract vectors from. Must support `reconstruct()` and\n    have an `id_map` attribute (IndexIDMap2 wrapper).\n\nReturns\n-------\ntuple[NDArrayF32, NDArrayI64]\n    Tuple of (vectors, ids):\n    - vectors: shape (n_vectors, vec_dim), dtype float32\n    - ids: shape (n_vectors,), dtype int64\n\nRaises\n------\nRuntimeError\n    If the index does not support vector reconstruction or ID mapping.\n    This can occur with certain index types or if the index is not wrapped\n    with IndexIDMap2.\nTypeError\n    If the index's ``id_map`` interface is invalid (missing ``at`` or not callable),\n    or if the id_map interface is missing required methods.",
  "is_public": false
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "FAISSManager._try_load_cuvs",
  "name": "_try_load_cuvs",
  "node_type": "FunctionDef",
  "lineno": 2385,
  "col": 4,
  "end_lineno": 2411,
  "end_col": 44,
  "parent_qualname": "FAISSManager",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": "Load cuVS acceleration library if available.\n\nRaises\n------\nImportError\n    If the optional pylibcuvs package is not installed.\nRuntimeError\n    If the cuVS shared library cannot be loaded.",
  "is_public": false
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "FAISSManager._require_cpu_index",
  "name": "_require_cpu_index",
  "node_type": "FunctionDef",
  "lineno": 2413,
  "col": 4,
  "end_lineno": 2429,
  "end_col": 29,
  "parent_qualname": "FAISSManager",
  "decorators": [],
  "bases": [],
  "docstring": "Return the CPU index if initialized.\n\nReturns\n-------\n_faiss.Index\n    Initialized CPU FAISS index.\n\nRaises\n------\nVectorIndexStateError\n    If the index has not been built or loaded yet.",
  "is_public": false
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "FAISSManager.require_cpu_index",
  "name": "require_cpu_index",
  "node_type": "FunctionDef",
  "lineno": 2431,
  "col": 4,
  "end_lineno": 2439,
  "end_col": 40,
  "parent_qualname": "FAISSManager",
  "decorators": [],
  "bases": [],
  "docstring": "Return the CPU FAISS index via the public interface.\n\nReturns\n-------\n_faiss.Index\n    Initialized CPU FAISS index.",
  "is_public": true
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "FAISSManager._search_with_params",
  "name": "_search_with_params",
  "node_type": "FunctionDef",
  "lineno": 2445,
  "col": 4,
  "end_lineno": 2495,
  "end_col": 29,
  "parent_qualname": "FAISSManager",
  "decorators": [],
  "bases": [],
  "docstring": "Direct search utility that applies ParameterSpace overrides ad-hoc.\n\nParameters\n----------\nquery : NDArrayF32\n    Query vector(s) of shape (n_queries, vec_dim) or (vec_dim,).\n    Automatically normalized for cosine similarity.\nk : int\n    Number of nearest neighbors to return per query.\nparam_str : str | None, optional\n    FAISS ParameterSpace parameter string (e.g., \"nprobe=64,ef_search=128\").\n    Applied directly to the index before search. If None, uses index defaults.\nrefine_k_factor : float | None, optional\n    If > 1.0, refines results by running exact search over primary index\n    with k * refine_k_factor candidates. Improves recall at cost of latency.\n\nReturns\n-------\ntuple[NDArrayF32, NDArrayI64]\n    Distances/IDs pair for the provided query batch. Distances are cosine\n    similarity scores; IDs are chunk identifiers.\n\nNotes\n-----\nThis method bypasses the dual-index search path and applies FAISS\nParameterSpace settings directly. Useful for ad-hoc tuning experiments.\nTime complexity depends on index type and param_str settings.",
  "is_public": false
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "FAISSManager._save_tuning_profile",
  "name": "_save_tuning_profile",
  "node_type": "FunctionDef",
  "lineno": 2497,
  "col": 4,
  "end_lineno": 2541,
  "end_col": 21,
  "parent_qualname": "FAISSManager",
  "decorators": [],
  "bases": [],
  "docstring": "Persist ``profile`` to ``tuning.json`` and return its path.\n\nThis method saves an autotune profile (containing parameter strings, recall\nmetrics, latency measurements, and other tuning metadata) to a JSON file.\nThe profile is serialized with indentation for readability and stored at\nthe configured autotune profile path or a custom path if specified. The\nparent directory is created if it doesn't exist.\n\nParameters\n----------\nprofile : Mapping[str, Any]\n    Autotune profile dictionary containing tuning results. Typically includes\n    keys like \"param_str\" (parameter string), \"recall_at_k\" (recall metric),\n    \"latency_ms\" (search latency), and \"refine_k_factor\" (refinement factor).\n    The dictionary is serialized to JSON format.\npath : Path | None, optional\n    Custom file system path to save the profile to. If None, uses the\n    configured autotune_profile_path. The parent directory is created\n    automatically if it doesn't exist.\n\nReturns\n-------\nPath\n    File system path where the tuning profile was saved. This is either\n    the provided path or the default autotune_profile_path. The path\n    points to a JSON file containing the serialized profile data.\n\nNotes\n-----\nThis method performs file I/O to persist autotune results for later use.\nThe profile JSON file can be loaded to restore optimal tuning parameters\nwithout re-running autotune. Time complexity: O(n) where n is the size of\nthe profile dictionary. The method creates parent directories if needed and\noverwrites existing files. Thread-safe if file system operations are atomic.",
  "is_public": false
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "FAISSManager.autotune",
  "name": "autotune",
  "node_type": "FunctionDef",
  "lineno": 2543,
  "col": 4,
  "end_lineno": 2596,
  "end_col": 22,
  "parent_qualname": "FAISSManager",
  "decorators": [],
  "bases": [],
  "docstring": "Sweep FAISS ParameterSpace settings and persist the best profile.\n\nParameters\n----------\nqueries : NDArrayF32\n    Query vectors of shape (n_queries, vec_dim) for evaluation.\n    Automatically normalized for cosine similarity.\ntruths : NDArrayF32\n    Ground truth vectors of shape (n_truths, vec_dim) used to compute\n    recall. Automatically normalized for cosine similarity.\nk : int, optional\n    Number of nearest neighbors to retrieve during evaluation (default: 10).\nsweep : Sequence[str] | None, optional\n    List of ParameterSpace parameter strings to evaluate (e.g.,\n    [\"nprobe=16\", \"nprobe=32\", \"nprobe=64\"]). If None, uses default\n    sweep over nprobe values [16, 32, 64, 96, 128].\n\nReturns\n-------\nMapping[str, Any]\n    Summary dictionary with keys:\n    - \"recall_at_k\": float, best recall achieved\n    - \"latency_ms\": float, latency in milliseconds for best config\n    - \"param_str\": str, ParameterSpace string for best config\n    - Additional keys parsed from param_str (e.g., \"nprobe\", \"ef_search\")\n\nNotes\n-----\nThis method performs brute-force ground truth computation, then evaluates\neach parameter combination in the sweep. The best configuration (highest\nrecall, breaking ties by lowest latency) is persisted to\n`autotune_profile_path` and stored in `_tuned_parameters` for future use.\nTime complexity: O(n_queries * n_truths) for ground truth + O(len(sweep) * search_time).",
  "is_public": true
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "FAISSManager._build_adaptive_index",
  "name": "_build_adaptive_index",
  "node_type": "FunctionDef",
  "lineno": 2602,
  "col": 4,
  "end_lineno": 2661,
  "end_col": 38,
  "parent_qualname": "FAISSManager",
  "decorators": [],
  "bases": [],
  "docstring": "Construct an index structure using heuristics for corpus size.\n\nParameters\n----------\nvectors : NDArrayF32\n    Training vectors of shape (n_vectors, vec_dim). Must match\n    `self.vec_dim`. Automatically normalized for cosine similarity.\nn_vectors : int\n    Number of vectors in the corpus. Used to select index type:\n    - < 5K: Flat (exact search)\n    - 5K-50K: IVFFlat (approximate, fast training)\n    - > 50K: IVF-PQ (approximate, compressed)\n\nReturns\n-------\ntuple[_faiss.Index, str]\n    Trained FAISS index and a descriptive factory label (\"Flat\", \"IVFFlat\",\n    or \"IVFPQ\"). The index is ready for search after training completes.\n\nNotes\n-----\nThis method implements adaptive index selection based on corpus size to\nbalance search speed, recall, and memory usage. Small corpora use exact\nsearch (Flat), medium corpora use IVFFlat for fast approximate search,\nand large corpora use IVF-PQ for memory-efficient approximate search.\nTraining time: O(n_vectors) for Flat, O(n_vectors * log(nlist)) for IVF-family.",
  "is_public": false
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "FAISSManager._dynamic_nlist",
  "name": "_dynamic_nlist",
  "node_type": "FunctionDef",
  "lineno": 2663,
  "col": 4,
  "end_lineno": 2701,
  "end_col": 52,
  "parent_qualname": "FAISSManager",
  "decorators": [],
  "bases": [],
  "docstring": "Calculate the number of IVF centroids (nlist) based on corpus size.\n\nThis method computes the optimal number of IVF centroids (nlist) for\nbuilding IVF-family indexes. When faiss_family is \"auto\", it uses a\nsquare-root heuristic (sqrt(n_vectors)) which balances training time\nand search recall. When a specific family is configured, it uses the\nconfigured nlist value. The result is always bounded by the minimum\nparameter to ensure reasonable index structure.\n\nParameters\n----------\nn_vectors : int\n    Number of vectors in the corpus. Used to compute nlist when in auto\n    mode. Must be positive. Larger corpora result in larger nlist values\n    (up to the configured maximum).\nminimum : int\n    Minimum nlist value to return. Ensures the index has at least this\n    many centroids even for small corpora. Typically 100 for medium\n    corpora, 1024 for large corpora.\n\nReturns\n-------\nint\n    Computed nlist value for IVF index construction. When faiss_family\n    is \"auto\", returns max(sqrt(n_vectors), minimum). When a specific\n    family is configured, returns max(configured_nlist, minimum). The\n    value is always >= minimum.\n\nNotes\n-----\nThe square-root heuristic (sqrt(n_vectors)) is a common practice in\nFAISS indexing that balances training time (O(nlist * log(nlist))) and\nsearch recall. More centroids improve recall but increase training time\nand memory usage. The method is deterministic and has O(1) time complexity.",
  "is_public": false
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "FAISSManager._factory_string_for",
  "name": "_factory_string_for",
  "node_type": "FunctionDef",
  "lineno": 2703,
  "col": 4,
  "end_lineno": 2755,
  "end_col": 21,
  "parent_qualname": "FAISSManager",
  "decorators": [],
  "bases": [],
  "docstring": "Generate a FAISS index factory string for the specified family.\n\nThis method converts a family name (e.g., \"ivf_pq\", \"hnsw\") into a\nFAISS index factory string that can be passed to faiss.index_factory().\nThe factory string encodes the index structure, including quantization\nparameters (PQ codes, OPQ preprocessing), IVF centroids (nlist), and\nHNSW graph parameters (m). The string format follows FAISS conventions\nfor index construction.\n\nParameters\n----------\nfamily : str\n    Index family name (case-insensitive). Valid values: \"flat\", \"ivf_flat\",\n    \"ivf_pq\", \"ivf_pq_refine\", \"hnsw\". Determines the index structure\n    and quantization strategy. Unknown families default to \"Flat\".\n_n_vectors : int\n    Number of vectors (unused, kept for API compatibility). The factory\n    string does not depend on corpus size, only on the configured family\n    and runtime options.\n\nReturns\n-------\nstr\n    FAISS index factory string suitable for faiss.index_factory(). Examples:\n    - \"Flat\" for exact search\n    - \"IVF8192,Flat\" for IVFFlat with 8192 centroids\n    - \"OPQ64,IVF8192,PQ64x8\" for IVF-PQ with OPQ preprocessing\n    - \"HNSW32\" for HNSW with m=32\n    The string format matches FAISS ParameterSpace conventions.\n\nNotes\n-----\nThis method is used by build_index() when a specific family is requested\n(non-auto mode). The factory string incorporates runtime options like\npq_m, pq_nbits, opq_m, hnsw_m, and nlist. Time complexity: O(1). The\nmethod is deterministic and case-insensitive for family names.",
  "is_public": false
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "FAISSManager._record_factory_choice",
  "name": "_record_factory_choice",
  "node_type": "FunctionDef",
  "lineno": 2757,
  "col": 4,
  "end_lineno": 2814,
  "end_col": 9,
  "parent_qualname": "FAISSManager",
  "decorators": [],
  "bases": [],
  "docstring": "Record the selected index factory and persist metadata.\n\nThis method logs the index factory choice, updates Prometheus metrics,\nand persists index metadata to disk. It extracts the index type name\n(either from the provided label or by inspecting the index object),\nrecords it in metrics, and writes a metadata snapshot including factory\nname, vector count, and parameter space configuration.\n\nParameters\n----------\nindex : _faiss.Index\n    FAISS index object that was built or loaded. Used to extract the\n    index type name if label is not provided. The index must be\n    initialized (ntotal >= 0).\nlabel : str | None, optional\n    Optional factory label to use instead of inferring from the index\n    type. When provided, this label is used for logging and metrics.\n    When None, the method attempts to extract the type name from the\n    index object via downcast_index().\nparameter_space : str | None, optional\n    Optional FAISS ParameterSpace parameter string (e.g., \"nprobe=64\").\n    When provided, included in the metadata snapshot. Used to track\n    runtime tuning parameters applied to the index.\nvector_count : int | None, optional\n    Optional vector count to record in metadata. When None, uses\n    index.ntotal to determine the count. When provided, overrides the\n    index's ntotal value. Used to record the number of vectors used\n    during index construction.\n\nNotes\n-----\nThis method is called after index construction or loading to record the\nindex configuration for observability and persistence. It updates\nPrometheus metrics (set_factory_id) and writes metadata to the meta JSON\nfile. Time complexity: O(1) for logging and metrics, O(n) for metadata\nserialization where n is the metadata size. The method performs file I/O\nto persist metadata and is not thread-safe if called concurrently.",
  "is_public": false
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "FAISSManager._apply_runtime_parameters",
  "name": "_apply_runtime_parameters",
  "node_type": "FunctionDef",
  "lineno": 2816,
  "col": 4,
  "end_lineno": 2871,
  "end_col": 42,
  "parent_qualname": "FAISSManager",
  "decorators": [],
  "bases": [],
  "docstring": "Apply runtime search knobs to the active FAISS index.\n\nThis method applies runtime tuning parameters (nprobe, efSearch,\nquantizer_efSearch) to the active FAISS index using the ParameterSpace\nAPI. These parameters control search behavior: nprobe controls IVF cell\ntraversal, efSearch controls HNSW graph exploration, and quantizer_efSearch\ncontrols quantizer search depth. The method falls back to direct attribute\nassignment if ParameterSpace API is unavailable.\n\nParameters\n----------\nnprobe : int | None\n    Number of IVF cells to probe during search. Higher values improve\n    recall but slow down search. Only applies to IVF-family indexes.\n    When None, the parameter is not applied.\nef_search : int | None\n    HNSW exploration factor controlling graph traversal depth. Higher\n    values improve recall but slow down search. Only applies to HNSW\n    indexes. When None, the parameter is not applied.\nquantizer_ef_search : int | None, optional\n    Exploration factor for IVF quantizer search (default: None). Controls\n    quantizer traversal depth for hierarchical IVF indexes. When None,\n    the parameter is not applied.\n\nNotes\n-----\nThis method modifies the index object in-place, affecting all subsequent\nsearch operations until parameters are changed again. The method attempts\nto use FAISS ParameterSpace API first, then falls back to direct attribute\nassignment (e.g., index.nprobe) if ParameterSpace is unavailable. Time\ncomplexity: O(1) for parameter application. The method is not thread-safe\nif the index is being used concurrently. Parameters persist for the lifetime\nof the index object or until explicitly changed.",
  "is_public": false
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "FAISSManager._metric_labels",
  "name": "_metric_labels",
  "node_type": "FunctionDef",
  "lineno": 2873,
  "col": 4,
  "end_lineno": 2914,
  "end_col": 9,
  "parent_qualname": "FAISSManager",
  "decorators": [],
  "bases": [],
  "docstring": "Generate Prometheus metric labels from a search plan.\n\nThis method constructs a dictionary of metric labels for Prometheus\nhistograms and counters based on the search plan parameters. The labels\ninclude index family, nprobe setting, ef_search setting, and refine_k_factor\n(computed as search_k / k). These labels enable fine-grained metric\naggregation and analysis of search performance across different index\nconfigurations and parameter settings.\n\nParameters\n----------\nplan : _SearchPlan\n    Search plan containing queries, effective k, search_k (with k_factor\n    expansion), and execution parameters (nprobe, ef_search, etc.). Used\n    to extract parameter values for metric labeling.\n\nReturns\n-------\ndict[str, str]\n    Dictionary of Prometheus metric labels with keys:\n    - \"index_family\": Index family name (\"auto\", \"ivf_pq\", \"hnsw\", etc.)\n    - \"nprobe\": nprobe value as string, or \"default\" if None\n    - \"ef_search\": ef_search value as string, or empty string if None\n    - \"refine_k_factor\": Ratio of search_k to k, formatted as \"X.XX\"\n    All values are strings as required by Prometheus label constraints.\n\nNotes\n-----\nThis method is used by search() to label Prometheus metrics (e.g.,\nFAISS_ANN_LATENCY_SECONDS, FAISS_REFINE_LATENCY_SECONDS) for dimensional\nanalysis. The refine_k_factor is computed as search_k / k to represent\ncandidate expansion ratio. Time complexity: O(1). The method is deterministic\nand produces consistent labels for the same search plan.",
  "is_public": false
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "FAISSManager._maybe_apply_runtime_parameters",
  "name": "_maybe_apply_runtime_parameters",
  "node_type": "FunctionDef",
  "lineno": 2916,
  "col": 4,
  "end_lineno": 2960,
  "end_col": 13,
  "parent_qualname": "FAISSManager",
  "decorators": [],
  "bases": [],
  "docstring": "Best-effort application of overrides to the live index if available.\n\nThis method attempts to apply runtime parameter overrides to the active\nFAISS index, but gracefully handles failures without raising exceptions.\nIt extracts nprobe, efSearch, and quantizer_efSearch from the overrides\ndictionary and applies them via _apply_runtime_parameters(). If the index\nis unavailable or parameter application fails, the method logs a debug\nmessage and continues without error.\n\nParameters\n----------\noverrides : Mapping[str, float | int]\n    Dictionary of runtime parameter overrides with keys \"nprobe\", \"efSearch\",\n    or \"quantizer_efSearch\". Values are converted to integers before\n    application. Empty dictionaries result in no-op. Unrecognized keys are\n    ignored.\n\nNotes\n-----\nThis method is used by apply_runtime_tuning() and reset_runtime_tuning()\nto update the live index when overrides are changed. The method is\nbest-effort: it does not raise exceptions if the index is unavailable\nor parameter application fails, allowing the override dictionary to be\nupdated even when the index is not ready. Time complexity: O(1) plus\nthe cost of _apply_runtime_parameters(). The method performs no I/O\noperations and is safe to call even when the index is not initialized.",
  "is_public": false
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "FAISSManager._sanitize_runtime_overrides",
  "name": "_sanitize_runtime_overrides",
  "node_type": "FunctionDef",
  "lineno": 2963,
  "col": 4,
  "end_lineno": 2995,
  "end_col": 24,
  "parent_qualname": "FAISSManager",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "FAISSManager.set_search_parameters",
  "name": "set_search_parameters",
  "node_type": "FunctionDef",
  "lineno": 2997,
  "col": 4,
  "end_lineno": 3027,
  "end_col": 40,
  "parent_qualname": "FAISSManager",
  "decorators": [],
  "bases": [],
  "docstring": "Apply FAISS ParameterSpace string and persist overrides.\n\nParameters\n----------\nparam_str : str\n    Comma-separated FAISS ParameterSpace string\n    (e.g., ``\"nprobe=64,efSearch=128\"``).\n\nReturns\n-------\ndict[str, object]\n    Runtime tuning snapshot as returned by :meth:`get_runtime_tuning`.\n\nRaises\n------\nValueError\n    If the parameter string is invalid or FAISS rejects the override.",
  "is_public": true
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "FAISSManager._prepare_parameter_string",
  "name": "_prepare_parameter_string",
  "node_type": "FunctionDef",
  "lineno": 3029,
  "col": 4,
  "end_lineno": 3114,
  "end_col": 74,
  "parent_qualname": "FAISSManager",
  "decorators": [],
  "bases": [],
  "docstring": "Parse and validate a FAISS parameter string into FAISS spec and overrides.\n\nThis method parses a comma-separated parameter string (e.g., \"nprobe=64,efSearch=128\")\ninto two components: (1) a FAISS ParameterSpace string for direct index\napplication, and (2) a sanitized override dictionary for persistence. The\nmethod validates parameter names (must be supported), values (must be numeric),\nand constraints (positive integers, k_factor >= 1.0). The k_factor parameter\nis excluded from the FAISS spec (it's manager-specific) but included in overrides.\n\nParameters\n----------\nparam_str : str\n    Comma-separated parameter string in format \"key1=value1,key2=value2\".\n    Supported keys: \"nprobe\", \"efSearch\", \"quantizer_efSearch\", \"k_factor\".\n    Values must be numeric. Whitespace around keys/values is stripped.\n    Must be non-empty and contain at least one valid parameter.\n\nReturns\n-------\ntuple[str | None, dict[str, float]]\n    Tuple containing:\n    - FAISS ParameterSpace string (e.g., \"nprobe=64,efSearch=128\") for\n      direct index application, or None if no FAISS parameters are present\n      (only k_factor was specified)\n    - Sanitized override dictionary with validated parameters, ready for\n      storage in _runtime_overrides. Always non-empty (raises ValueError\n      if empty after parsing).\n\nRaises\n------\nValueError\n    Raised in the following cases:\n    - param_str is empty or whitespace-only: parameter string must be non-empty\n    - Invalid parameter fragment: malformed key=value pair (missing =, empty key/value)\n    - Non-numeric parameter value: value cannot be converted to float\n    - Unsupported parameter name: key is not in the supported set\n    - Parameter validation fails: value violates constraints (see _sanitize_runtime_overrides)\n    - No valid parameters: all parameters were invalid or only k_factor was provided\n      (k_factor alone is insufficient)\n\nNotes\n-----\nThis method is used by set_search_parameters() to parse user-provided parameter\nstrings. It separates FAISS-specific parameters (for direct index application)\nfrom manager-specific parameters (k_factor, for override storage). The method\nperforms comprehensive validation and provides clear error messages. Time\ncomplexity: O(n) where n is the length of param_str. The method is deterministic\nand raises exceptions for invalid inputs.",
  "is_public": false
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "FAISSManager._format_parameter_string",
  "name": "_format_parameter_string",
  "node_type": "FunctionDef",
  "lineno": 3117,
  "col": 4,
  "end_lineno": 3160,
  "end_col": 53,
  "parent_qualname": "FAISSManager",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": "Format runtime override dictionary into a parameter string.\n\nThis method converts a dictionary of runtime parameter overrides into a\ncomma-separated parameter string suitable for display or persistence.\nParameters are formatted in a canonical order (nprobe, efSearch,\nquantizer_efSearch, k_factor) with integer parameters formatted as integers\nand k_factor formatted as a float. The resulting string can be parsed back\nby _prepare_parameter_string().\n\nParameters\n----------\noverrides : Mapping[str, float]\n    Dictionary of runtime parameter overrides with keys \"nprobe\", \"efSearch\",\n    \"quantizer_efSearch\", and/or \"k_factor\". Values are expected to be\n    numeric (integers or floats). Only recognized keys are included in the\n    output; unknown keys are ignored.\n\nReturns\n-------\nstr | None\n    Comma-separated parameter string (e.g., \"nprobe=64,efSearch=128,k_factor=2.0\")\n    with parameters in canonical order. Integer parameters are formatted without\n    decimal points; k_factor retains decimal precision. Returns None if the\n    dictionary is empty or contains no recognized parameters.\n\nNotes\n-----\nThis method is used by _write_meta_snapshot() and get_runtime_tuning() to\nserialize override dictionaries for persistence and display. The method\nensures consistent formatting and ordering for readability. Time complexity:\nO(1) since the number of parameters is fixed. The method is deterministic\nand produces consistent output for the same input dictionary.",
  "is_public": false
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "FAISSManager._meta_snapshot",
  "name": "_meta_snapshot",
  "node_type": "FunctionDef",
  "lineno": 3162,
  "col": 4,
  "end_lineno": 3217,
  "end_col": 23,
  "parent_qualname": "FAISSManager",
  "decorators": [],
  "bases": [],
  "docstring": "Load and update index metadata snapshot from disk.\n\nThis method loads the existing metadata JSON file (if present) and merges\nit with current manager configuration to create a comprehensive metadata\nsnapshot. The snapshot includes index path, vector dimension, FAISS family,\ndefault parameters, and any previously persisted metadata (factory name,\nvector count, parameter space, etc.). Used as a base for _write_meta_snapshot()\nto preserve existing metadata while updating specific fields.\n\nReturns\n-------\ndict[str, object]\n    Metadata snapshot dictionary containing:\n    - \"index_path\": String path to the index file\n    - \"vec_dim\": Vector dimension (int)\n    - \"faiss_family\": Index family name (str)\n    - \"default_parameters\": Dictionary with default nprobe, efSearch,\n      quantizer_efSearch, and k_factor values\n    - Any additional fields from the existing metadata file (factory,\n      vector_count, parameter_space, runtime_overrides, etc.)\n    Returns a fresh dictionary with current configuration if the metadata\n    file doesn't exist or is invalid JSON.\n\nNotes\n-----\nThis method performs file I/O to read the metadata JSON file. If the file\ndoesn't exist or contains invalid JSON, it returns a dictionary with current\nconfiguration only. The method merges existing metadata with current settings,\nallowing incremental updates without losing historical data. Time complexity:\nO(1) for file existence check, O(n) for JSON parsing where n is file size.\nThe method handles JSON decode errors gracefully, returning an empty base\ndictionary.",
  "is_public": false
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "FAISSManager._write_meta_snapshot",
  "name": "_write_meta_snapshot",
  "node_type": "FunctionDef",
  "lineno": 3219,
  "col": 4,
  "end_lineno": 3271,
  "end_col": 87,
  "parent_qualname": "FAISSManager",
  "decorators": [],
  "bases": [],
  "docstring": "Write index metadata snapshot to disk.\n\nThis method creates or updates the index metadata JSON file with current\nmanager configuration, runtime overrides, compile options, and optional\nupdate fields (factory name, vector count, parameter space). The metadata\nfile serves as a persistent record of index configuration for observability,\ndebugging, and index lifecycle management. The file is written with JSON\nindentation for readability.\n\nParameters\n----------\nfactory : str | None, optional\n    Optional factory name (index type) to record in metadata. When provided,\n    updates the \"factory\" field. When None, preserves existing factory value\n    or leaves it unset. Used to track the index structure (e.g., \"IVF8192,Flat\").\nvector_count : int | None, optional\n    Optional vector count to record in metadata. When provided, updates the\n    \"vector_count\" field. When None, preserves existing count or leaves it\n    unset. Used to track the number of vectors in the index.\nparameter_space : str | None, optional\n    Optional FAISS ParameterSpace parameter string to record in metadata.\n    When provided, updates the \"parameter_space\" field. When None, preserves\n    existing parameter space or leaves it unset. Used to track runtime tuning\n    parameters (e.g., \"nprobe=64,efSearch=128\").\n\nNotes\n-----\nThis method performs file I/O to write the metadata JSON file. The parent\ndirectory is created if it doesn't exist. The metadata includes a timestamp\n(updated_at) in ISO format for tracking when the snapshot was last updated.\nTime complexity: O(n) where n is the metadata size for JSON serialization,\nplus file I/O overhead. The method overwrites the existing metadata file\nand is not thread-safe if called concurrently.",
  "is_public": false
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "FAISSManager.get_compile_options",
  "name": "get_compile_options",
  "node_type": "FunctionDef",
  "lineno": 3274,
  "col": 4,
  "end_lineno": 3284,
  "end_col": 37,
  "parent_qualname": "FAISSManager",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": "Return FAISS compile options string when available.\n\nReturns\n-------\nstr\n    Compile-time configuration string for FAISS, including enabled\n    features and build flags. Returns an empty string if compile options\n    are not available.",
  "is_public": true
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "FAISSManager._resolve_search_knobs",
  "name": "_resolve_search_knobs",
  "node_type": "FunctionDef",
  "lineno": 3286,
  "col": 4,
  "end_lineno": 3357,
  "end_col": 57,
  "parent_qualname": "FAISSManager",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "FAISSManager._resolve_search_knobs._lookup_override",
  "name": "_lookup_override",
  "node_type": "FunctionDef",
  "lineno": 3299,
  "col": 8,
  "end_lineno": 3304,
  "end_col": 23,
  "parent_qualname": "FAISSManager._resolve_search_knobs",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "FAISSManager._resolve_search_knobs._pick",
  "name": "_pick",
  "node_type": "FunctionDef",
  "lineno": 3306,
  "col": 8,
  "end_lineno": 3323,
  "end_col": 26,
  "parent_qualname": "FAISSManager._resolve_search_knobs",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "FAISSManager._load_tuned_profile",
  "name": "_load_tuned_profile",
  "node_type": "FunctionDef",
  "lineno": 3359,
  "col": 4,
  "end_lineno": 3413,
  "end_col": 22,
  "parent_qualname": "FAISSManager",
  "decorators": [],
  "bases": [],
  "docstring": "Load autotune profile from disk with caching.\n\nThis method loads the persisted autotune profile (tuning results) from the\nJSON file, caches it in _tuned_parameters for subsequent access, and returns\nthe profile dictionary. The profile contains optimal parameter settings\ndiscovered during autotune sweeps, including param_str, recall_at_k, latency_ms,\nand extracted parameter values (nprobe, efSearch, etc.). The method handles\nfile I/O errors and JSON parsing errors gracefully, returning an empty\ndictionary when the profile cannot be loaded.\n\nReturns\n-------\ndict[str, float | str]\n    Autotune profile dictionary containing tuning results. Typical keys include:\n    - \"param_str\": Best parameter string (str)\n    - \"recall_at_k\": Best recall metric (float)\n    - \"latency_ms\": Search latency for best config (float)\n    - \"nprobe\", \"efSearch\", etc.: Extracted parameter values (float/int)\n    Returns the cached profile if already loaded, or an empty dictionary if\n    the profile file doesn't exist, cannot be read, or contains invalid JSON.\n\nNotes\n-----\nThis method implements caching: the profile is loaded once and stored in\n_tuned_parameters for subsequent calls. The method checks both the primary\nautotune profile path and legacy path for backward compatibility. Time\ncomplexity: O(1) if cached, O(n) for file I/O and JSON parsing where n is\nfile size. The method performs file I/O and handles errors gracefully without\nraising exceptions. Thread-safe if called under lock protection (as used in\n_resolve_search_knobs).",
  "is_public": false
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "FAISSManager._profile_path_for_read",
  "name": "_profile_path_for_read",
  "node_type": "FunctionDef",
  "lineno": 3415,
  "col": 4,
  "end_lineno": 3444,
  "end_col": 19,
  "parent_qualname": "FAISSManager",
  "decorators": [],
  "bases": [],
  "docstring": "Determine the autotune profile file path for reading.\n\nThis method checks for the existence of autotune profile files in order of\npreference: (1) primary autotune profile path (autotune_profile_path),\n(2) legacy autotune profile path (_legacy_autotune_profile_path). Returns\nthe first path that exists, or None if neither file exists. This enables\nbackward compatibility with older profile file locations while preferring\nthe new location.\n\nReturns\n-------\nPath | None\n    Path to the autotune profile JSON file if it exists, or None if neither\n    the primary nor legacy profile files are present. The returned path can\n    be used to read the profile data. Returns the primary path if both exist.\n\nNotes\n-----\nThis method performs file system checks to determine which profile file to\nuse. The legacy path uses a different naming convention (.tune.json suffix\nvs tuning.json filename) for backward compatibility. Time complexity: O(1)\nfor file existence checks. The method performs no I/O operations beyond\nexistence checks and is deterministic.",
  "is_public": false
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "FAISSManager._timed_search_with_params",
  "name": "_timed_search_with_params",
  "node_type": "FunctionDef",
  "lineno": 3446,
  "col": 4,
  "end_lineno": 3493,
  "end_col": 30,
  "parent_qualname": "FAISSManager",
  "decorators": [],
  "bases": [],
  "docstring": "Execute a parameterized search and measure its latency.\n\nThis method performs a FAISS search with the specified parameter string\nand measures the execution time in milliseconds. It wraps _search_with_params()\nwith timing instrumentation, recording the elapsed time from start to completion.\nUsed by autotune sweeps to evaluate parameter configurations and select optimal\nsettings based on recall and latency trade-offs.\n\nParameters\n----------\nqueries : NDArrayF32\n    Query vector(s) to search, shape (n_queries, vec_dim) or (vec_dim,).\n    Automatically normalized for cosine similarity by _search_with_params().\nk : int\n    Number of nearest neighbors to return per query. Must be positive.\n    Used to retrieve top-k results for evaluation.\nparam_str : str\n    FAISS ParameterSpace parameter string (e.g., \"nprobe=64,efSearch=128\").\n    Applied to the index before search. Used to test different parameter\n    configurations during autotune sweeps.\n\nReturns\n-------\ntuple[float, tuple[NDArrayF32, NDArrayI64]]\n    Tuple containing:\n    - Elapsed time in milliseconds (float): Search execution time measured\n      using perf_counter() for high-resolution timing\n    - Search results tuple: (distances, ids) arrays from _search_with_params(),\n      both with shape (n_queries, k). Distances are cosine similarity scores;\n      IDs are chunk identifiers.\n\nNotes\n-----\nThis method is used by AutoTuner.run_sweep() to evaluate parameter\nconfigurations during autotune sweeps. The timing measurement uses\nperf_counter() for high-resolution, monotonic timing that is not affected\nby system clock adjustments. Time complexity: O(search_time) where search_time\ndepends on index type and parameters, plus O(1) for timing overhead. The\nmethod modifies the index parameters in-place before search, affecting\nsubsequent searches until parameters are changed again.",
  "is_public": false
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "FAISSManager._brute_force_truth_ids",
  "name": "_brute_force_truth_ids",
  "node_type": "FunctionDef",
  "lineno": 3496,
  "col": 4,
  "end_lineno": 3546,
  "end_col": 35,
  "parent_qualname": "FAISSManager",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": "Compute ground-truth nearest neighbor IDs via exact brute-force search.\n\nThis method performs exact nearest neighbor search by computing the full\nsimilarity matrix (queries @ truths.T) and selecting the top-k most similar\ntruth vectors for each query. It uses argpartition for efficient top-k\nselection without full sorting. The result provides ground-truth IDs for\nrecall evaluation during autotune sweeps.\n\nParameters\n----------\nqueries : NDArrayF32\n    Query vectors with shape (n_queries, vec_dim) and dtype float32.\n    Used to compute similarities against truth vectors. Vectors should be\n    normalized for cosine similarity (inner product).\ntruths : NDArrayF32\n    Ground-truth vectors with shape (n_truths, vec_dim) and dtype float32.\n    Used as the corpus for exact nearest neighbor search. Vectors should be\n    normalized for cosine similarity. The number of truth vectors determines\n    the maximum k value (clamped to n_truths).\nk : int\n    Number of nearest neighbors to retrieve per query. Must be positive.\n    Clamped to min(k, n_truths) to avoid exceeding the truth corpus size.\n    When k <= 0 or k > n_truths, returns an empty array.\n\nReturns\n-------\nNDArrayI64\n    Array of ground-truth nearest neighbor indices with shape (n_queries, k_eff)\n    where k_eff = min(k, n_truths). Each row contains the indices (0-based) of\n    the top-k most similar truth vectors for the corresponding query, sorted\n    by similarity (descending). Returns an empty array with shape (n_queries, 0)\n    when k <= 0 or n_truths == 0.\n\nNotes\n-----\nThis method is used by AutoTuner.run_sweep() to compute ground-truth nearest\nneighbors for recall evaluation. It performs exact search via matrix\nmultiplication (O(n_queries * n_truths * vec_dim)) and argpartition\n(O(n_queries * n_truths * log(k))) for top-k selection. The method assumes\nvectors are normalized for cosine similarity (inner product). Time complexity:\nO(n_queries * n_truths * vec_dim) for similarity computation plus O(n_queries\n* n_truths * log(k)) for top-k selection. Space complexity: O(n_queries * n_truths)\nfor the similarity matrix.",
  "is_public": false
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "FAISSManager._estimate_recall",
  "name": "_estimate_recall",
  "node_type": "FunctionDef",
  "lineno": 3549,
  "col": 4,
  "end_lineno": 3599,
  "end_col": 35,
  "parent_qualname": "FAISSManager",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": "Compute recall@k metric by comparing candidates against ground truth.\n\nThis method computes the average recall@k across all queries by comparing\ncandidate IDs returned from FAISS search against ground-truth nearest\nneighbor IDs. Recall is computed as the fraction of ground-truth IDs that\nappear in the candidate set, averaged across all queries. The metric ranges\nfrom 0.0 (no matches) to 1.0 (all ground-truth IDs found).\n\nParameters\n----------\ncandidates : NDArrayI64\n    Candidate IDs returned from FAISS search, shape (n_queries, k_candidates).\n    Each row contains chunk IDs (or indices) from approximate search results.\n    Negative values are treated as invalid and ignored.\ntruth : NDArrayI64\n    Ground-truth nearest neighbor IDs (or indices), shape (n_queries, k_truth).\n    Each row contains the true top-k nearest neighbor IDs from exact search.\n    Negative values are treated as invalid and ignored. Must have the same\n    number of rows (n_queries) as candidates.\n\nReturns\n-------\nfloat\n    Average recall@k metric in the range [0.0, 1.0]. Computed as the mean\n    of per-query recall values, where each query's recall is the fraction\n    of ground-truth IDs found in the candidate set. Returns 0.0 if either\n    array is empty or if there are no queries (total == 0).\n\nNotes\n-----\nThis method is used by AutoTuner.run_sweep() to evaluate search quality\nduring parameter sweeps. The recall metric measures how well approximate\nsearch results match exact (brute-force) search results. The method handles\nvariable-length ground truth sets (queries with no ground truth are skipped)\nand invalid IDs (negative values). Time complexity: O(n_queries * (k_candidates\n+ k_truth)) for set operations and comparisons. Space complexity: O(k_truth)\nper query for truth set construction. The method is deterministic and produces\nconsistent results for the same input arrays.",
  "is_public": false
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "FAISSManager._ensure_2d",
  "name": "_ensure_2d",
  "node_type": "FunctionDef",
  "lineno": 3602,
  "col": 4,
  "end_lineno": 3637,
  "end_col": 18,
  "parent_qualname": "FAISSManager",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": "Ensure an array is 2-dimensional for consistent FAISS search interface.\n\nThis helper method normalizes array shapes for FAISS search operations, which\nexpect 2D arrays with shape (n_queries, vec_dim). Single query vectors\n(1D arrays with shape (vec_dim,)) are reshaped to (1, vec_dim) to maintain\nconsistent array dimensions. Multi-query arrays are returned unchanged.\n\nParameters\n----------\narray : NDArrayF32\n    Input array that may be 1D or 2D. Shape (vec_dim,) for single query or\n    (n_queries, vec_dim) for multiple queries. Dtype is converted to float32\n    if not already. The array is copied if reshaping is needed.\n\nReturns\n-------\nNDArrayF32\n    Normalized 2D array with shape (n_queries, vec_dim) where n_queries >= 1.\n    Single query vectors are reshaped from (vec_dim,) to (1, vec_dim).\n    Multi-query arrays are returned unchanged (after dtype conversion).\n    Dtype is guaranteed to be float32.\n\nNotes\n-----\nThis method is used throughout the FAISS manager to normalize query inputs\nbefore search operations. It ensures consistent array shapes for FAISS API\ncalls and simplifies handling of both single and batch queries. Time\ncomplexity: O(1) for shape check, O(n) for dtype conversion where n is\narray size. The method may create a copy if dtype conversion or reshaping\nis needed. The method is deterministic and preserves array values.",
  "is_public": false
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "FAISSManager._refine_with_flat",
  "name": "_refine_with_flat",
  "node_type": "FunctionDef",
  "lineno": 3639,
  "col": 4,
  "end_lineno": 3667,
  "end_col": 68,
  "parent_qualname": "FAISSManager",
  "decorators": [],
  "bases": [],
  "docstring": "Refine candidates by running an exact search over the primary index.\n\nParameters\n----------\nqueries : NDArrayF32\n    Query vector(s) of shape (n_queries, vec_dim) or (vec_dim,).\n    Automatically normalized for cosine similarity.\n_candidate_ids : NDArrayI64\n    Candidate IDs from initial approximate search (unused, kept for\n    API compatibility). The method performs a fresh exact search instead.\nk : int\n    Number of nearest neighbors to return per query.\n\nReturns\n-------\ntuple[NDArrayF32, NDArrayI64]\n    Distances and IDs computed via exact search over the primary index.\n    Distances are cosine similarity scores; IDs are chunk identifiers.\n\nNotes\n-----\nThis method performs exact (Flat) search over the primary index to refine\nresults from approximate search. Improves recall at the cost of higher\nlatency. Time complexity: O(n_vectors * k) for Flat index.",
  "is_public": false
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "FAISSManager._downcast_index",
  "name": "_downcast_index",
  "node_type": "FunctionDef",
  "lineno": 3670,
  "col": 4,
  "end_lineno": 3694,
  "end_col": 24,
  "parent_qualname": "FAISSManager",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": "Return a concrete FAISS index implementation when possible.\n\nParameters\n----------\nindex : _faiss.Index\n    FAISS index handle, which may be a base Index type or wrapper.\n\nReturns\n-------\n_faiss.Index\n    Downcast index when supported (e.g., IndexIVFFlat from Index),\n    otherwise the provided handle unchanged.\n\nNotes\n-----\nThis helper uses `faiss.downcast_index()` to extract concrete index\nimplementations from wrapper types. Useful for accessing index-specific\nattributes (e.g., `nprobe` on IVF indexes). No-op if downcast is not\nsupported or index is already concrete.",
  "is_public": false
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "FAISSManager._active_index",
  "name": "_active_index",
  "node_type": "FunctionDef",
  "lineno": 3696,
  "col": 4,
  "end_lineno": 3714,
  "end_col": 31,
  "parent_qualname": "FAISSManager",
  "decorators": [],
  "bases": [],
  "docstring": "Return the best available search index.\n\nReturns\n-------\n_faiss.Index\n    GPU-backed index when available, otherwise the CPU index.\n\nRaises\n------\nRuntimeError\n    If neither CPU nor GPU indexes are available.",
  "is_public": false
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "AutoTuner",
  "name": "AutoTuner",
  "node_type": "ClassDef",
  "lineno": 3717,
  "col": 0,
  "end_lineno": 3844,
  "end_col": 22,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Evaluate FAISS ParameterSpace candidates for a given manager.",
  "is_public": true
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "AutoTuner.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 3728,
  "col": 4,
  "end_lineno": 3729,
  "end_col": 31,
  "parent_qualname": "AutoTuner",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "AutoTuner.run_sweep",
  "name": "run_sweep",
  "node_type": "FunctionDef",
  "lineno": 3731,
  "col": 4,
  "end_lineno": 3822,
  "end_col": 22,
  "parent_qualname": "AutoTuner",
  "decorators": [],
  "bases": [],
  "docstring": "Return the selected operating-point profile.\n\nThis method performs a parameter sweep over a sequence of FAISS parameter\nstrings, evaluating each configuration's recall and latency. The method\nnormalizes query and truth vectors, computes ground-truth nearest neighbors,\nand tests each parameter configuration to find the optimal operating point\nbalancing recall and latency. The selected profile includes the best\nparameter string, recall metrics, latency measurements, and refinement\nfactor.\n\nParameters\n----------\nqueries : NDArrayF32\n    Query vectors with shape `(N, dim)` and dtype float32. Used to evaluate\n    search performance across parameter configurations. Vectors are normalized\n    to unit length (L2 normalization) before evaluation.\ntruths : NDArrayF32\n    Ground-truth vectors with shape `(M, dim)` and dtype float32. Used to\n    compute recall metrics by comparing search results against exact nearest\n    neighbors. Vectors are normalized to unit length (L2 normalization)\n    before evaluation.\nk : int, optional\n    Number of nearest neighbors to retrieve per query (defaults to 10).\n    Used to compute recall@k metrics and determine ground-truth IDs.\n    Must be positive and not exceed the number of truth vectors.\nsweep : Sequence[str] | None, optional\n    Sequence of FAISS parameter strings to evaluate (e.g., [\"nprobe=16\",\n    \"nprobe=32\", \"efSearch=64\"]). If None, uses the default parameter sweep\n    defined by the class. Each parameter string is applied to the index\n    and evaluated for recall and latency.\nrefine_k_factor : float | None, optional\n    Refinement factor to include in the profile. If None, uses the manager's\n    default refine_k_factor. Values > 1.0 enable candidate expansion and\n    exact reranking for improved recall.\n\nReturns\n-------\ndict[str, Any]\n    Selected operating-point profile dictionary containing:\n    - param_str: Best parameter string selected from the sweep\n    - recall_at_k: Recall@k metric for the selected configuration (float)\n    - latency_ms: Average search latency in milliseconds (float)\n    - refine_k_factor: Refinement factor for candidate expansion (float)\n    The profile represents the optimal balance between recall and latency\n    based on the sweep evaluation criteria.",
  "is_public": true
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "AutoTuner._select_candidate",
  "name": "_select_candidate",
  "node_type": "FunctionDef",
  "lineno": 3825,
  "col": 4,
  "end_lineno": 3844,
  "end_col": 22,
  "parent_qualname": "AutoTuner",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "_coerce_to_int",
  "name": "_coerce_to_int",
  "node_type": "FunctionDef",
  "lineno": 3847,
  "col": 0,
  "end_lineno": 3867,
  "end_col": 18,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Safely round arbitrary objects to integers for index comparisons.\n\nParameters\n----------\nvalue : object\n    Candidate value that might be converted to an integer.\ndefault : int\n    Fallback value when conversion is not possible.\n\nReturns\n-------\nint\n    Converted integer or the provided default.",
  "is_public": false
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "_configure_direct_map",
  "name": "_configure_direct_map",
  "node_type": "FunctionDef",
  "lineno": 3870,
  "col": 0,
  "end_lineno": 3875,
  "end_col": 40,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Ensure FAISS direct maps are array-backed for reconstruction.",
  "is_public": false
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "_set_direct_map_type",
  "name": "_set_direct_map_type",
  "node_type": "FunctionDef",
  "lineno": 3878,
  "col": 0,
  "end_lineno": 3918,
  "end_col": 13,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Enable direct map support on FAISS indexes when available.\n\nThis function attempts to enable direct map support on FAISS indexes that\nsupport it (primarily IVF-family indexes). Direct maps enable efficient vector\nreconstruction by storing array-backed mappings from index positions to vectors.\nThe function downcasts the index to a concrete type (if possible) and calls\nmake_direct_map() if available. Failures are logged but do not raise exceptions,\nallowing the index to function without direct map support.\n\nParameters\n----------\nindex : _faiss.Index\n    FAISS index object to enable direct map support on. May be a base Index\n    type or wrapper (IndexIDMap2, etc.). The function attempts to downcast\n    to concrete types to access index-specific methods.\n\nNotes\n-----\nThis function is called by _configure_direct_map() to enable vector reconstruction\ncapabilities. Direct maps are required for reconstruct_batch() and _extract_all_vectors()\noperations. Not all index types support direct maps (e.g., Flat indexes don't\nneed them). The function handles errors gracefully, logging debug messages when\ndirect map setup fails. Time complexity: O(1) for method lookup, O(n) for direct\nmap construction where n is the number of vectors (if supported). The function\nmodifies the index object in-place and is not thread-safe if the index is being\nused concurrently.",
  "is_public": false
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "_wrap_bool_contains",
  "name": "_wrap_bool_contains",
  "node_type": "FunctionDef",
  "lineno": 3921,
  "col": 0,
  "end_lineno": 3954,
  "end_col": 19,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Wrap a raw contains function that returns a boolean-like value.\n\nParameters\n----------\nraw : Callable[[int], object]\n    Raw contains function that returns a boolean-like value (truthy/falsy).\n\nReturns\n-------\nCallable[[int], bool]\n    Callable that returns ``True`` when ``raw`` reports membership.",
  "is_public": false
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "_wrap_bool_contains.contains",
  "name": "contains",
  "node_type": "FunctionDef",
  "lineno": 3935,
  "col": 4,
  "end_lineno": 3952,
  "end_col": 24,
  "parent_qualname": "_wrap_bool_contains",
  "decorators": [],
  "bases": [],
  "docstring": "Check if an ID value is contained in the wrapped collection.\n\nParameters\n----------\nid_val : int\n    ID value to check for membership.\n\nReturns\n-------\nbool\n    ``True`` if the ID is found, ``False`` otherwise. Returns ``False``\n    if type coercion fails.",
  "is_public": true
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "_wrap_index_contains",
  "name": "_wrap_index_contains",
  "node_type": "FunctionDef",
  "lineno": 3957,
  "col": 0,
  "end_lineno": 3992,
  "end_col": 19,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Wrap a raw contains function that returns an index position.\n\nParameters\n----------\nraw : Callable[[int], object]\n    Raw contains function that returns an index position (non-negative int)\n    when found, or a negative value/exception when not found.\n\nReturns\n-------\nCallable[[int], bool]\n    Callable that returns ``True`` when ``raw`` returns a non-negative index.",
  "is_public": false
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "_wrap_index_contains.contains",
  "name": "contains",
  "node_type": "FunctionDef",
  "lineno": 3972,
  "col": 4,
  "end_lineno": 3990,
  "end_col": 42,
  "parent_qualname": "_wrap_index_contains",
  "decorators": [],
  "bases": [],
  "docstring": "Check if an ID value is contained in the wrapped collection.\n\nParameters\n----------\nid_val : int\n    ID value to check for membership.\n\nReturns\n-------\nbool\n    ``True`` if the ID is found (non-negative index), ``False`` otherwise.\n    Returns ``False`` if type coercion fails or the index is negative.",
  "is_public": true
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "_coerce_optional_int",
  "name": "_coerce_optional_int",
  "node_type": "FunctionDef",
  "lineno": 3995,
  "col": 0,
  "end_lineno": 4026,
  "end_col": 24,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return ``value`` coerced to int when possible.\n\nParameters\n----------\nvalue : object | None\n    Value to coerce to an integer. Accepts integers, floats, or strings.\n    Empty strings and ``None`` are converted to ``None``.\n\nReturns\n-------\nint | None\n    Integer representation or ``None`` when the value is empty.\n\nRaises\n------\nTypeError\n    If ``value`` cannot be coerced to an integer.",
  "is_public": false
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "_coerce_optional_float",
  "name": "_coerce_optional_float",
  "node_type": "FunctionDef",
  "lineno": 4029,
  "col": 0,
  "end_lineno": 4060,
  "end_col": 24,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return ``value`` coerced to float when possible.\n\nParameters\n----------\nvalue : object | None\n    Value to coerce to a float. Accepts booleans, numeric types, or strings.\n    Empty strings and ``None`` are converted to ``None``.\n\nReturns\n-------\nfloat | None\n    Float representation or ``None`` when the value is empty.\n\nRaises\n------\nTypeError\n    If ``value`` cannot be coerced to a float.",
  "is_public": false
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "_parse_tuning_overrides",
  "name": "_parse_tuning_overrides",
  "node_type": "FunctionDef",
  "lineno": 4063,
  "col": 0,
  "end_lineno": 4086,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Normalize raw profile payload into structured overrides.\n\nParameters\n----------\nprofile : Mapping[str, Any]\n    Raw tuning profile dictionary containing runtime parameter overrides.\n    Expected keys include ``nprobe``, ``ef``, ``k_factor``, and ``quantizer``.\n\nReturns\n-------\n_TuningOverrides\n    Structured overrides with coerced numeric values.",
  "is_public": false
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "_persist_tuning_profile",
  "name": "_persist_tuning_profile",
  "node_type": "FunctionDef",
  "lineno": 4089,
  "col": 0,
  "end_lineno": 4098,
  "end_col": 45,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Persist tuning metadata without interrupting the caller.",
  "is_public": false
}
{
  "path": "io/faiss_manager.py",
  "module": "io.faiss_manager",
  "qualname": "_get_compile_options",
  "name": "_get_compile_options",
  "node_type": "FunctionDef",
  "lineno": 4101,
  "col": 0,
  "end_lineno": 4114,
  "end_col": 18,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return FAISS compile options for readiness logs.\n\nReturns\n-------\nstr\n    Compile option string or ``\"unknown\"`` when unavailable.",
  "is_public": false
}
{
  "path": "io/git_client.py",
  "module": "io.git_client",
  "qualname": "io.git_client",
  "name": "io.git_client",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Typed Git operations wrapper using GitPython.\n\nThis module provides typed Python APIs for Git operations (blame, history) using\nGitPython instead of subprocess calls. Benefits include:\n- 50-80ms latency reduction (no subprocess overhead)\n- Structured data returns (no text parsing)\n- Automatic Unicode/locale handling\n- Specific typed exceptions\n- Unit testable (mock git.Repo)\n\nExample Usage\n-------------\nInitialize client with repository path:\n\n>>> from pathlib import Path\n>>> git_client = GitClient(repo_path=Path(\"/path/to/repo\"))\n\nGet blame for line range:\n\n>>> entries = git_client.blame_range(\"src/main.py\", start_line=10, end_line=20)\n>>> for entry in entries:\n...     print(f\"Line {entry['line']}: {entry['author']} - {entry['message']}\")\n\nGet commit history:\n\n>>> commits = git_client.file_history(\"README.md\", limit=10)\n>>> for commit in commits:\n...     print(f\"{commit['sha']}: {commit['message']}\")\n\nAsync wrapper for non-blocking operations:\n\n>>> async_client = AsyncGitClient(git_client)\n>>> entries = await async_client.blame_range(\"src/main.py\", 10, 20)\n\nSee Also\n--------\ncodeintel_rev.mcp_server.adapters.history : Adapters using GitClient\nGitPython documentation : https://gitpython.readthedocs.io/",
  "is_public": true
}
{
  "path": "io/git_client.py",
  "module": "io.git_client",
  "qualname": "_string_attr",
  "name": "_string_attr",
  "node_type": "FunctionDef",
  "lineno": 65,
  "col": 0,
  "end_lineno": 67,
  "end_col": 50,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/git_client.py",
  "module": "io.git_client",
  "qualname": "_commit_iso_date",
  "name": "_commit_iso_date",
  "node_type": "FunctionDef",
  "lineno": 70,
  "col": 0,
  "end_lineno": 77,
  "end_col": 24,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/git_client.py",
  "module": "io.git_client",
  "qualname": "_author_field",
  "name": "_author_field",
  "node_type": "FunctionDef",
  "lineno": 80,
  "col": 0,
  "end_lineno": 85,
  "end_col": 50,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/git_client.py",
  "module": "io.git_client",
  "qualname": "_short_sha",
  "name": "_short_sha",
  "node_type": "FunctionDef",
  "lineno": 88,
  "col": 0,
  "end_lineno": 90,
  "end_col": 33,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/git_client.py",
  "module": "io.git_client",
  "qualname": "_normalize_line_numbers",
  "name": "_normalize_line_numbers",
  "node_type": "FunctionDef",
  "lineno": 93,
  "col": 0,
  "end_lineno": 103,
  "end_col": 13,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/git_client.py",
  "module": "io.git_client",
  "qualname": "_coerce_blame_tuple",
  "name": "_coerce_blame_tuple",
  "node_type": "FunctionDef",
  "lineno": 106,
  "col": 0,
  "end_lineno": 114,
  "end_col": 31,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/git_client.py",
  "module": "io.git_client",
  "qualname": "GitClient",
  "name": "GitClient",
  "node_type": "ClassDef",
  "lineno": 121,
  "col": 0,
  "end_lineno": 524,
  "end_col": 26,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Typed wrapper around GitPython for blame and history operations.\n\nProvides structured APIs that return typed dictionaries instead of parsing\nsubprocess text output. Handles encoding/locale issues automatically via\nGitPython's built-in Unicode support.\n\nThe Git repository is lazy-loaded on first access to avoid startup overhead\nfor applications that may not use Git operations immediately.\n\nAttributes\n----------\nrepo_path : Path\n    Path to repository root directory. GitPython will search parent\n    directories for .git if repo_path is a subdirectory.\n\nExamples\n--------\nCreate client and get blame:\n\n>>> from pathlib import Path\n>>> client = GitClient(repo_path=Path(\"/home/user/myrepo\"))\n>>> blame = client.blame_range(\"src/main.py\", 1, 10)\n>>> blame[0][\"author\"]\n'John Doe'\n\nGet commit history:\n\n>>> history = client.file_history(\"README.md\", limit=5)\n>>> len(history)\n5\n>>> history[0][\"message\"]\n'Update documentation'\n\nNotes\n-----\nThe GitPython Repo object is cached after first access. This is safe because\nGit repositories are generally not modified during server runtime (except for\nindexing operations which run separately).\n\nFor async operations, use AsyncGitClient wrapper which runs operations in\na threadpool via asyncio.to_thread.\n\nInternal attributes (not part of public API):\n- ``_repo``: Cached GitPython Repo instance (lazy-initialized on first property access)",
  "is_public": true
}
{
  "path": "io/git_client.py",
  "module": "io.git_client",
  "qualname": "GitClient.repo",
  "name": "repo",
  "node_type": "FunctionDef",
  "lineno": 172,
  "col": 4,
  "end_lineno": 214,
  "end_col": 43,
  "parent_qualname": "GitClient",
  "decorators": [
    "property"
  ],
  "bases": [],
  "docstring": "Lazy-load Git repository.\n\nCreates GitPython Repo instance on first access and caches it for\nsubsequent calls. This avoids repository initialization overhead at\nclient creation time.\n\nReturns\n-------\ngit.Repo\n    GitPython repository object for performing Git operations.\n\nRaises\n------\ngit.exc.InvalidGitRepositoryError\n    If repo_path is not a valid Git repository or .git cannot be found\n    in parent directories.\n\nExamples\n--------\n>>> client = GitClient(repo_path=Path(\".\"))\n>>> repo = client.repo  # Lazy initialization happens here\n>>> repo.head.commit.hexsha\n'a1b2c3d4...'",
  "is_public": true
}
{
  "path": "io/git_client.py",
  "module": "io.git_client",
  "qualname": "GitClient.with_cached_repo",
  "name": "with_cached_repo",
  "node_type": "FunctionDef",
  "lineno": 216,
  "col": 4,
  "end_lineno": 231,
  "end_col": 20,
  "parent_qualname": "GitClient",
  "decorators": [],
  "bases": [],
  "docstring": "Return a clone of this client with a cached repository.\n\nParameters\n----------\nrepo : git.Repo\n    Repository instance to seed the cache with.\n\nReturns\n-------\nGitClient\n    Clone of this client with ``repo`` cached.",
  "is_public": true
}
{
  "path": "io/git_client.py",
  "module": "io.git_client",
  "qualname": "GitClient.blame_range",
  "name": "blame_range",
  "node_type": "FunctionDef",
  "lineno": 233,
  "col": 4,
  "end_lineno": 394,
  "end_col": 26,
  "parent_qualname": "GitClient",
  "decorators": [],
  "bases": [],
  "docstring": "Get Git blame for line range.\n\nReturns blame information for each line in the specified range, showing\nwhich commit last modified the line, who authored it, when, and why.\n\nUses GitPython's blame_incremental() for efficient line-by-line blame.\nThis is faster than running `git blame` subprocess because it uses\nGitPython's internal optimizations and avoids text parsing.\n\nParameters\n----------\npath : str\n    File path relative to repository root. Path separators should be\n    forward slashes (/) even on Windows. GitPython normalizes paths.\nstart_line : int\n    Start line number (1-indexed, inclusive). Must be positive and\n    less than or equal to end_line.\nend_line : int\n    End line number (1-indexed, inclusive). Must be positive and\n    greater than or equal to start_line.\n\nReturns\n-------\nlist[GitBlameEntry]\n    List of blame entries, one per line in range. Each entry is a\n    typed dictionary with fields: line, commit, author, date, message.\n    Lines are ordered by line number (ascending).\n\nRaises\n------\nFileNotFoundError\n    If the specified file does not exist in the repository at HEAD.\n    This is raised instead of git.exc.GitCommandError for clearer\n    error handling in adapters.\ngit.exc.GitCommandError\n    If Git operation fails for other reasons (not a valid commit,\n    permission denied, etc.). The exception message contains details\n    from Git.\n\nExamples\n--------\nGet blame for first 10 lines:\n\n>>> client = GitClient(repo_path=Path(\".\"))\n>>> blame = client.blame_range(\"README.md\", 1, 10)\n>>> for entry in blame:\n...     print(f\"Line {entry['line']}: {entry['author']}\")\nLine 1: John Doe\nLine 2: Jane Smith\n...\n\nHandle file not found:\n\n>>> try:\n...     blame = client.blame_range(\"nonexistent.txt\", 1, 10)\n... except FileNotFoundError as exc:\n...     print(f\"File not found: {exc}\")\nFile not found: File not found: nonexistent.txt\n\nNotes\n-----\nGitPython's blame_incremental returns blame info for entire file, but\nwe filter to requested line range for efficiency. The function handles\nUnicode filenames and author names automatically.\n\nLine numbers are 1-indexed to match editor conventions and Git's\noutput format. Internally, GitPython uses 0-indexed lines.",
  "is_public": true
}
{
  "path": "io/git_client.py",
  "module": "io.git_client",
  "qualname": "GitClient.file_history",
  "name": "file_history",
  "node_type": "FunctionDef",
  "lineno": 396,
  "col": 4,
  "end_lineno": 524,
  "end_col": 26,
  "parent_qualname": "GitClient",
  "decorators": [],
  "bases": [],
  "docstring": "Get commit history for file.\n\nReturns list of commits that modified the specified file, ordered by\ncommit date (newest first). Includes commit metadata: SHA, author,\ndate, message.\n\nUses GitPython's iter_commits() for efficient history traversal. This\nis faster than `git log` subprocess because it avoids process overhead\nand text parsing.\n\nParameters\n----------\npath : str\n    File path relative to repository root. Path separators should be\n    forward slashes (/) even on Windows.\nlimit : int, optional\n    Maximum number of commits to return (default: 50). Set to a large\n    value (e.g., 1000) to get full history, but be aware of performance\n    impact for files with many commits.\n\nReturns\n-------\nlist[dict]\n    List of commit dictionaries ordered by date (newest first). Each\n    dict contains: sha (8 chars), full_sha (40 chars), author, email,\n    date (ISO 8601), message (summary line).\n\nRaises\n------\nFileNotFoundError\n    If the specified file does not exist in the repository history.\n    This includes files that were deleted in HEAD but existed in\n    past commits.\ngit.exc.GitCommandError\n    If Git operation fails for other reasons.\n\nExamples\n--------\nGet recent commits:\n\n>>> client = GitClient(repo_path=Path(\".\"))\n>>> history = client.file_history(\"README.md\", limit=5)\n>>> for commit in history:\n...     print(f\"{commit['sha']}: {commit['message']}\")\na1b2c3d4: Update documentation\ne5f6g7h8: Fix typo\n...\n\nGet full author info:\n\n>>> commit = history[0]\n>>> print(f\"{commit['author']} <{commit['email']}>\")\nJohn Doe <john@example.com>\n\nNotes\n-----\nThe function returns commits in reverse chronological order (newest\nfirst), matching `git log` default behavior. Dates are in ISO 8601\nformat with timezone info.\n\nFor files with rename history, GitPython's --follow equivalent may\nnot work perfectly. Consider using Git's --follow flag via subprocess\nif rename tracking is critical.",
  "is_public": true
}
{
  "path": "io/git_client.py",
  "module": "io.git_client",
  "qualname": "AsyncGitClient",
  "name": "AsyncGitClient",
  "node_type": "ClassDef",
  "lineno": 527,
  "col": 0,
  "end_lineno": 666,
  "end_col": 13,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Async wrapper around GitClient using asyncio.to_thread.\n\nProvides async versions of GitClient methods by running synchronous\nGitPython operations in a threadpool. This prevents blocking the event\nloop while allowing concurrent Git operations.\n\nGitPython is synchronous internally (it calls subprocess), so we use\nasyncio.to_thread to offload operations to a threadpool. This enables\nconcurrent Git operations without thread exhaustion.\n\nParameters\n----------\ngit_client : GitClient\n    Synchronous GitClient instance to wrap. The same instance can be\n    shared across multiple AsyncGitClient instances safely.\n\nExamples\n--------\nCreate async client and get blame:\n\n>>> from pathlib import Path\n>>> sync_client = GitClient(repo_path=Path(\".\"))\n>>> async_client = AsyncGitClient(sync_client)\n>>> blame = await async_client.blame_range(\"src/main.py\", 1, 10)\n>>> blame[0][\"author\"]\n'John Doe'\n\nGet commit history:\n\n>>> history = await async_client.file_history(\"README.md\", limit=5)\n>>> len(history)\n5\n\nNotes\n-----\nThe async methods run the synchronous GitClient methods in a threadpool\nvia asyncio.to_thread. This is safe because GitPython operations are\nthread-safe (each operation uses its own subprocess).\n\nFor best performance, use AsyncGitClient when you need to perform multiple\nGit operations concurrently (e.g., blaming multiple files in parallel).\n\nInternal attributes (not part of public API):\n- ``_sync_client``: Synchronous GitClient instance wrapped by this async client",
  "is_public": true
}
{
  "path": "io/git_client.py",
  "module": "io.git_client",
  "qualname": "AsyncGitClient.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 574,
  "col": 4,
  "end_lineno": 575,
  "end_col": 38,
  "parent_qualname": "AsyncGitClient",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/git_client.py",
  "module": "io.git_client",
  "qualname": "AsyncGitClient.blame_range",
  "name": "blame_range",
  "node_type": "AsyncFunctionDef",
  "lineno": 577,
  "col": 4,
  "end_lineno": 623,
  "end_col": 13,
  "parent_qualname": "AsyncGitClient",
  "decorators": [],
  "bases": [],
  "docstring": "Async version of GitClient.blame_range.\n\nRuns synchronous blame_range in threadpool to avoid blocking event loop.\nExceptions are propagated from the sync client (see GitClient.blame_range).\n\nParameters\n----------\npath : str\n    File path relative to repository root.\nstart_line : int\n    Start line number (1-indexed, inclusive).\nend_line : int\n    End line number (1-indexed, inclusive).\n\nReturns\n-------\nlist[GitBlameEntry]\n    List of blame entries for the line range.\n\nExamples\n--------\n>>> async_client = AsyncGitClient(GitClient(repo_path=Path(\".\")))\n>>> blame = await async_client.blame_range(\"README.md\", 1, 10)\n>>> len(blame)\n10",
  "is_public": true
}
{
  "path": "io/git_client.py",
  "module": "io.git_client",
  "qualname": "AsyncGitClient.file_history",
  "name": "file_history",
  "node_type": "AsyncFunctionDef",
  "lineno": 625,
  "col": 4,
  "end_lineno": 666,
  "end_col": 13,
  "parent_qualname": "AsyncGitClient",
  "decorators": [],
  "bases": [],
  "docstring": "Async version of GitClient.file_history.\n\nRuns synchronous file_history in threadpool to avoid blocking event loop.\nExceptions are propagated from the sync client (see GitClient.file_history).\n\nParameters\n----------\npath : str\n    File path relative to repository root.\nlimit : int, optional\n    Maximum number of commits to return (default: 50).\n\nReturns\n-------\nlist[dict]\n    List of commit dictionaries ordered by date (newest first).\n\nExamples\n--------\n>>> async_client = AsyncGitClient(GitClient(repo_path=Path(\".\")))\n>>> history = await async_client.file_history(\"README.md\", limit=5)\n>>> len(history)\n5",
  "is_public": true
}
{
  "path": "io/hybrid_search.py",
  "module": "io.hybrid_search",
  "qualname": "io.hybrid_search",
  "name": "io.hybrid_search",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Hybrid retrieval utilities combining FAISS, BM25, and SPLADE.",
  "is_public": true
}
{
  "path": "io/hybrid_search.py",
  "module": "io.hybrid_search",
  "qualname": "_LuceneHit",
  "name": "_LuceneHit",
  "node_type": "ClassDef",
  "lineno": 44,
  "col": 0,
  "end_lineno": 46,
  "end_col": 16,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "Protocol"
  ],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/hybrid_search.py",
  "module": "io.hybrid_search",
  "qualname": "_LuceneSearcher",
  "name": "_LuceneSearcher",
  "node_type": "ClassDef",
  "lineno": 49,
  "col": 0,
  "end_lineno": 60,
  "end_col": 11,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "Protocol"
  ],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/hybrid_search.py",
  "module": "io.hybrid_search",
  "qualname": "_LuceneSearcher.set_bm25",
  "name": "set_bm25",
  "node_type": "FunctionDef",
  "lineno": 50,
  "col": 4,
  "end_lineno": 52,
  "end_col": 11,
  "parent_qualname": "_LuceneSearcher",
  "decorators": [],
  "bases": [],
  "docstring": "Configure BM25 parameters for the searcher.",
  "is_public": true
}
{
  "path": "io/hybrid_search.py",
  "module": "io.hybrid_search",
  "qualname": "_LuceneSearcher.set_rm3",
  "name": "set_rm3",
  "node_type": "FunctionDef",
  "lineno": 54,
  "col": 4,
  "end_lineno": 56,
  "end_col": 11,
  "parent_qualname": "_LuceneSearcher",
  "decorators": [],
  "bases": [],
  "docstring": "Configure RM3 pseudo-relevance feedback parameters.",
  "is_public": true
}
{
  "path": "io/hybrid_search.py",
  "module": "io.hybrid_search",
  "qualname": "_LuceneSearcher.search",
  "name": "search",
  "node_type": "FunctionDef",
  "lineno": 58,
  "col": 4,
  "end_lineno": 60,
  "end_col": 11,
  "parent_qualname": "_LuceneSearcher",
  "decorators": [],
  "bases": [],
  "docstring": "Execute search and return Lucene hits.",
  "is_public": true
}
{
  "path": "io/hybrid_search.py",
  "module": "io.hybrid_search",
  "qualname": "BM25Rm3Config",
  "name": "BM25Rm3Config",
  "node_type": "ClassDef",
  "lineno": 64,
  "col": 0,
  "end_lineno": 70,
  "end_col": 26,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Bundle RM3 parameters and heuristics for BM25 search.",
  "is_public": true
}
{
  "path": "io/hybrid_search.py",
  "module": "io.hybrid_search",
  "qualname": "BM25SearchProvider",
  "name": "BM25SearchProvider",
  "node_type": "ClassDef",
  "lineno": 73,
  "col": 0,
  "end_lineno": 209,
  "end_col": 22,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Pyserini-backed BM25 searcher with optional RM3 heuristics.",
  "is_public": true
}
{
  "path": "io/hybrid_search.py",
  "module": "io.hybrid_search",
  "qualname": "BM25SearchProvider.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 76,
  "col": 4,
  "end_lineno": 99,
  "end_col": 57,
  "parent_qualname": "BM25SearchProvider",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/hybrid_search.py",
  "module": "io.hybrid_search",
  "qualname": "BM25SearchProvider._create_searcher",
  "name": "_create_searcher",
  "node_type": "FunctionDef",
  "lineno": 101,
  "col": 4,
  "end_lineno": 107,
  "end_col": 23,
  "parent_qualname": "BM25SearchProvider",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/hybrid_search.py",
  "module": "io.hybrid_search",
  "qualname": "BM25SearchProvider._ensure_rm3_searcher",
  "name": "_ensure_rm3_searcher",
  "node_type": "FunctionDef",
  "lineno": 109,
  "col": 4,
  "end_lineno": 123,
  "end_col": 23,
  "parent_qualname": "BM25SearchProvider",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/hybrid_search.py",
  "module": "io.hybrid_search",
  "qualname": "BM25SearchProvider._should_use_rm3",
  "name": "_should_use_rm3",
  "node_type": "FunctionDef",
  "lineno": 125,
  "col": 4,
  "end_lineno": 132,
  "end_col": 52,
  "parent_qualname": "BM25SearchProvider",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/hybrid_search.py",
  "module": "io.hybrid_search",
  "qualname": "BM25SearchProvider.search",
  "name": "search",
  "node_type": "FunctionDef",
  "lineno": 134,
  "col": 4,
  "end_lineno": 209,
  "end_col": 22,
  "parent_qualname": "BM25SearchProvider",
  "decorators": [],
  "bases": [],
  "docstring": "Return BM25 hits for ``query``, optionally applying RM3 when heuristics fire.\n\nParameters\n----------\nquery : str\n    Search query string.\ntop_k : int\n    Maximum number of results to return. Must be positive.\nforce_rm3 : bool | None, optional\n    Optional override to force RM3 usage. If None, uses heuristics to decide.\n    Defaults to None.\n\nReturns\n-------\nlist[SearchHit]\n    List of search results with document IDs and BM25 scores, sorted by\n    relevance descending. Returns empty list if top_k <= 0.\n\nRaises\n------\nRuntimeError\n    Raised when the underlying Pyserini searcher fails.",
  "is_public": true
}
{
  "path": "io/hybrid_search.py",
  "module": "io.hybrid_search",
  "qualname": "SpladeSearchProvider",
  "name": "SpladeSearchProvider",
  "node_type": "ClassDef",
  "lineno": 212,
  "col": 0,
  "end_lineno": 426,
  "end_col": 31,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "SPLADE query encoder and Lucene impact searcher for learned sparse retrieval.\n\nThis class combines a SPLADE (Sparse Lexical and Expansion) query encoder\nwith a Lucene impact searcher to perform learned sparse retrieval. SPLADE\nlearns to expand queries with relevant terms and assign importance weights,\ncreating sparse representations that are more effective than traditional\nkeyword matching while maintaining the efficiency of sparse retrieval.\n\nThe provider initializes a SPLADE encoder model (typically loaded from ONNX\nformat for efficiency) and a Lucene impact searcher that uses learned term\nweights for ranking. The encoder expands queries into weighted term vectors,\nwhich are then converted to bag-of-words representations for Lucene search.\n\nParameters\n----------\nconfig : SpladeConfig\n    SPLADE configuration containing model settings, quantization parameters,\n    and maximum term limits. Used to configure encoder behavior and search\n    parameters.\nmodel_dir : Path\n    Directory containing the SPLADE model files. The model directory should\n    contain the encoder weights and tokenizer configuration.\nonnx_dir : Path\n    Directory containing ONNX-exported model files. If an ONNX file exists\n    (specified in config.onnx_file), it will be used instead of the PyTorch\n    model for faster inference. Falls back to PyTorch model if ONNX not found.\nindex_dir : Path\n    Directory path containing the Lucene impact index. The index must be\n    created using Pyserini's indexing tools with SPLADE-encoded document\n    vectors. Each document should have term weights matching the SPLADE\n    encoding scheme.\n\nRaises\n------\nFileNotFoundError\n    If the SPLADE impact index directory does not exist or is not accessible.",
  "is_public": true
}
{
  "path": "io/hybrid_search.py",
  "module": "io.hybrid_search",
  "qualname": "SpladeSearchProvider.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 251,
  "col": 4,
  "end_lineno": 285,
  "end_col": 83,
  "parent_qualname": "SpladeSearchProvider",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/hybrid_search.py",
  "module": "io.hybrid_search",
  "qualname": "SpladeSearchProvider.search",
  "name": "search",
  "node_type": "FunctionDef",
  "lineno": 287,
  "col": 4,
  "end_lineno": 396,
  "end_col": 22,
  "parent_qualname": "SpladeSearchProvider",
  "decorators": [],
  "bases": [],
  "docstring": "Return SPLADE impact hits for ``query``.\n\nEncodes the query using the SPLADE encoder to generate a sparse term\nvector with learned importance weights. The vector is decoded into a\nbag-of-words representation with term repetitions based on quantized\nweights, then searched against the Lucene impact index. Results are\nranked by learned relevance scores.\n\nParameters\n----------\nquery : str\n    Search query string to encode and search. The SPLADE encoder will\n    expand this query with relevant terms and assign importance weights\n    based on learned patterns from training data.\ntop_k : int\n    Maximum number of results to return. The searcher returns the top-k\n    highest-scoring documents based on learned SPLADE relevance. Must be\n    a positive integer.\n\nReturns\n-------\nlist[SearchHit]\n    List of ranked SPLADE results, ordered by learned relevance score\n    (highest first). Each hit contains a document ID and SPLADE impact\n    score. Returns empty list if encoding fails, no terms are generated,\n    or top_k is 0.\n\nRaises\n------\nRuntimeError\n    Raised when the SPLADE encoder or impact searcher fails.",
  "is_public": true
}
{
  "path": "io/hybrid_search.py",
  "module": "io.hybrid_search",
  "qualname": "SpladeSearchProvider._filter_pairs",
  "name": "_filter_pairs",
  "node_type": "FunctionDef",
  "lineno": 398,
  "col": 4,
  "end_lineno": 409,
  "end_col": 23,
  "parent_qualname": "SpladeSearchProvider",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/hybrid_search.py",
  "module": "io.hybrid_search",
  "qualname": "SpladeSearchProvider._build_bow",
  "name": "_build_bow",
  "node_type": "FunctionDef",
  "lineno": 411,
  "col": 4,
  "end_lineno": 426,
  "end_col": 31,
  "parent_qualname": "SpladeSearchProvider",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/hybrid_search.py",
  "module": "io.hybrid_search",
  "qualname": "HybridSearchTuning",
  "name": "HybridSearchTuning",
  "node_type": "ClassDef",
  "lineno": 430,
  "col": 0,
  "end_lineno": 434,
  "end_col": 29,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Runtime overrides for FAISS search metadata.",
  "is_public": true
}
{
  "path": "io/hybrid_search.py",
  "module": "io.hybrid_search",
  "qualname": "HybridSearchOptions",
  "name": "HybridSearchOptions",
  "node_type": "ClassDef",
  "lineno": 438,
  "col": 0,
  "end_lineno": 444,
  "end_col": 28,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Optional knobs influencing hybrid fusion.",
  "is_public": true
}
{
  "path": "io/hybrid_search.py",
  "module": "io.hybrid_search",
  "qualname": "_MethodStats",
  "name": "_MethodStats",
  "node_type": "ClassDef",
  "lineno": 448,
  "col": 0,
  "end_lineno": 453,
  "end_col": 32,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/hybrid_search.py",
  "module": "io.hybrid_search",
  "qualname": "_FusionContext",
  "name": "_FusionContext",
  "node_type": "ClassDef",
  "lineno": 457,
  "col": 0,
  "end_lineno": 467,
  "end_col": 29,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "All inputs required to fuse dense and sparse channel runs.",
  "is_public": false
}
{
  "path": "io/hybrid_search.py",
  "module": "io.hybrid_search",
  "qualname": "_SearchTelemetryContext",
  "name": "_SearchTelemetryContext",
  "node_type": "ClassDef",
  "lineno": 471,
  "col": 0,
  "end_lineno": 473,
  "end_col": 42,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/hybrid_search.py",
  "module": "io.hybrid_search",
  "qualname": "_FusionWork",
  "name": "_FusionWork",
  "node_type": "ClassDef",
  "lineno": 477,
  "col": 0,
  "end_lineno": 488,
  "end_col": 29,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Resolved fusion parameters after pooler/weights are selected.",
  "is_public": false
}
{
  "path": "io/hybrid_search.py",
  "module": "io.hybrid_search",
  "qualname": "HybridSearchEngine",
  "name": "HybridSearchEngine",
  "node_type": "ClassDef",
  "lineno": 491,
  "col": 0,
  "end_lineno": 1470,
  "end_col": 29,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Combine dense (FAISS) and sparse channel plugins via RRF.",
  "is_public": true
}
{
  "path": "io/hybrid_search.py",
  "module": "io.hybrid_search",
  "qualname": "HybridSearchEngine.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 494,
  "col": 4,
  "end_lineno": 518,
  "end_col": 50,
  "parent_qualname": "HybridSearchEngine",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/hybrid_search.py",
  "module": "io.hybrid_search",
  "qualname": "HybridSearchEngine._make_stage_gate_config",
  "name": "_make_stage_gate_config",
  "node_type": "FunctionDef",
  "lineno": 520,
  "col": 4,
  "end_lineno": 549,
  "end_col": 9,
  "parent_qualname": "HybridSearchEngine",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/hybrid_search.py",
  "module": "io.hybrid_search",
  "qualname": "HybridSearchEngine._recency_config",
  "name": "_recency_config",
  "node_type": "FunctionDef",
  "lineno": 551,
  "col": 4,
  "end_lineno": 557,
  "end_col": 9,
  "parent_qualname": "HybridSearchEngine",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/hybrid_search.py",
  "module": "io.hybrid_search",
  "qualname": "HybridSearchEngine._profile_query",
  "name": "_profile_query",
  "node_type": "FunctionDef",
  "lineno": 560,
  "col": 4,
  "end_lineno": 577,
  "end_col": 36,
  "parent_qualname": "HybridSearchEngine",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/hybrid_search.py",
  "module": "io.hybrid_search",
  "qualname": "HybridSearchEngine._rrf_fuse",
  "name": "_rrf_fuse",
  "node_type": "FunctionDef",
  "lineno": 579,
  "col": 4,
  "end_lineno": 596,
  "end_col": 43,
  "parent_qualname": "HybridSearchEngine",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/hybrid_search.py",
  "module": "io.hybrid_search",
  "qualname": "HybridSearchEngine._build_debug_bundle",
  "name": "_build_debug_bundle",
  "node_type": "FunctionDef",
  "lineno": 599,
  "col": 4,
  "end_lineno": 613,
  "end_col": 9,
  "parent_qualname": "HybridSearchEngine",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/hybrid_search.py",
  "module": "io.hybrid_search",
  "qualname": "HybridSearchEngine._fuse_runs",
  "name": "_fuse_runs",
  "node_type": "FunctionDef",
  "lineno": 615,
  "col": 4,
  "end_lineno": 653,
  "end_col": 9,
  "parent_qualname": "HybridSearchEngine",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/hybrid_search.py",
  "module": "io.hybrid_search",
  "qualname": "HybridSearchEngine._apply_extra_channels",
  "name": "_apply_extra_channels",
  "node_type": "FunctionDef",
  "lineno": 656,
  "col": 4,
  "end_lineno": 666,
  "end_col": 22,
  "parent_qualname": "HybridSearchEngine",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/hybrid_search.py",
  "module": "io.hybrid_search",
  "qualname": "HybridSearchEngine._resolve_active_channels",
  "name": "_resolve_active_channels",
  "node_type": "FunctionDef",
  "lineno": 669,
  "col": 4,
  "end_lineno": 670,
  "end_col": 82,
  "parent_qualname": "HybridSearchEngine",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/hybrid_search.py",
  "module": "io.hybrid_search",
  "qualname": "HybridSearchEngine._record_fusion_start",
  "name": "_record_fusion_start",
  "node_type": "FunctionDef",
  "lineno": 673,
  "col": 4,
  "end_lineno": 689,
  "end_col": 9,
  "parent_qualname": "HybridSearchEngine",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/hybrid_search.py",
  "module": "io.hybrid_search",
  "qualname": "HybridSearchEngine._execute_fusion",
  "name": "_execute_fusion",
  "node_type": "FunctionDef",
  "lineno": 691,
  "col": 4,
  "end_lineno": 738,
  "end_col": 51,
  "parent_qualname": "HybridSearchEngine",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/hybrid_search.py",
  "module": "io.hybrid_search",
  "qualname": "HybridSearchEngine._run_rrf",
  "name": "_run_rrf",
  "node_type": "FunctionDef",
  "lineno": 740,
  "col": 4,
  "end_lineno": 768,
  "end_col": 43,
  "parent_qualname": "HybridSearchEngine",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/hybrid_search.py",
  "module": "io.hybrid_search",
  "qualname": "HybridSearchEngine._run_pool",
  "name": "_run_pool",
  "node_type": "FunctionDef",
  "lineno": 770,
  "col": 4,
  "end_lineno": 796,
  "end_col": 43,
  "parent_qualname": "HybridSearchEngine",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/hybrid_search.py",
  "module": "io.hybrid_search",
  "qualname": "HybridSearchEngine._apply_recency_boost_if_needed",
  "name": "_apply_recency_boost_if_needed",
  "node_type": "FunctionDef",
  "lineno": 798,
  "col": 4,
  "end_lineno": 809,
  "end_col": 9,
  "parent_qualname": "HybridSearchEngine",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/hybrid_search.py",
  "module": "io.hybrid_search",
  "qualname": "HybridSearchEngine.search",
  "name": "search",
  "node_type": "FunctionDef",
  "lineno": 811,
  "col": 4,
  "end_lineno": 873,
  "end_col": 23,
  "parent_qualname": "HybridSearchEngine",
  "decorators": [],
  "bases": [],
  "docstring": "Fuse dense and sparse retrieval results for ``query`` using adaptive budgets.\n\nParameters\n----------\nquery : str\n    Natural language or code search query.\nsemantic_hits : Sequence[tuple[int, float]]\n    Dense FAISS hits expressed as ``(chunk_id, score)`` pairs.\nlimit : int\n    Maximum number of fused results to return.\noptions : HybridSearchOptions | None, optional\n    Optional overrides for channel weights, additional channels, and FAISS\n    runtime metadata.\n\nReturns\n-------\nHybridSearchResult\n    Structured result set containing fused documents, per-document channel\n    contributions, warnings, and explainability metadata.",
  "is_public": true
}
{
  "path": "io/hybrid_search.py",
  "module": "io.hybrid_search",
  "qualname": "HybridSearchEngine._execute_hybrid_search",
  "name": "_execute_hybrid_search",
  "node_type": "FunctionDef",
  "lineno": 875,
  "col": 4,
  "end_lineno": 1019,
  "end_col": 21,
  "parent_qualname": "HybridSearchEngine",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/hybrid_search.py",
  "module": "io.hybrid_search",
  "qualname": "HybridSearchEngine._gather_channel_hits",
  "name": "_gather_channel_hits",
  "node_type": "FunctionDef",
  "lineno": 1021,
  "col": 4,
  "end_lineno": 1113,
  "end_col": 29,
  "parent_qualname": "HybridSearchEngine",
  "decorators": [],
  "bases": [],
  "docstring": "Collect per-channel search hits and warnings for ``query``.\n\nThis internal method coordinates retrieval across all enabled channels,\ncollecting results from semantic (FAISS), BM25, and SPLADE channels.\nEach channel is queried independently, and errors are captured as warnings\nrather than exceptions to ensure robust multi-channel retrieval.\n\nThe semantic channel is always included (converting IDs and scores to\nSearchHit objects). BM25 and SPLADE channels are conditionally enabled\nbased on settings and availability. Channel initialization errors are\ncaptured as warnings and included in the return value.\n\nParameters\n----------\nquery : str\n    Search query string. Used for sparse retrieval channels (BM25, SPLADE).\n    The semantic channel uses pre-computed results, so query is only\n    relevant for sparse channels.\nsemantic_hits : Sequence[tuple[int, float]]\n    Dense retrieval hits expressed as ``(doc_id, score)`` pairs.\nchannel_limits : Mapping[str, int] | None, optional\n    Optional per-channel depth overrides derived from budget decisions.\n    Keys correspond to channel names (e.g., \"semantic\", \"bm25\"). When\n    provided, each channel fetches at most the specified number of hits.\nstage_records : list[dict[str, object]]\n    Mutable list of stage timing records. This method appends timing\n    and status records for each channel search stage (e.g., \"search.faiss\",\n    \"search.bm25\", \"search.splade\") to this list. Each record contains\n    \"name\", \"status\", \"duration_seconds\", and optional channel-specific\n    metadata. Used for telemetry and performance analysis.\n\nReturns\n-------\ntuple[dict[str, list[SearchHit]], list[str]]\n    Tuple containing:\n    - Dictionary mapping channel identifiers (\"semantic\", \"bm25\", \"splade\")\n      to lists of SearchHit objects. Only channels that successfully\n      returned results are included.\n    - List of warning messages accumulated during channel retrieval. Includes\n      initialization errors, search failures, and availability issues.",
  "is_public": false
}
{
  "path": "io/hybrid_search.py",
  "module": "io.hybrid_search",
  "qualname": "HybridSearchEngine._channel_disabled_reason",
  "name": "_channel_disabled_reason",
  "node_type": "FunctionDef",
  "lineno": 1115,
  "col": 4,
  "end_lineno": 1124,
  "end_col": 19,
  "parent_qualname": "HybridSearchEngine",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/hybrid_search.py",
  "module": "io.hybrid_search",
  "qualname": "HybridSearchEngine._missing_capabilities",
  "name": "_missing_capabilities",
  "node_type": "FunctionDef",
  "lineno": 1126,
  "col": 4,
  "end_lineno": 1133,
  "end_col": 22,
  "parent_qualname": "HybridSearchEngine",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/hybrid_search.py",
  "module": "io.hybrid_search",
  "qualname": "HybridSearchEngine._collect_channel_hits",
  "name": "_collect_channel_hits",
  "node_type": "FunctionDef",
  "lineno": 1135,
  "col": 4,
  "end_lineno": 1218,
  "end_col": 25,
  "parent_qualname": "HybridSearchEngine",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/hybrid_search.py",
  "module": "io.hybrid_search",
  "qualname": "HybridSearchEngine._collect_channel_hits._record_stage",
  "name": "_record_stage",
  "node_type": "FunctionDef",
  "lineno": 1145,
  "col": 8,
  "end_lineno": 1161,
  "end_col": 39,
  "parent_qualname": "HybridSearchEngine._collect_channel_hits",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/hybrid_search.py",
  "module": "io.hybrid_search",
  "qualname": "HybridSearchEngine._emit_channel_skip",
  "name": "_emit_channel_skip",
  "node_type": "FunctionDef",
  "lineno": 1221,
  "col": 4,
  "end_lineno": 1230,
  "end_col": 65,
  "parent_qualname": "HybridSearchEngine",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/hybrid_search.py",
  "module": "io.hybrid_search",
  "qualname": "HybridSearchEngine._emit_channel_run",
  "name": "_emit_channel_run",
  "node_type": "FunctionDef",
  "lineno": 1233,
  "col": 4,
  "end_lineno": 1248,
  "end_col": 9,
  "parent_qualname": "HybridSearchEngine",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/hybrid_search.py",
  "module": "io.hybrid_search",
  "qualname": "HybridSearchEngine._with_stage_metadata",
  "name": "_with_stage_metadata",
  "node_type": "FunctionDef",
  "lineno": 1251,
  "col": 4,
  "end_lineno": 1259,
  "end_col": 21,
  "parent_qualname": "HybridSearchEngine",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/hybrid_search.py",
  "module": "io.hybrid_search",
  "qualname": "HybridSearchEngine.resolve_path",
  "name": "resolve_path",
  "node_type": "FunctionDef",
  "lineno": 1261,
  "col": 4,
  "end_lineno": 1278,
  "end_col": 60,
  "parent_qualname": "HybridSearchEngine",
  "decorators": [],
  "bases": [],
  "docstring": "Resolve a path string to an absolute Path.\n\nParameters\n----------\nvalue : str\n    Path string that may be absolute, relative, or use ~ expansion.\n\nReturns\n-------\nPath\n    Absolute resolved path. If input is absolute, returns as-is.\n    If relative, resolves relative to repository root.",
  "is_public": true
}
{
  "path": "io/hybrid_search.py",
  "module": "io.hybrid_search",
  "qualname": "HybridSearchEngine._build_semantic_channel_hits",
  "name": "_build_semantic_channel_hits",
  "node_type": "FunctionDef",
  "lineno": 1280,
  "col": 4,
  "end_lineno": 1299,
  "end_col": 28,
  "parent_qualname": "HybridSearchEngine",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/hybrid_search.py",
  "module": "io.hybrid_search",
  "qualname": "HybridSearchEngine._compute_pool_weights",
  "name": "_compute_pool_weights",
  "node_type": "FunctionDef",
  "lineno": 1301,
  "col": 4,
  "end_lineno": 1311,
  "end_col": 22,
  "parent_qualname": "HybridSearchEngine",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/hybrid_search.py",
  "module": "io.hybrid_search",
  "qualname": "HybridSearchEngine._resolve_pool_weights",
  "name": "_resolve_pool_weights",
  "node_type": "FunctionDef",
  "lineno": 1313,
  "col": 4,
  "end_lineno": 1324,
  "end_col": 22,
  "parent_qualname": "HybridSearchEngine",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/hybrid_search.py",
  "module": "io.hybrid_search",
  "qualname": "HybridSearchEngine._make_pooler",
  "name": "_make_pooler",
  "node_type": "FunctionDef",
  "lineno": 1326,
  "col": 4,
  "end_lineno": 1334,
  "end_col": 76,
  "parent_qualname": "HybridSearchEngine",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/hybrid_search.py",
  "module": "io.hybrid_search",
  "qualname": "HybridSearchEngine._select_pooler",
  "name": "_select_pooler",
  "node_type": "FunctionDef",
  "lineno": 1336,
  "col": 4,
  "end_lineno": 1346,
  "end_col": 30,
  "parent_qualname": "HybridSearchEngine",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/hybrid_search.py",
  "module": "io.hybrid_search",
  "qualname": "HybridSearchEngine._method_stats",
  "name": "_method_stats",
  "node_type": "FunctionDef",
  "lineno": 1349,
  "col": 4,
  "end_lineno": 1361,
  "end_col": 9,
  "parent_qualname": "HybridSearchEngine",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/hybrid_search.py",
  "module": "io.hybrid_search",
  "qualname": "HybridSearchEngine._flatten_hits_for_pool",
  "name": "_flatten_hits_for_pool",
  "node_type": "FunctionDef",
  "lineno": 1364,
  "col": 4,
  "end_lineno": 1379,
  "end_col": 24,
  "parent_qualname": "HybridSearchEngine",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/hybrid_search.py",
  "module": "io.hybrid_search",
  "qualname": "HybridSearchEngine._build_contribution_map",
  "name": "_build_contribution_map",
  "node_type": "FunctionDef",
  "lineno": 1382,
  "col": 4,
  "end_lineno": 1391,
  "end_col": 28,
  "parent_qualname": "HybridSearchEngine",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/hybrid_search.py",
  "module": "io.hybrid_search",
  "qualname": "HybridSearchEngine._compose_method_metadata",
  "name": "_compose_method_metadata",
  "node_type": "FunctionDef",
  "lineno": 1393,
  "col": 4,
  "end_lineno": 1425,
  "end_col": 21,
  "parent_qualname": "HybridSearchEngine",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/hybrid_search.py",
  "module": "io.hybrid_search",
  "qualname": "HybridSearchEngine._filter_semantic_hits",
  "name": "_filter_semantic_hits",
  "node_type": "FunctionDef",
  "lineno": 1427,
  "col": 4,
  "end_lineno": 1470,
  "end_col": 29,
  "parent_qualname": "HybridSearchEngine",
  "decorators": [],
  "bases": [],
  "docstring": "Drop semantic hits when FAISS is unavailable or below score threshold.\n\nThis method filters semantic search results based on FAISS availability and\nminimum score thresholds. It is called during hybrid search execution to\nensure only valid semantic hits are included in the final results. When FAISS\nis unavailable or scores are too low, warnings are generated for telemetry.\n\nParameters\n----------\nsemantic_hits : Sequence[tuple[int, float]]\n    Sequence of (chunk_id, score) tuples from semantic search.\nfaiss_ready : bool\n    Whether FAISS index is available and ready for use.\n\nReturns\n-------\ntuple[list[tuple[int, float]], list[str]]\n    Filtered list of (chunk_id, score) tuples and list of warning strings\n    indicating why hits were filtered (e.g., \"faiss_fallback:unavailable\" or\n    \"faiss_fallback:low_score\").",
  "is_public": false
}
{
  "path": "io/parquet_store.py",
  "module": "io.parquet_store",
  "qualname": "io.parquet_store",
  "name": "io.parquet_store",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Parquet storage for chunks and vectors using Arrow.\n\nStores chunks and embeddings in columnar Parquet format with FixedSizeList\nfor efficient vector storage and querying via DuckDB.",
  "is_public": true
}
{
  "path": "io/parquet_store.py",
  "module": "io.parquet_store",
  "qualname": "get_chunks_schema",
  "name": "get_chunks_schema",
  "node_type": "FunctionDef",
  "lineno": 36,
  "col": 0,
  "end_lineno": 67,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Get Arrow schema for chunks table.\n\nParameters\n----------\nvec_dim : int\n    Embedding dimension.\n\nReturns\n-------\npa.Schema\n    Arrow schema for chunks with embeddings.",
  "is_public": true
}
{
  "path": "io/parquet_store.py",
  "module": "io.parquet_store",
  "qualname": "ParquetWriteOptions",
  "name": "ParquetWriteOptions",
  "node_type": "ClassDef",
  "lineno": 74,
  "col": 0,
  "end_lineno": 82,
  "end_col": 44,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Configuration for Parquet persistence.",
  "is_public": true
}
{
  "path": "io/parquet_store.py",
  "module": "io.parquet_store",
  "qualname": "_hash_content",
  "name": "_hash_content",
  "node_type": "FunctionDef",
  "lineno": 85,
  "col": 0,
  "end_lineno": 109,
  "end_col": 76,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return stable 64-bit hash of chunk content.\n\nThis function computes a deterministic hash of text content using xxhash when\navailable, or falls back to a built-in hash function. The hash is used for\ncontent deduplication and change detection in chunk processing pipelines.\n\nParameters\n----------\ntext : str\n    Text content to hash. The text is encoded as UTF-8 (with error handling)\n    before hashing. Used to generate a stable identifier for chunk content.\n\nReturns\n-------\nint\n    Unsigned 64-bit hash value derived from the UTF-8 encoded text. The hash\n    is deterministic for the same input text and suitable for use as a content\n    fingerprint or deduplication key.",
  "is_public": false
}
{
  "path": "io/parquet_store.py",
  "module": "io.parquet_store",
  "qualname": "write_chunks_parquet",
  "name": "write_chunks_parquet",
  "node_type": "FunctionDef",
  "lineno": 112,
  "col": 0,
  "end_lineno": 207,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Write chunks and embeddings to Parquet.\n\nParameters\n----------\noutput_path : Path\n    Output Parquet file path.\nchunks : Sequence[Chunk]\n    Chunk metadata.\nembeddings : NDArrayF32\n    Embeddings array of shape (len(chunks), vec_dim).\noptions : ParquetWriteOptions | None, optional\n    Configuration for chunk identifiers, embedding dimension, and preview\n    truncation length. Defaults to :class:`ParquetWriteOptions`.\n\nRaises\n------\nValueError\n    If chunks and embeddings length mismatch.",
  "is_public": true
}
{
  "path": "io/parquet_store.py",
  "module": "io.parquet_store",
  "qualname": "read_chunks_parquet",
  "name": "read_chunks_parquet",
  "node_type": "FunctionDef",
  "lineno": 210,
  "col": 0,
  "end_lineno": 223,
  "end_col": 38,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Read chunks from Parquet file.\n\nParameters\n----------\nparquet_path : Path\n    Parquet file path.\n\nReturns\n-------\npa.Table\n    Chunks table.",
  "is_public": true
}
{
  "path": "io/parquet_store.py",
  "module": "io.parquet_store",
  "qualname": "extract_embeddings",
  "name": "extract_embeddings",
  "node_type": "FunctionDef",
  "lineno": 226,
  "col": 0,
  "end_lineno": 254,
  "end_col": 43,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Extract embeddings from chunks table.\n\nParameters\n----------\ntable : pa.Table\n    Chunks table with embedding column.\n\nReturns\n-------\nNDArrayF32\n    Embeddings array of shape (num_rows, vec_dim).\n\nRaises\n------\nTypeError\n    If the embedding column is not stored as a FixedSizeListArray.",
  "is_public": true
}
{
  "path": "io/path_utils.py",
  "module": "io.path_utils",
  "qualname": "io.path_utils",
  "name": "io.path_utils",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Path safety utilities for repository-scoped operations.",
  "is_public": true
}
{
  "path": "io/path_utils.py",
  "module": "io.path_utils",
  "qualname": "PathOutsideRepositoryError",
  "name": "PathOutsideRepositoryError",
  "node_type": "ClassDef",
  "lineno": 8,
  "col": 0,
  "end_lineno": 9,
  "end_col": 68,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "ValueError"
  ],
  "docstring": "Raised when a path escapes the configured repository root.",
  "is_public": true
}
{
  "path": "io/path_utils.py",
  "module": "io.path_utils",
  "qualname": "resolve_within_repo",
  "name": "resolve_within_repo",
  "node_type": "FunctionDef",
  "lineno": 12,
  "col": 0,
  "end_lineno": 54,
  "end_col": 20,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Resolve ``target`` against ``repo_root`` and ensure it stays within bounds.\n\nParameters\n----------\nrepo_root : Path\n    Repository root directory.\ntarget : str | Path\n    Requested path (relative or absolute).\nallow_nonexistent : bool, optional\n    When ``False`` the resolved path must already exist on disk.\n\nReturns\n-------\nPath\n    Absolute path inside ``repo_root``.\n\nRaises\n------\nPathOutsideRepositoryError\n    If the resolved path is outside the repository.\nFileNotFoundError\n    When ``allow_nonexistent`` is ``False`` and the path does not exist.",
  "is_public": true
}
{
  "path": "io/rerank_coderankllm.py",
  "module": "io.rerank_coderankllm",
  "qualname": "io.rerank_coderankllm",
  "name": "io.rerank_coderankllm",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Listwise reranking using the CodeRankLLM checkpoint.",
  "is_public": true
}
{
  "path": "io/rerank_coderankllm.py",
  "module": "io.rerank_coderankllm",
  "qualname": "CodeRankListwiseReranker",
  "name": "CodeRankListwiseReranker",
  "node_type": "ClassDef",
  "lineno": 33,
  "col": 0,
  "end_lineno": 173,
  "end_col": 22,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Listwise reranking helper built on CodeRankLLM.",
  "is_public": true
}
{
  "path": "io/rerank_coderankllm.py",
  "module": "io.rerank_coderankllm",
  "qualname": "CodeRankListwiseReranker.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 41,
  "col": 4,
  "end_lineno": 54,
  "end_col": 26,
  "parent_qualname": "CodeRankListwiseReranker",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/rerank_coderankllm.py",
  "module": "io.rerank_coderankllm",
  "qualname": "CodeRankListwiseReranker.rerank",
  "name": "rerank",
  "node_type": "FunctionDef",
  "lineno": 56,
  "col": 4,
  "end_lineno": 111,
  "end_col": 45,
  "parent_qualname": "CodeRankListwiseReranker",
  "decorators": [],
  "bases": [],
  "docstring": "Return ordered chunk IDs ranked by CodeRankLLM.\n\nParameters\n----------\nquery : str\n    Natural language search query string.\ncandidates : Sequence[tuple[int, str]]\n    Sequence of (chunk_id, code_snippet) tuples to rerank. The code\n    snippets are used as context for the LLM to determine relevance.\n\nReturns\n-------\nlist[int]\n    Ordered list of chunk IDs ranked by CodeRankLLM, highest score first.\n    Length matches len(candidates).\n\nRaises\n------\nRuntimeError\n    If model generation fails or the model cannot produce output.",
  "is_public": true
}
{
  "path": "io/rerank_coderankllm.py",
  "module": "io.rerank_coderankllm",
  "qualname": "CodeRankListwiseReranker._ensure_model",
  "name": "_ensure_model",
  "node_type": "FunctionDef",
  "lineno": 113,
  "col": 4,
  "end_lineno": 140,
  "end_col": 23,
  "parent_qualname": "CodeRankListwiseReranker",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/rerank_coderankllm.py",
  "module": "io.rerank_coderankllm",
  "qualname": "CodeRankListwiseReranker._build_prompt",
  "name": "_build_prompt",
  "node_type": "FunctionDef",
  "lineno": 143,
  "col": 4,
  "end_lineno": 148,
  "end_col": 92,
  "parent_qualname": "CodeRankListwiseReranker",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/rerank_coderankllm.py",
  "module": "io.rerank_coderankllm",
  "qualname": "CodeRankListwiseReranker._parse_rankings",
  "name": "_parse_rankings",
  "node_type": "FunctionDef",
  "lineno": 151,
  "col": 4,
  "end_lineno": 173,
  "end_col": 22,
  "parent_qualname": "CodeRankListwiseReranker",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/rrf.py",
  "module": "io.rrf",
  "qualname": "io.rrf",
  "name": "io.rrf",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Reciprocal Rank Fusion utilities (legacy compatibility wrappers).",
  "is_public": true
}
{
  "path": "io/rrf.py",
  "module": "io.rrf",
  "qualname": "weighted_rrf",
  "name": "weighted_rrf",
  "node_type": "FunctionDef",
  "lineno": 12,
  "col": 0,
  "end_lineno": 111,
  "end_col": 49,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Apply weighted Reciprocal Rank Fusion to channel hits.\n\nExtended Summary\n----------------\nThis function performs weighted Reciprocal Rank Fusion (RRF) across multiple\nretrieval channels, combining ranked lists from different search methods (e.g.,\nCodeRank, WARP, BM25) into a single unified ranking. It serves as a legacy\ncompatibility wrapper that converts integer-based channel hits into the internal\nSearchHit format, optionally normalizes scores per-channel (minmax or z-score),\ndelegates to the core fusion engine, and converts results back to integer document\nIDs. The function is used by the hybrid search pipeline to merge semantic and\nsparse retrieval signals with configurable per-channel weights and normalization.\n\nParameters\n----------\nchannels : Mapping[str, Sequence[tuple[int, float]]]\n    Per-channel ranked lists mapping channel names to sequences of (doc_id, score)\n    tuples. Each channel represents a distinct retrieval method (e.g., \"coderank\",\n    \"warp\", \"bm25\"). Document IDs must be convertible to integers.\nweights : Mapping[str, float]\n    Per-channel fusion weights. Channels not present in this mapping default to\n    weight 1.0. Zero-weighted channels are excluded from fusion. Weights control\n    the relative influence of each channel in the final ranking.\nk : int\n    RRF damping constant. Controls how quickly reciprocal rank contributions decay\n    with position. Higher values reduce the impact of lower-ranked items. Typical\n    values range from 20 to 100.\ntop_k : int\n    Maximum number of documents to return in the fused ranking. Must be positive.\n    The function returns the top_k highest-scoring documents after fusion.\nnormalize : Literal[\"none\", \"minmax\", \"z\"], optional\n    Optional per-channel score normalization applied before fusion. Use \"minmax\"\n    to scale raw scores to [0, 1] or \"z\" for z-score normalization. Defaults to\n    \"none\", preserving incoming scores.\n\nReturns\n-------\ntuple[list[int], dict[int, list[tuple[str, int, float]]], dict[int, float]]\n    A 3-tuple containing:\n    - Ranked list of document IDs (integers) sorted by fused RRF score (descending).\n    - Per-document contribution map: doc_id -> list of (channel, rank, score) tuples\n      showing which channels contributed to each document's final score.\n    - Per-document fused score map: doc_id -> final fused RRF score.\n\nRaises\n------\nValueError\n    If a document ID cannot be converted to an integer, or if top_k is not positive.\n\nNotes\n-----\nTime complexity O(n * m) where n is total hits across channels and m is the number\nof channels. Space complexity O(n) for the fused score map and contributions.\nThe function performs no I/O and has no side effects. Thread-safe if input mappings\nare immutable or accessed read-only.\n\nExamples\n--------\n>>> channels = {\"coderank\": [(1, 0.9), (2, 0.8)], \"warp\": [(2, 0.85), (1, 0.75)]}\n>>> weights = {\"coderank\": 1.0, \"warp\": 0.5}\n>>> doc_ids, contribs, scores = weighted_rrf(channels, weights=weights, k=60, top_k=2)\n>>> len(doc_ids) <= 2\nTrue\n>>> 1 in doc_ids and 2 in doc_ids\nTrue",
  "is_public": true
}
{
  "path": "io/rrf.py",
  "module": "io.rrf",
  "qualname": "_normalize_channel_hits",
  "name": "_normalize_channel_hits",
  "node_type": "FunctionDef",
  "lineno": 114,
  "col": 0,
  "end_lineno": 157,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Normalize channel hit scores using the specified mode.\n\nParameters\n----------\nhits : Sequence[tuple[int, float]]\n    Original hits as (doc_id, score) tuples.\nmode : Literal[\"none\", \"minmax\", \"z\"]\n    Normalization mode: \"none\" returns hits unchanged, \"minmax\" scales to [0, 1],\n    \"z\" applies z-score normalization.\n\nReturns\n-------\nlist[tuple[int, float]]\n    Normalized hits with same doc_ids but transformed scores.",
  "is_public": false
}
{
  "path": "io/rrf.py",
  "module": "io.rrf",
  "qualname": "_to_int",
  "name": "_to_int",
  "node_type": "FunctionDef",
  "lineno": 160,
  "col": 0,
  "end_lineno": 165,
  "end_col": 38,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/splade_manager.py",
  "module": "io.splade_manager",
  "qualname": "io.splade_manager",
  "name": "io.splade_manager",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "SPLADE artifact management, encoding, and Lucene impact index builders.",
  "is_public": true
}
{
  "path": "io/splade_manager.py",
  "module": "io.splade_manager",
  "qualname": "_SparseEncoderProtocol",
  "name": "_SparseEncoderProtocol",
  "node_type": "ClassDef",
  "lineno": 30,
  "col": 4,
  "end_lineno": 188,
  "end_col": 15,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "Protocol"
  ],
  "docstring": "Protocol defining the interface for SPLADE sparse encoders.\n\nThis protocol describes the methods that SPLADE encoder implementations\nmust provide for encoding documents and queries, decoding sparse vectors,\nand saving model artifacts. Used for type checking and dependency\ninjection in SPLADE encoding operations.\n\nMethods\n-------\nencode_document(sentences: Sequence[str]) -> Sequence[object]\n    Encode document texts into sparse vector embeddings.\n\nencode_query(queries: Sequence[str]) -> Sequence[object]\n    Encode query texts into sparse vector embeddings.\n\ndecode(embeddings: object, top_k: int | None = None) -> Sequence[Sequence[tuple[str, float]]]\n    Decode sparse vector embeddings into token-weight pairs.\n\nsave_pretrained(output_path: str) -> None\n    Save the encoder model to disk for later loading.",
  "is_public": false
}
{
  "path": "io/splade_manager.py",
  "module": "io.splade_manager",
  "qualname": "_SparseEncoderProtocol.encode_document",
  "name": "encode_document",
  "node_type": "FunctionDef",
  "lineno": 53,
  "col": 8,
  "end_lineno": 84,
  "end_col": 15,
  "parent_qualname": "_SparseEncoderProtocol",
  "decorators": [],
  "bases": [],
  "docstring": "Encode document texts into sparse vector embeddings.\n\nThis method processes a batch of document texts and produces sparse\nvector embeddings suitable for retrieval. The embeddings are typically\nhigh-dimensional sparse vectors where each dimension corresponds to a\nvocabulary token and the value represents the token's importance weight.\n\nParameters\n----------\nsentences : Sequence[str]\n    Batch of document texts to encode. Each string represents one\n    document from the corpus. The encoder processes the batch together\n    for efficiency.\n\nReturns\n-------\nSequence[object]\n    Sparse vector embeddings for the input documents. The exact type\n    depends on the encoder implementation (typically numpy arrays or\n    PyTorch tensors). Each embedding represents one input document\n    and can be decoded into token-weight pairs using decode().\n\nNotes\n-----\nThe embeddings produced by this method are optimized for document\nindexing and retrieval. They typically have different characteristics\nthan query embeddings (produced by encode_query()) to optimize for\ndifferent use cases. Time complexity: O(batch_size * avg_doc_length)\nfor encoding, plus model inference overhead.",
  "is_public": true
}
{
  "path": "io/splade_manager.py",
  "module": "io.splade_manager",
  "qualname": "_SparseEncoderProtocol.encode_query",
  "name": "encode_query",
  "node_type": "FunctionDef",
  "lineno": 86,
  "col": 8,
  "end_lineno": 115,
  "end_col": 15,
  "parent_qualname": "_SparseEncoderProtocol",
  "decorators": [],
  "bases": [],
  "docstring": "Encode query texts into sparse vector embeddings.\n\nThis method processes a batch of query texts and produces sparse\nvector embeddings optimized for query-time retrieval. Query embeddings\nare designed to match against document embeddings produced by\nencode_document() for semantic search.\n\nParameters\n----------\nqueries : Sequence[str]\n    Batch of query texts to encode. Each string represents one search\n    query. The encoder processes the batch together for efficiency.\n\nReturns\n-------\nSequence[object]\n    Sparse vector embeddings for the input queries. The exact type\n    depends on the encoder implementation (typically numpy arrays or\n    PyTorch tensors). Each embedding represents one input query and\n    can be decoded into token-weight pairs using decode().\n\nNotes\n-----\nQuery embeddings are optimized for retrieval against document embeddings.\nThey may have different sparsity patterns or weight distributions than\ndocument embeddings to improve query-document matching. Time complexity:\nO(batch_size * avg_query_length) for encoding, plus model inference overhead.",
  "is_public": true
}
{
  "path": "io/splade_manager.py",
  "module": "io.splade_manager",
  "qualname": "_SparseEncoderProtocol.decode",
  "name": "decode",
  "node_type": "FunctionDef",
  "lineno": 117,
  "col": 8,
  "end_lineno": 159,
  "end_col": 15,
  "parent_qualname": "_SparseEncoderProtocol",
  "decorators": [],
  "bases": [],
  "docstring": "Decode sparse vector embeddings into token-weight pairs.\n\nThis method converts sparse vector embeddings back into human-readable\ntoken-weight pairs. Each embedding is decoded into a sequence of\n(token, weight) tuples representing the most important tokens and their\nrelevance scores. Optionally filters to top-k tokens by weight.\n\nParameters\n----------\nembeddings : object\n    Sparse vector embeddings to decode. Typically numpy arrays or\n    PyTorch tensors produced by encode_document() or encode_query().\n    The embeddings should be in the format expected by the encoder\n    implementation.\ntop_k : int | None, optional\n    Maximum number of top tokens to return per embedding. If None,\n    returns all non-zero tokens. If specified, returns only the\n    top-k tokens by weight (descending order). Defaults to None.\n\nReturns\n-------\nSequence[Sequence[tuple[str, float]]]\n    Decoded token-weight pairs for each input embedding. Outer sequence\n    has one entry per input embedding. Inner sequence contains\n    (token, weight) tuples sorted by weight (descending). Tokens are\n    vocabulary strings; weights are floating-point relevance scores\n    (typically non-negative, higher is more relevant).\n\nNotes\n-----\nThe decode operation is typically used for:\n- Inspecting which tokens contribute most to an embedding\n- Converting embeddings to quantized token dictionaries for indexing\n- Debugging and understanding model behavior\nTime complexity: O(n_embeddings * embedding_dim) for full decoding,\nO(n_embeddings * top_k * log(embedding_dim)) if top_k is specified.",
  "is_public": true
}
{
  "path": "io/splade_manager.py",
  "module": "io.splade_manager",
  "qualname": "_SparseEncoderProtocol.save_pretrained",
  "name": "save_pretrained",
  "node_type": "FunctionDef",
  "lineno": 161,
  "col": 8,
  "end_lineno": 188,
  "end_col": 15,
  "parent_qualname": "_SparseEncoderProtocol",
  "decorators": [],
  "bases": [],
  "docstring": "Save the encoder model to disk for later loading.\n\nThis method persists the encoder's model weights, configuration, and\nvocabulary to disk so it can be loaded later without retraining. The\nsaved model can be loaded by instantiating a new encoder with the\nsame model identifier or path.\n\nParameters\n----------\noutput_path : str\n    Directory path where the model should be saved. The method creates\n    this directory if it doesn't exist and writes model files (weights,\n    config, vocabulary) into it. The path should be writable and have\n    sufficient disk space for the model artifacts.\n\nNotes\n-----\nThe saved model includes all components necessary for encoding:\n- Model weights (PyTorch state dict or ONNX format)\n- Tokenizer configuration and vocabulary\n- Model configuration (architecture, hyperparameters)\nThe saved model can be loaded later using the same encoder class\nconstructor with the output_path as the model identifier. Time\ncomplexity: O(model_size) for writing model files to disk. The method\nperforms I/O operations and may take several seconds for large models.",
  "is_public": true
}
{
  "path": "io/splade_manager.py",
  "module": "io.splade_manager",
  "qualname": "_OptimizerFunction",
  "name": "_OptimizerFunction",
  "node_type": "ClassDef",
  "lineno": 190,
  "col": 4,
  "end_lineno": 199,
  "end_col": 22,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "Protocol"
  ],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/splade_manager.py",
  "module": "io.splade_manager",
  "qualname": "_OptimizerFunction.__call__",
  "name": "__call__",
  "node_type": "FunctionDef",
  "lineno": 191,
  "col": 8,
  "end_lineno": 199,
  "end_col": 22,
  "parent_qualname": "_OptimizerFunction",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/splade_manager.py",
  "module": "io.splade_manager",
  "qualname": "_QuantizerFunction",
  "name": "_QuantizerFunction",
  "node_type": "ClassDef",
  "lineno": 201,
  "col": 4,
  "end_lineno": 210,
  "end_col": 22,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "Protocol"
  ],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/splade_manager.py",
  "module": "io.splade_manager",
  "qualname": "_QuantizerFunction.__call__",
  "name": "__call__",
  "node_type": "FunctionDef",
  "lineno": 202,
  "col": 8,
  "end_lineno": 210,
  "end_col": 22,
  "parent_qualname": "_QuantizerFunction",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/splade_manager.py",
  "module": "io.splade_manager",
  "qualname": "SpladeArtifactMetadata",
  "name": "SpladeArtifactMetadata",
  "node_type": "ClassDef",
  "lineno": 241,
  "col": 0,
  "end_lineno": 253,
  "end_col": 18,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "msgspec.Struct"
  ],
  "docstring": "Metadata describing exported SPLADE ONNX artifacts.",
  "is_public": true
}
{
  "path": "io/splade_manager.py",
  "module": "io.splade_manager",
  "qualname": "SpladeExportSummary",
  "name": "SpladeExportSummary",
  "node_type": "ClassDef",
  "lineno": 256,
  "col": 0,
  "end_lineno": 260,
  "end_col": 22,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "msgspec.Struct"
  ],
  "docstring": "Summary returned after exporting SPLADE artifacts.",
  "is_public": true
}
{
  "path": "io/splade_manager.py",
  "module": "io.splade_manager",
  "qualname": "SpladeEncodingMetadata",
  "name": "SpladeEncodingMetadata",
  "node_type": "ClassDef",
  "lineno": 263,
  "col": 0,
  "end_lineno": 274,
  "end_col": 18,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "msgspec.Struct"
  ],
  "docstring": "Metadata describing SPLADE vector encoding runs.",
  "is_public": true
}
{
  "path": "io/splade_manager.py",
  "module": "io.splade_manager",
  "qualname": "SpladeEncodingSummary",
  "name": "SpladeEncodingSummary",
  "node_type": "ClassDef",
  "lineno": 277,
  "col": 0,
  "end_lineno": 283,
  "end_col": 20,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "msgspec.Struct"
  ],
  "docstring": "Summary describing SPLADE encoding output.",
  "is_public": true
}
{
  "path": "io/splade_manager.py",
  "module": "io.splade_manager",
  "qualname": "SpladeBenchmarkOptions",
  "name": "SpladeBenchmarkOptions",
  "node_type": "ClassDef",
  "lineno": 286,
  "col": 0,
  "end_lineno": 292,
  "end_col": 32,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "msgspec.Struct"
  ],
  "docstring": "Options controlling SPLADE encoder latency benchmarks.",
  "is_public": true
}
{
  "path": "io/splade_manager.py",
  "module": "io.splade_manager",
  "qualname": "SpladeBenchmarkSummary",
  "name": "SpladeBenchmarkSummary",
  "node_type": "ClassDef",
  "lineno": 295,
  "col": 0,
  "end_lineno": 308,
  "end_col": 25,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "msgspec.Struct"
  ],
  "docstring": "Summary describing SPLADE encoder latency benchmarks.",
  "is_public": true
}
{
  "path": "io/splade_manager.py",
  "module": "io.splade_manager",
  "qualname": "SpladeExportOptions",
  "name": "SpladeExportOptions",
  "node_type": "ClassDef",
  "lineno": 311,
  "col": 0,
  "end_lineno": 319,
  "end_col": 37,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "msgspec.Struct"
  ],
  "docstring": "Options controlling SPLADE ONNX export behaviour.",
  "is_public": true
}
{
  "path": "io/splade_manager.py",
  "module": "io.splade_manager",
  "qualname": "SpladeEncodeOptions",
  "name": "SpladeEncodeOptions",
  "node_type": "ClassDef",
  "lineno": 322,
  "col": 0,
  "end_lineno": 330,
  "end_col": 32,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "msgspec.Struct"
  ],
  "docstring": "Options controlling SPLADE corpus encoding.",
  "is_public": true
}
{
  "path": "io/splade_manager.py",
  "module": "io.splade_manager",
  "qualname": "SpladeBuildOptions",
  "name": "SpladeBuildOptions",
  "node_type": "ClassDef",
  "lineno": 333,
  "col": 0,
  "end_lineno": 340,
  "end_col": 26,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "msgspec.Struct"
  ],
  "docstring": "Options controlling SPLADE Lucene impact index builds.",
  "is_public": true
}
{
  "path": "io/splade_manager.py",
  "module": "io.splade_manager",
  "qualname": "SpladeIndexMetadata",
  "name": "SpladeIndexMetadata",
  "node_type": "ClassDef",
  "lineno": 343,
  "col": 0,
  "end_lineno": 354,
  "end_col": 18,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "msgspec.Struct"
  ],
  "docstring": "Metadata describing a SPLADE Lucene impact index.",
  "is_public": true
}
{
  "path": "io/splade_manager.py",
  "module": "io.splade_manager",
  "qualname": "_ShardState",
  "name": "_ShardState",
  "node_type": "ClassDef",
  "lineno": 358,
  "col": 0,
  "end_lineno": 367,
  "end_col": 24,
  "parent_qualname": null,
  "decorators": [
    "dataclass(frozen=True)"
  ],
  "bases": [],
  "docstring": "Mutable encoding state for shard rotation.",
  "is_public": false
}
{
  "path": "io/splade_manager.py",
  "module": "io.splade_manager",
  "qualname": "_ExportContext",
  "name": "_ExportContext",
  "node_type": "ClassDef",
  "lineno": 374,
  "col": 0,
  "end_lineno": 382,
  "end_col": 32,
  "parent_qualname": null,
  "decorators": [
    "dataclass(frozen=True)"
  ],
  "bases": [],
  "docstring": "Context for SPLADE export operations.",
  "is_public": false
}
{
  "path": "io/splade_manager.py",
  "module": "io.splade_manager",
  "qualname": "_require_sparse_encoder",
  "name": "_require_sparse_encoder",
  "node_type": "FunctionDef",
  "lineno": 385,
  "col": 0,
  "end_lineno": 392,
  "end_col": 30,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/splade_manager.py",
  "module": "io.splade_manager",
  "qualname": "_require_export_helpers",
  "name": "_require_export_helpers",
  "node_type": "FunctionDef",
  "lineno": 395,
  "col": 0,
  "end_lineno": 405,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/splade_manager.py",
  "module": "io.splade_manager",
  "qualname": "_write_struct",
  "name": "_write_struct",
  "node_type": "FunctionDef",
  "lineno": 408,
  "col": 0,
  "end_lineno": 413,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/splade_manager.py",
  "module": "io.splade_manager",
  "qualname": "_directory_size",
  "name": "_directory_size",
  "node_type": "FunctionDef",
  "lineno": 416,
  "col": 0,
  "end_lineno": 441,
  "end_col": 16,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Compute total size in bytes for all files beneath a directory.\n\nThis utility function recursively traverses a directory tree and sums the\nsizes of all regular files found. It's used to calculate index sizes for\nmetadata purposes. Symbolic links are followed, but directories themselves\ndon't contribute to the size.\n\nParameters\n----------\npath : Path\n    Root directory path to measure. The function recursively traverses all\n    subdirectories and sums file sizes. The path must exist and be a directory.\n\nReturns\n-------\nint\n    Total size in bytes for all regular files contained within the directory\n    tree. Returns 0 if the directory is empty or contains no files. The\n    size is calculated using file system stat information (st_size).",
  "is_public": false
}
{
  "path": "io/splade_manager.py",
  "module": "io.splade_manager",
  "qualname": "_detect_pyserini_version",
  "name": "_detect_pyserini_version",
  "node_type": "FunctionDef",
  "lineno": 444,
  "col": 0,
  "end_lineno": 450,
  "end_col": 61,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/splade_manager.py",
  "module": "io.splade_manager",
  "qualname": "_serialize_relative",
  "name": "_serialize_relative",
  "node_type": "FunctionDef",
  "lineno": 453,
  "col": 0,
  "end_lineno": 457,
  "end_col": 24,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/splade_manager.py",
  "module": "io.splade_manager",
  "qualname": "_percentile_value",
  "name": "_percentile_value",
  "node_type": "FunctionDef",
  "lineno": 460,
  "col": 0,
  "end_lineno": 498,
  "end_col": 68,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return the percentile value using linear interpolation.\n\nParameters\n----------\nsorted_values : Sequence[float]\n    Non-empty sorted sequence of latency values.\npercentile : float\n    Desired percentile in the inclusive range [0, 100].\n\nReturns\n-------\nfloat\n    Interpolated percentile value.\n\nRaises\n------\nValueError\n    If :paramref:`sorted_values` is empty.",
  "is_public": false
}
{
  "path": "io/splade_manager.py",
  "module": "io.splade_manager",
  "qualname": "_quantize_tokens",
  "name": "_quantize_tokens",
  "node_type": "FunctionDef",
  "lineno": 501,
  "col": 0,
  "end_lineno": 509,
  "end_col": 17,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/splade_manager.py",
  "module": "io.splade_manager",
  "qualname": "_iter_corpus",
  "name": "_iter_corpus",
  "node_type": "FunctionDef",
  "lineno": 512,
  "col": 0,
  "end_lineno": 518,
  "end_col": 34,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/splade_manager.py",
  "module": "io.splade_manager",
  "qualname": "_open_writer",
  "name": "_open_writer",
  "node_type": "FunctionDef",
  "lineno": 521,
  "col": 0,
  "end_lineno": 548,
  "end_col": 61,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Create a shard writer for the given shard index.\n\nThis helper function creates a new JSONL shard file for writing encoded\nvectors. Shard files are named with zero-padded indices (e.g., part-00000.jsonl,\npart-00001.jsonl) to ensure proper ordering and easy identification. The file\nis opened in write mode with UTF-8 encoding.\n\nParameters\n----------\nvectors_dir : Path\n    Directory where shard files are stored. The directory should already\n    exist (created by the caller). Shard files are written directly to this\n    directory.\nindex : int\n    Zero-based shard index. Used to generate the shard filename with zero\n    padding (5 digits). Must be non-negative.\n\nReturns\n-------\ntuple[Path, TextIO]\n    Tuple containing:\n    - Path to the created shard file (e.g., vectors_dir/part-00000.jsonl)\n    - Open text file handle in write mode, UTF-8 encoded, ready for writing\n      JSONL records. The caller is responsible for closing the handle.",
  "is_public": false
}
{
  "path": "io/splade_manager.py",
  "module": "io.splade_manager",
  "qualname": "_flush_batch",
  "name": "_flush_batch",
  "node_type": "FunctionDef",
  "lineno": 551,
  "col": 0,
  "end_lineno": 614,
  "end_col": 17,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Encode and persist the current batch of documents.\n\nThis function processes a batch of documents by encoding them using the\nSPLADE encoder, decoding the sparse vectors into token-weight pairs, quantizing\nthe weights, and writing the results to JSONL shard files. The batch is\ncleared after processing.\n\nThe function handles shard file management automatically, creating new shard\nfiles when needed based on the configured shard size. Documents are written\nin JSONL format with document ID, empty contents (for compatibility), and\nthe quantized sparse vector.\n\nParameters\n----------\nencoder : _SparseEncoderProtocol\n    SPLADE encoder instance used to encode document texts into sparse vectors.\n    The encoder must support encode_document() and decode() methods.\nbatch : list[tuple[str, str]]\n    List of (document_id, text) tuples to encode. Each tuple represents one\n    document from the corpus. The batch is cleared after processing.\nstate : _ShardState\n    Mutable state object tracking shard file handles, document counts, shard\n    indices, and encoding parameters. The state is updated as documents are\n    written and shard files are rotated.\n\nRaises\n------\nRuntimeError\n    If a shard file handle unexpectedly becomes None during writing. This\n    should not occur in normal operation and indicates a programming error\n    or resource management issue.",
  "is_public": false
}
{
  "path": "io/splade_manager.py",
  "module": "io.splade_manager",
  "qualname": "_persist_encoding_metadata",
  "name": "_persist_encoding_metadata",
  "node_type": "FunctionDef",
  "lineno": 617,
  "col": 0,
  "end_lineno": 680,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Write metadata for an encoding run and return the summary.\n\nThis function creates and persists metadata about a SPLADE encoding operation,\nincluding document counts, shard information, encoding parameters, and\nprovenance data. The metadata is written as JSON to a standard location\nwithin the vectors directory and can be used later to verify corpus integrity\nand understand encoding configuration.\n\nParameters\n----------\nstate : _ShardState\n    Encoding state object containing accumulated statistics: document count,\n    shard count, quantization parameter, and other encoding metadata. The\n    state reflects the final state after all documents have been encoded.\nvectors_dir : Path\n    Directory where encoded vector shards are stored. The metadata file will\n    be written to this directory with a standard filename.\nsource_path : Path\n    Path to the original JSONL corpus file that was encoded. Stored in\n    metadata for provenance tracking and corpus identification.\nbatch_size : int\n    Batch size used during encoding. This parameter affects encoding\n    throughput and memory usage. Stored in metadata for reproducibility.\nprovider : str\n    ONNX runtime provider used for encoding (e.g., \"cpu\", \"cuda\", \"tensorrt\").\n    Affects encoding performance and hardware requirements. Stored for\n    reproducibility and performance analysis.\n\nReturns\n-------\nSpladeEncodingSummary\n    Summary object containing:\n    - doc_count: Total number of documents encoded\n    - vectors_dir: Directory path where shards are stored\n    - metadata_path: Path to the written metadata JSON file\n    - shard_count: Number of shard files created",
  "is_public": false
}
{
  "path": "io/splade_manager.py",
  "module": "io.splade_manager",
  "qualname": "_encode_records",
  "name": "_encode_records",
  "node_type": "FunctionDef",
  "lineno": 683,
  "col": 0,
  "end_lineno": 752,
  "end_col": 39,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Stream records from disk, validate them, and flush in batches.\n\nThis function orchestrates the encoding process by reading JSONL records from\na corpus file, validating that each record has required fields (id and\ncontents/text), accumulating records into batches, and flushing batches when\nthey reach the configured size. The final batch is flushed even if it's\nsmaller than the batch size.\n\nThe function handles streaming large corpora efficiently by processing records\none at a time and batching encoding operations. This minimizes memory usage\nwhile maintaining good throughput through batch encoding.\n\nParameters\n----------\nencoder : _SparseEncoderProtocol\n    SPLADE encoder instance used to encode document texts. The encoder\n    processes batches of texts and returns sparse vector representations.\nstate : _ShardState\n    Mutable encoding state tracking shard files, document counts, and encoding\n    parameters. Updated as batches are flushed and documents are written.\nbatch : list[tuple[str, str]]\n    Accumulator list for batching documents. Documents are added to this list\n    until it reaches batch_size, then the batch is flushed. The list is\n    cleared after each flush. Must be empty initially.\nbatch_size : int\n    Maximum number of documents to accumulate before flushing. Larger batches\n    improve encoding throughput but increase memory usage. Must be positive.\nsource_path : Path\n    Path to the JSONL corpus file to encode. The file is read line-by-line\n    and each line is parsed as JSON. The file must exist and be readable.\n\nRaises\n------\nTypeError\n    Raised when corpus entries violate type requirements:\n    - Document 'id' field is missing or not a string\n    - Document is missing both 'contents' and 'text' fields, or the content\n      field is not a string\n\nNotes\n-----\nException Propagation:\n    This function may propagate exceptions from underlying operations:\n    - FileNotFoundError: If the source_path does not exist (from file operations\n      in _iter_corpus)\n    - json.JSONDecodeError: If a line in the corpus file contains invalid JSON\n      (from json.loads() in _iter_corpus)",
  "is_public": false
}
{
  "path": "io/splade_manager.py",
  "module": "io.splade_manager",
  "qualname": "_optimize_export",
  "name": "_optimize_export",
  "node_type": "FunctionDef",
  "lineno": 755,
  "col": 0,
  "end_lineno": 802,
  "end_col": 67,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Run graph optimization if requested and return the base ONNX path.\n\nThis function conditionally applies ONNX graph optimizations to improve\ninference performance. If optimization is enabled in the export context,\nit runs the optimizer with O3 optimization level (aggressive optimizations)\nand returns the path to the optimized model. Otherwise, returns the path\nto the original unoptimized model.\n\nGraph optimization can significantly improve inference latency and reduce\nmodel size by applying transformations like constant folding, operator fusion,\nand dead code elimination. However, optimization may increase export time.\n\nParameters\n----------\nencoder : _SparseEncoderProtocol\n    SPLADE encoder model to optimize. The encoder must support the optimization\n    interface provided by sentence-transformers export helpers.\nctx : _ExportContext\n    Export context containing export options, directory paths, model\n    identifier, and provider information. The ctx.options.optimize flag\n    determines whether optimization is performed.\n\nReturns\n-------\nPath\n    Path to the ONNX model file to use as the base for further processing\n    (quantization, etc.). If optimization was performed and successful,\n    returns the optimized model path (model_O3.onnx). Otherwise, returns\n    the original model path (model.onnx).",
  "is_public": false
}
{
  "path": "io/splade_manager.py",
  "module": "io.splade_manager",
  "qualname": "_quantize_export",
  "name": "_quantize_export",
  "node_type": "FunctionDef",
  "lineno": 805,
  "col": 0,
  "end_lineno": 868,
  "end_col": 16,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Apply dynamic quantization and ensure the target ONNX exists.\n\nThis function conditionally applies dynamic quantization to the ONNX model\nto reduce model size and potentially improve inference speed. If quantization\nis enabled, it uses the configured quantization settings to produce a\nquantized model. If quantization is disabled or fails, it ensures the target\npath exists by copying the base model if needed.\n\nDynamic quantization converts floating-point weights to lower precision\n(typically INT8) while maintaining model accuracy. This reduces model size\nand can improve inference speed on certain hardware, but may slightly\ndegrade accuracy.\n\nParameters\n----------\nencoder : _SparseEncoderProtocol\n    SPLADE encoder model to quantize. The encoder must support the quantization\n    interface provided by sentence-transformers export helpers.\nctx : _ExportContext\n    Export context containing quantization options, target path, model\n    directories, and provider information. The ctx.options.quantize flag\n    determines whether quantization is performed, and ctx.options.quantization_config\n    specifies quantization parameters.\nbase_onnx : Path\n    Path to the base ONNX model file (optimized or original). This is the\n    input for quantization. If quantization is disabled, this file is copied\n    to the target path.\n\nReturns\n-------\nbool\n    True if a quantized artifact was successfully produced and exists at\n    the target path. False if quantization was disabled, failed, or the\n    base model was copied instead. Used by callers to determine which model\n    file was actually created.",
  "is_public": false
}
{
  "path": "io/splade_manager.py",
  "module": "io.splade_manager",
  "qualname": "_persist_export_metadata",
  "name": "_persist_export_metadata",
  "node_type": "FunctionDef",
  "lineno": 871,
  "col": 0,
  "end_lineno": 918,
  "end_col": 96,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Write export metadata and return the resulting summary.\n\nThis function creates and persists metadata about a SPLADE ONNX export\noperation, including model identifier, export paths, provider information,\noptimization and quantization status, and export timestamp. The metadata\nis written as JSON to a standard location and can be used to verify exports\nand understand export configuration.\n\nParameters\n----------\nctx : _ExportContext\n    Export context containing all export information: model identifier,\n    directory paths, provider, target file path, and export options\n    (optimization, quantization settings). Used to populate metadata fields.\nquantized : bool\n    Flag indicating whether the exported model is quantized. Determines\n    which quantization configuration (if any) is stored in metadata. True\n    if dynamic quantization was successfully applied, False otherwise.\n\nReturns\n-------\nSpladeExportSummary\n    Summary object containing:\n    - onnx_file: Path to the exported ONNX model file (relative or absolute)\n    - metadata_path: Path to the written metadata JSON file\n    The summary can be used to locate the exported artifacts and verify\n    export completion.",
  "is_public": false
}
{
  "path": "io/splade_manager.py",
  "module": "io.splade_manager",
  "qualname": "SpladeArtifactsManager",
  "name": "SpladeArtifactsManager",
  "node_type": "ClassDef",
  "lineno": 921,
  "col": 0,
  "end_lineno": 1003,
  "end_col": 22,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Manage SPLADE model exports and ONNX artifacts.",
  "is_public": true
}
{
  "path": "io/splade_manager.py",
  "module": "io.splade_manager",
  "qualname": "SpladeArtifactsManager.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 924,
  "col": 4,
  "end_lineno": 928,
  "end_col": 38,
  "parent_qualname": "SpladeArtifactsManager",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/splade_manager.py",
  "module": "io.splade_manager",
  "qualname": "SpladeArtifactsManager.model_dir",
  "name": "model_dir",
  "node_type": "FunctionDef",
  "lineno": 931,
  "col": 4,
  "end_lineno": 939,
  "end_col": 75,
  "parent_qualname": "SpladeArtifactsManager",
  "decorators": [
    "property"
  ],
  "bases": [],
  "docstring": "Return the repository-relative directory containing saved SPLADE weights.\n\nReturns\n-------\nPath\n    Absolute path to the configured SPLADE model directory.",
  "is_public": true
}
{
  "path": "io/splade_manager.py",
  "module": "io.splade_manager",
  "qualname": "SpladeArtifactsManager.onnx_dir",
  "name": "onnx_dir",
  "node_type": "FunctionDef",
  "lineno": 942,
  "col": 4,
  "end_lineno": 950,
  "end_col": 74,
  "parent_qualname": "SpladeArtifactsManager",
  "decorators": [
    "property"
  ],
  "bases": [],
  "docstring": "Return the directory where exported ONNX artifacts are stored.\n\nReturns\n-------\nPath\n    Absolute path to the configured ONNX artifacts directory.",
  "is_public": true
}
{
  "path": "io/splade_manager.py",
  "module": "io.splade_manager",
  "qualname": "SpladeArtifactsManager.export_onnx",
  "name": "export_onnx",
  "node_type": "FunctionDef",
  "lineno": 952,
  "col": 4,
  "end_lineno": 1003,
  "end_col": 22,
  "parent_qualname": "SpladeArtifactsManager",
  "decorators": [],
  "bases": [],
  "docstring": "Export SPLADE ONNX artifacts and record metadata.\n\nParameters\n----------\noptions : SpladeExportOptions | None, optional\n    Overrides for model identifier, provider, and export behaviour.\n\nReturns\n-------\nSpladeExportSummary\n    Summary describing the exported artifact and metadata path.",
  "is_public": true
}
{
  "path": "io/splade_manager.py",
  "module": "io.splade_manager",
  "qualname": "SpladeEncoderService",
  "name": "SpladeEncoderService",
  "node_type": "ClassDef",
  "lineno": 1006,
  "col": 0,
  "end_lineno": 1284,
  "end_col": 22,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Encode corpora into SPLADE JsonVectorCollection shards.",
  "is_public": true
}
{
  "path": "io/splade_manager.py",
  "module": "io.splade_manager",
  "qualname": "SpladeEncoderService.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 1009,
  "col": 4,
  "end_lineno": 1013,
  "end_col": 38,
  "parent_qualname": "SpladeEncoderService",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/splade_manager.py",
  "module": "io.splade_manager",
  "qualname": "SpladeEncoderService.vectors_dir",
  "name": "vectors_dir",
  "node_type": "FunctionDef",
  "lineno": 1016,
  "col": 4,
  "end_lineno": 1024,
  "end_col": 77,
  "parent_qualname": "SpladeEncoderService",
  "decorators": [
    "property"
  ],
  "bases": [],
  "docstring": "Return the directory that stores SPLADE JsonVectorCollection shards.\n\nReturns\n-------\nPath\n    Absolute path to the configured vectors directory.",
  "is_public": true
}
{
  "path": "io/splade_manager.py",
  "module": "io.splade_manager",
  "qualname": "SpladeEncoderService._resolve_vectors_dir",
  "name": "_resolve_vectors_dir",
  "node_type": "FunctionDef",
  "lineno": 1026,
  "col": 4,
  "end_lineno": 1054,
  "end_col": 23,
  "parent_qualname": "SpladeEncoderService",
  "decorators": [],
  "bases": [],
  "docstring": "Resolve the vectors directory override or fall back to the configured path.\n\nThis method resolves the output directory for encoded vectors, either\nusing an explicit override path or falling back to the configured default.\nThe directory is created if it doesn't exist, ensuring it's ready for\nwriting shard files.\n\nParameters\n----------\noverride : str | Path | None, optional\n    Optional override path for the vectors directory. If provided, this\n    path is resolved relative to the repository root and used instead of\n    the configured default. If None, uses the configured vectors_dir\n    from settings. Defaults to None.\n\nReturns\n-------\nPath\n    Absolute path to the directory where encoded vectors will be written.\n    The directory is guaranteed to exist (created if necessary). The path\n    is resolved relative to the repository root and normalized.",
  "is_public": false
}
{
  "path": "io/splade_manager.py",
  "module": "io.splade_manager",
  "qualname": "SpladeEncoderService._initialise_encoder",
  "name": "_initialise_encoder",
  "node_type": "FunctionDef",
  "lineno": 1056,
  "col": 4,
  "end_lineno": 1122,
  "end_col": 82,
  "parent_qualname": "SpladeEncoderService",
  "decorators": [],
  "bases": [],
  "docstring": "Instantiate a SparseEncoder and return the resolved ONNX artifact (if any).\n\nThis method initializes a SPLADE sparse encoder instance, searching for\nONNX model files in a priority order: explicit onnx_file parameter,\nconfigured default ONNX file, or falls back to PyTorch model if no ONNX\nfile is found. The encoder is configured with the specified provider\n(CPU, CUDA, etc.) for inference.\n\nThe method searches multiple candidate paths to find an available ONNX\nmodel, preferring explicitly specified files over defaults. If an ONNX\nfile is found, it's used for faster inference. Otherwise, the encoder\nfalls back to the PyTorch model.\n\nParameters\n----------\nprovider : str\n    ONNX runtime provider to use for inference (e.g., \"cpu\", \"cuda\",\n    \"tensorrt\"). The provider determines which hardware/backend is used\n    for model execution. Must be a valid provider name supported by the\n    ONNX runtime.\nonnx_file : str | None, optional\n    Optional explicit ONNX filename to use. If provided, this file is\n    searched first in the ONNX directory. If not found or None, falls\n    back to the configured default ONNX filename. Defaults to None.\n\nReturns\n-------\ntuple[_SparseEncoderProtocol, str | None]\n    Tuple containing:\n    - Encoder instance ready for encoding operations. The encoder is\n      configured with the found ONNX model (if available) or PyTorch\n      model, using the specified provider.\n    - Relative path to the ONNX file used (relative to model_dir), or\n      None if no ONNX file was found and PyTorch model was used instead.\n      This path can be stored in metadata for reproducibility.",
  "is_public": false
}
{
  "path": "io/splade_manager.py",
  "module": "io.splade_manager",
  "qualname": "SpladeEncoderService._build_encoder",
  "name": "_build_encoder",
  "node_type": "FunctionDef",
  "lineno": 1124,
  "col": 4,
  "end_lineno": 1126,
  "end_col": 22,
  "parent_qualname": "SpladeEncoderService",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/splade_manager.py",
  "module": "io.splade_manager",
  "qualname": "SpladeEncoderService.encode_corpus",
  "name": "encode_corpus",
  "node_type": "FunctionDef",
  "lineno": 1128,
  "col": 4,
  "end_lineno": 1199,
  "end_col": 22,
  "parent_qualname": "SpladeEncoderService",
  "decorators": [],
  "bases": [],
  "docstring": "Encode ``source`` JSONL into SPLADE JsonVectorCollection shards.\n\nParameters\n----------\nsource : str | Path\n    Path to the JSONL corpus containing ``id`` and ``contents``/``text`` fields.\noptions : SpladeEncodeOptions | None, optional\n    Overrides for output directory, batch size, quantization, provider, and ONNX file.\n\nReturns\n-------\nSpladeEncodingSummary\n    Summary including document count, vectors directory, metadata path, and shard count.\n\nRaises\n------\nTypeError\n    If corpus entries are missing identifiers or textual content.",
  "is_public": true
}
{
  "path": "io/splade_manager.py",
  "module": "io.splade_manager",
  "qualname": "SpladeEncoderService.benchmark_queries",
  "name": "benchmark_queries",
  "node_type": "FunctionDef",
  "lineno": 1201,
  "col": 4,
  "end_lineno": 1284,
  "end_col": 22,
  "parent_qualname": "SpladeEncoderService",
  "decorators": [],
  "bases": [],
  "docstring": "Benchmark SPLADE query encoding latency.\n\nParameters\n----------\nqueries : Sequence[str]\n    One or more query strings to encode during the benchmark.\noptions : SpladeBenchmarkOptions | None, optional\n    Benchmark configuration overrides. Defaults to :class:`SpladeBenchmarkOptions`.\n\nReturns\n-------\nSpladeBenchmarkSummary\n    Latency statistics captured across the measured iterations.\n\nRaises\n------\nValueError\n    Raised when the query list is empty or the benchmark configuration is invalid.",
  "is_public": true
}
{
  "path": "io/splade_manager.py",
  "module": "io.splade_manager",
  "qualname": "SpladeIndexManager",
  "name": "SpladeIndexManager",
  "node_type": "ClassDef",
  "lineno": 1287,
  "col": 0,
  "end_lineno": 1422,
  "end_col": 29,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Build SPLADE Lucene impact indexes from vector collections.",
  "is_public": true
}
{
  "path": "io/splade_manager.py",
  "module": "io.splade_manager",
  "qualname": "SpladeIndexManager.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 1290,
  "col": 4,
  "end_lineno": 1294,
  "end_col": 38,
  "parent_qualname": "SpladeIndexManager",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/splade_manager.py",
  "module": "io.splade_manager",
  "qualname": "SpladeIndexManager.vectors_dir",
  "name": "vectors_dir",
  "node_type": "FunctionDef",
  "lineno": 1297,
  "col": 4,
  "end_lineno": 1305,
  "end_col": 77,
  "parent_qualname": "SpladeIndexManager",
  "decorators": [
    "property"
  ],
  "bases": [],
  "docstring": "Return the configured JsonVectorCollection directory.\n\nReturns\n-------\nPath\n    Absolute path to the JsonVectorCollection directory used for indexing.",
  "is_public": true
}
{
  "path": "io/splade_manager.py",
  "module": "io.splade_manager",
  "qualname": "SpladeIndexManager.index_dir",
  "name": "index_dir",
  "node_type": "FunctionDef",
  "lineno": 1308,
  "col": 4,
  "end_lineno": 1316,
  "end_col": 75,
  "parent_qualname": "SpladeIndexManager",
  "decorators": [
    "property"
  ],
  "bases": [],
  "docstring": "Return the configured Lucene impact index directory.\n\nReturns\n-------\nPath\n    Absolute path to the Lucene impact index output directory.",
  "is_public": true
}
{
  "path": "io/splade_manager.py",
  "module": "io.splade_manager",
  "qualname": "SpladeIndexManager.build_index",
  "name": "build_index",
  "node_type": "FunctionDef",
  "lineno": 1318,
  "col": 4,
  "end_lineno": 1422,
  "end_col": 29,
  "parent_qualname": "SpladeIndexManager",
  "decorators": [],
  "bases": [],
  "docstring": "Invoke Pyserini to build a SPLADE Lucene impact index.\n\nParameters\n----------\noptions : SpladeBuildOptions | None, optional\n    Overrides for vectors/index directories, thread count, clause limit, and overwrite.\n\nReturns\n-------\nSpladeIndexMetadata\n    Metadata describing the resulting Lucene impact index.\n\nRaises\n------\nFileExistsError\n    If the index directory already exists and ``overwrite`` is ``False``.",
  "is_public": true
}
{
  "path": "io/symbol_catalog.py",
  "module": "io.symbol_catalog",
  "qualname": "io.symbol_catalog",
  "name": "io.symbol_catalog",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "DuckDB symbol catalog writer.",
  "is_public": true
}
{
  "path": "io/symbol_catalog.py",
  "module": "io.symbol_catalog",
  "qualname": "SymbolDefRow",
  "name": "SymbolDefRow",
  "node_type": "ClassDef",
  "lineno": 12,
  "col": 0,
  "end_lineno": 26,
  "end_col": 32,
  "parent_qualname": null,
  "decorators": [
    "dataclass(frozen=True)"
  ],
  "bases": [],
  "docstring": "Immutable row describing a symbol definition.",
  "is_public": true
}
{
  "path": "io/symbol_catalog.py",
  "module": "io.symbol_catalog",
  "qualname": "SymbolOccurrenceRow",
  "name": "SymbolOccurrenceRow",
  "node_type": "ClassDef",
  "lineno": 30,
  "col": 0,
  "end_lineno": 42,
  "end_col": 17,
  "parent_qualname": null,
  "decorators": [
    "dataclass(frozen=True)"
  ],
  "bases": [],
  "docstring": "Service row for individual symbol occurrences.",
  "is_public": true
}
{
  "path": "io/symbol_catalog.py",
  "module": "io.symbol_catalog",
  "qualname": "SymbolCatalog",
  "name": "SymbolCatalog",
  "node_type": "ClassDef",
  "lineno": 45,
  "col": 0,
  "end_lineno": 240,
  "end_col": 9,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Writer for symbol metadata tables alongside `chunks`.",
  "is_public": true
}
{
  "path": "io/symbol_catalog.py",
  "module": "io.symbol_catalog",
  "qualname": "SymbolCatalog.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 48,
  "col": 4,
  "end_lineno": 49,
  "end_col": 31,
  "parent_qualname": "SymbolCatalog",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/symbol_catalog.py",
  "module": "io.symbol_catalog",
  "qualname": "SymbolCatalog.ensure_schema",
  "name": "ensure_schema",
  "node_type": "FunctionDef",
  "lineno": 51,
  "col": 4,
  "end_lineno": 123,
  "end_col": 13,
  "parent_qualname": "SymbolCatalog",
  "decorators": [],
  "bases": [],
  "docstring": "Ensure symbol tables and indexes exist in DuckDB.",
  "is_public": true
}
{
  "path": "io/symbol_catalog.py",
  "module": "io.symbol_catalog",
  "qualname": "SymbolCatalog.upsert_symbol_defs",
  "name": "upsert_symbol_defs",
  "node_type": "FunctionDef",
  "lineno": 125,
  "col": 4,
  "end_lineno": 166,
  "end_col": 13,
  "parent_qualname": "SymbolCatalog",
  "decorators": [],
  "bases": [],
  "docstring": "Insert or replace symbol definitions in bulk.",
  "is_public": true
}
{
  "path": "io/symbol_catalog.py",
  "module": "io.symbol_catalog",
  "qualname": "SymbolCatalog.bulk_insert_occurrences",
  "name": "bulk_insert_occurrences",
  "node_type": "FunctionDef",
  "lineno": 168,
  "col": 4,
  "end_lineno": 174,
  "end_col": 82,
  "parent_qualname": "SymbolCatalog",
  "decorators": [],
  "bases": [],
  "docstring": "Bulk load symbol occurrences.",
  "is_public": true
}
{
  "path": "io/symbol_catalog.py",
  "module": "io.symbol_catalog",
  "qualname": "SymbolCatalog.bulk_insert_chunk_symbols",
  "name": "bulk_insert_chunk_symbols",
  "node_type": "FunctionDef",
  "lineno": 176,
  "col": 4,
  "end_lineno": 186,
  "end_col": 78,
  "parent_qualname": "SymbolCatalog",
  "decorators": [],
  "bases": [],
  "docstring": "Associate chunks with the symbols they contain.",
  "is_public": true
}
{
  "path": "io/symbol_catalog.py",
  "module": "io.symbol_catalog",
  "qualname": "SymbolCatalog.fetch_symbol_defs",
  "name": "fetch_symbol_defs",
  "node_type": "FunctionDef",
  "lineno": 188,
  "col": 4,
  "end_lineno": 240,
  "end_col": 9,
  "parent_qualname": "SymbolCatalog",
  "decorators": [],
  "bases": [],
  "docstring": "Return symbol definitions with stable chunk identifiers.\n\nParameters\n----------\nlimit : int | None, optional\n    Optional upper bound on the number of rows returned.\nkinds : Sequence[str] | None, optional\n    When provided, restricts returned rows to the specified symbol kinds.\n\nReturns\n-------\nlist[SymbolDefRow]\n    Materialized symbol definition rows ordered by symbol identifier.",
  "is_public": true
}
{
  "path": "io/vllm_client.py",
  "module": "io.vllm_client",
  "qualname": "io.vllm_client",
  "name": "io.vllm_client",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "vLLM embedding client using msgspec for fast serialization.\n\nOpenAI-compatible /v1/embeddings endpoint with batching support.",
  "is_public": true
}
{
  "path": "io/vllm_client.py",
  "module": "io.vllm_client",
  "qualname": "_get_numpy",
  "name": "_get_numpy",
  "node_type": "FunctionDef",
  "lineno": 42,
  "col": 0,
  "end_lineno": 75,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [
    "lru_cache(maxsize=1)"
  ],
  "bases": [],
  "docstring": "Load numpy lazily when embeddings are computed.\n\nExtended Summary\n----------------\nThis function provides lazy import of the NumPy module for embedding operations\nin VLLMClient. It uses LRU caching to ensure the module is imported only once\nper process, reducing import overhead. The function gates the import using\n``gate_import`` to prevent eager loading of NumPy when it's not needed, which\nis important for keeping the codebase lightweight and avoiding unnecessary\ndependencies in environments where NumPy may not be available.\n\nReturns\n-------\nModuleType\n    The lazily imported NumPy module. The return type is ``ModuleType`` to\n    match the runtime type, but the actual value is the ``numpy`` module\n    (cast from the gate_import result).\n\nNotes\n-----\nTime complexity O(1) after first call (cached); O(n) on first call where n\nis import overhead. Space complexity O(1) - single module reference cached.\nThe function performs module import I/O on first call only. Thread-safe due\nto lru_cache implementation. Uses ``gate_import`` to ensure proper typing\nfacade compliance and prevent eager NumPy loading.",
  "is_public": false
}
{
  "path": "io/vllm_client.py",
  "module": "io.vllm_client",
  "qualname": "EmbeddingRequest",
  "name": "EmbeddingRequest",
  "node_type": "ClassDef",
  "lineno": 78,
  "col": 0,
  "end_lineno": 103,
  "end_col": 14,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "msgspec.Struct"
  ],
  "docstring": "OpenAI-compatible embedding request payload.\n\nRequest structure for the vLLM /v1/embeddings endpoint, matching the OpenAI\nAPI format. This allows vLLM to be used as a drop-in replacement for OpenAI's\nembedding API.\n\nThe request can embed a single text (str) or a batch of texts (list[str]).\nBatch requests are more efficient as they're processed in parallel by the\nmodel.\n\nAttributes\n----------\ninput : str | list[str]\n    Text(s) to embed. Can be a single string for one embedding, or a list\n    of strings for batch embedding. Batch processing is more efficient.\n    Each text should be a code chunk or query string.\nmodel : str\n    Model identifier string. Must match a model loaded by the vLLM server.\n    Defaults to \"nomic-ai/nomic-embed-code\" which is a code-specific\n    embedding model with 2560 dimensions. The embedding dimensionality is\n    surfaced via :class:`codeintel_rev.config.settings.VLLMConfig` ``embedding_dim``.",
  "is_public": true
}
{
  "path": "io/vllm_client.py",
  "module": "io.vllm_client",
  "qualname": "EmbeddingData",
  "name": "EmbeddingData",
  "node_type": "ClassDef",
  "lineno": 106,
  "col": 0,
  "end_lineno": 128,
  "end_col": 14,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "msgspec.Struct"
  ],
  "docstring": "Single embedding result from a batch request.\n\nRepresents one embedding vector from a batch embedding request. Each text\nin the input batch produces one EmbeddingData object. The index field\nindicates the position in the original batch, which is important because\nvLLM may return results in a different order than the input.\n\nAttributes\n----------\nembedding : list[float]\n    Embedding vector as a list of floats. The length matches the model's\n    dimension (e.g., 2560 for nomic-embed-code). Values are typically\n    normalized for cosine similarity. The expected size is available as\n    ``VLLMConfig.embedding_dim``.\nindex : int\n    Zero-based index indicating the position of this embedding in the\n    original input batch. Used to match embeddings back to their input\n    texts when results may be reordered.",
  "is_public": true
}
{
  "path": "io/vllm_client.py",
  "module": "io.vllm_client",
  "qualname": "EmbeddingResponse",
  "name": "EmbeddingResponse",
  "node_type": "ClassDef",
  "lineno": 131,
  "col": 0,
  "end_lineno": 159,
  "end_col": 15,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "msgspec.Struct"
  ],
  "docstring": "OpenAI-compatible embedding response payload.\n\nResponse structure from the vLLM /v1/embeddings endpoint, matching the OpenAI\nAPI format. Contains the embedding vectors along with metadata about the\nrequest and model usage.\n\nThe data field contains one EmbeddingData per input text. Results may be\nreturned in a different order than the input, so use the index field to\nmatch embeddings to their original texts.\n\nAttributes\n----------\ndata : list[EmbeddingData]\n    List of embedding results, one per input text. The list length matches\n    the number of texts in the request. Each EmbeddingData contains the\n    vector and its index in the original batch.\nmodel : str\n    Model identifier that was used to generate the embeddings. Should match\n    the model field from the request. Useful for verification and logging.\nusage : dict\n    Token usage statistics dictionary. Typically contains keys like \"prompt_tokens\"\n    and \"total_tokens\" indicating how many tokens were processed. Useful for\n    monitoring and cost tracking.",
  "is_public": true
}
{
  "path": "io/vllm_client.py",
  "module": "io.vllm_client",
  "qualname": "VLLMClient",
  "name": "VLLMClient",
  "node_type": "ClassDef",
  "lineno": 162,
  "col": 0,
  "end_lineno": 648,
  "end_col": 27,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "vLLM embedding client supporting HTTP or in-process execution.\n\nMaintains a persistent HTTP client for connection reuse across embedding\nbatches. This reduces latency by eliminating TCP handshake overhead and\nenables HTTP/1.1 keep-alive for better performance.\n\nThe client is created during initialization and reused for all embed_batch\ncalls. Connection pooling is configured with limits to prevent server\noverload. The client must be closed during application shutdown via the\nclose() method to avoid resource leaks.\n\nParameters\n----------\nconfig : VLLMConfig\n    vLLM configuration including base URL, timeout, and model name.\n\nExamples\n--------\nCreate client and embed batch:\n\n>>> from codeintel_rev.config.settings import VLLMConfig\n>>> config = VLLMConfig(base_url=\"http://localhost:8000\", model=\"test-model\")\n>>> client = VLLMClient(config)\n>>> vectors = client.embed_batch([\"def hello(): pass\", \"def world(): pass\"])\n>>> vectors.shape\n(2, 2560)\n\nCleanup during shutdown:\n\n>>> client.close()  # Must be called to close HTTP connections\n\nNotes\n-----\nConnection pool limits:\n- max_connections=100: Maximum total connections in pool\n- max_keepalive_connections=20: Maximum connections kept alive for reuse\n\nThese limits prevent overwhelming the vLLM server while allowing efficient\nconnection reuse for high-throughput embedding workloads.\n\nInternal attributes (not part of public API):\n- ``config``: vLLM configuration\n- ``_client``: Persistent HTTP client with connection pooling. Created during\n  initialization and reused across all requests\n- ``_async_client``: Optional async HTTP client for concurrent embedding generation.\n  Lazy-initialized on first call to embed_batch_async\n- ``_encoder``: Fast JSON encoder for request serialization\n- ``_decoder``: Fast JSON decoder for response deserialization",
  "is_public": true
}
{
  "path": "io/vllm_client.py",
  "module": "io.vllm_client",
  "qualname": "VLLMClient.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 213,
  "col": 4,
  "end_lineno": 226,
  "end_col": 42,
  "parent_qualname": "VLLMClient",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/vllm_client.py",
  "module": "io.vllm_client",
  "qualname": "VLLMClient._initialize_local_engine",
  "name": "_initialize_local_engine",
  "node_type": "FunctionDef",
  "lineno": 228,
  "col": 4,
  "end_lineno": 235,
  "end_col": 9,
  "parent_qualname": "VLLMClient",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/vllm_client.py",
  "module": "io.vllm_client",
  "qualname": "VLLMClient._initialize_http_client",
  "name": "_initialize_http_client",
  "node_type": "FunctionDef",
  "lineno": 237,
  "col": 4,
  "end_lineno": 254,
  "end_col": 9,
  "parent_qualname": "VLLMClient",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/vllm_client.py",
  "module": "io.vllm_client",
  "qualname": "VLLMClient.embed_batch",
  "name": "embed_batch",
  "node_type": "FunctionDef",
  "lineno": 256,
  "col": 4,
  "end_lineno": 378,
  "end_col": 22,
  "parent_qualname": "VLLMClient",
  "decorators": [],
  "bases": [],
  "docstring": "Embed texts using the configured transport (HTTP or local).\n\nExtended Summary\n----------------\nThis method generates dense vector embeddings for a batch of text strings using\nthe configured vLLM service. It supports both HTTP-based remote embedding (when\nvLLM runs as a separate service) and in-process embedding (when vLLM is loaded\nlocally). The method automatically selects the appropriate transport based on\nthe client configuration and handles empty input batches gracefully. This is the\nprimary entry point for generating embeddings in Stage-0 retrieval pipelines.\n\nParameters\n----------\ntexts : Sequence[str]\n    Ordered sequence of text strings to embed. Empty sequences result in an\n    empty embedding matrix. Each text will be tokenized and encoded by the\n    vLLM model to produce a dense vector representation.\n\nReturns\n-------\nNDArrayF32\n    Embedding matrix with shape (N, embedding_dim) where N is len(texts) and\n    embedding_dim matches the configured model's output dimensionality. Dtype is\n    float32. Each row corresponds to the embedding of the corresponding input text.\n\nRaises\n------\nException\n    Exceptions from the embedding operation are caught and re-raised unchanged.\n    Common exceptions include network errors (HTTP mode), model loading errors\n    (local mode), timeout errors, and encoding/decoding errors. Transport\n    exceptions from HTTPX or the in-process engine propagate unchanged so callers\n    can apply their own retry or problem-details handling.\n\nNotes\n-----\nTime complexity O(N * T) where N is batch size and T is average token count per\ntext, plus network latency for HTTP mode. Space complexity O(N * embedding_dim)\nfor the result matrix. The method performs network I/O in HTTP mode or GPU\ncomputation in local mode. Thread-safe if the underlying HTTP client or local\nengine is thread-safe. Empty batches return shape (0, embedding_dim).",
  "is_public": true
}
{
  "path": "io/vllm_client.py",
  "module": "io.vllm_client",
  "qualname": "VLLMClient._embed_batch_http",
  "name": "_embed_batch_http",
  "node_type": "FunctionDef",
  "lineno": 380,
  "col": 4,
  "end_lineno": 405,
  "end_col": 9,
  "parent_qualname": "VLLMClient",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/vllm_client.py",
  "module": "io.vllm_client",
  "qualname": "VLLMClient.embed_single",
  "name": "embed_single",
  "node_type": "FunctionDef",
  "lineno": 407,
  "col": 4,
  "end_lineno": 429,
  "end_col": 25,
  "parent_qualname": "VLLMClient",
  "decorators": [],
  "bases": [],
  "docstring": "Embed a single string and return its vector.\n\nParameters\n----------\ntext : str\n    Text to embed.\n\nReturns\n-------\nNDArrayF32\n    One-dimensional embedding vector for the supplied text.\n\nRaises\n------\nRuntimeError\n    If the embedding service returns an empty response.",
  "is_public": true
}
{
  "path": "io/vllm_client.py",
  "module": "io.vllm_client",
  "qualname": "VLLMClient.embed_chunks",
  "name": "embed_chunks",
  "node_type": "FunctionDef",
  "lineno": 431,
  "col": 4,
  "end_lineno": 482,
  "end_col": 44,
  "parent_qualname": "VLLMClient",
  "decorators": [],
  "bases": [],
  "docstring": "Embed texts in batches.\n\nThis method processes multiple texts efficiently by splitting them into\nbatches and sending each batch to the vLLM embedding service. Batching\nimproves throughput by amortizing HTTP request overhead and allowing\nthe service to process multiple texts in parallel.\n\nThe method handles empty input gracefully, returning an empty array with\nthe correct shape. Batch size can be customized per call or defaults to\nthe client's configured batch size. Results are concatenated into a single\narray maintaining the input order.\n\nParameters\n----------\ntexts : Sequence[str]\n    Sequence of texts to embed. Can be any sequence type (list, tuple, etc.).\n    Each text should be a code chunk or query string suitable for the\n    embedding model. Empty sequence returns empty array.\nbatch_size : int | None, optional\n    Number of texts to process per batch. If None, uses the client's\n    configured batch_size from config. Larger batches improve throughput\n    but increase memory usage. Defaults to None (use config.batch_size).\n\nReturns\n-------\nNDArrayF32\n    Embeddings array of shape (len(texts), vec_dim) where vec_dim is the\n    model's embedding dimension (e.g., 2560). Dtype is float32 for memory\n    efficiency. Returns an empty array of shape (0, self.config.embedding_dim)\n    when texts is empty. The order matches the input texts.",
  "is_public": true
}
{
  "path": "io/vllm_client.py",
  "module": "io.vllm_client",
  "qualname": "VLLMClient.embed_batch_async",
  "name": "embed_batch_async",
  "node_type": "AsyncFunctionDef",
  "lineno": 484,
  "col": 4,
  "end_lineno": 576,
  "end_col": 22,
  "parent_qualname": "VLLMClient",
  "decorators": [],
  "bases": [],
  "docstring": "Asynchronous variant of embed_batch for async/await workflows.\n\nExtended Summary\n----------------\nThis method provides an asynchronous interface for generating dense vector\nembeddings, enabling non-blocking embedding generation in async contexts.\nIt supports both HTTP-based remote embedding (via async HTTP client) and\nin-process embedding (via async local engine wrapper). The method handles\nempty input batches gracefully and provides the same functionality as\nembed_batch but with async/await semantics for use in async event loops.\n\nParameters\n----------\ntexts : Sequence[str]\n    Ordered sequence of text strings to embed. Empty sequences result in an\n    empty embedding matrix. Each text will be tokenized and encoded by the\n    vLLM model to produce a dense vector representation.\n\nReturns\n-------\nNDArrayF32\n    Embedding matrix with shape (N, embedding_dim) where N is len(texts) and\n    embedding_dim matches the configured model's output dimensionality. Dtype is\n    float32. Each row corresponds to the embedding of the corresponding input text.\n\nNotes\n-----\nTime complexity O(N * T) where N is batch size and T is average token count per\ntext, plus network latency for HTTP mode. Space complexity O(N * embedding_dim)\nfor the result matrix. The method performs async network I/O in HTTP mode or\nasync GPU computation in local mode. Thread-safe if the underlying async HTTP\nclient or local engine is thread-safe. Empty batches return shape (0, embedding_dim).",
  "is_public": true
}
{
  "path": "io/vllm_client.py",
  "module": "io.vllm_client",
  "qualname": "VLLMClient.close",
  "name": "close",
  "node_type": "FunctionDef",
  "lineno": 578,
  "col": 4,
  "end_lineno": 600,
  "end_col": 51,
  "parent_qualname": "VLLMClient",
  "decorators": [],
  "bases": [],
  "docstring": "Close HTTP clients, async clients, and the local engine.",
  "is_public": true
}
{
  "path": "io/vllm_client.py",
  "module": "io.vllm_client",
  "qualname": "VLLMClient.aclose",
  "name": "aclose",
  "node_type": "AsyncFunctionDef",
  "lineno": 602,
  "col": 4,
  "end_lineno": 613,
  "end_col": 59,
  "parent_qualname": "VLLMClient",
  "decorators": [],
  "bases": [],
  "docstring": "Asynchronously release all clients/engines.",
  "is_public": true
}
{
  "path": "io/vllm_client.py",
  "module": "io.vllm_client",
  "qualname": "VLLMClient._embed_batch_async_local",
  "name": "_embed_batch_async_local",
  "node_type": "AsyncFunctionDef",
  "lineno": 615,
  "col": 4,
  "end_lineno": 624,
  "end_col": 96,
  "parent_qualname": "VLLMClient",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/vllm_client.py",
  "module": "io.vllm_client",
  "qualname": "VLLMClient._ensure_async_http_client",
  "name": "_ensure_async_http_client",
  "node_type": "FunctionDef",
  "lineno": 626,
  "col": 4,
  "end_lineno": 642,
  "end_col": 33,
  "parent_qualname": "VLLMClient",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/vllm_client.py",
  "module": "io.vllm_client",
  "qualname": "VLLMClient._require_http_client",
  "name": "_require_http_client",
  "node_type": "FunctionDef",
  "lineno": 644,
  "col": 4,
  "end_lineno": 648,
  "end_col": 27,
  "parent_qualname": "VLLMClient",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/vllm_engine.py",
  "module": "io.vllm_engine",
  "qualname": "io.vllm_engine",
  "name": "io.vllm_engine",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "In-process vLLM embedding engine for Stage-0 retrieval.",
  "is_public": true
}
{
  "path": "io/vllm_engine.py",
  "module": "io.vllm_engine",
  "qualname": "_InprocessVLLMRuntime",
  "name": "_InprocessVLLMRuntime",
  "node_type": "ClassDef",
  "lineno": 37,
  "col": 0,
  "end_lineno": 56,
  "end_col": 29,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Mutable runtime backing the frozen embedder.",
  "is_public": false
}
{
  "path": "io/vllm_engine.py",
  "module": "io.vllm_engine",
  "qualname": "_InprocessVLLMRuntime.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 42,
  "col": 4,
  "end_lineno": 44,
  "end_col": 38,
  "parent_qualname": "_InprocessVLLMRuntime",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/vllm_engine.py",
  "module": "io.vllm_engine",
  "qualname": "_InprocessVLLMRuntime.close",
  "name": "close",
  "node_type": "FunctionDef",
  "lineno": 46,
  "col": 4,
  "end_lineno": 56,
  "end_col": 29,
  "parent_qualname": "_InprocessVLLMRuntime",
  "decorators": [],
  "bases": [],
  "docstring": "Release tokenizer/engine references.",
  "is_public": true
}
{
  "path": "io/vllm_engine.py",
  "module": "io.vllm_engine",
  "qualname": "InprocessVLLMEmbedder",
  "name": "InprocessVLLMEmbedder",
  "node_type": "ClassDef",
  "lineno": 60,
  "col": 0,
  "end_lineno": 240,
  "end_col": 22,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Embed text batches locally using vLLM.\n\nExtended Summary\n----------------\nThis embedder provides in-process embedding generation using vLLM, enabling\nhigh-throughput batch embedding without HTTP overhead. It initializes a local\nvLLM engine with the specified model and pooling configuration, tokenizes input\ntexts, and generates embeddings via vLLM's embedding API. The embedder is used\nin Stage-0 retrieval pipelines when vLLM is available and in-process mode is\npreferred over HTTP-based embedding services.\n\nAttributes\n----------\nconfig : VLLMConfig\n    Fully populated vLLM configuration. The ``run.mode`` field must be\n    ``\"inprocess\"`` to avoid HTTP calls. Contains model path, pooling type,\n    normalization settings, and GPU memory configuration.\n\nExamples\n--------\n>>> from codeintel_rev.config.settings import VLLMConfig, VLLMRunMode\n>>> cfg = VLLMConfig(run=VLLMRunMode(mode=\"inprocess\"))\n>>> embedder = InprocessVLLMEmbedder(cfg)\n>>> vecs = embedder.embed_batch([\"hello world\"])\n>>> vecs.shape[0]\n1",
  "is_public": true
}
{
  "path": "io/vllm_engine.py",
  "module": "io.vllm_engine",
  "qualname": "InprocessVLLMEmbedder.__post_init__",
  "name": "__post_init__",
  "node_type": "FunctionDef",
  "lineno": 96,
  "col": 4,
  "end_lineno": 106,
  "end_col": 9,
  "parent_qualname": "InprocessVLLMEmbedder",
  "decorators": [],
  "bases": [],
  "docstring": "Initialize tokenizer and vLLM engine.",
  "is_public": false
}
{
  "path": "io/vllm_engine.py",
  "module": "io.vllm_engine",
  "qualname": "InprocessVLLMEmbedder.embed_batch",
  "name": "embed_batch",
  "node_type": "FunctionDef",
  "lineno": 108,
  "col": 4,
  "end_lineno": 134,
  "end_col": 22,
  "parent_qualname": "InprocessVLLMEmbedder",
  "decorators": [],
  "bases": [],
  "docstring": "Return embeddings for ``texts`` (shape ``[N, dim]``).\n\nThis method generates embeddings for a batch of text inputs using the\nconfigured vLLM embedding model. It delegates to embed_batch_with_stats()\nand returns only the embedding vectors, discarding token count statistics.\nThe embeddings are normalized if configured and ready for similarity\ncomputation or storage.\n\nParameters\n----------\ntexts : Sequence[str]\n    Sequence of text strings to embed. Each string is tokenized and passed\n    through the vLLM embedding model to generate a dense vector representation.\n    The batch is processed efficiently using vLLM's batched inference.\n\nReturns\n-------\nNDArrayF32\n    Embedding matrix with shape `(N, dim)` where N is the number of input\n    texts and dim is the embedding dimension (model-dependent). Dtype is\n    float32. Embeddings are normalized if the normalize configuration is\n    enabled, otherwise raw model outputs. The matrix is ready for similarity\n    computation, storage, or indexing operations.",
  "is_public": true
}
{
  "path": "io/vllm_engine.py",
  "module": "io.vllm_engine",
  "qualname": "InprocessVLLMEmbedder.embed_batch_with_stats",
  "name": "embed_batch_with_stats",
  "node_type": "FunctionDef",
  "lineno": 136,
  "col": 4,
  "end_lineno": 192,
  "end_col": 36,
  "parent_qualname": "InprocessVLLMEmbedder",
  "decorators": [],
  "bases": [],
  "docstring": "Return embeddings and total token count for ``texts``.\n\nParameters\n----------\ntexts : Sequence[str]\n    Ordered text payload to embed.\n\nReturns\n-------\ntuple[NDArrayF32, int]\n    Tuple containing the embedding matrix and the total prompt token count.\n\nRaises\n------\nRuntimeError\n    If the vLLM runtime failed to initialize.",
  "is_public": true
}
{
  "path": "io/vllm_engine.py",
  "module": "io.vllm_engine",
  "qualname": "InprocessVLLMEmbedder.close",
  "name": "close",
  "node_type": "FunctionDef",
  "lineno": 194,
  "col": 4,
  "end_lineno": 196,
  "end_col": 26,
  "parent_qualname": "InprocessVLLMEmbedder",
  "decorators": [],
  "bases": [],
  "docstring": "Release tokenizer/engine references to help GC.",
  "is_public": true
}
{
  "path": "io/vllm_engine.py",
  "module": "io.vllm_engine",
  "qualname": "InprocessVLLMEmbedder._load_tokenizer",
  "name": "_load_tokenizer",
  "node_type": "FunctionDef",
  "lineno": 198,
  "col": 4,
  "end_lineno": 203,
  "end_col": 9,
  "parent_qualname": "InprocessVLLMEmbedder",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/vllm_engine.py",
  "module": "io.vllm_engine",
  "qualname": "InprocessVLLMEmbedder._load_engine",
  "name": "_load_engine",
  "node_type": "FunctionDef",
  "lineno": 205,
  "col": 4,
  "end_lineno": 219,
  "end_col": 9,
  "parent_qualname": "InprocessVLLMEmbedder",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/vllm_engine.py",
  "module": "io.vllm_engine",
  "qualname": "InprocessVLLMEmbedder._initialize_runtime",
  "name": "_initialize_runtime",
  "node_type": "FunctionDef",
  "lineno": 221,
  "col": 4,
  "end_lineno": 233,
  "end_col": 22,
  "parent_qualname": "InprocessVLLMEmbedder",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/vllm_engine.py",
  "module": "io.vllm_engine",
  "qualname": "InprocessVLLMEmbedder._runtime",
  "name": "_runtime",
  "node_type": "FunctionDef",
  "lineno": 235,
  "col": 4,
  "end_lineno": 240,
  "end_col": 22,
  "parent_qualname": "InprocessVLLMEmbedder",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/warp_engine.py",
  "module": "io.warp_engine",
  "qualname": "io.warp_engine",
  "name": "io.warp_engine",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Adapter for the optional WARP/XTR late interaction executor.",
  "is_public": true
}
{
  "path": "io/warp_engine.py",
  "module": "io.warp_engine",
  "qualname": "WarpExecutorProtocol",
  "name": "WarpExecutorProtocol",
  "node_type": "ClassDef",
  "lineno": 19,
  "col": 0,
  "end_lineno": 30,
  "end_col": 11,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "Protocol"
  ],
  "docstring": "Protocol describing the WARP executor search surface.",
  "is_public": true
}
{
  "path": "io/warp_engine.py",
  "module": "io.warp_engine",
  "qualname": "WarpExecutorProtocol.search",
  "name": "search",
  "node_type": "FunctionDef",
  "lineno": 22,
  "col": 4,
  "end_lineno": 30,
  "end_col": 11,
  "parent_qualname": "WarpExecutorProtocol",
  "decorators": [],
  "bases": [],
  "docstring": "Return ranked candidate tuples.",
  "is_public": true
}
{
  "path": "io/warp_engine.py",
  "module": "io.warp_engine",
  "qualname": "WarpUnavailableError",
  "name": "WarpUnavailableError",
  "node_type": "ClassDef",
  "lineno": 36,
  "col": 0,
  "end_lineno": 37,
  "end_col": 71,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "RuntimeError"
  ],
  "docstring": "Raised when the WARP executor or index artifacts are missing.",
  "is_public": true
}
{
  "path": "io/warp_engine.py",
  "module": "io.warp_engine",
  "qualname": "WarpEngine",
  "name": "WarpEngine",
  "node_type": "ClassDef",
  "lineno": 40,
  "col": 0,
  "end_lineno": 164,
  "end_col": 29,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Encapsulates interactions with the optional ``xtr-warp`` executor.",
  "is_public": true
}
{
  "path": "io/warp_engine.py",
  "module": "io.warp_engine",
  "qualname": "WarpEngine.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 43,
  "col": 4,
  "end_lineno": 50,
  "end_col": 58,
  "parent_qualname": "WarpEngine",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/warp_engine.py",
  "module": "io.warp_engine",
  "qualname": "WarpEngine.rerank",
  "name": "rerank",
  "node_type": "FunctionDef",
  "lineno": 52,
  "col": 4,
  "end_lineno": 108,
  "end_col": 25,
  "parent_qualname": "WarpEngine",
  "decorators": [],
  "bases": [],
  "docstring": "Return WARP scores for candidate document IDs.\n\nParameters\n----------\nquery : str\n    Natural language search query string.\ncandidate_ids : Sequence[int]\n    Sequence of document/chunk IDs to rerank using WARP late-interaction\n    scoring. These are typically top-k results from an initial retrieval stage.\ntop_k : int\n    Maximum number of results to return. Must be positive.\n\nReturns\n-------\nlist[tuple[int, float]]\n    List of (doc_id, score) tuples ranked by WARP scores in descending order.\n    Length is min(len(candidate_ids), top_k).\n\nRaises\n------\nWarpUnavailableError\n    If WARP executor is unavailable or search fails.",
  "is_public": true
}
{
  "path": "io/warp_engine.py",
  "module": "io.warp_engine",
  "qualname": "WarpEngine._load_executor_cls",
  "name": "_load_executor_cls",
  "node_type": "FunctionDef",
  "lineno": 110,
  "col": 4,
  "end_lineno": 128,
  "end_col": 56,
  "parent_qualname": "WarpEngine",
  "decorators": [],
  "bases": [],
  "docstring": "Import the WARP executor class via ``gate_import``.\n\nReturns\n-------\nWarpExecutorFactory\n    The WarpExecutor factory class from xtr_warp.executor module.\n\nRaises\n------\nWarpUnavailableError\n    If the WarpExecutor class is not found in the module.",
  "is_public": false
}
{
  "path": "io/warp_engine.py",
  "module": "io.warp_engine",
  "qualname": "WarpEngine._import_warp_executor_module",
  "name": "_import_warp_executor_module",
  "node_type": "FunctionDef",
  "lineno": 131,
  "col": 4,
  "end_lineno": 134,
  "end_col": 41,
  "parent_qualname": "WarpEngine",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/warp_engine.py",
  "module": "io.warp_engine",
  "qualname": "WarpEngine._ensure_executor",
  "name": "_ensure_executor",
  "node_type": "FunctionDef",
  "lineno": 136,
  "col": 4,
  "end_lineno": 164,
  "end_col": 29,
  "parent_qualname": "WarpEngine",
  "decorators": [],
  "bases": [],
  "docstring": "Ensure the WARP executor is initialized and return it.\n\nReturns\n-------\nWarpExecutorProtocol\n    The initialized WARP executor instance conforming to the protocol.\n\nRaises\n------\nWarpUnavailableError\n    If executor initialization fails.",
  "is_public": false
}
{
  "path": "io/warp_engine.py",
  "module": "io.warp_engine",
  "qualname": "_safe_int",
  "name": "_safe_int",
  "node_type": "FunctionDef",
  "lineno": 167,
  "col": 0,
  "end_lineno": 188,
  "end_col": 18,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Convert an object to int safely, falling back to the provided default.\n\nParameters\n----------\nvalue : object | None\n    Value to convert to int. Can be int, float, or str. If None or\n    conversion fails, returns default.\ndefault : int, optional\n    Fallback value returned if conversion fails. Defaults to 0.\n\nReturns\n-------\nint\n    Integer representation of value or the fallback default.",
  "is_public": false
}
{
  "path": "io/warp_engine.py",
  "module": "io.warp_engine",
  "qualname": "_safe_float",
  "name": "_safe_float",
  "node_type": "FunctionDef",
  "lineno": 191,
  "col": 0,
  "end_lineno": 212,
  "end_col": 18,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Convert an object to float safely, falling back to the provided default.\n\nParameters\n----------\nvalue : object | None\n    Value to convert to float. Can be int, float, or str. If None or\n    conversion fails, returns default.\ndefault : float, optional\n    Fallback value returned if conversion fails. Defaults to 0.0.\n\nReturns\n-------\nfloat\n    Float representation of value or the fallback default.",
  "is_public": false
}
{
  "path": "io/xtr_manager.py",
  "module": "io.xtr_manager",
  "qualname": "io.xtr_manager",
  "name": "io.xtr_manager",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Token-level XTR index manager with late-interaction scoring utilities.",
  "is_public": true
}
{
  "path": "io/xtr_manager.py",
  "module": "io.xtr_manager",
  "qualname": "XTRMetadata",
  "name": "XTRMetadata",
  "node_type": "ClassDef",
  "lineno": 29,
  "col": 0,
  "end_lineno": 38,
  "end_col": 22,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "TypedDict"
  ],
  "docstring": "Metadata persisted alongside the token memmap.",
  "is_public": true
}
{
  "path": "io/xtr_manager.py",
  "module": "io.xtr_manager",
  "qualname": "_XTRIndexRuntime",
  "name": "_XTRIndexRuntime",
  "node_type": "ClassDef",
  "lineno": 41,
  "col": 0,
  "end_lineno": 61,
  "end_col": 32,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Mutable runtime artifacts for XTRIndex.",
  "is_public": false
}
{
  "path": "io/xtr_manager.py",
  "module": "io.xtr_manager",
  "qualname": "_XTRIndexRuntime.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 46,
  "col": 4,
  "end_lineno": 52,
  "end_col": 67,
  "parent_qualname": "_XTRIndexRuntime",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/xtr_manager.py",
  "module": "io.xtr_manager",
  "qualname": "_XTRIndexRuntime.close",
  "name": "close",
  "node_type": "FunctionDef",
  "lineno": 54,
  "col": 4,
  "end_lineno": 61,
  "end_col": 32,
  "parent_qualname": "_XTRIndexRuntime",
  "decorators": [],
  "bases": [],
  "docstring": "Release loaded tokenizer/model/memmaps.",
  "is_public": true
}
{
  "path": "io/xtr_manager.py",
  "module": "io.xtr_manager",
  "qualname": "XTRIndex",
  "name": "XTRIndex",
  "node_type": "ClassDef",
  "lineno": 65,
  "col": 0,
  "end_lineno": 640,
  "end_col": 32,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Memory-mapped XTR token index with query encoding + scoring helpers.",
  "is_public": true
}
{
  "path": "io/xtr_manager.py",
  "module": "io.xtr_manager",
  "qualname": "XTRIndex.open",
  "name": "open",
  "node_type": "FunctionDef",
  "lineno": 76,
  "col": 4,
  "end_lineno": 128,
  "end_col": 9,
  "parent_qualname": "XTRIndex",
  "decorators": [],
  "bases": [],
  "docstring": "Open metadata and memory-map the token matrix if artifacts exist.\n\nRaises\n------\nValueError\n    If the stored metadata does not match the token matrix shape.",
  "is_public": true
}
{
  "path": "io/xtr_manager.py",
  "module": "io.xtr_manager",
  "qualname": "XTRIndex.ready",
  "name": "ready",
  "node_type": "FunctionDef",
  "lineno": 131,
  "col": 4,
  "end_lineno": 140,
  "end_col": 82,
  "parent_qualname": "XTRIndex",
  "decorators": [
    "property"
  ],
  "bases": [],
  "docstring": "Return ``True`` when both metadata and token memmap are available.\n\nReturns\n-------\nbool\n    ``True`` if the index is ready for scoring.",
  "is_public": true
}
{
  "path": "io/xtr_manager.py",
  "module": "io.xtr_manager",
  "qualname": "XTRIndex.metadata",
  "name": "metadata",
  "node_type": "FunctionDef",
  "lineno": 142,
  "col": 4,
  "end_lineno": 153,
  "end_col": 52,
  "parent_qualname": "XTRIndex",
  "decorators": [],
  "bases": [],
  "docstring": "Return a shallow copy of index metadata when loaded.\n\nReturns\n-------\nXTRMetadata | None\n    Metadata dictionary or ``None`` when index not opened.",
  "is_public": true
}
{
  "path": "io/xtr_manager.py",
  "module": "io.xtr_manager",
  "qualname": "XTRIndex.encode_query_tokens",
  "name": "encode_query_tokens",
  "node_type": "FunctionDef",
  "lineno": 155,
  "col": 4,
  "end_lineno": 195,
  "end_col": 21,
  "parent_qualname": "XTRIndex",
  "decorators": [],
  "bases": [],
  "docstring": "Encode text into normalized token embeddings.\n\nParameters\n----------\ntext : str\n    Query text string to encode. Will be tokenized and truncated to\n    max_query_tokens if necessary.\n\nReturns\n-------\nNDArrayF32\n    Array shaped [tokens, dim] with L2-normalized token vectors.\n    Each row is a token embedding normalized to unit length.",
  "is_public": true
}
{
  "path": "io/xtr_manager.py",
  "module": "io.xtr_manager",
  "qualname": "XTRIndex.search",
  "name": "search",
  "node_type": "FunctionDef",
  "lineno": 197,
  "col": 4,
  "end_lineno": 281,
  "end_col": 22,
  "parent_qualname": "XTRIndex",
  "decorators": [],
  "bases": [],
  "docstring": "Perform index-wide MaxSim search across all chunks (wide mode).\n\nExtended Summary\n----------------\nThis method performs exhaustive MaxSim search across the entire XTR index,\nscoring all chunks against the query and returning the top-k results. It is\nused for wide-mode retrieval when no initial candidate set is available. The\nmethod encodes the query into token embeddings, computes MaxSim scores against\nall document chunks, and returns ranked results with optional explainability\ndata. This is the primary entry point for XTR-based search when operating\nwithout a Stage-0 retrieval system.\n\nParameters\n----------\nquery : str\n    Natural language search query string. Will be tokenized and encoded\n    into query token embeddings for MaxSim computation.\nk : int\n    Maximum number of results to return. Must be positive. Results are\n    ranked by MaxSim score in descending order.\nexplain : bool, optional\n    If True, include explainability payload with token-level alignment\n    information for each result. Defaults to False.\ntopk_explanations : int, optional\n    Maximum number of token matches to include in explainability payload\n    when explain=True. Defaults to 5.\n\nReturns\n-------\nlist[tuple[int, float, dict[str, Any] | None]]\n    Ranked list of (chunk_id, score, explainability_payload) tuples.\n    Scores are MaxSim sums across query tokens. Explainability payload is\n    None if explain=False or no matches found. Length is min(k, total_chunks).\n\nNotes\n-----\nTime complexity O(n * m * d) where n is query tokens, m is total document\ntokens across all chunks, and d is embedding dimension. Space complexity\nO(n * d + m * d) for query and document embeddings. The method performs\nI/O to read token embeddings from memory-mapped files. Thread-safe if\nindex is read-only. Returns empty list if index is not ready or k <= 0.\n\nExamples\n--------\n>>> # Requires XTRIndex instance with opened index\n>>> # index = XTRIndex(root=Path(\"...\"), config=...)\n>>> # index.open()\n>>> # results = index.search(\"vector store\", k=10)\n>>> # len(results) <= 10\n>>> # all(isinstance(r[0], int) and isinstance(r[1], float) for r in results)\n>>> # True",
  "is_public": true
}
{
  "path": "io/xtr_manager.py",
  "module": "io.xtr_manager",
  "qualname": "XTRIndex.rescore",
  "name": "rescore",
  "node_type": "FunctionDef",
  "lineno": 283,
  "col": 4,
  "end_lineno": 365,
  "end_col": 22,
  "parent_qualname": "XTRIndex",
  "decorators": [],
  "bases": [],
  "docstring": "Rescore a Stage-0 candidate set using MaxSim (narrow mode).\n\nExtended Summary\n----------------\nThis method performs focused MaxSim rescoring on a pre-filtered set of\ncandidate chunks, typically from an initial retrieval stage (e.g., CodeRank\nFAISS search). It encodes the query, computes MaxSim scores only for the\nprovided candidates, and returns ranked results. This narrow-mode operation\nis more efficient than full index search when a high-quality candidate set\nis available. The method is used in two-stage retrieval pipelines where\nStage-0 provides candidates and XTR provides late-interaction reranking.\n\nParameters\n----------\nquery : str\n    Natural language search query string. Will be tokenized and encoded\n    into query token embeddings for MaxSim computation.\ncandidate_chunk_ids : Iterable[int]\n    Iterable of chunk IDs from Stage-0 retrieval to rescore. Duplicates\n    are automatically deduplicated. Empty iterables result in empty results.\nexplain : bool, optional\n    If True, include explainability payload with token-level alignment\n    information for each result. Defaults to False.\ntopk_explanations : int, optional\n    Maximum number of token matches to include in explainability payload\n    when explain=True. Defaults to 5.\n\nReturns\n-------\nlist[tuple[int, float, dict[str, Any] | None]]\n    Ranked list of (chunk_id, score, explainability_payload) tuples,\n    restricted to the provided candidate chunk IDs. Scores are MaxSim sums\n    across query tokens. Explainability payload is None if explain=False\n    or no matches found. Results are sorted by score descending.\n\nNotes\n-----\nTime complexity O(n * m * d) where n is query tokens, m is total document\ntokens across candidate chunks, and d is embedding dimension. Space complexity\nO(n * d + c * m * d) where c is candidate count. More efficient than search()\nwhen candidate set is small relative to total chunks. The method performs\nI/O to read token embeddings from memory-mapped files. Thread-safe if index\nis read-only. Returns empty list if index is not ready or candidates is empty.\n\nExamples\n--------\n>>> # Requires XTRIndex instance with opened index\n>>> # index = XTRIndex(root=Path(\"...\"), config=...)\n>>> # index.open()\n>>> # candidates = [1, 2, 3, 4, 5]\n>>> # results = index.rescore(\"vector store\", candidates, explain=True)\n>>> # len(results) <= len(candidates)\n>>> # all(r[0] in candidates for r in results)\n>>> # True",
  "is_public": true
}
{
  "path": "io/xtr_manager.py",
  "module": "io.xtr_manager",
  "qualname": "XTRIndex.score_candidates",
  "name": "score_candidates",
  "node_type": "FunctionDef",
  "lineno": 367,
  "col": 4,
  "end_lineno": 445,
  "end_col": 22,
  "parent_qualname": "XTRIndex",
  "decorators": [],
  "bases": [],
  "docstring": "Compute MaxSim scores for candidate chunk IDs.\n\nParameters\n----------\nquery_vecs : NDArrayF32\n    Query token embeddings array shaped [query_tokens, dim]. Used to compute\n    MaxSim scores against document token embeddings.\ncandidate_chunk_ids : Iterable[int]\n    Iterable of chunk IDs to score. Duplicates are automatically deduplicated.\nexplain : bool, optional\n    If True, include explainability payload with token-level alignments.\n    Defaults to False.\ntopk_explanations : int, optional\n    Maximum number of token matches to include in explainability payload.\n    Defaults to 5.\nlimit : int | None, optional\n    Optional cap on the number of rescored results returned. ``None`` retains\n    every candidate.\n\nReturns\n-------\nlist[tuple[int, float, dict[str, Any] | None]]\n    Ranked list containing (chunk_id, score, explainability_payload) tuples.\n    Scores are MaxSim sums across query tokens. Explainability payload is None\n    if explain=False or no matches found.",
  "is_public": true
}
{
  "path": "io/xtr_manager.py",
  "module": "io.xtr_manager",
  "qualname": "XTRIndex._ensure_encoder",
  "name": "_ensure_encoder",
  "node_type": "FunctionDef",
  "lineno": 447,
  "col": 4,
  "end_lineno": 469,
  "end_col": 31,
  "parent_qualname": "XTRIndex",
  "decorators": [],
  "bases": [],
  "docstring": "Instantiate and cache tokenizer/model pair.\n\nReturns\n-------\ntuple[Any, Any]\n    Tokenizer/model pair loaded from Hugging Face.",
  "is_public": false
}
{
  "path": "io/xtr_manager.py",
  "module": "io.xtr_manager",
  "qualname": "XTRIndex._resolve_device",
  "name": "_resolve_device",
  "node_type": "FunctionDef",
  "lineno": 471,
  "col": 4,
  "end_lineno": 529,
  "end_col": 48,
  "parent_qualname": "XTRIndex",
  "decorators": [],
  "bases": [],
  "docstring": "Resolve the runtime torch.device honoring config preferences.\n\nParameters\n----------\ntorch_module : TorchModule\n    Torch module instance used to check CUDA availability and create\n    device objects.\n\nReturns\n-------\nobject\n    Device reference (torch.device) pointing to cpu or cuda based on\n    config and availability.",
  "is_public": false
}
{
  "path": "io/xtr_manager.py",
  "module": "io.xtr_manager",
  "qualname": "XTRIndex._parse_cuda_ordinal",
  "name": "_parse_cuda_ordinal",
  "node_type": "FunctionDef",
  "lineno": 532,
  "col": 4,
  "end_lineno": 569,
  "end_col": 23,
  "parent_qualname": "XTRIndex",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": "Extract CUDA device ordinal from a device string.\n\nExtended Summary\n----------------\nThis method parses a CUDA device string (e.g., \"cuda:0\", \"cuda:1\") to extract\nthe device ordinal. It handles malformed input gracefully by returning None\nwhen the format is invalid or when no ordinal is specified. This is used\ninternally by the XTR index to resolve device assignments from configuration\nstrings and ensure proper GPU device selection for tensor operations.\n\nParameters\n----------\nvalue : str\n    Device string that may contain a CUDA ordinal in the format \"cuda:<ordinal>\".\n    If the string doesn't contain a colon or the part after the colon is not\n    a valid integer, the function returns None.\n\nReturns\n-------\nint | None\n    Parsed ordinal as an integer (e.g., 0, 1, 2) when ``value`` contains\n    ``cuda:<ordinal>``, or ``None`` when unspecified, invalid, or not in\n    the expected format.\n\nNotes\n-----\nTime complexity O(1) - simple string split and int conversion. Space\ncomplexity O(1). No I/O or side effects. Handles ValueError exceptions\nfrom int() conversion by returning None, making it safe for malformed input.",
  "is_public": false
}
{
  "path": "io/xtr_manager.py",
  "module": "io.xtr_manager",
  "qualname": "XTRIndex._slice_chunk",
  "name": "_slice_chunk",
  "node_type": "FunctionDef",
  "lineno": 571,
  "col": 4,
  "end_lineno": 606,
  "end_col": 59,
  "parent_qualname": "XTRIndex",
  "decorators": [],
  "bases": [],
  "docstring": "Return token matrix slice for chunk_id.\n\nParameters\n----------\nchunk_id : int\n    Chunk ID to extract embeddings for. Must exist in the index metadata.\n\nReturns\n-------\nNDArrayF32\n    View over the token matrix for the requested chunk. Array shaped\n    [tokens, dim] with token embeddings.\n\nRaises\n------\nRuntimeError\n    If the index has not been opened.\nKeyError\n    If the chunk identifier is not present in metadata.",
  "is_public": false
}
{
  "path": "io/xtr_manager.py",
  "module": "io.xtr_manager",
  "qualname": "XTRIndex._build_chunk_lookup",
  "name": "_build_chunk_lookup",
  "node_type": "FunctionDef",
  "lineno": 609,
  "col": 4,
  "end_lineno": 630,
  "end_col": 9,
  "parent_qualname": "XTRIndex",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": "Build fast chunk metadata for offset lookups.\n\nParameters\n----------\nmeta : XTRMetadata\n    Metadata containing chunk dimensions for the index.\n\nReturns\n-------\ndict[int, tuple[int, int]]\n    Mapping from chunk ID to (offset, length).",
  "is_public": false
}
{
  "path": "io/xtr_manager.py",
  "module": "io.xtr_manager",
  "qualname": "XTRIndex.close",
  "name": "close",
  "node_type": "FunctionDef",
  "lineno": 632,
  "col": 4,
  "end_lineno": 634,
  "end_col": 26,
  "parent_qualname": "XTRIndex",
  "decorators": [],
  "bases": [],
  "docstring": "Release runtime resources such as memmaps and tokenizer.",
  "is_public": true
}
{
  "path": "io/xtr_manager.py",
  "module": "io.xtr_manager",
  "qualname": "XTRIndex._ensure_state",
  "name": "_ensure_state",
  "node_type": "FunctionDef",
  "lineno": 636,
  "col": 4,
  "end_lineno": 637,
  "end_col": 61,
  "parent_qualname": "XTRIndex",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "io/xtr_manager.py",
  "module": "io.xtr_manager",
  "qualname": "XTRIndex._current_state",
  "name": "_current_state",
  "node_type": "FunctionDef",
  "lineno": 639,
  "col": 4,
  "end_lineno": 640,
  "end_col": 32,
  "parent_qualname": "XTRIndex",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "mcp_server/__init__.py",
  "module": "mcp_server",
  "qualname": "mcp_server",
  "name": "mcp_server",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "MCP server implementation and tool adapters for CodeIntel.",
  "is_public": true
}
{
  "path": "mcp_server/__init__.py",
  "module": "mcp_server",
  "qualname": "__getattr__",
  "name": "__getattr__",
  "node_type": "FunctionDef",
  "lineno": 17,
  "col": 0,
  "end_lineno": 42,
  "end_col": 17,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Lazy-load heavy submodules to avoid circular imports.\n\nParameters\n----------\nname : str\n    Attribute name to resolve.\n\nReturns\n-------\nModuleType\n    Imported module when name matches ``_EXPORTS``.\n\nRaises\n------\nAttributeError\n    If the requested attribute name is not available in this module.",
  "is_public": false
}
{
  "path": "mcp_server/__init__.py",
  "module": "mcp_server",
  "qualname": "__dir__",
  "name": "__dir__",
  "node_type": "FunctionDef",
  "lineno": 45,
  "col": 0,
  "end_lineno": 46,
  "end_col": 48,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "mcp_server/adapters/__init__.py",
  "module": "mcp_server.adapters",
  "qualname": "mcp_server.adapters",
  "name": "mcp_server.adapters",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "MCP tool adapters.\n\nAdapters implement the actual logic for MCP tools, separating\nconcerns between the MCP interface and business logic.",
  "is_public": true
}
{
  "path": "mcp_server/adapters/deep_research.py",
  "module": "mcp_server.adapters.deep_research",
  "qualname": "mcp_server.adapters.deep_research",
  "name": "mcp_server.adapters.deep_research",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Adapters that expose MCP Deep-Research search/fetch semantics.",
  "is_public": true
}
{
  "path": "mcp_server/adapters/deep_research.py",
  "module": "mcp_server.adapters.deep_research",
  "qualname": "_pool_dir",
  "name": "_pool_dir",
  "node_type": "FunctionDef",
  "lineno": 45,
  "col": 0,
  "end_lineno": 46,
  "end_col": 35,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "mcp_server/adapters/deep_research.py",
  "module": "mcp_server.adapters.deep_research",
  "qualname": "_clamp_top_k",
  "name": "_clamp_top_k",
  "node_type": "FunctionDef",
  "lineno": 49,
  "col": 0,
  "end_lineno": 51,
  "end_col": 38,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "mcp_server/adapters/deep_research.py",
  "module": "mcp_server.adapters.deep_research",
  "qualname": "_clamp_max_tokens",
  "name": "_clamp_max_tokens",
  "node_type": "FunctionDef",
  "lineno": 54,
  "col": 0,
  "end_lineno": 56,
  "end_col": 43,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "mcp_server/adapters/deep_research.py",
  "module": "mcp_server.adapters.deep_research",
  "qualname": "_serialize_search_response",
  "name": "_serialize_search_response",
  "node_type": "FunctionDef",
  "lineno": 59,
  "col": 0,
  "end_lineno": 102,
  "end_col": 18,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Convert an internal search response into MCP structured content.\n\nThis function transforms a SearchResponse dataclass (containing search results\nfrom the retrieval pipeline) into a SearchStructuredContent TypedDict suitable\nfor JSON serialization and transmission via the MCP protocol. The function\nextracts chunk metadata (IDs, titles, URLs, snippets, scores) and formats\nthem according to the MCP schema.\n\nParameters\n----------\nresponse : SearchResponse\n    Internal search response containing ranked results, query echo, top_k,\n    and optional limits. The response.results list contains SearchResult\n    objects with chunk metadata and scores.\n\nReturns\n-------\nSearchStructuredContent\n    JSON-safe payload returned to the MCP transport. Contains a list of\n    SearchResultItem objects with id, title, url, snippet, score, source,\n    and metadata fields. Also includes queryEcho, top_k, and optional\n    limits array.",
  "is_public": false
}
{
  "path": "mcp_server/adapters/deep_research.py",
  "module": "mcp_server.adapters.deep_research",
  "qualname": "_serialize_fetch_response",
  "name": "_serialize_fetch_response",
  "node_type": "FunctionDef",
  "lineno": 105,
  "col": 0,
  "end_lineno": 137,
  "end_col": 50,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Convert an internal fetch response into MCP structured content.\n\nThis function transforms a FetchResponse dataclass (containing hydrated chunk\nobjects from the catalog) into a FetchStructuredContent TypedDict suitable for\nJSON serialization and transmission via the MCP protocol. The function extracts\nchunk content and metadata (IDs, titles, URLs, content, metadata) and formats\nthem according to the MCP schema.\n\nParameters\n----------\nresponse : FetchResponse\n    Internal fetch response containing hydrated chunk objects. The response.objects\n    list contains FetchObjectResult objects with full chunk content and metadata.\n\nReturns\n-------\nFetchStructuredContent\n    JSON-safe payload containing hydrated chunk objects. Contains a list of\n    FetchObject objects with id, title, url, content, and metadata fields.\n    The content field contains the full text of the chunk.",
  "is_public": false
}
{
  "path": "mcp_server/adapters/deep_research.py",
  "module": "mcp_server.adapters.deep_research",
  "qualname": "search",
  "name": "search",
  "node_type": "AsyncFunctionDef",
  "lineno": 140,
  "col": 0,
  "end_lineno": 215,
  "end_col": 45,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Execute the Deep-Research search pipeline.\n\nThis async function orchestrates the complete search workflow: validates\nFAISS index availability, normalizes search filters, constructs search\nrequests, executes FAISS search with optional reranking, and serializes\nresults for MCP transport. The function runs the search operation in a\nthread pool to avoid blocking the async event loop.\n\nParameters\n----------\ncontext : ApplicationContext\n    Application context providing access to FAISS manager, catalog, embedding\n    client, settings, and data directories. Used to construct search dependencies\n    and validate index availability.\ntimeline : Timeline\n    Timeline instance for recording search events and observability. Used to\n    track search operations and provide session/run IDs for telemetry.\npayload : SearchToolArgs\n    MCP search tool arguments containing query text, optional top_k, rerank\n    flag, and optional filters (languages, include/exclude paths, symbols).\n    The payload is validated and normalized before constructing SearchRequest.\n\nReturns\n-------\nSearchStructuredContent\n    Structured MCP payload containing ranked chunk results with metadata\n    (IDs, titles, URLs, snippets, scores). Results are ranked by relevance\n    score and filtered according to the provided filters.\n\nRaises\n------\nVectorSearchError\n    Raised when the FAISS index cannot be loaded or is unavailable. The error\n    includes context about the index path for debugging.",
  "is_public": true
}
{
  "path": "mcp_server/adapters/deep_research.py",
  "module": "mcp_server.adapters.deep_research",
  "qualname": "search._work",
  "name": "_work",
  "node_type": "FunctionDef",
  "lineno": 198,
  "col": 4,
  "end_lineno": 212,
  "end_col": 55,
  "parent_qualname": "search",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "mcp_server/adapters/deep_research.py",
  "module": "mcp_server.adapters.deep_research",
  "qualname": "fetch",
  "name": "fetch",
  "node_type": "AsyncFunctionDef",
  "lineno": 218,
  "col": 0,
  "end_lineno": 269,
  "end_col": 45,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Hydrate chunk ids returned from the MCP search tool.\n\nThis async function retrieves full chunk content and metadata for a list of\nchunk IDs returned from a previous search operation. The function normalizes\nobject IDs, constructs fetch requests, queries the DuckDB catalog, and\nserializes hydrated chunks for MCP transport. The function runs the fetch\noperation in a thread pool to avoid blocking the async event loop.\n\nParameters\n----------\ncontext : ApplicationContext\n    Application context providing access to DuckDB catalog, settings, and\n    data directories. Used to construct fetch dependencies and open catalog\n    connections.\ntimeline : Timeline\n    Timeline instance for recording fetch events and observability. Used to\n    track fetch operations and provide session/run IDs for telemetry.\npayload : FetchToolArgs\n    MCP fetch tool arguments containing objectIds (list of chunk ID strings)\n    and optional max_tokens limit. The objectIds are normalized to integers\n    and validated before querying the catalog.\n\nReturns\n-------\nFetchStructuredContent\n    Structured MCP payload containing hydrated chunk objects with full content\n    and metadata (IDs, titles, URLs, content, metadata). Chunks are returned\n    in the order specified by objectIds, with missing chunks omitted.",
  "is_public": true
}
{
  "path": "mcp_server/adapters/deep_research.py",
  "module": "mcp_server.adapters.deep_research",
  "qualname": "fetch._work",
  "name": "_work",
  "node_type": "FunctionDef",
  "lineno": 258,
  "col": 4,
  "end_lineno": 266,
  "end_col": 54,
  "parent_qualname": "fetch",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "mcp_server/adapters/deep_research.py",
  "module": "mcp_server.adapters.deep_research",
  "qualname": "_normalize_object_ids",
  "name": "_normalize_object_ids",
  "node_type": "FunctionDef",
  "lineno": 272,
  "col": 0,
  "end_lineno": 298,
  "end_col": 45,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Normalize object identifiers while preserving ordering.\n\nThis helper function converts a sequence of string chunk IDs to a tuple of\nintegers, preserving the original order. Used to normalize MCP fetch payload\nobjectIds before querying the catalog. Invalid IDs (non-numeric strings)\nraise ValueError during conversion.\n\nParameters\n----------\nraw_ids : Sequence[str]\n    Sequence of chunk ID strings to normalize. Each string should represent\n    a valid integer chunk ID. Empty sequences return an empty tuple.\n\nReturns\n-------\ntuple[int, ...]\n    Tuple of normalized integer chunk IDs preserving the incoming order.\n    The tuple has the same length as raw_ids (unless conversion fails).\n\nNotes\n-----\nThis function is used by fetch() to normalize MCP payload objectIds before\nconstructing FetchRequest. Time complexity: O(n) where n is the length of\nraw_ids. The function is deterministic and preserves order.",
  "is_public": false
}
{
  "path": "mcp_server/adapters/deep_research.py",
  "module": "mcp_server.adapters.deep_research",
  "qualname": "_bounded",
  "name": "_bounded",
  "node_type": "AsyncFunctionDef",
  "lineno": 305,
  "col": 0,
  "end_lineno": 339,
  "end_col": 22,
  "parent_qualname": null,
  "decorators": [
    "asynccontextmanager"
  ],
  "bases": [],
  "docstring": "Enforce concurrency and timeout guards for MCP operations.\n\nThis context manager limits concurrent MCP operations using a semaphore and\nenforces a timeout to prevent operations from hanging indefinitely. It is used\nby deep research adapters to ensure resource limits are respected during\nvector search and retrieval operations.\n\nParameters\n----------\noperation : str\n    Name of the operation being bounded, used in error messages.\ntimeout_s : int\n    Maximum duration in seconds before the operation times out.\n\nYields\n------\nNone\n    Yields control to the bounded operation block.\n\nRaises\n------\nVectorSearchError\n    Raised when the bounded block exceeds ``timeout_s`` seconds.",
  "is_public": false
}
{
  "path": "mcp_server/adapters/files.py",
  "module": "mcp_server.adapters.files",
  "qualname": "mcp_server.adapters.files",
  "name": "mcp_server.adapters.files",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "File and scope management adapter.\n\nProvides file listing, reading, and scope configuration.",
  "is_public": true
}
{
  "path": "mcp_server/adapters/files.py",
  "module": "mcp_server.adapters.files",
  "qualname": "FileListFilters",
  "name": "FileListFilters",
  "node_type": "ClassDef",
  "lineno": 39,
  "col": 0,
  "end_lineno": 45,
  "end_col": 27,
  "parent_qualname": null,
  "decorators": [
    "dataclass(frozen=True)"
  ],
  "bases": [],
  "docstring": "Configuration for file listing filters.",
  "is_public": true
}
{
  "path": "mcp_server/adapters/files.py",
  "module": "mcp_server.adapters.files",
  "qualname": "DirectoryFilters",
  "name": "DirectoryFilters",
  "node_type": "ClassDef",
  "lineno": 49,
  "col": 0,
  "end_lineno": 55,
  "end_col": 20,
  "parent_qualname": null,
  "decorators": [
    "dataclass(frozen=True)"
  ],
  "bases": [],
  "docstring": "Prepared filters used during directory traversal.",
  "is_public": true
}
{
  "path": "mcp_server/adapters/files.py",
  "module": "mcp_server.adapters.files",
  "qualname": "set_scope",
  "name": "set_scope",
  "node_type": "AsyncFunctionDef",
  "lineno": 58,
  "col": 0,
  "end_lineno": 99,
  "end_col": 79,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Set query scope for subsequent operations.\n\nStores scope in the session-scoped registry keyed by session ID. Subsequent\nqueries within the same session automatically apply these constraints.\n\nParameters\n----------\ncontext : ApplicationContext\n    Application context containing scope registry.\nscope : ScopeIn\n    Scope configuration with repos, branches, paths, languages.\n\nReturns\n-------\ndict\n    Confirmation with effective scope and session ID.\n\nExamples\n--------\n>>> result = set_scope(context, {\"languages\": [\"python\"], \"include_globs\": [\"src/**\"]})\n>>> result[\"status\"]\n'ok'\n>>> result[\"session_id\"]  # UUID format\n'abc123...'\n>>> result[\"effective_scope\"][\"languages\"]\n['python']\n\nNotes\n-----\nThe session ID is extracted from the request context (set by middleware).\nIf no session ID is available, this function will raise RuntimeError.",
  "is_public": true
}
{
  "path": "mcp_server/adapters/files.py",
  "module": "mcp_server.adapters.files",
  "qualname": "list_paths",
  "name": "list_paths",
  "node_type": "AsyncFunctionDef",
  "lineno": 102,
  "col": 0,
  "end_lineno": 200,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "List files in repository (async with threadpool offload).\n\nApplies session scope filters (include_globs, exclude_globs, languages) if\nset via `set_scope`. Explicit parameters override session scope.\n\nThis function runs the blocking directory traversal in a threadpool via\n`asyncio.to_thread` to prevent blocking the event loop. This enables\nconcurrent file listing operations without thread exhaustion.\n\nParameters\n----------\ncontext : ApplicationContext\n    Application context containing repo root and settings.\n*args : object\n    Positional arguments (up to 5): path, include_globs, exclude_globs, languages, max_results.\n    Positional arguments are supported for backward compatibility but keyword\n    arguments are preferred.\n**kwargs : object\n    Keyword arguments accepted:\n    - path : str | None\n        Starting path relative to repo root (None = root).\n    - include_globs : list[str] | None\n        Glob patterns to include (e.g., [\"*.py\"]).\n        Overrides session scope if provided.\n    - exclude_globs : list[str] | None\n        Glob patterns to exclude (e.g., [\"__pycache__\", \"*.pyc\"]).\n        Overrides session scope if provided.\n    - languages : list[str] | None\n        Programming languages to include (overrides session scope when provided).\n    - max_results : int\n        Maximum number of files to return (default: 1000).\n\nReturns\n-------\ndict\n    File listing with paths and metadata.\n\nExamples\n--------\nBasic usage:\n\n>>> result = list_paths(context, path=\"src\", include_globs=[\"*.py\"])\n>>> isinstance(result[\"items\"], list)\nTrue\n\nWith session scope:\n\n>>> set_scope(context, {\"languages\": [\"python\"], \"include_globs\": [\"src/**\"]})\n>>> result = list_paths(context, path=None)\n>>> # Returns only Python files in src/ directory\n\nExplicit parameters override scope:\n\n>>> set_scope(context, {\"languages\": [\"python\"]})\n>>> result = list_paths(context, include_globs=[\"**/*.ts\"])\n>>> # Returns TypeScript files (explicit override), not Python\n\nNotes\n-----\nAsync Pattern:\n- The blocking directory traversal runs in a threadpool via `asyncio.to_thread`.\n- This prevents blocking the event loop and enables concurrent operations.\n- The sync implementation (`_list_paths_sync`) contains the actual logic.\n\nScope Integration:\n- Session scope is retrieved from registry using session ID (set by middleware).\n- Scope's `include_globs` and `exclude_globs` are merged with explicit parameters.\n- Explicit parameters take precedence over scope (explicit wins).\n- Scope's `languages` filter is applied after directory traversal (post-filtering).\n- If no scope is set, behaves as before (no filtering beyond explicit params).\n\nThe traversal skips directories that match the default or user supplied\nexclusion globs (for example ``**/.git/**``) so that large dependency\nfolders are pruned without visiting their contents.",
  "is_public": true
}
{
  "path": "mcp_server/adapters/files.py",
  "module": "mcp_server.adapters.files",
  "qualname": "_normalize_list_paths_arguments",
  "name": "_normalize_list_paths_arguments",
  "node_type": "FunctionDef",
  "lineno": 203,
  "col": 0,
  "end_lineno": 232,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "mcp_server/adapters/files.py",
  "module": "mcp_server.adapters.files",
  "qualname": "_list_paths_sync",
  "name": "_list_paths_sync",
  "node_type": "FunctionDef",
  "lineno": 235,
  "col": 0,
  "end_lineno": 351,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "List files in repository (synchronous implementation).\n\nSynchronous implementation of list_paths that performs the actual directory\ntraversal. This function runs in a threadpool when called from the async\n`list_paths` wrapper.\n\nParameters\n----------\ncontext : ApplicationContext\n    Application context containing repo root and settings.\nsession_id : str\n    Session identifier for logging and scope resolution.\nscope : ScopeIn | None\n    Session scope containing include/exclude globs and language filters.\n    Overridden by explicit ``include_globs`` and ``exclude_globs`` parameters.\npath : str | None\n    Starting path relative to repo root (None = root).\nfilters : FileListFilters | None\n    Filters for includes, excludes, language restrictions, and max results.\n    If None, default filters are used (no restrictions).\n\nReturns\n-------\ndict\n    File listing with paths and metadata.\n\nNotes\n-----\nExceptions raised by ``_resolve_search_root`` (PathNotFoundError,\nPathNotDirectoryError, PathOutsideRepositoryError) may propagate through\nthis function.",
  "is_public": false
}
{
  "path": "mcp_server/adapters/files.py",
  "module": "mcp_server.adapters.files",
  "qualname": "_collect_filtered_paths",
  "name": "_collect_filtered_paths",
  "node_type": "FunctionDef",
  "lineno": 354,
  "col": 0,
  "end_lineno": 416,
  "end_col": 42,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Walk directories and apply include/exclude filters.\n\nParameters\n----------\nsearch_root : Path\n    Directory to start walking from.\nrepo_root : Path\n    Repository root directory.\nfilters : DirectoryFilters\n    Prepared include/exclude/language filters plus max results.\n\nReturns\n-------\ntuple[list[dict[str, object]], int, bool]\n    Tuple containing:\n    - items: List of file entries with path, size, and modified time\n    - matched_count: Total number of files that matched filters\n    - truncated: True if results were truncated due to max_results limit",
  "is_public": false
}
{
  "path": "mcp_server/adapters/files.py",
  "module": "mcp_server.adapters.files",
  "qualname": "_prune_directories",
  "name": "_prune_directories",
  "node_type": "FunctionDef",
  "lineno": 419,
  "col": 0,
  "end_lineno": 438,
  "end_col": 37,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "mcp_server/adapters/files.py",
  "module": "mcp_server.adapters.files",
  "qualname": "_create_file_entry",
  "name": "_create_file_entry",
  "node_type": "FunctionDef",
  "lineno": 441,
  "col": 0,
  "end_lineno": 495,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return a file entry dict when filters accept the file.\n\nChecks if a file path matches the provided include/exclude patterns and\nlanguage extensions. Returns a dictionary with file metadata if the file\npasses all filters, otherwise returns None.\n\nParameters\n----------\nfile_path : Path\n    Absolute path to the file being checked.\nrepo_root : Path\n    Root directory of the repository, used to compute relative paths.\nincludes : list[str]\n    List of glob patterns that the file path must match to be included.\n    Empty list means no inclusion filter is applied.\nexcludes : list[str]\n    List of glob patterns that the file path must not match to be included.\n    Empty list means no exclusion filter is applied.\nlanguage_extensions : set[str] | None\n    Set of file extensions (with leading dot) that the file must have.\n    If None, no language filter is applied.\n\nReturns\n-------\ndict[str, object] | None\n    Dictionary containing file metadata (path, relative_path, etc.) when\n    filters are satisfied, otherwise ``None``.",
  "is_public": false
}
{
  "path": "mcp_server/adapters/files.py",
  "module": "mcp_server.adapters.files",
  "qualname": "open_file",
  "name": "open_file",
  "node_type": "FunctionDef",
  "lineno": 498,
  "col": 0,
  "end_lineno": 601,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Read file content with optional line slicing.\n\nParameters\n----------\ncontext : ApplicationContext\n    Application context containing repo root and settings.\npath : str\n    File path relative to repo root.\nstart_line : int | None\n    Start line (1-indexed, inclusive). Must be positive when provided.\nend_line : int | None\n    End line (1-indexed, inclusive). Must be positive when provided.\n\nReturns\n-------\ndict\n    File content and metadata with keys: path, content, lines, size.\n\nRaises\n------\nPathNotFoundError\n    If the requested file does not exist or is not a regular file.\nFileReadError\n    If file is binary or has encoding issues.\nInvalidLineRangeError\n    If line range parameters are invalid.\n\nNotes\n-----\n``start_line`` and ``end_line`` are inclusive and 1-indexed. If both bounds\nare supplied then ``start_line`` must be less than or equal to ``end_line``.\nProviding a single bound slices from the start or through the end of the\nfile respectively.\n\nExamples\n--------\n>>> result = open_file(context, \"README.md\", start_line=1, end_line=10)\n>>> \"content\" in result\nTrue",
  "is_public": true
}
{
  "path": "mcp_server/adapters/files.py",
  "module": "mcp_server.adapters.files",
  "qualname": "_resolve_search_root",
  "name": "_resolve_search_root",
  "node_type": "FunctionDef",
  "lineno": 607,
  "col": 0,
  "end_lineno": 651,
  "end_col": 22,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Resolve search root path, raising descriptive errors on failure.\n\nThis function calls ``resolve_within_repo`` and converts generic file\nexceptions into domain-specific errors for consistent error handling.\n\nParameters\n----------\nrepo_root : Path\n    Repository root directory.\nrequested : str | None\n    Requested path (None = root).\n\nReturns\n-------\nPath\n    Resolved search root path.\n\nRaises\n------\nPathOutsideRepositoryError\n    If the resolved path escapes the repository root (raised by\n    ``resolve_within_repo``).\nPathNotFoundError\n    If the requested path does not exist within the repository.\nPathNotDirectoryError\n    If the resolved path exists but is not a directory.",
  "is_public": false
}
{
  "path": "mcp_server/adapters/files.py",
  "module": "mcp_server.adapters.files",
  "qualname": "_matches_any",
  "name": "_matches_any",
  "node_type": "FunctionDef",
  "lineno": 654,
  "col": 0,
  "end_lineno": 656,
  "end_col": 76,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "mcp_server/adapters/files.py",
  "module": "mcp_server.adapters.files",
  "qualname": "_relative_path_str",
  "name": "_relative_path_str",
  "node_type": "FunctionDef",
  "lineno": 659,
  "col": 0,
  "end_lineno": 668,
  "end_col": 35,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "mcp_server/adapters/files.py",
  "module": "mcp_server.adapters.files",
  "qualname": "_safe_stat",
  "name": "_safe_stat",
  "node_type": "FunctionDef",
  "lineno": 671,
  "col": 0,
  "end_lineno": 675,
  "end_col": 19,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "mcp_server/adapters/files.py",
  "module": "mcp_server.adapters.files",
  "qualname": "_collect_language_extensions",
  "name": "_collect_language_extensions",
  "node_type": "FunctionDef",
  "lineno": 678,
  "col": 0,
  "end_lineno": 694,
  "end_col": 21,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return canonical file extensions for the requested languages.\n\nParameters\n----------\nlanguages : Sequence[str]\n    Language codes to get extensions for (e.g., [\"python\", \"javascript\"]).\n\nReturns\n-------\nset[str]\n    Set of file extensions (with leading dots) for the requested languages.",
  "is_public": false
}
{
  "path": "mcp_server/adapters/files.py",
  "module": "mcp_server.adapters.files",
  "qualname": "_matches_language",
  "name": "_matches_language",
  "node_type": "FunctionDef",
  "lineno": 697,
  "col": 0,
  "end_lineno": 714,
  "end_col": 62,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return True when the path matches one of the requested extensions.\n\nParameters\n----------\npath : str\n    File path to check.\nextensions : set[str]\n    Set of file extensions (with leading dots) to match against.\n\nReturns\n-------\nbool\n    True if the path ends with one of the extensions (case-insensitive),\n    False otherwise.",
  "is_public": false
}
{
  "path": "mcp_server/adapters/history.py",
  "module": "mcp_server.adapters.history",
  "qualname": "mcp_server.adapters.history",
  "name": "mcp_server.adapters.history",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Git history adapter for blame and log operations.\n\nProvides git blame and commit history using GitPython via GitClient.\nThis replaces subprocess-based Git operations with typed Python APIs for\nbetter performance (50-80ms latency reduction) and reliability.",
  "is_public": true
}
{
  "path": "mcp_server/adapters/history.py",
  "module": "mcp_server.adapters.history",
  "qualname": "blame_range",
  "name": "blame_range",
  "node_type": "AsyncFunctionDef",
  "lineno": 24,
  "col": 0,
  "end_lineno": 116,
  "end_col": 29,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Get git blame for line range using GitPython (async).\n\nUses AsyncGitClient for typed Git operations, providing structured data returns\nwithout subprocess overhead. This is faster and more reliable than parsing\ngit blame porcelain output. The async implementation enables concurrent Git\noperations without blocking the event loop.\n\nParameters\n----------\ncontext : ApplicationContext\n    Application context containing GitClient and repo root.\npath : str\n    File path relative to repo root.\nstart_line : int\n    Start line (1-indexed, inclusive).\nend_line : int\n    End line (1-indexed, inclusive).\n\nReturns\n-------\ndict\n    Dictionary with \"blame\" key containing list of GitBlameEntry dicts.\n\nRaises\n------\nGitOperationError\n    If Git blame operation fails. This function calls ``resolve_within_repo``\n    which may raise ``PathOutsideRepositoryError``. If the requested path\n    does not exist, ``PathNotFoundError`` is raised.\nPathNotFoundError\n    If the requested file path does not exist within the repository.\n\nExamples\n--------\n>>> result = blame_range(context, \"README.md\", 1, 10)\n>>> isinstance(result[\"blame\"], list)\nTrue\n>>> entry = result[\"blame\"][0]\n>>> \"line\" in entry and \"author\" in entry\nTrue\n\nNotes\n-----\nAsync Pattern:\n- Uses AsyncGitClient which wraps GitClient operations in asyncio.to_thread.\n- This prevents blocking the event loop and enables concurrent Git operations.",
  "is_public": true
}
{
  "path": "mcp_server/adapters/history.py",
  "module": "mcp_server.adapters.history",
  "qualname": "file_history",
  "name": "file_history",
  "node_type": "AsyncFunctionDef",
  "lineno": 119,
  "col": 0,
  "end_lineno": 200,
  "end_col": 31,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Get commit history for file using GitPython (async).\n\nUses AsyncGitClient for typed Git operations, providing structured commit data\nwithout subprocess overhead or text parsing. This is faster and more\nreliable than parsing git log output. The async implementation enables\nconcurrent Git operations without blocking the event loop.\n\nParameters\n----------\ncontext : ApplicationContext\n    Application context containing GitClient and repo root.\npath : str\n    File path relative to repo root.\nlimit : int, optional\n    Maximum number of commits to return (default: 50).\n\nReturns\n-------\ndict\n    Dictionary with \"commits\" key containing list of commit dicts with\n    fields: sha, full_sha, author, email, date, message.\n\nRaises\n------\nGitOperationError\n    If Git log operation fails. This function calls ``resolve_within_repo``\n    which may raise ``PathOutsideRepositoryError``. If the requested path\n    does not exist, ``PathNotFoundError`` is raised.\nPathNotFoundError\n    If the requested file path does not exist within the repository.\n\nExamples\n--------\n>>> result = file_history(context, \"README.md\", limit=10)\n>>> isinstance(result[\"commits\"], list)\nTrue\n>>> commit = result[\"commits\"][0]\n>>> \"sha\" in commit and \"author\" in commit\nTrue\n\nNotes\n-----\nAsync Pattern:\n- Uses AsyncGitClient which wraps GitClient operations in asyncio.to_thread.\n- This prevents blocking the event loop and enables concurrent Git operations.",
  "is_public": true
}
{
  "path": "mcp_server/adapters/semantic.py",
  "module": "mcp_server.adapters.semantic",
  "qualname": "mcp_server.adapters.semantic",
  "name": "mcp_server.adapters.semantic",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Semantic search adapter using FAISS GPU and DuckDB.\n\nImplements semantic code search by embedding queries and searching\nthe FAISS index, then hydrating results from DuckDB.",
  "is_public": true
}
{
  "path": "mcp_server/adapters/semantic.py",
  "module": "mcp_server.adapters.semantic",
  "qualname": "_ScopeFilterFlags",
  "name": "_ScopeFilterFlags",
  "node_type": "ClassDef",
  "lineno": 65,
  "col": 0,
  "end_lineno": 96,
  "end_col": 85,
  "parent_qualname": null,
  "decorators": [
    "dataclass(frozen=True)"
  ],
  "bases": [],
  "docstring": "Aggregated boolean flags describing the active scope filters.",
  "is_public": false
}
{
  "path": "mcp_server/adapters/semantic.py",
  "module": "mcp_server.adapters.semantic",
  "qualname": "_ScopeFilterFlags.from_scope",
  "name": "from_scope",
  "node_type": "FunctionDef",
  "lineno": 73,
  "col": 4,
  "end_lineno": 91,
  "end_col": 9,
  "parent_qualname": "_ScopeFilterFlags",
  "decorators": [
    "classmethod"
  ],
  "bases": [],
  "docstring": "Create flags from an optional ``ScopeIn`` dictionary.\n\nParameters\n----------\nscope : ScopeIn | None\n    Optional scope dictionary containing include_globs, exclude_globs,\n    or languages keys.\n\nReturns\n-------\n_ScopeFilterFlags\n    Flags instance indicating which scope filters are present.",
  "is_public": true
}
{
  "path": "mcp_server/adapters/semantic.py",
  "module": "mcp_server.adapters.semantic",
  "qualname": "_ScopeFilterFlags.has_filters",
  "name": "has_filters",
  "node_type": "FunctionDef",
  "lineno": 94,
  "col": 4,
  "end_lineno": 96,
  "end_col": 85,
  "parent_qualname": "_ScopeFilterFlags",
  "decorators": [
    "property"
  ],
  "bases": [],
  "docstring": "Return ``True`` when any of the scope filters are active.",
  "is_public": true
}
{
  "path": "mcp_server/adapters/semantic.py",
  "module": "mcp_server.adapters.semantic",
  "qualname": "_FaissFanout",
  "name": "_FaissFanout",
  "node_type": "ClassDef",
  "lineno": 100,
  "col": 0,
  "end_lineno": 104,
  "end_col": 23,
  "parent_qualname": null,
  "decorators": [
    "dataclass(frozen=True)"
  ],
  "bases": [],
  "docstring": "FAISS fan-out plan produced for a semantic search request.",
  "is_public": false
}
{
  "path": "mcp_server/adapters/semantic.py",
  "module": "mcp_server.adapters.semantic",
  "qualname": "_HybridSearchState",
  "name": "_HybridSearchState",
  "node_type": "ClassDef",
  "lineno": 108,
  "col": 0,
  "end_lineno": 117,
  "end_col": 21,
  "parent_qualname": null,
  "decorators": [
    "dataclass(frozen=True)"
  ],
  "bases": [],
  "docstring": "Encapsulate the outputs of FAISS prior to hybrid re-ranking.",
  "is_public": false
}
{
  "path": "mcp_server/adapters/semantic.py",
  "module": "mcp_server.adapters.semantic",
  "qualname": "_HybridResult",
  "name": "_HybridResult",
  "node_type": "ClassDef",
  "lineno": 121,
  "col": 0,
  "end_lineno": 128,
  "end_col": 29,
  "parent_qualname": null,
  "decorators": [
    "dataclass(frozen=True)"
  ],
  "bases": [],
  "docstring": "Hydration payload returned after hybrid re-ranking.",
  "is_public": false
}
{
  "path": "mcp_server/adapters/semantic.py",
  "module": "mcp_server.adapters.semantic",
  "qualname": "_SemanticPipelineResult",
  "name": "_SemanticPipelineResult",
  "node_type": "ClassDef",
  "lineno": 132,
  "col": 0,
  "end_lineno": 139,
  "end_col": 30,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "mcp_server/adapters/semantic.py",
  "module": "mcp_server.adapters.semantic",
  "qualname": "_FaissStageResult",
  "name": "_FaissStageResult",
  "node_type": "ClassDef",
  "lineno": 143,
  "col": 0,
  "end_lineno": 148,
  "end_col": 31,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Outputs from the FAISS stage before hybrid reranking.",
  "is_public": false
}
{
  "path": "mcp_server/adapters/semantic.py",
  "module": "mcp_server.adapters.semantic",
  "qualname": "_HydrationOutcome",
  "name": "_HydrationOutcome",
  "node_type": "ClassDef",
  "lineno": 152,
  "col": 0,
  "end_lineno": 157,
  "end_col": 22,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "DuckDB hydration outcome with duration metadata.",
  "is_public": false
}
{
  "path": "mcp_server/adapters/semantic.py",
  "module": "mcp_server.adapters.semantic",
  "qualname": "_SemanticPipelineRequest",
  "name": "_SemanticPipelineRequest",
  "node_type": "ClassDef",
  "lineno": 161,
  "col": 0,
  "end_lineno": 167,
  "end_col": 29,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "mcp_server/adapters/semantic.py",
  "module": "mcp_server.adapters.semantic",
  "qualname": "_SearchBudget",
  "name": "_SearchBudget",
  "node_type": "ClassDef",
  "lineno": 171,
  "col": 0,
  "end_lineno": 177,
  "end_col": 21,
  "parent_qualname": null,
  "decorators": [
    "dataclass(frozen=True)"
  ],
  "bases": [],
  "docstring": "Typed representation of the effective limit and metadata.",
  "is_public": false
}
{
  "path": "mcp_server/adapters/semantic.py",
  "module": "mcp_server.adapters.semantic",
  "qualname": "_SemanticSearchPlan",
  "name": "_SemanticSearchPlan",
  "node_type": "ClassDef",
  "lineno": 181,
  "col": 0,
  "end_lineno": 190,
  "end_col": 21,
  "parent_qualname": null,
  "decorators": [
    "dataclass(frozen=True)"
  ],
  "bases": [],
  "docstring": "Bundled semantic search parameters derived from scope and settings.",
  "is_public": false
}
{
  "path": "mcp_server/adapters/semantic.py",
  "module": "mcp_server.adapters.semantic",
  "qualname": "_MethodContext",
  "name": "_MethodContext",
  "node_type": "ClassDef",
  "lineno": 194,
  "col": 0,
  "end_lineno": 203,
  "end_col": 43,
  "parent_qualname": null,
  "decorators": [
    "dataclass(frozen=True)"
  ],
  "bases": [],
  "docstring": "Inputs required to build method metadata.",
  "is_public": false
}
{
  "path": "mcp_server/adapters/semantic.py",
  "module": "mcp_server.adapters.semantic",
  "qualname": "_FaissSearchRequest",
  "name": "_FaissSearchRequest",
  "node_type": "ClassDef",
  "lineno": 207,
  "col": 0,
  "end_lineno": 216,
  "end_col": 40,
  "parent_qualname": null,
  "decorators": [
    "dataclass(frozen=True)"
  ],
  "bases": [],
  "docstring": "Container describing a FAISS search invocation.",
  "is_public": false
}
{
  "path": "mcp_server/adapters/semantic.py",
  "module": "mcp_server.adapters.semantic",
  "qualname": "semantic_search",
  "name": "semantic_search",
  "node_type": "AsyncFunctionDef",
  "lineno": 219,
  "col": 0,
  "end_lineno": 283,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Perform semantic search using embeddings.\n\nApplies session scope filters during DuckDB hydration (if scope has path/language\nconstraints). FAISS search is performed without scope constraints (FAISS has no\nbuilt-in filtering), then results are filtered via DuckDB catalog queries.\n\nParameters\n----------\ncontext : ApplicationContext\n    Application context containing FAISS manager, vLLM client, and settings.\nquery : str\n    Search query text.\nlimit : int, optional\n    Maximum number of results to return. Defaults to 20.\n\nReturns\n-------\nAnswerEnvelope\n    Semantic search response payload with findings and applied scope.\n\nNotes\n-----\nThis function delegates to ``_semantic_search_sync`` which may raise\n``VectorSearchError`` or ``EmbeddingError``. Those exceptions are not\nexplicitly caught or re-raised by this async wrapper function.\n\nExamples\n--------\nBasic usage:\n\n>>> result = await semantic_search(context, \"data processing\")\n>>> isinstance(result[\"findings\"], list)\nTrue\n\nWith session scope:\n\n>>> set_scope(context, {\"languages\": [\"python\"], \"include_globs\": [\"src/**\"]})\n>>> result = await semantic_search(context, \"data processing\")\n>>> # Returns only Python chunks from src/ directory\n>>> result[\"scope\"][\"languages\"]\n['python']\n\nNotes\n-----\nScope Integration:\n- Session scope is retrieved from registry using session ID (set by middleware).\n- FAISS search is performed without scope constraints (FAISS has no built-in filtering).\n- Chunk IDs from FAISS are filtered via DuckDB catalog using scope's `include_globs`,\n  `exclude_globs`, and `languages` (see `query_by_filters` method).\n- Applied scope is included in response envelope (`scope` field) for transparency.\n- If no scope is set, searches all indexed chunks without filtering.",
  "is_public": true
}
{
  "path": "mcp_server/adapters/semantic.py",
  "module": "mcp_server.adapters.semantic",
  "qualname": "_semantic_search_sync",
  "name": "_semantic_search_sync",
  "node_type": "FunctionDef",
  "lineno": 286,
  "col": 0,
  "end_lineno": 413,
  "end_col": 23,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "mcp_server/adapters/semantic.py",
  "module": "mcp_server.adapters.semantic",
  "qualname": "_execute_semantic_pipeline",
  "name": "_execute_semantic_pipeline",
  "node_type": "FunctionDef",
  "lineno": 416,
  "col": 0,
  "end_lineno": 491,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "mcp_server/adapters/semantic.py",
  "module": "mcp_server.adapters.semantic",
  "qualname": "_run_faiss_stage",
  "name": "_run_faiss_stage",
  "node_type": "FunctionDef",
  "lineno": 494,
  "col": 0,
  "end_lineno": 537,
  "end_col": 73,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "mcp_server/adapters/semantic.py",
  "module": "mcp_server.adapters.semantic",
  "qualname": "_run_hydration_stage",
  "name": "_run_hydration_stage",
  "node_type": "FunctionDef",
  "lineno": 540,
  "col": 0,
  "end_lineno": 588,
  "end_col": 64,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Execute DuckDB hydration stage with instrumentation and error handling.\n\nThis function hydrates search result IDs with chunk metadata from DuckDB,\napplying scope filters and measuring duration. It is called during semantic\nsearch execution after hybrid reranking to enrich results with full chunk\ninformation. Used by semantic search adapters to isolate hydration logic.\n\nParameters\n----------\nrequest : _SemanticPipelineRequest\n    Semantic pipeline request containing context, scope, and timeline.\nhybrid_result : _HybridResult\n    Hybrid search result containing hydration IDs and scores.\ncatalog : DuckDBCatalog\n    DuckDB catalog instance for querying chunk metadata.\n\nReturns\n-------\n_HydrationOutcome\n    Outcome containing hydrated findings, any exception that occurred, and\n    hydration duration in milliseconds.",
  "is_public": false
}
{
  "path": "mcp_server/adapters/semantic.py",
  "module": "mcp_server.adapters.semantic",
  "qualname": "_clamp_result_limit",
  "name": "_clamp_result_limit",
  "node_type": "FunctionDef",
  "lineno": 591,
  "col": 0,
  "end_lineno": 617,
  "end_col": 36,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Enforce bounds on requested limit with explanatory metadata.\n\nParameters\n----------\nrequested_limit : int\n    Client supplied limit from the API call.\nmax_results : int\n    Globally configured maximum number of results.\n\nReturns\n-------\ntuple[int, list[str]]\n    Adjusted limit and zero or more informational messages describing why\n    truncation occurred.",
  "is_public": false
}
{
  "path": "mcp_server/adapters/semantic.py",
  "module": "mcp_server.adapters.semantic",
  "qualname": "_build_search_budget",
  "name": "_build_search_budget",
  "node_type": "FunctionDef",
  "lineno": 620,
  "col": 0,
  "end_lineno": 660,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Combine limit clamping and FAISS readiness metadata for a search.\n\nThis function constructs a search budget by clamping the requested limit to\nconfigured maximums and checking FAISS index readiness. It is called during\nsemantic search planning to ensure search operations respect resource limits\nand handle FAISS unavailability gracefully.\n\nParameters\n----------\ncontext : ApplicationContext\n    Application context providing settings and FAISS manager.\nrequested_limit : int\n    Requested result limit from client.\nobservation : Observation\n    Observation block reserved for future error tracking. Currently unused\n    but maintained for API consistency with other search planning functions.\n\nReturns\n-------\n_SearchBudget\n    Search budget containing effective limit, max results, and limits metadata.",
  "is_public": false
}
{
  "path": "mcp_server/adapters/semantic.py",
  "module": "mcp_server.adapters.semantic",
  "qualname": "_build_semantic_search_plan",
  "name": "_build_semantic_search_plan",
  "node_type": "FunctionDef",
  "lineno": 663,
  "col": 0,
  "end_lineno": 731,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Construct FAISS fan-out and tuning plan for a semantic search.\n\nParameters\n----------\ncontext : ApplicationContext\n    Application context containing settings and configuration.\nscope : ScopeIn | None\n    Optional scope dictionary with filters and tuning overrides.\nrequested_limit : int\n    Requested number of results from the search.\nobservation : Observation\n    Observation context for metrics and tracing.\n\nReturns\n-------\n_SemanticSearchPlan\n    Search plan containing scope flags, tuning overrides, limits metadata,\n    effective limit, FAISS fan-out parameters, and nprobe setting.",
  "is_public": false
}
{
  "path": "mcp_server/adapters/semantic.py",
  "module": "mcp_server.adapters.semantic",
  "qualname": "_calculate_faiss_fanout",
  "name": "_calculate_faiss_fanout",
  "node_type": "FunctionDef",
  "lineno": 734,
  "col": 0,
  "end_lineno": 768,
  "end_col": 48,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Compute FAISS fan-out (k) and the target expansion for filtering.\n\nParameters\n----------\neffective_limit : int\n    Limit after applying clamping rules.\nmax_results : int\n    System-wide cap on FAISS results.\nmultiplier : int\n    Semantic over-fetch multiplier configured in settings.\nscope_flags : _ScopeFilterFlags\n    Flags describing whether scope filters are active.\n\nReturns\n-------\n_FaissFanout\n    Fan-out plan containing both the actual FAISS ``k`` and the unclamped\n    ``k`` target prior to ``max_results`` enforcement.",
  "is_public": false
}
{
  "path": "mcp_server/adapters/semantic.py",
  "module": "mcp_server.adapters.semantic",
  "qualname": "_overfetch_bonus",
  "name": "_overfetch_bonus",
  "node_type": "FunctionDef",
  "lineno": 771,
  "col": 0,
  "end_lineno": 799,
  "end_col": 12,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Determine additional fan-out when scope filters may drop results.\n\nCalculates an over-fetch bonus to compensate for results that may be filtered\nout by scope filters (include/exclude globs, language filters). The bonus\nis higher when multiple filter types are active, as more results are likely\nto be filtered out.\n\nParameters\n----------\neffective_limit : int\n    Base number of results requested by the user.\nscope_flags : _ScopeFilterFlags\n    Flags indicating which types of scope filters are active (include globs,\n    exclude globs, language filters).\n\nReturns\n-------\nint\n    Additional results to fetch beyond effective_limit to account for filtering.\n    Returns effective_limit when both glob and language filters are active,\n    effective_limit // 2 when only one type is active, or 0 when no filters\n    are active.",
  "is_public": false
}
{
  "path": "mcp_server/adapters/semantic.py",
  "module": "mcp_server.adapters.semantic",
  "qualname": "_resolve_hybrid_results",
  "name": "_resolve_hybrid_results",
  "node_type": "FunctionDef",
  "lineno": 802,
  "col": 0,
  "end_lineno": 901,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Join hybrid retrieval results with the FAISS output when available.\n\nParameters\n----------\ncontext : ApplicationContext\n    Application context that can provide the hybrid search engine.\nstate : _HybridSearchState\n    FAISS search state carrying IDs, scores, query text, and applied limit.\nlimits_metadata : list[str]\n    Mutable metadata bucket for reporting search limitations.\nretrieval_channels : Sequence[str]\n    Base retrieval channels (semantic + FAISS).\n\nReturns\n-------\n_HybridResult\n    Hydration IDs, scores, optional hybrid contributions, and the final list of\n    retrieval channels that contributed to the answer.",
  "is_public": false
}
{
  "path": "mcp_server/adapters/semantic.py",
  "module": "mcp_server.adapters.semantic",
  "qualname": "_build_hybrid_result",
  "name": "_build_hybrid_result",
  "node_type": "FunctionDef",
  "lineno": 904,
  "col": 0,
  "end_lineno": 941,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Trim FAISS/hybrid candidates to the effective limit.\n\nParameters\n----------\nhydration : tuple[list[int], list[float]]\n    Candidate IDs and scores to trim.\nlimit : int\n    Maximum number of results to keep.\ncontribution_map : dict[int, list[tuple[str, int, float]]] | None\n    Optional map of contributions.\nretrieval_channels : Sequence[str]\n    Channels that participated in retrieval.\nmethod : MethodInfo | None\n    Hybrid method metadata.\n\nReturns\n-------\n_HybridResult\n    Trimmed result with IDs, scores, contribution map, and channels.",
  "is_public": false
}
{
  "path": "mcp_server/adapters/semantic.py",
  "module": "mcp_server.adapters.semantic",
  "qualname": "_embed_query_or_raise",
  "name": "_embed_query_or_raise",
  "node_type": "FunctionDef",
  "lineno": 944,
  "col": 0,
  "end_lineno": 981,
  "end_col": 20,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Embed text or raise with a structured embedding error.\n\nParameters\n----------\nclient : VLLMClient\n    vLLM client used to emit the embedding.\nquery : str\n    Query text to embed.\nobservation : Observation\n    Duration observation used for marking failure.\nvllm_url : str\n    URL used for diagnostics in error contexts.\n\nReturns\n-------\nNDArrayF32\n    Normalized query vector with shape (1, dim).\n\nRaises\n------\nEmbeddingError\n    If embedding fails or service is unavailable.",
  "is_public": false
}
{
  "path": "mcp_server/adapters/semantic.py",
  "module": "mcp_server.adapters.semantic",
  "qualname": "_run_faiss_search_or_raise",
  "name": "_run_faiss_search_or_raise",
  "node_type": "FunctionDef",
  "lineno": 984,
  "col": 0,
  "end_lineno": 1018,
  "end_col": 36,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Perform FAISS search and raise when the index search fails.\n\nExtended Summary\n----------------\nThis helper executes FAISS search with error handling and observation tracking.\nIt applies optional tuning overrides (from scope metadata), performs the search,\nand raises exceptions if search fails. Used by semantic search adapters to\nexecute FAISS queries with consistent error handling and telemetry.\n\nParameters\n----------\nrequest : _FaissSearchRequest\n    Prepared FAISS search request containing context, vector, limits, and overrides.\n\nReturns\n-------\ntuple[list[int], list[float]]\n    Chunk identifiers and their similarity scores.\n\nRaises\n------\nVectorSearchError\n    If FAISS search fails.",
  "is_public": false
}
{
  "path": "mcp_server/adapters/semantic.py",
  "module": "mcp_server.adapters.semantic",
  "qualname": "_ensure_hydration_success",
  "name": "_ensure_hydration_success",
  "node_type": "FunctionDef",
  "lineno": 1021,
  "col": 0,
  "end_lineno": 1053,
  "end_col": 22,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Stop execution when DuckDB hydration fails.\n\nParameters\n----------\nhydrate_exc : Exception | None\n    Exception returned from ``_hydrate_findings``.\nobservation : Observation\n    Observation used to mark the duration as failed.\ncontext : ApplicationContext\n    Context for building error metadata.\n\nRaises\n------\nCatalogConsistencyError\n    If hydration fails.",
  "is_public": false
}
{
  "path": "mcp_server/adapters/semantic.py",
  "module": "mcp_server.adapters.semantic",
  "qualname": "_warn_scope_filter_reduction",
  "name": "_warn_scope_filter_reduction",
  "node_type": "FunctionDef",
  "lineno": 1056,
  "col": 0,
  "end_lineno": 1091,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Log when scope filtering reduces the result set below the requested limit.\n\nParameters\n----------\nscope : ScopeIn | None\n    Applied scope configuration.\nscope_flags : _ScopeFilterFlags\n    Flags describing the active scope filters.\nfindings_count : int\n    Number of findings returned to the client.\neffective_limit : int\n    Limit applied after clamping.\nfaiss_result_count : int\n    Number of results returned from FAISS prior to filtering.",
  "is_public": false
}
{
  "path": "mcp_server/adapters/semantic.py",
  "module": "mcp_server.adapters.semantic",
  "qualname": "_annotate_hybrid_contributions",
  "name": "_annotate_hybrid_contributions",
  "node_type": "FunctionDef",
  "lineno": 1094,
  "col": 0,
  "end_lineno": 1122,
  "end_col": 71,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Attach hybrid contribution narratives to findings when available.\n\nParameters\n----------\nfindings : list[Finding]\n    Findings returned to the client.\ncontribution_map : dict[int, list[tuple[str, int, float]]] | None\n    Contribution information keyed by chunk id.\nrrf_k : int\n    Reciprocal rank fusion parameter used for the narrative.",
  "is_public": false
}
{
  "path": "mcp_server/adapters/semantic.py",
  "module": "mcp_server.adapters.semantic",
  "qualname": "_embed_query",
  "name": "_embed_query",
  "node_type": "FunctionDef",
  "lineno": 1125,
  "col": 0,
  "end_lineno": 1146,
  "end_col": 22,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Embed query text and return a normalized vector and error message.\n\nParameters\n----------\nclient : VLLMClient\n    vLLM client for generating embeddings.\nquery : str\n    Query text to embed.\n\nReturns\n-------\ntuple[NDArrayF32 | None, str | None]\n    Pair of (query_vector, error_message). Exactly one element will be ``None``.",
  "is_public": false
}
{
  "path": "mcp_server/adapters/semantic.py",
  "module": "mcp_server.adapters.semantic",
  "qualname": "_run_faiss_search",
  "name": "_run_faiss_search",
  "node_type": "FunctionDef",
  "lineno": 1149,
  "col": 0,
  "end_lineno": 1195,
  "end_col": 55,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Execute FAISS search and return result identifiers and scores.\n\nExtended Summary\n----------------\nThis helper executes FAISS search with error handling that returns exceptions\ninstead of raising them. It applies optional tuning overrides, performs the\nsearch, and returns results with any exception that occurred. Used by semantic\nsearch adapters when exceptions should be handled by callers rather than\npropagated immediately.\n\nParameters\n----------\nrequest : _FaissSearchRequest\n    Query vector of shape (1, vec_dim).\n\nReturns\n-------\ntuple[list[int], list[float], Exception | None]\n    Tuple of (chunk_ids, distances, error). ``error`` is ``None`` when the\n    search succeeds; otherwise it contains the triggering exception.",
  "is_public": false
}
{
  "path": "mcp_server/adapters/semantic.py",
  "module": "mcp_server.adapters.semantic",
  "qualname": "_normalize_scope_faiss_tuning",
  "name": "_normalize_scope_faiss_tuning",
  "node_type": "FunctionDef",
  "lineno": 1198,
  "col": 0,
  "end_lineno": 1260,
  "end_col": 30,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Normalize faiss_tuning payload from scope metadata.\n\nExtended Summary\n----------------\nThis helper normalizes FAISS tuning parameters from scope metadata by mapping\naliases to canonical key names and filtering unrecognized keys. It handles\nboth camelCase and snake_case variants (e.g., \"efSearch\" -> \"ef_search\") and\nvalidates parameter types. Used to extract tuning overrides from session scope\nfor application to FAISS searches.\n\nParameters\n----------\nraw : Mapping[str, object] | None\n    Raw tuning parameters from scope metadata. May contain aliases (e.g., \"efSearch\")\n    and unrecognized keys. If None, returns empty dict and empty list.\n\nReturns\n-------\ntuple[dict[str, float | int], list[str]]\n    Tuple of (normalized tuning parameters dict, list of unrecognized keys).\n    Normalized dict uses canonical key names (e.g., \"ef_search\" not \"efSearch\").\n    Unrecognized keys are returned for logging/debugging purposes.\n\nNotes\n-----\nThis helper ensures consistent parameter naming across the codebase by mapping\naliases to canonical names. Parameter values are validated as numeric (float or int).\nTime complexity: O(n) where n is the number of keys in raw.",
  "is_public": false
}
{
  "path": "mcp_server/adapters/semantic.py",
  "module": "mcp_server.adapters.semantic",
  "qualname": "_hydrate_findings",
  "name": "_hydrate_findings",
  "node_type": "FunctionDef",
  "lineno": 1263,
  "col": 0,
  "end_lineno": 1386,
  "end_col": 38,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Hydrate FAISS search results from DuckDB.\n\nApplies scope filters (path globs, languages) during chunk hydration if scope\nis provided. FAISS search is performed without scope constraints, then results\nare filtered via DuckDB catalog queries.\n\nParameters\n----------\ncontext : ApplicationContext\n    Application context for accessing DuckDB catalog.\nchunk_ids : Sequence[int]\n    Chunk identifiers from FAISS search.\nscores : Sequence[float]\n    Similarity scores aligned with chunk_ids.\nscope : ScopeIn | None, optional\n    Session scope with optional `include_globs`, `exclude_globs`, and `languages`\n    fields. If provided and contains filters, uses `query_by_filters` instead of\n    `query_by_ids`. Defaults to None.\ncatalog : DuckDBCatalog | None, optional\n    Reused DuckDB catalog connection. When ``None``, the helper opens a new\n    catalog via :meth:`ApplicationContext.open_catalog`.\n\nReturns\n-------\ntuple[list[Finding], Exception | None]\n    Findings constructed from the catalog and optional hydration exception.\n\nNotes\n-----\nScope Filtering:\n- If scope has `include_globs`, `exclude_globs`, or `languages`, uses\n  `catalog.query_by_filters()` to filter chunks by path patterns and file\n  extensions.\n- If scope is None or has no filters, uses `catalog.query_by_ids()` for\n  unfiltered retrieval (backward compatible).\n- Filtering happens during DuckDB hydration (post-FAISS), so FAISS search\n  may return more IDs than needed to compensate for filtering.\ncatalog provided : DuckDBCatalog | None\n    Existing DuckDB catalog to reuse. When ``None``, a new catalog instance\n    is opened via :meth:`ApplicationContext.open_catalog`.",
  "is_public": false
}
{
  "path": "mcp_server/adapters/semantic.py",
  "module": "mcp_server.adapters.semantic",
  "qualname": "_hydrate_findings._hydrate",
  "name": "_hydrate",
  "node_type": "FunctionDef",
  "lineno": 1313,
  "col": 4,
  "end_lineno": 1381,
  "end_col": 29,
  "parent_qualname": "_hydrate_findings",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "mcp_server/adapters/semantic.py",
  "module": "mcp_server.adapters.semantic",
  "qualname": "_build_method",
  "name": "_build_method",
  "node_type": "FunctionDef",
  "lineno": 1389,
  "col": 0,
  "end_lineno": 1423,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Build method metadata for the response.\n\nParameters\n----------\nfindings_count : int\n    Number of findings returned.\nrequested_limit : int\n    Requested result limit.\neffective_limit : int\n    Effective limit applied after clamping.\nstart_time : float\n    Search start time (monotonic clock).\nretrieval_channels : Sequence[str]\n    Retrieval systems that contributed to the final result set.\n\nReturns\n-------\nMethodInfo\n    Retrieval metadata describing semantic search coverage.",
  "is_public": false
}
{
  "path": "mcp_server/adapters/semantic.py",
  "module": "mcp_server.adapters.semantic",
  "qualname": "_make_envelope",
  "name": "_make_envelope",
  "node_type": "FunctionDef",
  "lineno": 1426,
  "col": 0,
  "end_lineno": 1476,
  "end_col": 19,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Construct an AnswerEnvelope with optional metadata.\n\nParameters\n----------\nfindings : Sequence[Finding]\n    Search findings.\nanswer : str\n    Answer text.\nconfidence : float\n    Confidence score (0.0 to 1.0).\nextras : dict[str, object] | None, optional\n    Additional envelope fields (for example ``limits``, ``method``, or\n    ``problem`` metadata). Defaults to None.\n\nReturns\n-------\nAnswerEnvelope\n    Response payload ready for MCP clients.",
  "is_public": false
}
{
  "path": "mcp_server/adapters/semantic.py",
  "module": "mcp_server.adapters.semantic",
  "qualname": "_observability_links",
  "name": "_observability_links",
  "node_type": "FunctionDef",
  "lineno": 1479,
  "col": 0,
  "end_lineno": 1508,
  "end_col": 17,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return trace/run metadata for AnswerEnvelope extras.\n\nParameters\n----------\ntimeline : Timeline | None\n    Optional timeline object containing run metadata. If None, metadata\n    is extracted from the current context (trace ID, span ID, run ID, session ID).\n\nReturns\n-------\nAnswerEnvelope\n    Observability extras populated with trace/run diagnostics.",
  "is_public": false
}
{
  "path": "mcp_server/adapters/semantic.py",
  "module": "mcp_server.adapters.semantic",
  "qualname": "build_observability_links",
  "name": "build_observability_links",
  "node_type": "FunctionDef",
  "lineno": 1511,
  "col": 0,
  "end_lineno": 1525,
  "end_col": 41,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return observability extras for semantic responses.\n\nParameters\n----------\ntimeline : Timeline | None\n    Optional timeline object containing run metadata. If None, metadata\n    is extracted from the current context (trace ID, span ID, run ID, session ID).\n\nReturns\n-------\nAnswerEnvelope\n    Extras populated with trace/run metadata.",
  "is_public": true
}
{
  "path": "mcp_server/adapters/semantic.py",
  "module": "mcp_server.adapters.semantic",
  "qualname": "_success_extras",
  "name": "_success_extras",
  "node_type": "FunctionDef",
  "lineno": 1528,
  "col": 0,
  "end_lineno": 1549,
  "end_col": 17,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Build a success extras payload with optional limits metadata.\n\nParameters\n----------\nlimits : Sequence[str]\n    Search limitations or warnings.\nmethod : MethodInfo\n    Retrieval metadata to include in the response.\n\nReturns\n-------\ndict[str, object]\n    Extras payload including method metadata and optional limits.",
  "is_public": false
}
{
  "path": "mcp_server/adapters/semantic.py",
  "module": "mcp_server.adapters.semantic",
  "qualname": "_build_response_extras",
  "name": "_build_response_extras",
  "node_type": "FunctionDef",
  "lineno": 1552,
  "col": 0,
  "end_lineno": 1597,
  "end_col": 17,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Build extras payload including method metadata and optional scope.\n\nParameters\n----------\ncontext : _MethodContext\n    Context values required to build method metadata.\nlimits : Sequence[str]\n    Search limitations or warnings.\nscope : ScopeIn | None\n    Optional scope configuration to include in extras.\n\nReturns\n-------\ndict[str, object]\n    Extras payload dictionary containing method metadata and optional scope.",
  "is_public": false
}
{
  "path": "mcp_server/adapters/semantic_pro.py",
  "module": "mcp_server.adapters.semantic_pro",
  "qualname": "mcp_server.adapters.semantic_pro",
  "name": "mcp_server.adapters.semantic_pro",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Two-stage semantic search (CodeRank  optional WARP  optional reranker).",
  "is_public": true
}
{
  "path": "mcp_server/adapters/semantic_pro.py",
  "module": "mcp_server.adapters.semantic_pro",
  "qualname": "RerankOptionPayload",
  "name": "RerankOptionPayload",
  "node_type": "ClassDef",
  "lineno": 65,
  "col": 0,
  "end_lineno": 71,
  "end_col": 17,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "TypedDict"
  ],
  "docstring": "User-facing payload for overruling rerank behavior.",
  "is_public": true
}
{
  "path": "mcp_server/adapters/semantic_pro.py",
  "module": "mcp_server.adapters.semantic_pro",
  "qualname": "SemanticProOptions",
  "name": "SemanticProOptions",
  "node_type": "ClassDef",
  "lineno": 74,
  "col": 0,
  "end_lineno": 83,
  "end_col": 31,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "TypedDict"
  ],
  "docstring": "User-facing options for semantic_pro retrieval.",
  "is_public": true
}
{
  "path": "mcp_server/adapters/semantic_pro.py",
  "module": "mcp_server.adapters.semantic_pro",
  "qualname": "RerankRuntimeOptions",
  "name": "RerankRuntimeOptions",
  "node_type": "ClassDef",
  "lineno": 87,
  "col": 0,
  "end_lineno": 93,
  "end_col": 31,
  "parent_qualname": null,
  "decorators": [
    "dataclass(frozen=True)"
  ],
  "bases": [],
  "docstring": "Runtime overrides for optional reranker stage.",
  "is_public": true
}
{
  "path": "mcp_server/adapters/semantic_pro.py",
  "module": "mcp_server.adapters.semantic_pro",
  "qualname": "RerankPlan",
  "name": "RerankPlan",
  "node_type": "ClassDef",
  "lineno": 97,
  "col": 0,
  "end_lineno": 104,
  "end_col": 29,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Concrete rerank execution plan derived from settings + overrides.",
  "is_public": true
}
{
  "path": "mcp_server/adapters/semantic_pro.py",
  "module": "mcp_server.adapters.semantic_pro",
  "qualname": "SemanticProRuntimeOptions",
  "name": "SemanticProRuntimeOptions",
  "node_type": "ClassDef",
  "lineno": 108,
  "col": 0,
  "end_lineno": 117,
  "end_col": 46,
  "parent_qualname": null,
  "decorators": [
    "dataclass(frozen=True)"
  ],
  "bases": [],
  "docstring": "Internal immutable representation of semantic_pro options.",
  "is_public": true
}
{
  "path": "mcp_server/adapters/semantic_pro.py",
  "module": "mcp_server.adapters.semantic_pro",
  "qualname": "StageOnePlan",
  "name": "StageOnePlan",
  "node_type": "ClassDef",
  "lineno": 124,
  "col": 0,
  "end_lineno": 132,
  "end_col": 40,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Container for Stage-1 orchestration inputs to reduce argument lists.",
  "is_public": true
}
{
  "path": "mcp_server/adapters/semantic_pro.py",
  "module": "mcp_server.adapters.semantic_pro",
  "qualname": "HydrationPlan",
  "name": "HydrationPlan",
  "node_type": "ClassDef",
  "lineno": 136,
  "col": 0,
  "end_lineno": 145,
  "end_col": 28,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Hydration plus rerank inputs passed as a cohesive plan.",
  "is_public": true
}
{
  "path": "mcp_server/adapters/semantic_pro.py",
  "module": "mcp_server.adapters.semantic_pro",
  "qualname": "HydrationOutcome",
  "name": "HydrationOutcome",
  "node_type": "ClassDef",
  "lineno": 149,
  "col": 0,
  "end_lineno": 153,
  "end_col": 30,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Result of DuckDB hydration and optional LLM rerank.",
  "is_public": true
}
{
  "path": "mcp_server/adapters/semantic_pro.py",
  "module": "mcp_server.adapters.semantic_pro",
  "qualname": "build_runtime_options",
  "name": "build_runtime_options",
  "node_type": "FunctionDef",
  "lineno": 156,
  "col": 0,
  "end_lineno": 235,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Normalize user-supplied options into an immutable dataclass.\n\nExtended Summary\n----------------\nThis function converts user-facing TypedDict options into an internal immutable\ndataclass representation with defaults applied. It serves as the boundary between\nthe MCP server's request schema and the internal retrieval pipeline, ensuring\ntype safety and providing sensible defaults for optional configuration. The\nfunction is called once per semantic_pro request to prepare runtime options\nfor the two-stage retrieval pipeline (CodeRank  optional WARP  optional reranker).\n\nParameters\n----------\noptions : SemanticProOptions | None\n    User-supplied options dictionary. May be ``None`` to use all defaults.\n    Keys include: ``use_coderank`` (default True), ``use_warp`` (default True),\n    ``use_reranker`` (default False), ``stage_weights`` (default empty dict),\n    ``explain`` (default True). Missing keys are filled with defaults.\n\nReturns\n-------\nSemanticProRuntimeOptions\n    Immutable dataclass instance with normalized options. All fields have\n    defaults applied, ensuring the returned value is always valid for pipeline\n    execution.\n\nNotes\n-----\nTime complexity O(1). No I/O or side effects. The function performs a shallow\ncopy of stage_weights to ensure immutability of the returned dataclass.\n\nExamples\n--------\n>>> opts = build_runtime_options(None)\n>>> opts.use_coderank\nTrue\n>>> opts.use_warp\nTrue\n>>> opts.use_reranker\nFalse\n>>> user_opts = {\"use_warp\": False, \"use_reranker\": True}\n>>> opts = build_runtime_options(user_opts)\n>>> opts.use_warp\nFalse\n>>> opts.use_reranker\nTrue",
  "is_public": true
}
{
  "path": "mcp_server/adapters/semantic_pro.py",
  "module": "mcp_server.adapters.semantic_pro",
  "qualname": "_summarize_options",
  "name": "_summarize_options",
  "node_type": "FunctionDef",
  "lineno": 238,
  "col": 0,
  "end_lineno": 248,
  "end_col": 18,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "mcp_server/adapters/semantic_pro.py",
  "module": "mcp_server.adapters.semantic_pro",
  "qualname": "semantic_search_pro",
  "name": "semantic_search_pro",
  "node_type": "AsyncFunctionDef",
  "lineno": 251,
  "col": 0,
  "end_lineno": 341,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Execute the two-stage semantic search pipeline (CodeRank  optional WARP  optional reranker).\n\nExtended Summary\n----------------\nThis async function orchestrates the semantic_pro retrieval pipeline, which combines\nCodeRank dense vector search with optional WARP late-interaction reranking and optional\nCodeRankLLM listwise reranking. The function normalizes options, resolves scope filters,\nexecutes stages conditionally based on gating logic and user preferences, fuses results\nusing weighted RRF, hydrates metadata from DuckDB, and assembles the final AnswerEnvelope\nwith findings, explanations, and telemetry. It is the primary entry point for semantic\ncode search in the MCP server, providing high-quality ranked results with explainability\nand performance budgets.\n\nParameters\n----------\ncontext : ApplicationContext\n    Application context containing settings, paths, and initialized components\n    (FAISS managers, embedders, catalog). Must have valid CodeRank FAISS index\n    and catalog configured.\nquery : str\n    Natural language search query. Will be embedded using CodeRank embedder\n    and optionally processed by WARP for late-interaction scoring.\nlimit : int\n    Maximum number of results to return. Will be clamped to the configured\n    max_results limit. Must be positive.\noptions : SemanticProOptions | None, optional\n    User-supplied pipeline options. Controls which stages run (use_coderank,\n    use_warp, use_reranker), fusion weights (stage_weights), and whether to\n    include explanations (explain). Defaults to None (all defaults applied).\n\nReturns\n-------\nAnswerEnvelope\n    Search results envelope containing:\n    - ``answer``: Human-readable summary string\n    - ``findings``: List of Finding objects with location, snippet, score, and optional why\n    - ``method``: Retrieval metadata including channels used, coverage, and stage timings\n    - ``limits``: Optional list of warnings about budget overruns or limit clamping\n    - ``scope``: Optional scope filters that were applied\n    - ``query_kind``: Always \"semantic_pro\"\n    - ``confidence``: Float between 0.0 and 1.0\n\nRaises\n------\nVectorSearchError\n    If limit is not positive, CodeRank FAISS index is missing, search fails,\n    or DuckDB hydration fails. All errors include Problem Details context.\n\nNotes\n-----\nTime complexity dominated by I/O: embedding (O(1) queries), FAISS search (O(k log n)\nwhere k is fanout and n is index size), WARP reranking (O(m * d) where m is candidates\nand d is sequence length), fusion (O(n * c) where n is hits and c is channels), DuckDB\nhydration (O(r) where r is result count), optional reranking (O(r * model_latency)).\nThe function performs extensive I/O (FAISS, DuckDB, optional GPU models) and is not\nthread-safe (uses context managers and shared state). Performance budgets are tracked\nper stage and violations are reported in the limits field. The function uses asyncio\nto offload synchronous work to a thread pool. Note that EmbeddingError may be propagated\nfrom downstream functions (e.g., CodeRank embedder failures) but is wrapped as VectorSearchError\nat the API boundary.\n\nExamples\n--------\n>>> # Minimal example (requires ApplicationContext setup)\n>>> # from codeintel_rev.app.config_context import ApplicationContext\n>>> # context = ApplicationContext(...)\n>>> # results = await semantic_search_pro(context, query=\"vector store\", limit=10)\n>>> # assert results[\"query_kind\"] == \"semantic_pro\"\n>>> # assert len(results[\"findings\"]) <= 10",
  "is_public": true
}
{
  "path": "mcp_server/adapters/semantic_pro.py",
  "module": "mcp_server.adapters.semantic_pro",
  "qualname": "_semantic_search_pro_sync",
  "name": "_semantic_search_pro_sync",
  "node_type": "FunctionDef",
  "lineno": 344,
  "col": 0,
  "end_lineno": 536,
  "end_col": 13,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "mcp_server/adapters/semantic_pro.py",
  "module": "mcp_server.adapters.semantic_pro",
  "qualname": "_semantic_search_pro_sync._finish",
  "name": "_finish",
  "node_type": "FunctionDef",
  "lineno": 359,
  "col": 4,
  "end_lineno": 371,
  "end_col": 23,
  "parent_qualname": "_semantic_search_pro_sync",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "mcp_server/adapters/semantic_pro.py",
  "module": "mcp_server.adapters.semantic_pro",
  "qualname": "_run_coderank_stage",
  "name": "_run_coderank_stage",
  "node_type": "FunctionDef",
  "lineno": 539,
  "col": 0,
  "end_lineno": 604,
  "end_col": 15,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "mcp_server/adapters/semantic_pro.py",
  "module": "mcp_server.adapters.semantic_pro",
  "qualname": "_timed_coderank_stage",
  "name": "_timed_coderank_stage",
  "node_type": "FunctionDef",
  "lineno": 607,
  "col": 0,
  "end_lineno": 624,
  "end_col": 33,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "mcp_server/adapters/semantic_pro.py",
  "module": "mcp_server.adapters.semantic_pro",
  "qualname": "_maybe_run_warp",
  "name": "_maybe_run_warp",
  "node_type": "FunctionDef",
  "lineno": 627,
  "col": 0,
  "end_lineno": 649,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "mcp_server/adapters/semantic_pro.py",
  "module": "mcp_server.adapters.semantic_pro",
  "qualname": "_should_execute_stage_two",
  "name": "_should_execute_stage_two",
  "node_type": "FunctionDef",
  "lineno": 652,
  "col": 0,
  "end_lineno": 703,
  "end_col": 22,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "mcp_server/adapters/semantic_pro.py",
  "module": "mcp_server.adapters.semantic_pro",
  "qualname": "_execute_stage_two",
  "name": "_execute_stage_two",
  "node_type": "FunctionDef",
  "lineno": 706,
  "col": 0,
  "end_lineno": 737,
  "end_col": 18,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "mcp_server/adapters/semantic_pro.py",
  "module": "mcp_server.adapters.semantic_pro",
  "qualname": "_run_fusion_stage",
  "name": "_run_fusion_stage",
  "node_type": "FunctionDef",
  "lineno": 740,
  "col": 0,
  "end_lineno": 771,
  "end_col": 16,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "mcp_server/adapters/semantic_pro.py",
  "module": "mcp_server.adapters.semantic_pro",
  "qualname": "_maybe_apply_rerank_stage",
  "name": "_maybe_apply_rerank_stage",
  "node_type": "FunctionDef",
  "lineno": 774,
  "col": 0,
  "end_lineno": 848,
  "end_col": 37,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "mcp_server/adapters/semantic_pro.py",
  "module": "mcp_server.adapters.semantic_pro",
  "qualname": "_RerankOutcome",
  "name": "_RerankOutcome",
  "node_type": "ClassDef",
  "lineno": 852,
  "col": 0,
  "end_lineno": 854,
  "end_col": 16,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "mcp_server/adapters/semantic_pro.py",
  "module": "mcp_server.adapters.semantic_pro",
  "qualname": "_reorder_docs",
  "name": "_reorder_docs",
  "node_type": "FunctionDef",
  "lineno": 857,
  "col": 0,
  "end_lineno": 896,
  "end_col": 65,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "mcp_server/adapters/semantic_pro.py",
  "module": "mcp_server.adapters.semantic_pro",
  "qualname": "_emit_rerank_decision",
  "name": "_emit_rerank_decision",
  "node_type": "FunctionDef",
  "lineno": 899,
  "col": 0,
  "end_lineno": 902,
  "end_col": 60,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "mcp_server/adapters/semantic_pro.py",
  "module": "mcp_server.adapters.semantic_pro",
  "qualname": "_build_rerank_plan",
  "name": "_build_rerank_plan",
  "node_type": "FunctionDef",
  "lineno": 905,
  "col": 0,
  "end_lineno": 923,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "mcp_server/adapters/semantic_pro.py",
  "module": "mcp_server.adapters.semantic_pro",
  "qualname": "_resolve_reranker",
  "name": "_resolve_reranker",
  "node_type": "FunctionDef",
  "lineno": 926,
  "col": 0,
  "end_lineno": 938,
  "end_col": 29,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "mcp_server/adapters/semantic_pro.py",
  "module": "mcp_server.adapters.semantic_pro",
  "qualname": "_maybe_schedule_xtr_wide",
  "name": "_maybe_schedule_xtr_wide",
  "node_type": "FunctionDef",
  "lineno": 941,
  "col": 0,
  "end_lineno": 971,
  "end_col": 27,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "mcp_server/adapters/semantic_pro.py",
  "module": "mcp_server.adapters.semantic_pro",
  "qualname": "_resolve_stage_one_outcome",
  "name": "_resolve_stage_one_outcome",
  "node_type": "FunctionDef",
  "lineno": 974,
  "col": 0,
  "end_lineno": 1049,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Resolve Stage-1 orchestration outcome from a StageOnePlan.\n\nExtended Summary\n----------------\nThis function orchestrates the resolution of Stage-1 search outcomes, coordinating\nbetween wide-mode XTR search (if initiated) and narrow-mode Stage-2 execution.\nIt evaluates whether Stage-2 should run based on candidate quality and options,\nhandles wide search futures, and falls back to narrow mode when wide search fails\nor is not available. The function manages executor lifecycle and aggregates notes\nfrom both stages, producing a unified WarpOutcome for downstream processing.\n\nParameters\n----------\nplan : StageOnePlan\n    Container holding Stage-1 orchestration inputs including context, query,\n    candidates, options, coderank timing, and optional wide search handle.\n    The plan encapsulates all state needed to resolve the search outcome.\n\nReturns\n-------\nWarpOutcome\n    Outcome describing hits, notes, timing, explainability, and channel.\n    The outcome aggregates results from wide search (if successful) or Stage-2\n    execution, with notes from both stages combined.\n\nNotes\n-----\nTime complexity depends on search mode: O(1) if Stage-2 is skipped, O(C * T * D)\nfor narrow mode where C is candidate count, T is tokens, D is embedding dimension.\nSpace complexity O(k) for results where k is the effective limit. The function\nperforms I/O via wide search future and Stage-2 execution. Executor shutdown is\nbest-effort (wait=False) to avoid blocking. Thread-safe for concurrent plan\nprocessing. Handles wide search failures gracefully by falling back to narrow mode.",
  "is_public": false
}
{
  "path": "mcp_server/adapters/semantic_pro.py",
  "module": "mcp_server.adapters.semantic_pro",
  "qualname": "_run_xtr_wide_stage",
  "name": "_run_xtr_wide_stage",
  "node_type": "FunctionDef",
  "lineno": 1052,
  "col": 0,
  "end_lineno": 1081,
  "end_col": 18,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "mcp_server/adapters/semantic_pro.py",
  "module": "mcp_server.adapters.semantic_pro",
  "qualname": "_calculate_xtr_k",
  "name": "_calculate_xtr_k",
  "node_type": "FunctionDef",
  "lineno": 1084,
  "col": 0,
  "end_lineno": 1088,
  "end_col": 32,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "mcp_server/adapters/semantic_pro.py",
  "module": "mcp_server.adapters.semantic_pro",
  "qualname": "_build_extra_channels",
  "name": "_build_extra_channels",
  "node_type": "FunctionDef",
  "lineno": 1091,
  "col": 0,
  "end_lineno": 1108,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "mcp_server/adapters/semantic_pro.py",
  "module": "mcp_server.adapters.semantic_pro",
  "qualname": "_append_budget_notes",
  "name": "_append_budget_notes",
  "node_type": "FunctionDef",
  "lineno": 1111,
  "col": 0,
  "end_lineno": 1123,
  "end_col": 13,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "mcp_server/adapters/semantic_pro.py",
  "module": "mcp_server.adapters.semantic_pro",
  "qualname": "_safe_int",
  "name": "_safe_int",
  "node_type": "FunctionDef",
  "lineno": 1126,
  "col": 0,
  "end_lineno": 1131,
  "end_col": 45,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "mcp_server/adapters/semantic_pro.py",
  "module": "mcp_server.adapters.semantic_pro",
  "qualname": "_merge_rrf_weights",
  "name": "_merge_rrf_weights",
  "node_type": "FunctionDef",
  "lineno": 1134,
  "col": 0,
  "end_lineno": 1147,
  "end_col": 18,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "mcp_server/adapters/semantic_pro.py",
  "module": "mcp_server.adapters.semantic_pro",
  "qualname": "_run_warp_stage",
  "name": "_run_warp_stage",
  "node_type": "FunctionDef",
  "lineno": 1150,
  "col": 0,
  "end_lineno": 1170,
  "end_col": 50,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "mcp_server/adapters/semantic_pro.py",
  "module": "mcp_server.adapters.semantic_pro",
  "qualname": "_warp_executor_hits",
  "name": "_warp_executor_hits",
  "node_type": "FunctionDef",
  "lineno": 1173,
  "col": 0,
  "end_lineno": 1211,
  "end_col": 22,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "mcp_server/adapters/semantic_pro.py",
  "module": "mcp_server.adapters.semantic_pro",
  "qualname": "_xtr_rescore_hits",
  "name": "_xtr_rescore_hits",
  "node_type": "FunctionDef",
  "lineno": 1214,
  "col": 0,
  "end_lineno": 1259,
  "end_col": 39,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "mcp_server/adapters/semantic_pro.py",
  "module": "mcp_server.adapters.semantic_pro",
  "qualname": "_hydrate_records",
  "name": "_hydrate_records",
  "node_type": "FunctionDef",
  "lineno": 1262,
  "col": 0,
  "end_lineno": 1283,
  "end_col": 46,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "mcp_server/adapters/semantic_pro.py",
  "module": "mcp_server.adapters.semantic_pro",
  "qualname": "_hydrate_and_rerank_records",
  "name": "_hydrate_and_rerank_records",
  "node_type": "FunctionDef",
  "lineno": 1286,
  "col": 0,
  "end_lineno": 1451,
  "end_col": 63,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Hydrate DuckDB records and optionally rerank them using CodeRankLLM.\n\nExtended Summary\n----------------\nThis function performs the hydration and reranking stage of semantic search,\nconverting chunk IDs from hybrid search results into full DuckDB records with\nmetadata. It optionally applies CodeRankLLM reranking when enabled in options,\nand clips results to the effective limit specified in the plan. The function\naggregates timing information from both hydration and reranking operations,\nproviding observability into stage performance. This is a critical path in the\nsemantic search pipeline, bridging between vector search results and final\nranked document outputs.\n\nParameters\n----------\nplan : HydrationPlan\n    Container holding hydration and reranking inputs including context, query,\n    fused hybrid search results, scope filters, effective limit, options, and\n    observation tracking. The plan encapsulates all state needed to hydrate\n    and rerank search results.\n\nReturns\n-------\nHydrationOutcome\n    Dataclass containing:\n    - records: list[dict], hydrated records clipped to ``effective_limit``, each\n      record is a dict with chunk metadata from DuckDB.\n    - timings: list[StageTiming], timing snapshots from hydration and reranking\n      stages for observability.\n\nRaises\n------\nVectorSearchError\n    Raised when DuckDB hydration fails even after retries. This occurs when\n    the database is unavailable, queries timeout, or chunk IDs are invalid.\n\nNotes\n-----\nTime complexity O(R + L) where R is reranking cost (if enabled, depends on\nLLM inference) and L is limit clipping. Space complexity O(k) where k is\neffective_limit. The function performs database I/O for hydration and optional\nLLM API calls for reranking. Thread-safe for concurrent plan processing.\nResults are clipped to effective_limit to respect user constraints and prevent\nmemory exhaustion. Timing snapshots enable performance monitoring and debugging.",
  "is_public": false
}
{
  "path": "mcp_server/adapters/semantic_pro.py",
  "module": "mcp_server.adapters.semantic_pro",
  "qualname": "_maybe_rerank",
  "name": "_maybe_rerank",
  "node_type": "FunctionDef",
  "lineno": 1454,
  "col": 0,
  "end_lineno": 1496,
  "end_col": 32,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "mcp_server/adapters/semantic_pro.py",
  "module": "mcp_server.adapters.semantic_pro",
  "qualname": "_rerank_gate_decision",
  "name": "_rerank_gate_decision",
  "node_type": "FunctionDef",
  "lineno": 1499,
  "col": 0,
  "end_lineno": 1513,
  "end_col": 59,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "mcp_server/adapters/semantic_pro.py",
  "module": "mcp_server.adapters.semantic_pro",
  "qualname": "_build_findings",
  "name": "_build_findings",
  "node_type": "FunctionDef",
  "lineno": 1516,
  "col": 0,
  "end_lineno": 1553,
  "end_col": 19,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "mcp_server/adapters/semantic_pro.py",
  "module": "mcp_server.adapters.semantic_pro",
  "qualname": "merge_explainability_into_findings",
  "name": "merge_explainability_into_findings",
  "node_type": "FunctionDef",
  "lineno": 1556,
  "col": 0,
  "end_lineno": 1618,
  "end_col": 76,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Append token-level explainability snippets to existing findings.\n\nExtended Summary\n----------------\nThis function enriches Finding objects with token-level alignment information\nfrom XTR/WARP explainability data. It matches explainability entries to findings\nby chunk_id, extracts token match summaries, and appends formatted alignment\nstrings to the \"why\" field. The function mutates findings in-place, adding\nXTR alignment details (query token index  document token index with similarity\nscores) to help users understand why specific code chunks were retrieved.\nThis is called after findings are built but before the final AnswerEnvelope\nis assembled.\n\nParameters\n----------\nfindings : list[Finding]\n    List of Finding dictionaries to enrich. Each finding should have a \"chunk_id\"\n    field for matching. Findings without matching explainability entries are\n    left unchanged. Mutated in-place.\nexplainability : Sequence[tuple[int, dict[str, Any]]]\n    Explainability data as (chunk_id, payload) tuples. Each payload should\n    contain a \"token_matches\" key with alignment information. Empty sequences\n    result in no modifications.\n\nNotes\n-----\nTime complexity O(n * m) where n is len(findings) and m is len(explainability)\ndue to lookup construction and matching. Space complexity O(m) for the lookup\ndictionary. The function mutates findings in-place and has no return value.\nThread-safe if findings list is not modified concurrently.\n\nExamples\n--------\n>>> findings = [{\"chunk_id\": 1, \"why\": \"Fusion weights: coderank rank=1\"}]\n>>> explain = [(1, {\"token_matches\": [{\"q_index\": 0, \"doc_index\": 5, \"similarity\": 0.8}]})]\n>>> merge_explainability_into_findings(findings, explain)\n>>> \"XTR alignments\" in findings[0][\"why\"]\nTrue",
  "is_public": true
}
{
  "path": "mcp_server/adapters/semantic_pro.py",
  "module": "mcp_server.adapters.semantic_pro",
  "qualname": "_build_method_explainability",
  "name": "_build_method_explainability",
  "node_type": "FunctionDef",
  "lineno": 1621,
  "col": 0,
  "end_lineno": 1685,
  "end_col": 28,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Build explainability payload for MethodInfo.\n\nExtended Summary\n----------------\nThis helper function converts raw explainability tuples (chunk_id, payload) into\na structured dictionary format suitable for inclusion in MethodInfo. It filters\nentries to include only those with token matches, limits the number of entries\nto prevent payload bloat, and organizes them by channel (currently \"warp\").\nThe function is called after the retrieval pipeline completes to package\ntoken-level alignment data for observability.\n\nParameters\n----------\nexplainability : Sequence[tuple[int, dict[str, Any]]]\n    Raw explainability data as (chunk_id, payload) tuples. Each payload should\n    contain a \"token_matches\" key with alignment information. Empty sequences\n    result in None return.\nlimit : int, optional\n    Maximum number of explainability entries to include in the result. Defaults\n    to 5 to keep payload sizes manageable. Higher values provide more detail but\n    increase response size.\n\nReturns\n-------\ndict[str, list[dict[str, Any]]] | None\n    Structured explainability data keyed by channel name (e.g., \"warp\"). Each\n    entry contains chunk_id and token_matches. Returns None if no valid entries\n    are found or if explainability is empty.\n\nNotes\n-----\nTime complexity O(n) where n is min(len(explainability), limit). Space complexity\nO(n) for the result dictionary. No I/O or side effects. Thread-safe.\n\nExamples\n--------\n>>> explain = [(1, {\"token_matches\": [{\"q_index\": 0, \"doc_index\": 5, \"similarity\": 0.8}]})]\n>>> result = _build_method_explainability(explain, limit=5)\n>>> result is not None and \"warp\" in result\nTrue\n>>> result = _build_method_explainability([], limit=5)\n>>> result is None\nTrue",
  "is_public": false
}
{
  "path": "mcp_server/adapters/semantic_pro.py",
  "module": "mcp_server.adapters.semantic_pro",
  "qualname": "_build_method",
  "name": "_build_method",
  "node_type": "FunctionDef",
  "lineno": 1688,
  "col": 0,
  "end_lineno": 1724,
  "end_col": 17,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "mcp_server/adapters/semantic_pro.py",
  "module": "mcp_server.adapters.semantic_pro",
  "qualname": "_assemble_extras",
  "name": "_assemble_extras",
  "node_type": "FunctionDef",
  "lineno": 1727,
  "col": 0,
  "end_lineno": 1789,
  "end_col": 17,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Assemble response metadata extras dictionary.\n\nExtended Summary\n----------------\nThis helper function constructs the extras dictionary for an AnswerEnvelope,\ncombining method metadata (retrieval channels, coverage, stage timings) with\noptional limits warnings and scope filters. It is called after the retrieval\npipeline completes to package telemetry and configuration context into the\nresponse. The function ensures that only non-empty optional fields are included,\nkeeping the response payload minimal.\n\nParameters\n----------\nmethod : MethodInfo\n    Method metadata dictionary containing retrieval channels, coverage string,\n    and optional stage timings. This is produced by _build_method() and describes\n    how the search was executed.\nlimits : list[str]\n    List of warning messages about budget overruns, limit clamping, or other\n    operational constraints. Empty list means no warnings. Non-empty lists are\n    included in the extras as the \"limits\" field.\nscope : ScopeIn | None\n    Scope filters that were applied during search (include_globs, exclude_globs,\n    languages). None means no scope filtering was applied. Non-None values are\n    included in the extras as the \"scope\" field.\n\nReturns\n-------\nAnswerEnvelope\n    Dictionary containing the method field (always present) and optionally\n    limits and scope fields if they are non-empty/non-None. This dictionary\n    is merged into the final AnswerEnvelope by _make_envelope().\n\nNotes\n-----\nTime complexity O(1). No I/O or side effects. The function performs shallow\ndictionary construction only. Thread-safe.\n\nExamples\n--------\n>>> method = {\"retrieval\": [\"coderank\"], \"coverage\": \"5/10 results in 42ms\"}\n>>> extras = _assemble_extras(method=method, limits=[], scope=None)\n>>> extras[\"method\"] == method\nTrue\n>>> \"limits\" in extras\nFalse\n>>> extras = _assemble_extras(method=method, limits=[\"Budget exceeded\"], scope=None)\n>>> extras[\"limits\"] == [\"Budget exceeded\"]\nTrue",
  "is_public": false
}
{
  "path": "mcp_server/adapters/semantic_pro.py",
  "module": "mcp_server.adapters.semantic_pro",
  "qualname": "_make_envelope",
  "name": "_make_envelope",
  "node_type": "FunctionDef",
  "lineno": 1792,
  "col": 0,
  "end_lineno": 1808,
  "end_col": 19,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "mcp_server/adapters/semantic_pro.py",
  "module": "mcp_server.adapters.semantic_pro",
  "qualname": "_observability_links",
  "name": "_observability_links",
  "node_type": "FunctionDef",
  "lineno": 1811,
  "col": 0,
  "end_lineno": 1835,
  "end_col": 17,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return trace/run metadata for semantic_pro envelopes.\n\nReturns\n-------\nAnswerEnvelope\n    Observability extras populated with trace/run diagnostics.",
  "is_public": false
}
{
  "path": "mcp_server/adapters/semantic_pro.py",
  "module": "mcp_server.adapters.semantic_pro",
  "qualname": "build_observability_links",
  "name": "build_observability_links",
  "node_type": "FunctionDef",
  "lineno": 1838,
  "col": 0,
  "end_lineno": 1846,
  "end_col": 33,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return observability extras for semantic-pro responses.\n\nReturns\n-------\nAnswerEnvelope\n    Extras populated with trace/run metadata.",
  "is_public": true
}
{
  "path": "mcp_server/adapters/semantic_pro.py",
  "module": "mcp_server.adapters.semantic_pro",
  "qualname": "_clamp_limit",
  "name": "_clamp_limit",
  "node_type": "FunctionDef",
  "lineno": 1849,
  "col": 0,
  "end_lineno": 1857,
  "end_col": 38,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "mcp_server/adapters/semantic_pro.py",
  "module": "mcp_server.adapters.semantic_pro",
  "qualname": "_coerce_positive_int",
  "name": "_coerce_positive_int",
  "node_type": "FunctionDef",
  "lineno": 1860,
  "col": 0,
  "end_lineno": 1867,
  "end_col": 41,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "mcp_server/adapters/semantic_pro.py",
  "module": "mcp_server.adapters.semantic_pro",
  "qualname": "_dedupe_preserve_order",
  "name": "_dedupe_preserve_order",
  "node_type": "FunctionDef",
  "lineno": 1870,
  "col": 0,
  "end_lineno": 1878,
  "end_col": 18,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "mcp_server/adapters/semantic_pro.py",
  "module": "mcp_server.adapters.semantic_pro",
  "qualname": "WarpOutcome",
  "name": "WarpOutcome",
  "node_type": "ClassDef",
  "lineno": 1882,
  "col": 0,
  "end_lineno": 1889,
  "end_col": 25,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Container describing the results of the optional WARP stage.",
  "is_public": true
}
{
  "path": "mcp_server/adapters/semantic_pro.py",
  "module": "mcp_server.adapters.semantic_pro",
  "qualname": "FusionRequest",
  "name": "FusionRequest",
  "node_type": "ClassDef",
  "lineno": 1893,
  "col": 0,
  "end_lineno": 1903,
  "end_col": 15,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Inputs required to execute the fusion stage.",
  "is_public": true
}
{
  "path": "mcp_server/adapters/semantic_pro.py",
  "module": "mcp_server.adapters.semantic_pro",
  "qualname": "MethodContext",
  "name": "MethodContext",
  "node_type": "ClassDef",
  "lineno": 1907,
  "col": 0,
  "end_lineno": 1919,
  "end_col": 43,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Inputs required to build the MethodInfo payload.",
  "is_public": true
}
{
  "path": "mcp_server/adapters/text_search.py",
  "module": "mcp_server.adapters.text_search",
  "qualname": "mcp_server.adapters.text_search",
  "name": "mcp_server.adapters.text_search",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Text search adapter using ripgrep.\n\nFast text search with regex support.",
  "is_public": true
}
{
  "path": "mcp_server/adapters/text_search.py",
  "module": "mcp_server.adapters.text_search",
  "qualname": "TextSearchOptions",
  "name": "TextSearchOptions",
  "node_type": "ClassDef",
  "lineno": 46,
  "col": 0,
  "end_lineno": 118,
  "end_col": 9,
  "parent_qualname": null,
  "decorators": [
    "dataclass(frozen=True)"
  ],
  "bases": [],
  "docstring": "Parameters controlling ripgrep execution.",
  "is_public": true
}
{
  "path": "mcp_server/adapters/text_search.py",
  "module": "mcp_server.adapters.text_search",
  "qualname": "TextSearchOptions.from_overrides",
  "name": "from_overrides",
  "node_type": "FunctionDef",
  "lineno": 69,
  "col": 4,
  "end_lineno": 118,
  "end_col": 9,
  "parent_qualname": "TextSearchOptions",
  "decorators": [
    "classmethod"
  ],
  "bases": [],
  "docstring": "Build search options from keyword overrides.\n\nConstructs a TextSearchOptions instance from a query string and a mapping\nof keyword arguments. Validates that all override keys are allowed options.\n\nParameters\n----------\nquery : str\n    Search query string (regex pattern if regex=True).\noverrides : Mapping[str, object]\n    Dictionary of keyword arguments corresponding to TextSearchOptions fields.\n    Valid keys are: regex, case_sensitive, paths, include_globs, exclude_globs,\n    max_results.\n\nReturns\n-------\nTextSearchOptions\n    Configured search options instance with query and overrides applied.\n\nRaises\n------\nTypeError\n    If any keys in overrides are not recognized as valid TextSearchOptions\n    fields. This prevents typos and ensures type safety.",
  "is_public": true
}
{
  "path": "mcp_server/adapters/text_search.py",
  "module": "mcp_server.adapters.text_search",
  "qualname": "_bool_override",
  "name": "_bool_override",
  "node_type": "FunctionDef",
  "lineno": 121,
  "col": 0,
  "end_lineno": 145,
  "end_col": 16,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return a boolean override for the given key.\n\nParameters\n----------\noverrides : Mapping[str, object]\n    Override dictionary provided by the adapter call.\nkey : str\n    Lookup key corresponding to a TextSearchOptions boolean field.\n\nReturns\n-------\nbool\n    Boolean override value retrieved from the overrides mapping.\n\nRaises\n------\nTypeError\n    If the override is present but not a boolean.",
  "is_public": false
}
{
  "path": "mcp_server/adapters/text_search.py",
  "module": "mcp_server.adapters.text_search",
  "qualname": "_sequence_override",
  "name": "_sequence_override",
  "node_type": "FunctionDef",
  "lineno": 148,
  "col": 0,
  "end_lineno": 178,
  "end_col": 24,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return a sequence override if the value is a valid sequence of strings.\n\nParameters\n----------\noverrides : Mapping[str, object]\n    Override dictionary provided by the adapter call.\nkey : str\n    Lookup key corresponding to a sequence field in TextSearchOptions.\n\nReturns\n-------\nSequence[str] | None\n    Sequence override if present, otherwise ``None``.\n\nRaises\n------\nTypeError\n    If the override is present but not a sequence of strings.",
  "is_public": false
}
{
  "path": "mcp_server/adapters/text_search.py",
  "module": "mcp_server.adapters.text_search",
  "qualname": "_int_override",
  "name": "_int_override",
  "node_type": "FunctionDef",
  "lineno": 181,
  "col": 0,
  "end_lineno": 205,
  "end_col": 16,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return an integer override for the given key.\n\nParameters\n----------\noverrides : Mapping[str, object]\n    Override dictionary provided by the adapter call.\nkey : str\n    Lookup key corresponding to the ``max_results`` parameter.\n\nReturns\n-------\nint\n    Integer override value retrieved from the overrides mapping.\n\nRaises\n------\nTypeError\n    If the override is present but not an integer.",
  "is_public": false
}
{
  "path": "mcp_server/adapters/text_search.py",
  "module": "mcp_server.adapters.text_search",
  "qualname": "search_text",
  "name": "search_text",
  "node_type": "AsyncFunctionDef",
  "lineno": 208,
  "col": 0,
  "end_lineno": 288,
  "end_col": 45,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Fast text search using ripgrep (async wrapper).\n\nApplies session scope path filters if set via `set_scope`. Explicit parameters\noverride session scope following the precedence rules documented above.\n\nParameters\n----------\ncontext : ApplicationContext\n    Application context containing repo root and settings.\nquery : str\n    Search query string (regex pattern if ``regex=True``).\noptions : TextSearchOptions | None, optional\n    Explicit search configuration. When ``None``, keyword overrides are permitted.\n**overrides : object\n    Backward-compatible keyword overrides corresponding to\n    ``TextSearchOptions`` fields (``regex``, ``case_sensitive``, ``paths``,\n    ``include_globs``, ``exclude_globs``, ``max_results``).\n\nReturns\n-------\ndict\n    Search results containing matched paths and metadata.\n\nRaises\n------\nTypeError\n    If both ``options`` and keyword ``overrides`` are provided simultaneously.\n    Only one method of providing search options is allowed per call.",
  "is_public": true
}
{
  "path": "mcp_server/adapters/text_search.py",
  "module": "mcp_server.adapters.text_search",
  "qualname": "search_text._run_sync",
  "name": "_run_sync",
  "node_type": "FunctionDef",
  "lineno": 267,
  "col": 4,
  "end_lineno": 286,
  "end_col": 25,
  "parent_qualname": "search_text",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "mcp_server/adapters/text_search.py",
  "module": "mcp_server.adapters.text_search",
  "qualname": "_search_text_sync",
  "name": "_search_text_sync",
  "node_type": "FunctionDef",
  "lineno": 291,
  "col": 0,
  "end_lineno": 432,
  "end_col": 9,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "mcp_server/adapters/text_search.py",
  "module": "mcp_server.adapters.text_search",
  "qualname": "_fallback_grep",
  "name": "_fallback_grep",
  "node_type": "FunctionDef",
  "lineno": 435,
  "col": 0,
  "end_lineno": 550,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Fallback to basic grep if ripgrep unavailable.\n\nParameters\n----------\nobservation : Observation\n    Metrics observation context used to record success or failure.\nrepo_root : Path\n    Repository root directory.\nquery : str\n    Search query.\ncase_sensitive : bool\n    Case-sensitive search.\nmax_results : int\n    Maximum results.\ntelemetry_attrs : Mapping[str, object] | None, optional\n    Optional telemetry attributes to include in span context. These are\n    merged with stage-specific attributes for observability. Defaults to None.\n\nReturns\n-------\ndict\n    Search results.\n\nRaises\n------\nVectorSearchError\n    If fallback grep operation fails (timeout, subprocess error, etc.).",
  "is_public": false
}
{
  "path": "mcp_server/adapters/text_search.py",
  "module": "mcp_server.adapters.text_search",
  "qualname": "RipgrepCommandParams",
  "name": "RipgrepCommandParams",
  "node_type": "ClassDef",
  "lineno": 554,
  "col": 0,
  "end_lineno": 563,
  "end_col": 20,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Parameter bundle for constructing ripgrep commands.",
  "is_public": true
}
{
  "path": "mcp_server/adapters/text_search.py",
  "module": "mcp_server.adapters.text_search",
  "qualname": "_build_ripgrep_command",
  "name": "_build_ripgrep_command",
  "node_type": "FunctionDef",
  "lineno": 566,
  "col": 0,
  "end_lineno": 603,
  "end_col": 18,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Assemble the ripgrep command arguments.\n\nParameters\n----------\nparams : RipgrepCommandParams\n    Parameter bundle describing ripgrep invocation.\n\nReturns\n-------\nlist[str]\n    Argument vector for ripgrep invocation.",
  "is_public": false
}
{
  "path": "mcp_server/adapters/text_search.py",
  "module": "mcp_server.adapters.text_search",
  "qualname": "_parse_ripgrep_output",
  "name": "_parse_ripgrep_output",
  "node_type": "FunctionDef",
  "lineno": 606,
  "col": 0,
  "end_lineno": 670,
  "end_col": 29,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Parse ripgrep JSON output into structured matches.\n\nParameters\n----------\nstdout : str\n    Ripgrep JSON output.\nrepo_root : Path\n    Repository root directory.\nmax_results : int\n    Maximum number of results to parse.\n\nReturns\n-------\ntuple[list[Match], bool]\n    Parsed match list and whether results were truncated at max_results.",
  "is_public": false
}
{
  "path": "mcp_server/adapters/text_search.py",
  "module": "mcp_server.adapters.text_search",
  "qualname": "_preview_text",
  "name": "_preview_text",
  "node_type": "FunctionDef",
  "lineno": 673,
  "col": 0,
  "end_lineno": 695,
  "end_col": 44,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return a truncated preview suitable for span attributes.\n\nParameters\n----------\nvalue : str\n    Text string to truncate. Leading and trailing whitespace is stripped\n    before truncation.\nlimit : int, optional\n    Maximum length of the returned string. If the text exceeds this limit,\n    it is truncated and \"...\" is appended. Defaults to 200.\n\nReturns\n-------\nstr\n    Truncated text preview. If the original text (after stripping) is shorter\n    than the limit, returns the text unchanged. Otherwise, returns the\n    truncated text with \"...\" appended.",
  "is_public": false
}
{
  "path": "mcp_server/adapters/text_search.py",
  "module": "mcp_server.adapters.text_search",
  "qualname": "_clean_attrs",
  "name": "_clean_attrs",
  "node_type": "FunctionDef",
  "lineno": 698,
  "col": 0,
  "end_lineno": 714,
  "end_col": 76,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Filter out ``None`` values to keep span attributes compact.\n\nParameters\n----------\nattrs : Mapping[str, object]\n    Dictionary of span attributes. May contain None values which will be\n    filtered out in the returned dictionary.\n\nReturns\n-------\ndict[str, object]\n    Dictionary containing only non-None key-value pairs from the input.\n    Preserves the original key-value pairs, excluding any entries where\n    the value is None.",
  "is_public": false
}
{
  "path": "mcp_server/common/__init__.py",
  "module": "mcp_server.common",
  "qualname": "mcp_server.common",
  "name": "mcp_server.common",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Common utilities and shared code for MCP server adapters.",
  "is_public": true
}
{
  "path": "mcp_server/common/observability.py",
  "module": "mcp_server.common.observability",
  "qualname": "mcp_server.common.observability",
  "name": "mcp_server.common.observability",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Unified observability helpers for CodeIntel MCP adapters.\n\nThe adapters previously duplicated more than sixty lines of metrics boilerplate.\nThis module centralises the logic, delegates to :mod:`kgfoundry_common`\nobservability primitives, and keeps behaviour backward compatible with existing\nPrometheus dashboards.\n\nExamples\n--------\nBasic usage in an adapter:\n\n>>> from codeintel_rev.mcp_server.common.observability import observe_duration\n>>> with observe_duration(\"search\", \"text_search\") as observation:\n...     result = perform_search()\n...     observation.mark_success()\n\nGraceful degradation when metrics are unavailable:\n\n>>> with observe_duration(\"semantic_search\", \"codeintel_mcp\") as observation:\n...     try:\n...         perform_semantic_search()\n...         observation.mark_success()\n...     except RuntimeError:\n...         observation.mark_error()\n...         raise",
  "is_public": true
}
{
  "path": "mcp_server/common/observability.py",
  "module": "mcp_server.common.observability",
  "qualname": "_supports_histogram_labels",
  "name": "_supports_histogram_labels",
  "node_type": "FunctionDef",
  "lineno": 50,
  "col": 0,
  "end_lineno": 70,
  "end_col": 20,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return ``True`` when the histogram exposes label support.\n\nParameters\n----------\nhistogram : object\n    Prometheus histogram instance or stub implementing ``_labelnames``.\n\nReturns\n-------\nbool\n    ``True`` when the histogram exposes at least one label, ``False`` when\n    labels are missing or the attribute cannot be inspected.",
  "is_public": false
}
{
  "path": "mcp_server/common/observability.py",
  "module": "mcp_server.common.observability",
  "qualname": "_NoopObservation",
  "name": "_NoopObservation",
  "node_type": "ClassDef",
  "lineno": 73,
  "col": 0,
  "end_lineno": 80,
  "end_col": 75,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Fallback observation used when metrics cannot be recorded.",
  "is_public": false
}
{
  "path": "mcp_server/common/observability.py",
  "module": "mcp_server.common.observability",
  "qualname": "_NoopObservation.mark_error",
  "name": "mark_error",
  "node_type": "FunctionDef",
  "lineno": 76,
  "col": 4,
  "end_lineno": 77,
  "end_col": 71,
  "parent_qualname": "_NoopObservation",
  "decorators": [],
  "bases": [],
  "docstring": "Mark the observation as failed without recording metrics.",
  "is_public": true
}
{
  "path": "mcp_server/common/observability.py",
  "module": "mcp_server.common.observability",
  "qualname": "_NoopObservation.mark_success",
  "name": "mark_success",
  "node_type": "FunctionDef",
  "lineno": 79,
  "col": 4,
  "end_lineno": 80,
  "end_col": 75,
  "parent_qualname": "_NoopObservation",
  "decorators": [],
  "bases": [],
  "docstring": "Mark the observation as successful without recording metrics.",
  "is_public": true
}
{
  "path": "mcp_server/common/observability.py",
  "module": "mcp_server.common.observability",
  "qualname": "Observation",
  "name": "Observation",
  "node_type": "ClassDef",
  "lineno": 83,
  "col": 0,
  "end_lineno": 90,
  "end_col": 49,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "Protocol"
  ],
  "docstring": "Protocol describing the helpers provided by metrics observations.",
  "is_public": true
}
{
  "path": "mcp_server/common/observability.py",
  "module": "mcp_server.common.observability",
  "qualname": "Observation.mark_error",
  "name": "mark_error",
  "node_type": "FunctionDef",
  "lineno": 86,
  "col": 4,
  "end_lineno": 87,
  "end_col": 45,
  "parent_qualname": "Observation",
  "decorators": [],
  "bases": [],
  "docstring": "Mark the observation as failed.",
  "is_public": true
}
{
  "path": "mcp_server/common/observability.py",
  "module": "mcp_server.common.observability",
  "qualname": "Observation.mark_success",
  "name": "mark_success",
  "node_type": "FunctionDef",
  "lineno": 89,
  "col": 4,
  "end_lineno": 90,
  "end_col": 49,
  "parent_qualname": "Observation",
  "decorators": [],
  "bases": [],
  "docstring": "Mark the observation as successful.",
  "is_public": true
}
{
  "path": "mcp_server/common/observability.py",
  "module": "mcp_server.common.observability",
  "qualname": "observe_duration",
  "name": "observe_duration",
  "node_type": "FunctionDef",
  "lineno": 94,
  "col": 0,
  "end_lineno": 149,
  "end_col": 41,
  "parent_qualname": null,
  "decorators": [
    "contextmanager"
  ],
  "bases": [],
  "docstring": "Yield a metrics observation with graceful degradation.\n\nParameters\n----------\noperation : str\n    Operation identifier, propagated to the ``operation`` metric label.\ncomponent : str\n    Component identifier, propagated to the ``component`` metric label.\nmetrics : MetricsProvider | None, optional\n    Metrics provider instance. When ``None`` (the default), the global\n    :class:`~kgfoundry_common.observability.MetricsProvider` singleton is\n    used.\n\nYields\n------\nObservation\n    Observation object supporting ``mark_success`` and ``mark_error``.\n\nNotes\n-----\n- Ensures label compatibility before attempting to record metrics.\n- Catches ``ValueError`` raised by the underlying observability helper and\n  falls back to a no-op observation.\n- Logging uses structured fields (``operation`` and ``component``) for\n  downstream correlation.",
  "is_public": true
}
{
  "path": "mcp_server/common/observability.py",
  "module": "mcp_server.common.observability",
  "qualname": "_record_exemplar",
  "name": "_record_exemplar",
  "node_type": "FunctionDef",
  "lineno": 152,
  "col": 0,
  "end_lineno": 175,
  "end_col": 72,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Attach exemplars to the duration histogram when supported.",
  "is_public": false
}
{
  "path": "mcp_server/error_handling.py",
  "module": "mcp_server.error_handling",
  "qualname": "mcp_server.error_handling",
  "name": "mcp_server.error_handling",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Centralized error handling for CodeIntel MCP server.\n\nThis module provides the unified error handling infrastructure for all MCP tools,\nensuring consistent error responses with RFC 9457 Problem Details compliance and\nstructured logging for observability.\n\nArchitecture\n------------\nThe error handling follows a three-layer pattern:\n\n1. **Adapter Layer**: Pure domain logic that raises typed exceptions\n2. **Decorator Layer**: Automatic exception  envelope conversion\n3. **Client Layer**: Uniform error envelope with Problem Details\n\nAll MCP tool functions are decorated with ``@handle_adapter_errors`` which\ncatches all exceptions, converts them to Problem Details, logs with structured\ncontext, and returns a unified error envelope.\n\nExamples\n--------\nApplying decorator to MCP tool:\n\n>>> @mcp.tool()\n>>> @handle_adapter_errors(\n...     operation=\"files:open_file\", empty_result={\"path\": \"\", \"content\": \"\", \"lines\": 0, \"size\": 0}\n... )\n... def open_file(path: str, start_line: int | None, end_line: int | None) -> dict:\n...     context = get_context()\n...     return files_adapter.open_file(context, path, start_line, end_line)\n\nError envelope structure:\n\n>>> # On success:\n>>> {\"path\": \"src/main.py\", \"content\": \"...\", \"lines\": 10, \"size\": 234}\n>>>\n>>> # On error (FileNotFoundError):\n>>> {\n...     \"path\": \"\",\n...     \"content\": \"\",\n...     \"lines\": 0,\n...     \"size\": 0,\n...     \"error\": \"File not found: src/main.py\",\n...     \"problem\": {\n...         \"type\": \"https://kgfoundry.dev/problems/file-not-found\",\n...         \"title\": \"File Not Found\",\n...         \"status\": 404,\n...         \"detail\": \"File not found: src/main.py\",\n...         \"instance\": \"urn:codeintel:files:open_file\",\n...         \"code\": \"file-not-found\",\n...     },\n... }",
  "is_public": true
}
{
  "path": "mcp_server/error_handling.py",
  "module": "mcp_server.error_handling",
  "qualname": "ProblemMapping",
  "name": "ProblemMapping",
  "node_type": "ClassDef",
  "lineno": 119,
  "col": 0,
  "end_lineno": 157,
  "end_col": 15,
  "parent_qualname": null,
  "decorators": [
    "dataclass(frozen=True)"
  ],
  "bases": [],
  "docstring": "Mapping from exception type to RFC 9457 Problem Details metadata.\n\nExtended Summary\n----------------\nThis dataclass encapsulates the mapping between Python exception types and\nRFC 9457 Problem Details fields (code, title, status). It is used by the\nerror handling infrastructure to convert exceptions into standardized Problem\nDetails responses. The mapping is immutable and used as a lookup key in\nEXCEPTION_TO_ERROR_CODE to determine appropriate HTTP status codes and error\ncodes for different exception types.\n\nAttributes\n----------\ncode : str\n    Machine-readable error code identifier (e.g., \"path-not-found\",\n    \"invalid-parameter\"). Used in Problem Details \"code\" field and for\n    structured logging. Should be kebab-case and descriptive.\ntitle : str\n    Human-readable error title (e.g., \"Path Not Found\", \"Invalid Parameter\").\n    Used in Problem Details \"title\" field. Should be title-case and concise.\nstatus : int\n    HTTP status code (e.g., 404, 400, 500). Must be a valid HTTP status code\n    (100-599). Used in Problem Details \"status\" field and HTTP response\n    status. Common values: 400 (Bad Request), 404 (Not Found), 500 (Internal\n    Server Error).\n\nNotes\n-----\nThis mapping is used by format_error_response() to convert exceptions into\nProblem Details. The code should match the problem type URI suffix (e.g.,\n\"path-not-found\" maps to \"https://kgfoundry.dev/problems/path-not-found\").\nStatus codes follow RFC 7231 semantics: 4xx for client errors, 5xx for server\nerrors.",
  "is_public": true
}
{
  "path": "mcp_server/error_handling.py",
  "module": "mcp_server.error_handling",
  "qualname": "format_error_response",
  "name": "format_error_response",
  "node_type": "FunctionDef",
  "lineno": 176,
  "col": 0,
  "end_lineno": 231,
  "end_col": 46,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return Problem Details payload for the provided exception.\n\nParameters\n----------\nexc : BaseException\n    Exception instance to convert into Problem Details.\ninstance : str\n    RFC 9457 ``instance`` URI identifying the operation that failed.\n\nReturns\n-------\ndict[str, object]\n    Dictionary containing ``problem`` (Problem Details payload) and\n    ``status`` (HTTP status code).",
  "is_public": true
}
{
  "path": "mcp_server/error_handling.py",
  "module": "mcp_server.error_handling",
  "qualname": "convert_exception_to_envelope",
  "name": "convert_exception_to_envelope",
  "node_type": "FunctionDef",
  "lineno": 234,
  "col": 0,
  "end_lineno": 417,
  "end_col": 19,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Convert exception to unified error envelope with Problem Details.\n\nThis function is the single source of truth for exception  envelope\nconversion. It handles all exception types (KgFoundryError subclasses,\nbuiltin exceptions, unknown exceptions) and produces a consistent error\nstructure with RFC 9457 Problem Details compliance.\n\nThe error envelope includes:\n- All fields from ``empty_result`` (tool-specific fields with empty/zero values)\n- ``error`` field with human-readable message\n- ``problem`` field with RFC 9457 Problem Details\n\nParameters\n----------\nexc : BaseException\n    Exception to convert. Can be any exception type - KgFoundryError\n    subclasses are handled specially, builtin exceptions (FileNotFoundError,\n    ValueError, etc.) are mapped to standard Problem Details, unknown\n    exceptions are mapped to 500 Internal Error.\noperation : str\n    Operation identifier in format \"category:operation\" (e.g.,\n    \"files:open_file\", \"search:text\"). Used for Problem Details instance\n    field and structured logging.\nempty_result : Mapping[str, object]\n    Tool-specific result fields with empty/zero values. These are merged\n    into the error envelope so clients always see the same field structure.\n    Example: ``{\"path\": \"\", \"content\": \"\", \"lines\": 0, \"size\": 0}``\n\nReturns\n-------\ndict\n    Error envelope with:\n\n    - All fields from ``empty_result`` (empty/zero values)\n    - ``error: str`` - Human-readable error message\n    - ``problem: ProblemDetails`` - RFC 9457 Problem Details with type,\n      title, status, detail, instance, code, and optional extensions\n\nNotes\n-----\nException Mapping:\n\n- **KgFoundryError**: Uses ``to_problem_details()`` method. HTTP status,\n  error code, and context from exception fields. Logged at exception's\n  log_level with structured context.\n- **FileNotFoundError**: 404 Not Found, code \"file-not-found\". Logged\n  at WARNING level.\n- **UnicodeDecodeError**: 415 Unsupported Media Type, code\n  \"unsupported-encoding\". Encoding and reason in extensions. Logged at\n  WARNING level.\n- **ValueError**: 400 Bad Request, code \"invalid-parameter\". Logged at\n  WARNING level.\n- **Unknown exceptions**: 500 Internal Server Error, code \"internal-error\".\n  Exception type in extensions. Logged at EXCEPTION level (includes stack\n  trace).\n\nStructured Logging:\n\nAll exceptions are logged with structured context:\n\n- KgFoundryError: ``operation``, ``error_code``, ``component``\n- Builtin exceptions: ``operation``, ``component``, ``error``\n- Unknown exceptions: ``operation``, ``component``, ``exception_type``\n\nExamples\n--------\nConvert FileNotFoundError:\n\n>>> exc = FileNotFoundError(\"File not found: src/main.py\")\n>>> envelope = convert_exception_to_envelope(\n...     exc,\n...     operation=\"files:open_file\",\n...     empty_result={\"path\": \"\", \"content\": \"\", \"lines\": 0, \"size\": 0},\n... )\n>>> envelope[\"error\"]\n'File not found: src/main.py'\n>>> envelope[\"problem\"][\"status\"]\n404\n>>> envelope[\"problem\"][\"code\"]\n'file-not-found'\n>>> envelope[\"path\"]\n''\n\nConvert KgFoundryError with context:\n\n>>> from kgfoundry_common.errors import VectorSearchError\n>>> exc = VectorSearchError(\"Search timeout\", context={\"query\": \"def main\"})\n>>> envelope = convert_exception_to_envelope(\n...     exc, operation=\"search:text\", empty_result={\"matches\": [], \"total\": 0}\n... )\n>>> envelope[\"problem\"][\"extensions\"][\"query\"]\n'def main'",
  "is_public": true
}
{
  "path": "mcp_server/error_handling.py",
  "module": "mcp_server.error_handling",
  "qualname": "_record_exception_event",
  "name": "_record_exception_event",
  "node_type": "FunctionDef",
  "lineno": 420,
  "col": 0,
  "end_lineno": 444,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Emit an OpenTelemetry exception event for adapter errors.",
  "is_public": false
}
{
  "path": "mcp_server/error_handling.py",
  "module": "mcp_server.error_handling",
  "qualname": "handle_adapter_errors",
  "name": "handle_adapter_errors",
  "node_type": "FunctionDef",
  "lineno": 447,
  "col": 0,
  "end_lineno": 728,
  "end_col": 20,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Convert adapter exceptions to unified error envelopes.\n\nThis decorator is applied to all MCP tool functions to provide automatic\nerror handling. It catches all exceptions raised by adapters and converts\nthem to consistent error envelopes with Problem Details.\n\nThe decorator:\n\n1. Catches ALL exceptions (no exception escapes)\n2. Converts exception  Problem Details  error envelope\n3. Logs with structured context (operation, error_code, etc.)\n4. Returns error envelope (does not re-raise)\n5. Preserves function signature (important for FastMCP schema generation)\n\nParameters\n----------\noperation : str\n    Operation identifier in format \"category:operation\". Examples:\n\n    - \"files:open_file\"\n    - \"files:list_paths\"\n    - \"search:text\"\n    - \"search:semantic\"\n    - \"git:blame_range\"\n    - \"git:file_history\"\n\n    Used for Problem Details instance field and structured logging.\nempty_result : Mapping[str, object]\n    Tool-specific result fields with empty/zero values. These are merged\n    into the error envelope so clients always see the same field structure\n    (just with empty values on error).\n\nExamples\n--------\n    - open_file: ``{\"path\": \"\", \"content\": \"\", \"lines\": 0, \"size\": 0}``\n    - list_paths: ``{\"items\": [], \"total\": 0, \"truncated\": False}``\n    - blame_range: ``{\"blame\": []}``\n    - file_history: ``{\"commits\": []}``\n    - search_text: ``{\"matches\": [], \"total\": 0, \"truncated\": False}``\n    - semantic_search: ``{\"findings\": [], \"answer\": \"\", \"confidence\": 0.0}``\n\nReturns\n-------\nCallable[[F], F]\n    Decorator function that wraps the adapter call in try/except and\n    converts exceptions to error envelopes.\n\nNotes\n-----\nDecorator Order:\n\nThe decorator MUST be applied AFTER ``@mcp.tool()`` so FastMCP sees the\nunwrapped function signature for JSON Schema generation:\n\n.. code-block:: python\n\n    @mcp.tool()  # FIRST\n    @handle_adapter_errors(...)  # SECOND\n    def my_tool(...):\n        ...\n\nFunction Signature Preservation:\n\nThe decorator uses ``functools.wraps`` to preserve the function's\n``__name__``, ``__doc__``, and ``__annotations__``. This is critical for\nFastMCP's automatic JSON Schema generation.\n\nAsync Function Compatibility:\n\nThe decorator works with both sync and async functions. Async functions\nshould use ``async def`` and the decorator will properly await the result.\n\nExamples\n--------\nSync function:\n\n>>> @mcp.tool()\n>>> @handle_adapter_errors(\n...     operation=\"files:open_file\",\n...     empty_result={\"path\": \"\", \"content\": \"\", \"lines\": 0, \"size\": 0},\n... )\n... def open_file(path: str, start_line: int | None, end_line: int | None) -> dict:\n...     context = get_context()\n...     return files_adapter.open_file(context, path, start_line, end_line)\n\nAsync function:\n\n>>> @mcp.tool()\n>>> @handle_adapter_errors(operation=\"git:blame_range\", empty_result={\"blame\": []})\n... async def blame_range(path: str, start_line: int, end_line: int) -> dict:\n...     context = get_context()\n...     return await history_adapter.blame_range(context, path, start_line, end_line)\n\nSuccess case (no exception):\n\n>>> @handle_adapter_errors(operation=\"test\", empty_result={\"value\": 0})\n... def func():\n...     return {\"value\": 42}\n>>> result = func()\n>>> result\n{'value': 42}\n\nError case (exception raised):\n\n>>> @handle_adapter_errors(operation=\"test\", empty_result={\"value\": 0})\n... def func():\n...     raise FileNotFoundError(\"File not found\")\n>>> result = func()\n>>> result[\"error\"]\n'File not found'\n>>> result[\"problem\"][\"status\"]\n404\n>>> result[\"value\"]\n0",
  "is_public": true
}
{
  "path": "mcp_server/error_handling.py",
  "module": "mcp_server.error_handling",
  "qualname": "handle_adapter_errors.decorator",
  "name": "decorator",
  "node_type": "FunctionDef",
  "lineno": 568,
  "col": 4,
  "end_lineno": 726,
  "end_col": 38,
  "parent_qualname": "handle_adapter_errors",
  "decorators": [],
  "bases": [],
  "docstring": "Inner decorator function that wraps the adapter function.\n\nExtended Summary\n----------------\nThis inner function is returned by handle_adapter_errors() and wraps the\nactual adapter function (func) with exception handling. It detects whether\nfunc is async or sync and creates the appropriate wrapper. The wrapper\ncatches all user exceptions, converts them to error envelopes, and returns\nthe envelope instead of re-raising. This ensures consistent error responses\nat the MCP boundary.\n\nParameters\n----------\nfunc : F\n    The adapter function to wrap. Can be sync or async. Must return a\n    dict-compatible result on success.\n\nReturns\n-------\nF\n    Wrapped function with the same signature as func but with automatic\n    exception handling. The wrapper preserves function metadata (name,\n    docstring, annotations) for FastMCP schema generation.",
  "is_public": true
}
{
  "path": "mcp_server/error_handling.py",
  "module": "mcp_server.error_handling",
  "qualname": "handle_adapter_errors.decorator.async_wrapper",
  "name": "async_wrapper",
  "node_type": "AsyncFunctionDef",
  "lineno": 596,
  "col": 12,
  "end_lineno": 658,
  "end_col": 35,
  "parent_qualname": "handle_adapter_errors.decorator",
  "decorators": [
    "wraps(func)"
  ],
  "bases": [],
  "docstring": "Async wrapper that catches exceptions and converts to error envelopes.\n\nExtended Summary\n----------------\nThis wrapper function handles async adapter functions by awaiting\nthe function call and catching all user exceptions. On success,\nreturns the function result. On exception, converts the exception\nto a Problem Details error envelope and returns it. System-level\nexceptions (KeyboardInterrupt, SystemExit, GeneratorExit) are\nre-raised to allow proper shutdown.\n\nParameters\n----------\n*args : object\n    Positional arguments passed to the wrapped function.\n**kwargs : object\n    Keyword arguments passed to the wrapped function.\n\nReturns\n-------\ndict[str, object]\n    Function result dict on success, or error envelope dict on\n    exception. The error envelope includes empty_result fields,\n    error message, and Problem Details.\n\nRaises\n------\nKeyboardInterrupt\n    Re-raised to allow proper keyboard interrupt handling.\nSystemExit\n    Re-raised to allow proper system shutdown.\nGeneratorExit\n    Re-raised to allow proper generator cleanup.\n\nNotes\n-----\nThis wrapper ensures all async adapter exceptions are caught and\nconverted to error envelopes. The function signature is preserved\nfor FastMCP schema generation. Time complexity: O(1) wrapper overhead\nplus the wrapped function's complexity.",
  "is_public": true
}
{
  "path": "mcp_server/error_handling.py",
  "module": "mcp_server.error_handling",
  "qualname": "handle_adapter_errors.decorator.sync_wrapper",
  "name": "sync_wrapper",
  "node_type": "FunctionDef",
  "lineno": 663,
  "col": 8,
  "end_lineno": 724,
  "end_col": 31,
  "parent_qualname": "handle_adapter_errors.decorator",
  "decorators": [
    "wraps(func)"
  ],
  "bases": [],
  "docstring": "Sync wrapper that catches exceptions and converts to error envelopes.\n\nExtended Summary\n----------------\nThis wrapper function handles sync adapter functions by calling the\nfunction and catching all user exceptions. On success, returns the\nfunction result. On exception, converts the exception to a Problem\nDetails error envelope and returns it. System-level exceptions\n(KeyboardInterrupt, SystemExit, GeneratorExit) are re-raised to allow\nproper shutdown.\n\nParameters\n----------\n*args : object\n    Positional arguments passed to the wrapped function.\n**kwargs : object\n    Keyword arguments passed to the wrapped function.\n\nReturns\n-------\ndict[str, object]\n    Function result dict on success, or error envelope dict on\n    exception. The error envelope includes empty_result fields,\n    error message, and Problem Details.\n\nRaises\n------\nKeyboardInterrupt\n    Re-raised to allow proper keyboard interrupt handling.\nSystemExit\n    Re-raised to allow proper system shutdown.\nGeneratorExit\n    Re-raised to allow proper generator cleanup.\n\nNotes\n-----\nThis wrapper ensures all sync adapter exceptions are caught and\nconverted to error envelopes. The function signature is preserved\nfor FastMCP schema generation. Time complexity: O(1) wrapper overhead\nplus the wrapped function's complexity.",
  "is_public": true
}
{
  "path": "mcp_server/error_handling.py",
  "module": "mcp_server.error_handling",
  "qualname": "_extract_context_from_args",
  "name": "_extract_context_from_args",
  "node_type": "FunctionDef",
  "lineno": 739,
  "col": 0,
  "end_lineno": 760,
  "end_col": 54,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "mcp_server/error_handling.py",
  "module": "mcp_server.error_handling",
  "qualname": "_maybe_attach_runpack",
  "name": "_maybe_attach_runpack",
  "node_type": "FunctionDef",
  "lineno": 763,
  "col": 0,
  "end_lineno": 790,
  "end_col": 39,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "mcp_server/fetch_tool.py",
  "module": "mcp_server.fetch_tool",
  "qualname": "mcp_server.fetch_tool",
  "name": "mcp_server.fetch_tool",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Lightweight fetch helper used by the in-process MCP harness.",
  "is_public": true
}
{
  "path": "mcp_server/fetch_tool.py",
  "module": "mcp_server.fetch_tool",
  "qualname": "CatalogProtocol",
  "name": "CatalogProtocol",
  "node_type": "ClassDef",
  "lineno": 11,
  "col": 0,
  "end_lineno": 16,
  "end_col": 33,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Protocol describing the catalog lookups required for fetch.",
  "is_public": true
}
{
  "path": "mcp_server/fetch_tool.py",
  "module": "mcp_server.fetch_tool",
  "qualname": "CatalogProtocol.query_by_ids",
  "name": "query_by_ids",
  "node_type": "FunctionDef",
  "lineno": 14,
  "col": 4,
  "end_lineno": 16,
  "end_col": 33,
  "parent_qualname": "CatalogProtocol",
  "decorators": [],
  "bases": [],
  "docstring": "Return hydrated chunk rows for the provided identifiers.",
  "is_public": true
}
{
  "path": "mcp_server/fetch_tool.py",
  "module": "mcp_server.fetch_tool",
  "qualname": "handle_fetch",
  "name": "handle_fetch",
  "node_type": "FunctionDef",
  "lineno": 19,
  "col": 0,
  "end_lineno": 75,
  "end_col": 39,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Hydrate chunk IDs using the provided catalog.\n\nThis function processes fetch tool requests by querying the catalog for chunk\nmetadata corresponding to the provided object IDs. It is called by MCP tool\nhandlers to retrieve full chunk information (URI, line ranges, content, language)\nfor search result IDs.\n\nParameters\n----------\ncatalog : CatalogProtocol\n    Catalog implementation providing query_by_ids method for chunk retrieval.\nargs : dict[str, object]\n    Dictionary containing FetchInput fields, typically with \"objectIds\" key\n    containing a list of chunk identifier strings.\n\nReturns\n-------\nFetchOutput\n    Structured response containing hydrated chunks with metadata, or empty\n    objects list if no valid IDs are provided.",
  "is_public": true
}
{
  "path": "mcp_server/fetch_tool.py",
  "module": "mcp_server.fetch_tool",
  "qualname": "_build_url",
  "name": "_build_url",
  "node_type": "FunctionDef",
  "lineno": 78,
  "col": 0,
  "end_lineno": 94,
  "end_col": 42,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Build a repo:// URL from chunk metadata row.\n\nParameters\n----------\nrow : Mapping[str, object]\n    Chunk metadata dictionary containing uri, start_line, and end_line.\n\nReturns\n-------\nstr\n    URL in format \"repo://{uri}#L{start}-L{end}\" with 1-based line numbers.",
  "is_public": false
}
{
  "path": "mcp_server/fetch_tool.py",
  "module": "mcp_server.fetch_tool",
  "qualname": "_normalize_fetch_input",
  "name": "_normalize_fetch_input",
  "node_type": "FunctionDef",
  "lineno": 97,
  "col": 0,
  "end_lineno": 128,
  "end_col": 83,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Normalize and validate fetch tool input arguments.\n\nParameters\n----------\nargs : Mapping[str, object]\n    Raw arguments dictionary containing objectIds, max_tokens, and resolve.\n\nReturns\n-------\nFetchInput\n    Normalized and validated FetchInput object.\n\nRaises\n------\nValueError\n    If objectIds is missing or empty, or if resolve value is invalid.\nTypeError\n    If objectIds is not a sequence (raised by ``_coerce_object_ids``).",
  "is_public": false
}
{
  "path": "mcp_server/fetch_tool.py",
  "module": "mcp_server.fetch_tool",
  "qualname": "_coerce_optional_int",
  "name": "_coerce_optional_int",
  "node_type": "FunctionDef",
  "lineno": 131,
  "col": 0,
  "end_lineno": 146,
  "end_col": 29,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Coerce an optional value to int or None.\n\nParameters\n----------\nvalue : object | None\n    Value to coerce, or None.\n\nReturns\n-------\nint | None\n    Coerced integer value, or None if input is None.",
  "is_public": false
}
{
  "path": "mcp_server/fetch_tool.py",
  "module": "mcp_server.fetch_tool",
  "qualname": "_coerce_object_ids",
  "name": "_coerce_object_ids",
  "node_type": "FunctionDef",
  "lineno": 149,
  "col": 0,
  "end_lineno": 180,
  "end_col": 16,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Coerce object IDs to a list of non-empty strings.\n\nParameters\n----------\nvalue : object\n    Value to coerce to a list of object ID strings.\n\nReturns\n-------\nlist[str]\n    List of non-empty object ID strings.\n\nRaises\n------\nTypeError\n    If value is not a sequence (excluding strings and bytes).\nValueError\n    If the resulting list is empty.",
  "is_public": false
}
{
  "path": "mcp_server/fetch_tool.py",
  "module": "mcp_server.fetch_tool",
  "qualname": "_coerce_resolve",
  "name": "_coerce_resolve",
  "node_type": "FunctionDef",
  "lineno": 183,
  "col": 0,
  "end_lineno": 213,
  "end_col": 25,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Coerce resolve option to a valid literal value.\n\nParameters\n----------\nvalue : object | None\n    Resolve option value to coerce, or None for default.\n\nReturns\n-------\nLiteral[\"full\", \"summary\", \"metadata_only\"]\n    Valid resolve option, defaulting to \"full\" if None.\n\nRaises\n------\nValueError\n    If value does not match any allowed option.",
  "is_public": false
}
{
  "path": "mcp_server/fetch_tool.py",
  "module": "mcp_server.fetch_tool",
  "qualname": "_coerce_int",
  "name": "_coerce_int",
  "node_type": "FunctionDef",
  "lineno": 216,
  "col": 0,
  "end_lineno": 252,
  "end_col": 20,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Coerce a value to an integer with fallback to default.\n\nThis function attempts to convert various types (bool, int, float, str) to\nan integer, falling back to the default value if conversion fails or the\nvalue is None. Used by input normalization functions to safely coerce\nuser-provided values.\n\nParameters\n----------\nvalue : object\n    Value to coerce to integer.\ndefault : int\n    Default value to return if coercion fails. Defaults to 0.\n\nReturns\n-------\nint\n    Coerced integer value, or default if conversion fails.",
  "is_public": false
}
{
  "path": "mcp_server/registry.py",
  "module": "mcp_server.registry",
  "qualname": "mcp_server.registry",
  "name": "mcp_server.registry",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "In-process registry for the lightweight MCP testing harness.",
  "is_public": true
}
{
  "path": "mcp_server/registry.py",
  "module": "mcp_server.registry",
  "qualname": "McpDeps",
  "name": "McpDeps",
  "node_type": "ClassDef",
  "lineno": 23,
  "col": 0,
  "end_lineno": 28,
  "end_col": 78,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Dependencies required for running the lightweight MCP tools.",
  "is_public": true
}
{
  "path": "mcp_server/registry.py",
  "module": "mcp_server.registry",
  "qualname": "list_tools",
  "name": "list_tools",
  "node_type": "FunctionDef",
  "lineno": 31,
  "col": 0,
  "end_lineno": 52,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return tool metadata compatible with MCP /tools/list responses.\n\nReturns\n-------\nlist[dict[str, Any]]\n    Tool descriptor records with JSON Schemas for search and fetch.",
  "is_public": true
}
{
  "path": "mcp_server/registry.py",
  "module": "mcp_server.registry",
  "qualname": "call_tool",
  "name": "call_tool",
  "node_type": "FunctionDef",
  "lineno": 55,
  "col": 0,
  "end_lineno": 96,
  "end_col": 51,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Execute a tool using the provided dependencies.\n\nThis function dispatches tool execution requests to the appropriate handler\n(search or fetch) and packages the response in MCP-compatible format. It is\ncalled by MCP server implementations to execute tools requested by clients.\n\nParameters\n----------\ndeps : McpDeps\n    MCP dependencies including catalog and search functions.\nname : str\n    Tool name to execute, typically \"search\" or \"fetch\".\narguments : dict[str, Any]\n    Tool-specific arguments dictionary passed to the handler.\n\nReturns\n-------\ndict[str, Any]\n    MCP-compatible response envelope containing structuredContent for successful\n    tool execution, or isError flag with error content for unknown tools.",
  "is_public": true
}
{
  "path": "mcp_server/registry.py",
  "module": "mcp_server.registry",
  "qualname": "_error_response",
  "name": "_error_response",
  "node_type": "FunctionDef",
  "lineno": 99,
  "col": 0,
  "end_lineno": 117,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Build an MCP-compatible error response envelope.\n\nParameters\n----------\nmessage : str\n    Error message to include in the response.\n\nReturns\n-------\ndict[str, Any]\n    MCP error response dictionary with isError flag and content array.",
  "is_public": false
}
{
  "path": "mcp_server/retrieval/__init__.py",
  "module": "mcp_server.retrieval",
  "qualname": "mcp_server.retrieval",
  "name": "mcp_server.retrieval",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Retrieval utilities exposed via MCP tooling.",
  "is_public": true
}
{
  "path": "mcp_server/retrieval/xtr_cli.py",
  "module": "mcp_server.retrieval.xtr_cli",
  "qualname": "mcp_server.retrieval.xtr_cli",
  "name": "mcp_server.retrieval.xtr_cli",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Typer CLI for building, verifying, and probing XTR artifacts.",
  "is_public": true
}
{
  "path": "mcp_server/retrieval/xtr_cli.py",
  "module": "mcp_server.retrieval.xtr_cli",
  "qualname": "build",
  "name": "build",
  "node_type": "FunctionDef",
  "lineno": 31,
  "col": 0,
  "end_lineno": 40,
  "end_col": 51,
  "parent_qualname": null,
  "decorators": [
    "app.command('build')"
  ],
  "bases": [],
  "docstring": "Build token-level XTR artifacts from the DuckDB catalog.",
  "is_public": true
}
{
  "path": "mcp_server/retrieval/xtr_cli.py",
  "module": "mcp_server.retrieval.xtr_cli",
  "qualname": "verify",
  "name": "verify",
  "node_type": "FunctionDef",
  "lineno": 44,
  "col": 0,
  "end_lineno": 66,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [
    "app.command('verify')"
  ],
  "bases": [],
  "docstring": "Verify that XTR artifacts can be opened.\n\nRaises\n------\ntyper.Exit\n    If artifacts are missing or unreadable.",
  "is_public": true
}
{
  "path": "mcp_server/retrieval/xtr_cli.py",
  "module": "mcp_server.retrieval.xtr_cli",
  "qualname": "search",
  "name": "search",
  "node_type": "FunctionDef",
  "lineno": 70,
  "col": 0,
  "end_lineno": 155,
  "end_col": 52,
  "parent_qualname": null,
  "decorators": [
    "app.command('search')"
  ],
  "bases": [],
  "docstring": "Run a quick XTR search (wide or narrow depending on candidate ids).\n\nExtended Summary\n----------------\nThis CLI command performs XTR-based semantic search, supporting both wide-mode\n(index-wide search) and narrow-mode (rescoring Stage-0 candidates) depending on\nwhether candidate_ids are provided. It loads the XTR index, executes the search,\nand prints results to stdout. This is a utility command for testing and debugging\nXTR search functionality outside of the main MCP server.\n\nParameters\n----------\nquery : _QueryArg\n    Natural language query string to search for. Will be encoded into token\n    embeddings and used for MaxSim computation against the XTR index.\n    Type alias for ``Annotated[str, typer.Argument(...)]`` for CLI argument\n    specification. Provided as a positional argument via typer.\nk : _KOption, optional\n    Maximum number of top-k documents to return. Must be at least 1.\n    Defaults to 5. Type alias for ``Annotated[int, typer.Option(...)]`` for\n    CLI option specification. Provided as an option via typer (--k, -k).\ncandidate_ids : _CandidateIdsOption, optional\n    Optional list of Stage-0 candidate chunk IDs to rescore. If provided,\n    performs narrow-mode rescoring on these candidates only. If None, performs\n    wide-mode search across all chunks. Defaults to None. Type alias for\n    ``Annotated[list[int] | None, typer.Option(...)]`` for CLI option\n    specification. Provided as an option via typer (--candidate-id, -c).\nexplain : _ExplainOption, optional\n    Whether to include token-level attribution information in results. If True,\n    includes explainability data showing token alignments. If None, defaults\n    to True (explainability enabled). Type alias for\n    ``Annotated[bool | None, typer.Option(...)]`` for CLI option specification.\n    Provided as an option via typer.\n\nRaises\n------\ntyper.Exit\n    If XTR artifacts are missing and the command cannot run. This occurs when\n    the XTR index has not been built or is not ready for search operations.\n\nNotes\n-----\nTime complexity depends on search mode: O(N * T * D) for wide-mode where N is\ntotal chunks, T is tokens per chunk, D is embedding dimension; O(C * T * D) for\nnarrow-mode where C is candidate count. Space complexity O(k) for results.\nThe function performs file I/O to load the XTR index and GPU/CPU computation\nfor encoding and scoring. Not thread-safe due to index loading.",
  "is_public": true
}
{
  "path": "mcp_server/retrieval/xtr_cli.py",
  "module": "mcp_server.retrieval.xtr_cli",
  "qualname": "main",
  "name": "main",
  "node_type": "FunctionDef",
  "lineno": 158,
  "col": 0,
  "end_lineno": 160,
  "end_col": 9,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Execute the Typer app.",
  "is_public": true
}
{
  "path": "mcp_server/schemas.py",
  "module": "mcp_server.schemas",
  "qualname": "mcp_server.schemas",
  "name": "mcp_server.schemas",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "MCP server schemas using TypedDict for FastMCP compatibility.\n\nTypedDict provides automatic JSON Schema generation for FastMCP tools.",
  "is_public": true
}
{
  "path": "mcp_server/schemas.py",
  "module": "mcp_server.schemas",
  "qualname": "BaseErrorFields",
  "name": "BaseErrorFields",
  "node_type": "ClassDef",
  "lineno": 13,
  "col": 0,
  "end_lineno": 32,
  "end_col": 31,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "TypedDict"
  ],
  "docstring": "Base fields present in ALL error responses.\n\nThese fields are automatically added by the error handling decorator\nwhen an exception is caught. Adapters should never construct these\nmanually - they only appear on error paths handled by the decorator.\n\nAttributes\n----------\nerror : str\n    Human-readable error message. Present on all error responses.\n    Used for display in user interfaces and debugging.\nproblem : ProblemDetailsDict\n    RFC 9457 Problem Details payload with structured error information.\n    Includes type, title, status, detail, instance, code, and optional\n    extensions. Present on all error responses.",
  "is_public": true
}
{
  "path": "mcp_server/schemas.py",
  "module": "mcp_server.schemas",
  "qualname": "ScopeIn",
  "name": "ScopeIn",
  "node_type": "ClassDef",
  "lineno": 35,
  "col": 0,
  "end_lineno": 89,
  "end_col": 47,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "TypedDict"
  ],
  "docstring": "Query scope parameters for filtering search results.\n\nDefines the scope of a code intelligence query, allowing filtering by\nrepository, branch, commit, file patterns, and languages. All fields\nare optional (total=False) - unspecified fields don't filter results.\n\nThis scope is used throughout the MCP server to limit searches to relevant\nparts of the codebase. For example, a query might be scoped to a specific\nrepository and Python files only.\n\nAttributes\n----------\nrepos : list[str]\n    List of repository names to include in the search. Repository names\n    should match the repository identifier in the index. Empty list or\n    omitted means all repositories.\nbranches : list[str]\n    List of branch names to search. Useful for limiting to specific branches\n    (e.g., [\"main\", \"develop\"]). Empty list or omitted means all branches.\ncommit : str\n    Specific commit SHA to search. If provided, results are limited to\n    code as it existed at this commit. Useful for historical queries.\ninclude_globs : list[str]\n    File path glob patterns to include (e.g., [\"**/*.py\", \"src/**\"]).\n    Only files matching these patterns are searched. Empty list or omitted\n    means all files.\nexclude_globs : list[str]\n    File path glob patterns to exclude (e.g., [\"**/test_*.py\", \"**/__pycache__/**\"]).\n    Files matching these patterns are excluded from search. Empty list or\n    omitted means no exclusions.\nlanguages : list[str]\n    Programming languages to include (e.g., [\"python\", \"typescript\"]).\n    Only files of these languages are searched. Empty list or omitted means\n    all languages.\nkinds : list[str]\n    Symbol kinds to include (e.g., [\"function\", \"class\", \"method\"]).\n    Results are scoped to these symbol categories when provided.\nsymbols : list[str]\n    Specific SCIP symbol identifiers to focus on regardless of location.\nfaiss_tuning : NotRequired[dict[str, float]]\n    Optional per-session FAISS overrides (e.g., {\"nprobe\": 64.0, \"ef_search\": 128.0})\n    used to adjust runtime search knobs without rebuilding indexes. Values are\n    converted to float during normalization. This attribute is optional (NotRequired).",
  "is_public": true
}
{
  "path": "mcp_server/schemas.py",
  "module": "mcp_server.schemas",
  "qualname": "Match",
  "name": "Match",
  "node_type": "ClassDef",
  "lineno": 92,
  "col": 0,
  "end_lineno": 127,
  "end_col": 29,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "TypedDict"
  ],
  "docstring": "Search match result from text or semantic search.\n\nRepresents a single match found by a search operation (text search, semantic\nsearch, etc.). Contains the file location and a code preview for display.\n\nThe score field is optional because some search types (like exact text match)\nmay not have a relevance score. When present, scores are typically normalized\nto 0-1 range with higher values indicating better matches.\n\nAttributes\n----------\npath : str\n    File path where the match was found. Typically a relative path from the\n    repository root. Used for navigation and file filtering.\nline : int\n    Line number where the match occurs (1-indexed for human readability).\n    Used for \"go to line\" functionality and displaying code context.\ncolumn : int\n    Column/character position within the line (0-indexed). Used for precise\n    positioning within a line, especially for symbol references.\npreview : str\n    Code snippet preview showing the matched code in context. Typically\n    1-3 lines around the match. Used for displaying search results without\n    opening the full file.\nscore : NotRequired[float]\n    Relevance score for the match (0.0 to 1.0, higher is better). Present\n    for semantic search results, may be omitted for exact text matches.\n    Used for ranking and filtering results.",
  "is_public": true
}
{
  "path": "mcp_server/schemas.py",
  "module": "mcp_server.schemas",
  "qualname": "Location",
  "name": "Location",
  "node_type": "ClassDef",
  "lineno": 130,
  "col": 0,
  "end_lineno": 165,
  "end_col": 19,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "TypedDict"
  ],
  "docstring": "Source code location with precise line and column positions.\n\nRepresents a contiguous region of source code using line and column\ncoordinates. Used for symbol definitions, references, and code ranges.\nMatches the LSP Location format for compatibility with language servers.\n\nAll coordinates are 0-indexed to match programming conventions. The range\nis inclusive at start, exclusive at end (matching LSP/SCIP convention).\n\nAttributes\n----------\nuri : str\n    File URI or path identifying the source file. Typically a relative path\n    from the repository root. Used to locate and open the file.\nstart_line : int\n    Starting line number (0-indexed). The first line of a file is line 0.\n    Together with start_column, defines the start of the range.\nstart_column : int\n    Starting column/character position (0-indexed) within start_line.\n    Character 0 is the first character on the line. Defines the precise\n    start position.\nend_line : int\n    Ending line number (0-indexed, inclusive). The range spans from start_line\n    to end_line (inclusive). For single-line ranges, equals start_line.\nend_column : int\n    Ending column/character position (0-indexed, exclusive) within end_line.\n    The range includes characters from start_column up to (but not including)\n    end_column. This matches LSP/SCIP convention.",
  "is_public": true
}
{
  "path": "mcp_server/schemas.py",
  "module": "mcp_server.schemas",
  "qualname": "Finding",
  "name": "Finding",
  "node_type": "ClassDef",
  "lineno": 168,
  "col": 0,
  "end_lineno": 215,
  "end_col": 17,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "TypedDict"
  ],
  "docstring": "Generic finding result from code intelligence queries.\n\nRepresents a single finding from a search or analysis operation. Findings\ncan be symbol definitions, references, documentation, security issues, API\nusages, etc. All fields are optional (total=False) to allow flexible\nresult structures.\n\nFindings are the primary result type returned by MCP tools. They combine\nlocation information, code snippets, and metadata to provide actionable\ncode intelligence.\n\nAttributes\n----------\ntype : Literal[\"definition\", \"reference\", \"usage\", \"doc\", \"security\", \"api\"]\n    Type of finding. \"definition\" = symbol definition, \"reference\" = symbol\n    reference/usage, \"usage\" = how something is used, \"doc\" = documentation,\n    \"security\" = security-related finding, \"api\" = API usage or definition.\ntitle : str\n    Human-readable title for the finding. Should be concise and descriptive\n    (e.g., \"Function definition: process_data\", \"Security issue: SQL injection\").\n    Used for display in search results and tooltips.\nlocation : Location\n    Source code location where this finding occurs. Includes file URI and\n    precise line/column positions for navigation.\nsnippet : str\n    Code snippet showing the relevant code. Typically 3-10 lines of context\n    around the finding. Used for preview without opening the full file.\nscore : float\n    Relevance score (0.0 to 1.0, higher is better). Indicates how well this\n    finding matches the query. Used for ranking and filtering results.\nwhy : str\n    Explanation of why this finding matches the query. Provides context and\n    reasoning for the match (e.g., \"Matches query 'data processing' because\n    function name contains 'process' and docstring mentions 'data'\").\nchunk_id : int\n    Internal chunk identifier used for hydration bookkeeping and hybrid fusion.\n    Not all clients need this value; it is primarily used by the server when\n    combining multiple retrieval channels.",
  "is_public": true
}
{
  "path": "mcp_server/schemas.py",
  "module": "mcp_server.schemas",
  "qualname": "MethodInfo",
  "name": "MethodInfo",
  "node_type": "ClassDef",
  "lineno": 218,
  "col": 0,
  "end_lineno": 253,
  "end_col": 29,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "TypedDict"
  ],
  "docstring": "Retrieval method metadata for search operations.\n\nDescribes which retrieval methods were used to generate search results and\nprovides information about search coverage. Useful for understanding result\nquality and debugging search behavior.\n\nAll fields are optional (total=False) to allow flexible metadata structures.\n\nAttributes\n----------\nretrieval : list[str]\n    List of retrieval methods used to generate results. Common values:\n    \"semantic\" (FAISS/dense embeddings), \"bm25\" (keyword/BM25), \"splade\"\n    (learned sparse), \"structural\" (AST-based). Multiple methods indicate\n    hybrid retrieval with RRF fusion.\ncoverage : str\n    Human-readable description of search coverage. Explains what was searched\n    and any limitations (e.g., \"Searched 1.2M chunks across Python files\",\n    \"Limited to main branch\", \"Index incomplete - missing recent commits\").\nstages : list[StageInfo]\n    Optional stage-level timing data for observability.\nnotes : list[str]\n    Optional free-form notes about retrieval decisions (e.g., gating reasons).\nexplainability : dict[str, list[dict[str, object]]]\n    Optional structured explainability payload keyed by channel.\nrerank : dict[str, object]\n    Optional metadata describing the reranker decision (provider, reason).",
  "is_public": true
}
{
  "path": "mcp_server/schemas.py",
  "module": "mcp_server.schemas",
  "qualname": "StageInfo",
  "name": "StageInfo",
  "node_type": "ClassDef",
  "lineno": 256,
  "col": 0,
  "end_lineno": 265,
  "end_col": 29,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "TypedDict"
  ],
  "docstring": "Timing metadata for an individual retrieval stage.",
  "is_public": true
}
{
  "path": "mcp_server/schemas.py",
  "module": "mcp_server.schemas",
  "qualname": "SearchFilterPayload",
  "name": "SearchFilterPayload",
  "node_type": "ClassDef",
  "lineno": 268,
  "col": 0,
  "end_lineno": 287,
  "end_col": 22,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "TypedDict"
  ],
  "docstring": "Structured filter payload for Deep Research search requests.\n\nAttributes\n----------\nlang : list[str]\n    Programming languages to restrict results to. Uses the same language\n    mapping as :func:`scope_utils.apply_language_filter`.\ninclude : list[str]\n    Glob patterns that candidate paths must match (e.g., ``src/**``).\nexclude : list[str]\n    Glob patterns that candidate paths must *not* match.\nsymbols : list[str]\n    Exact symbol identifiers the chunk must contain.",
  "is_public": true
}
{
  "path": "mcp_server/schemas.py",
  "module": "mcp_server.schemas",
  "qualname": "SearchToolArgs",
  "name": "SearchToolArgs",
  "node_type": "ClassDef",
  "lineno": 290,
  "col": 0,
  "end_lineno": 296,
  "end_col": 29,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "TypedDict"
  ],
  "docstring": "Input schema for the MCP ``search`` tool.",
  "is_public": true
}
{
  "path": "mcp_server/schemas.py",
  "module": "mcp_server.schemas",
  "qualname": "SearchExplainability",
  "name": "SearchExplainability",
  "node_type": "ClassDef",
  "lineno": 299,
  "col": 0,
  "end_lineno": 305,
  "end_col": 13,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "TypedDict"
  ],
  "docstring": "Explainability payload attached to each search result.",
  "is_public": true
}
{
  "path": "mcp_server/schemas.py",
  "module": "mcp_server.schemas",
  "qualname": "SearchResultMetadata",
  "name": "SearchResultMetadata",
  "node_type": "ClassDef",
  "lineno": 308,
  "col": 0,
  "end_lineno": 318,
  "end_col": 33,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "TypedDict"
  ],
  "docstring": "Metadata exposed alongside each MCP search hit.",
  "is_public": true
}
{
  "path": "mcp_server/schemas.py",
  "module": "mcp_server.schemas",
  "qualname": "SearchResultItem",
  "name": "SearchResultItem",
  "node_type": "ClassDef",
  "lineno": 321,
  "col": 0,
  "end_lineno": 330,
  "end_col": 34,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "TypedDict"
  ],
  "docstring": "Single MCP search result entry.",
  "is_public": true
}
{
  "path": "mcp_server/schemas.py",
  "module": "mcp_server.schemas",
  "qualname": "SearchStructuredContent",
  "name": "SearchStructuredContent",
  "node_type": "ClassDef",
  "lineno": 333,
  "col": 0,
  "end_lineno": 339,
  "end_col": 21,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "TypedDict"
  ],
  "docstring": "Structured payload returned by the MCP ``search`` tool.",
  "is_public": true
}
{
  "path": "mcp_server/schemas.py",
  "module": "mcp_server.schemas",
  "qualname": "FetchToolArgs",
  "name": "FetchToolArgs",
  "node_type": "ClassDef",
  "lineno": 342,
  "col": 0,
  "end_lineno": 346,
  "end_col": 32,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "TypedDict"
  ],
  "docstring": "Input schema for the MCP ``fetch`` tool.",
  "is_public": true
}
{
  "path": "mcp_server/schemas.py",
  "module": "mcp_server.schemas",
  "qualname": "FetchObjectMetadata",
  "name": "FetchObjectMetadata",
  "node_type": "ClassDef",
  "lineno": 349,
  "col": 0,
  "end_lineno": 357,
  "end_col": 13,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "TypedDict"
  ],
  "docstring": "Metadata describing a hydrated chunk object.",
  "is_public": true
}
{
  "path": "mcp_server/schemas.py",
  "module": "mcp_server.schemas",
  "qualname": "FetchObject",
  "name": "FetchObject",
  "node_type": "ClassDef",
  "lineno": 360,
  "col": 0,
  "end_lineno": 367,
  "end_col": 33,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "TypedDict"
  ],
  "docstring": "Object entry returned by the MCP ``fetch`` tool.",
  "is_public": true
}
{
  "path": "mcp_server/schemas.py",
  "module": "mcp_server.schemas",
  "qualname": "FetchStructuredContent",
  "name": "FetchStructuredContent",
  "node_type": "ClassDef",
  "lineno": 370,
  "col": 0,
  "end_lineno": 373,
  "end_col": 30,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "TypedDict"
  ],
  "docstring": "Structured payload returned by the MCP ``fetch`` tool.",
  "is_public": true
}
{
  "path": "mcp_server/schemas.py",
  "module": "mcp_server.schemas",
  "qualname": "AnswerEnvelope",
  "name": "AnswerEnvelope",
  "node_type": "ClassDef",
  "lineno": 376,
  "col": 0,
  "end_lineno": 477,
  "end_col": 31,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "TypedDict"
  ],
  "docstring": "Standard response envelope for MCP code intelligence tools.\n\nComprehensive response structure that wraps all types of code intelligence\nresults. This envelope provides a consistent format across all MCP tools,\nmaking it easy for clients to process results uniformly.\n\nAll fields are optional (total=False) - tools include only relevant fields\nfor their specific operation. For example, a semantic search might include\nfindings and method, while a symbol lookup might include xrefs and docs.\n\nAttributes\n----------\nanswer : str\n    Human-readable summary answer to the query. Provides a natural language\n    explanation of the results (e.g., \"Found 15 functions related to data\n    processing in src/core/\"). Used for display in chat interfaces.\nquery_kind : str\n    Type of query that was executed (e.g., \"semantic_search\", \"symbol_lookup\",\n    \"text_search\", \"code_review\"). Used for result categorization and routing.\nscope : ScopeIn\n    Query scope that was applied to filter results. Shows which repositories,\n    branches, files, and languages were searched. Useful for understanding\n    result limitations.\nmethod : MethodInfo\n    Retrieval method metadata describing how results were generated. Includes\n    which retrieval systems were used and search coverage information.\nfindings : list[Finding]\n    Primary search results as Finding objects. Each finding represents a\n    code location with context. This is the main result field for most queries.\nxrefs : dict\n    Cross-reference information (callers, callees, dependencies). Structure\n    varies by query type. For symbol queries, might contain \"callers\" and\n    \"callees\" lists. For dependency queries, might contain dependency graphs.\nhistory : list[dict]\n    Git history entries related to the query. Each entry typically contains\n    commit SHA, author, date, message. Used for \"who changed this\" queries.\ndocs : list[dict]\n    Documentation entries found. Might include ADRs, API docs, README sections.\n    Structure varies by documentation format.\nsecurity : list[dict]\n    Security-related findings (vulnerabilities, issues, best practices).\n    Each entry describes a security concern with location and severity.\napi : dict\n    API catalog information. Contains API definitions, endpoints, schemas\n    relevant to the query. Structure depends on API format (OpenAPI, etc.).\nowners : list[dict]\n    Code ownership information. Lists who owns or maintains the code in question.\n    Each entry might contain name, email, team, ownership percentage.\nrelated : list[dict]\n    Related findings or suggestions. Might include similar code, related\n    symbols, or follow-up queries. Structure varies.\nconfidence : float\n    Overall confidence score for the results (0.0 to 1.0). Indicates how\n    confident the system is that results are relevant and complete. Higher\n    values indicate high-quality, complete results.\nlimits : list[str]\n    List of limitations or degraded service notices. Explains any constraints\n    on the search (e.g., \"Index incomplete\", \"GPU unavailable - using CPU\",\n    \"Limited to 1000 results\"). Used for transparency and debugging.\nnext_steps : list[str]\n    Suggested follow-up queries or actions. Provides guidance on how to\n    refine the search or explore related topics (e.g., \"Try searching for\n    'data validation'\", \"See callers of this function\").\ntelemetry : dict[str, str]\n    Telemetry metadata describing the request/session identifiers. Contains\n    ``run_id`` (trace identifier) and ``session_id`` when available, enabling\n    correlation with traces and run reports.\ntrace_id : str\n    OpenTelemetry trace identifier associated with the request, when available.\nspan_id : str\n    Identifier of the span responsible for assembling the response envelope.\nrun_id : str\n    Diagnostic run identifier that can be used to correlate with run reports.\ndiag_report_uri : str\n    Path to the flight recorder JSON artifact summarizing the run.\nproblem : ProblemDetailsDict\n    RFC 9457 Problem Details payload describing the failure when the request\n    could not be fulfilled successfully.",
  "is_public": true
}
{
  "path": "mcp_server/schemas.py",
  "module": "mcp_server.schemas",
  "qualname": "SymbolInfo",
  "name": "SymbolInfo",
  "node_type": "ClassDef",
  "lineno": 480,
  "col": 0,
  "end_lineno": 508,
  "end_col": 25,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "TypedDict"
  ],
  "docstring": "Symbol information with location and documentation.\n\nRepresents a programming language symbol (function, class, variable, etc.)\nwith its location and optional documentation. Used for symbol search results\nand \"go to definition\" functionality.\n\nAttributes\n----------\nname : str\n    Symbol name as it appears in source code (e.g., \"process_data\", \"DataProcessor\").\n    Used for display and matching.\nkind : str\n    Symbol kind/type (e.g., \"function\", \"class\", \"variable\", \"method\", \"module\").\n    Language-specific but typically follows LSP symbol kinds. Used for\n    filtering and categorization.\nlocation : Location\n    Source code location where the symbol is defined. Includes file URI and\n    precise line/column positions for navigation.\ndoc : NotRequired[str]\n    Documentation string for the symbol (docstring, JSDoc, etc.). May be\n    omitted if no documentation is available. Used for displaying symbol\n    information without opening the file.",
  "is_public": true
}
{
  "path": "mcp_server/schemas.py",
  "module": "mcp_server.schemas",
  "qualname": "GitBlameEntry",
  "name": "GitBlameEntry",
  "node_type": "ClassDef",
  "lineno": 511,
  "col": 0,
  "end_lineno": 541,
  "end_col": 16,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "TypedDict"
  ],
  "docstring": "Git blame entry for a single line of code.\n\nRepresents the git blame information for one line, showing who last modified\nit, when, and why. Used for code ownership queries and understanding code\nhistory.\n\nAttributes\n----------\nline : int\n    Line number (1-indexed for human readability). The line this blame entry\n    refers to.\ncommit : str\n    Full commit SHA (40-character hex string) that last modified this line.\n    Used for linking to commit details and diffs.\nauthor : str\n    Name of the author who made the commit. Typically in \"Name <email>\"\n    format. Used for identifying code owners.\ndate : str\n    Commit date in ISO 8601 format (e.g., \"2024-01-15T10:30:00Z\"). Used for\n    temporal analysis and filtering by date.\nmessage : str\n    Commit message explaining why the change was made. First line or full\n    message depending on context. Used for understanding the reason for changes.",
  "is_public": true
}
{
  "path": "mcp_server/schemas.py",
  "module": "mcp_server.schemas",
  "qualname": "OpenFileResponse",
  "name": "OpenFileResponse",
  "node_type": "ClassDef",
  "lineno": 544,
  "col": 0,
  "end_lineno": 565,
  "end_col": 13,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "BaseErrorFields"
  ],
  "docstring": "Response from open_file tool.\n\nOn success: path, content, lines, size are populated.\nOn error: all result fields are empty/zero, error and problem are present.\n\nAttributes\n----------\npath : str\n    File path relative to repository root. Empty string on error.\ncontent : str\n    File content (optionally sliced by line range). Empty string on error.\nlines : int\n    Number of lines in the returned content. Zero on error.\nsize : int\n    Size of the returned content in bytes. Zero on error.",
  "is_public": true
}
{
  "path": "mcp_server/schemas.py",
  "module": "mcp_server.schemas",
  "qualname": "ListPathsResponse",
  "name": "ListPathsResponse",
  "node_type": "ClassDef",
  "lineno": 568,
  "col": 0,
  "end_lineno": 586,
  "end_col": 32,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "BaseErrorFields"
  ],
  "docstring": "Response from list_paths tool.\n\nOn success: items list is populated, total > 0.\nOn error: items is empty list, total is 0, error and problem are present.\n\nAttributes\n----------\nitems : list[dict]\n    List of file items with path, size, modified timestamp. Empty list on error.\ntotal : int\n    Total number of files found. Zero on error.\ntruncated : NotRequired[bool]\n    Whether results were truncated due to max_results limit. False on error.",
  "is_public": true
}
{
  "path": "mcp_server/schemas.py",
  "module": "mcp_server.schemas",
  "qualname": "BlameRangeResponse",
  "name": "BlameRangeResponse",
  "node_type": "ClassDef",
  "lineno": 589,
  "col": 0,
  "end_lineno": 601,
  "end_col": 30,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "BaseErrorFields"
  ],
  "docstring": "Response from blame_range tool.\n\nOn success: blame list is populated.\nOn error: blame is empty list, error and problem are present.\n\nAttributes\n----------\nblame : list[GitBlameEntry]\n    List of git blame entries for the requested line range. Empty list on error.",
  "is_public": true
}
{
  "path": "mcp_server/schemas.py",
  "module": "mcp_server.schemas",
  "qualname": "FileHistoryResponse",
  "name": "FileHistoryResponse",
  "node_type": "ClassDef",
  "lineno": 604,
  "col": 0,
  "end_lineno": 616,
  "end_col": 23,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "BaseErrorFields"
  ],
  "docstring": "Response from file_history tool.\n\nOn success: commits list is populated.\nOn error: commits is empty list, error and problem are present.\n\nAttributes\n----------\ncommits : list[dict]\n    List of commit entries with SHA, author, date, message. Empty list on error.",
  "is_public": true
}
{
  "path": "mcp_server/schemas.py",
  "module": "mcp_server.schemas",
  "qualname": "SearchTextResponse",
  "name": "SearchTextResponse",
  "node_type": "ClassDef",
  "lineno": 619,
  "col": 0,
  "end_lineno": 637,
  "end_col": 32,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "BaseErrorFields"
  ],
  "docstring": "Response from search_text tool.\n\nOn success: matches list is populated, total > 0.\nOn error: matches is empty, total is 0, error and problem are present.\n\nAttributes\n----------\nmatches : list[Match]\n    List of search matches. Empty list on error.\ntotal : int\n    Total number of matches found. Zero on error.\ntruncated : NotRequired[bool]\n    Whether results were truncated due to max_results limit. False on error.",
  "is_public": true
}
{
  "path": "mcp_server/scope_utils.py",
  "module": "mcp_server.scope_utils",
  "qualname": "mcp_server.scope_utils",
  "name": "mcp_server.scope_utils",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Scope filtering and merging utilities for CodeIntel MCP.\n\nThis module provides helper functions for retrieving session scopes, merging them\nwith explicit adapter parameters, and applying path/language filters to search results.\n\nKey Functions\n-------------\nget_effective_scope : Retrieve session scope from registry\nmerge_scope_filters : Merge session scope with explicit parameters (explicit wins)\napply_path_filters : Filter paths using glob patterns (fnmatch)\napply_language_filter : Filter paths by programming language extension\npath_matches_glob : Test if path matches glob pattern\n\nDesign Principles\n-----------------\n- **Explicit Precedence**: Explicit adapter parameters always override session scope\n- **Fail-Safe**: Missing scope or empty filters return unfiltered results\n- **Cross-Platform**: Normalize path separators for Windows/Unix compatibility\n- **Performance**: Early-exit for empty filters to avoid unnecessary iterations\n\nExample Usage\n-------------\nRetrieve and merge scope in adapter:\n\n>>> from codeintel_rev.mcp_server.scope_utils import get_effective_scope, merge_scope_filters\n>>> session_id = get_session_id()\n>>> scope = get_effective_scope(context, session_id)\n>>> merged = merge_scope_filters(scope, {\"include_globs\": [\"src/**\"]})\n>>> # merged[\"include_globs\"] is now [\"src/**\"] (explicit overrides scope)\n\nFilter paths by glob patterns:\n\n>>> from codeintel_rev.mcp_server.scope_utils import apply_path_filters\n>>> paths = [\"src/main.py\", \"tests/test_main.py\", \"docs/README.md\"]\n>>> filtered = apply_path_filters(paths, include_globs=[\"**/*.py\"], exclude_globs=[\"**/test_*.py\"])\n>>> filtered\n['src/main.py']\n\nFilter paths by language:\n\n>>> from codeintel_rev.mcp_server.scope_utils import apply_language_filter\n>>> paths = [\"src/main.py\", \"src/app.ts\", \"README.md\"]\n>>> filtered = apply_language_filter(paths, [\"python\"])\n>>> filtered\n['src/main.py']\n\nSee Also\n--------\ncodeintel_rev.app.scope_store : ScopeStore for storing session scopes\ncodeintel_rev.app.middleware : get_session_id for retrieving session ID",
  "is_public": true
}
{
  "path": "mcp_server/scope_utils.py",
  "module": "mcp_server.scope_utils",
  "qualname": "get_effective_scope",
  "name": "get_effective_scope",
  "node_type": "AsyncFunctionDef",
  "lineno": 116,
  "col": 0,
  "end_lineno": 157,
  "end_col": 52,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Retrieve session scope from the scope store.\n\nHelper function that wraps ScopeStore.get with null-safety for missing session\nIDs. Returns None if session_id is None or scope not found, allowing adapters\nto gracefully fall back to \"no scope\" behavior.\n\nParameters\n----------\ncontext : ApplicationContext\n    Application context containing scope store.\nsession_id : str | None\n    Session identifier to look up. If None, returns None immediately\n    without registry access.\n\nReturns\n-------\nScopeIn | None\n    Scope dictionary if session exists and has scope, None otherwise.\n\nExamples\n--------\n>>> context = ApplicationContext.create()\n>>> session_id = \"test-session-123\"\n>>> await context.scope_store.set(session_id, {\"languages\": [\"python\"]})\n>>> scope = await get_effective_scope(context, session_id)\n>>> scope\n{'languages': ['python']}\n>>> get_effective_scope(context, None)  # No session ID\n>>> get_effective_scope(context, \"nonexistent\")  # No scope set\n\nNotes\n-----\nThis function is preferred over direct registry access because it handles\nthe None case explicitly, making adapter code cleaner.",
  "is_public": true
}
{
  "path": "mcp_server/scope_utils.py",
  "module": "mcp_server.scope_utils",
  "qualname": "merge_scope_filters",
  "name": "merge_scope_filters",
  "node_type": "FunctionDef",
  "lineno": 160,
  "col": 0,
  "end_lineno": 232,
  "end_col": 17,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Merge session scope with explicit adapter parameters.\n\nCombines scope fields with explicit function parameters, giving precedence\nto explicit parameters. This allows users to override session scope for\nindividual queries without clearing the scope.\n\nMerge Rules:\n- If explicit param is present (not None), use it (override scope).\n- If explicit param is absent (None), use scope value (default).\n- If both absent, field is omitted from result.\n\nParameters\n----------\nscope : ScopeIn | None\n    Session scope from registry (may be None if no scope set).\nexplicit_params : dict\n    Parameters passed directly to adapter (e.g., {\"include_globs\": [...]}).\n    Keys match ScopeIn fields. Values of None are treated as \"not provided\".\n\nReturns\n-------\ndict\n    Merged dictionary with explicit params overriding scope defaults.\n\nExamples\n--------\nExplicit parameter overrides scope:\n\n>>> scope = {\"include_globs\": [\"**/*.py\"], \"languages\": [\"python\"]}\n>>> explicit = {\"include_globs\": [\"src/**\"]}\n>>> merged = merge_scope_filters(scope, explicit)\n>>> merged\n{'include_globs': ['src/**'], 'languages': ['python']}\n\nScope provides defaults for unspecified params:\n\n>>> scope = {\"include_globs\": [\"**/*.py\"], \"exclude_globs\": [\"**/test_*\"]}\n>>> explicit = {\"include_globs\": None, \"exclude_globs\": None}\n>>> merged = merge_scope_filters(scope, explicit)\n>>> merged\n{'include_globs': ['**/*.py'], 'exclude_globs': ['**/test_*']}\n\nNo scope (all from explicit params):\n\n>>> merged = merge_scope_filters(None, {\"include_globs\": [\"**/*.ts\"]})\n>>> merged\n{'include_globs': ['**/*.ts']}\n\nEmpty scope and empty params:\n\n>>> merged = merge_scope_filters(None, {})\n>>> merged\n{}\n\nNotes\n-----\nThe function does not modify input dictsit returns a new dict. This\nensures thread safety (no shared mutable state).",
  "is_public": true
}
{
  "path": "mcp_server/scope_utils.py",
  "module": "mcp_server.scope_utils",
  "qualname": "apply_path_filters",
  "name": "apply_path_filters",
  "node_type": "FunctionDef",
  "lineno": 235,
  "col": 0,
  "end_lineno": 321,
  "end_col": 19,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Filter paths using glob patterns.\n\nApplies include and exclude glob patterns to a list of file paths. Paths\nmust match at least one include pattern AND no exclude patterns to be kept.\n\nMatching is done using fnmatch (Unix shell-style globs):\n- `*` matches anything (including `/` in our implementation)\n- `?` matches any single character\n- `[seq]` matches any character in seq\n- `[!seq]` matches any character not in seq\n\nParameters\n----------\npaths : list[str]\n    File paths to filter (typically relative to repo root).\ninclude_globs : list[str]\n    Glob patterns to include. Paths must match at least one pattern.\n    Empty list means \"include all\" (no filtering).\nexclude_globs : list[str]\n    Glob patterns to exclude. Paths matching any pattern are removed.\n    Empty list means \"exclude none\".\n\nReturns\n-------\nlist[str]\n    Filtered paths list (order preserved from input).\n\nExamples\n--------\nInclude only Python files:\n\n>>> paths = [\"src/main.py\", \"src/app.ts\", \"README.md\"]\n>>> filtered = apply_path_filters(paths, include_globs=[\"**/*.py\"], exclude_globs=[])\n>>> filtered\n['src/main.py']\n\nExclude test files:\n\n>>> paths = [\"src/main.py\", \"tests/test_main.py\", \"src/utils.py\"]\n>>> filtered = apply_path_filters(paths, include_globs=[\"**/*.py\"], exclude_globs=[\"**/test_*\"])\n>>> filtered\n['src/main.py', 'src/utils.py']\n\nEmpty include globs (include all):\n\n>>> filtered = apply_path_filters(paths, include_globs=[], exclude_globs=[\"**/test_*\"])\n>>> # All paths except test files\n\nNotes\n-----\nPath separators are normalized to forward slashes (/) before matching to\nensure Windows paths (backslash) match Unix-style glob patterns.\n\nPerformance: O(n * m) where n = len(paths), m = max(len(include), len(exclude)).\nFor large path lists, consider pre-filtering during directory traversal\ninstead of post-filtering.",
  "is_public": true
}
{
  "path": "mcp_server/scope_utils.py",
  "module": "mcp_server.scope_utils",
  "qualname": "apply_language_filter",
  "name": "apply_language_filter",
  "node_type": "FunctionDef",
  "lineno": 324,
  "col": 0,
  "end_lineno": 415,
  "end_col": 19,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Filter paths by programming language.\n\nReturns only paths whose file extensions match the specified languages.\nUses LANGUAGE_EXTENSIONS mapping to resolve language names to extensions.\n\nParameters\n----------\npaths : list[str]\n    File paths to filter.\nlanguages : list[str]\n    Programming language names (e.g., [\"python\", \"typescript\"]).\n    Case-insensitive (normalized to lowercase).\n\nReturns\n-------\nlist[str]\n    Paths with extensions matching specified languages (order preserved).\n\nExamples\n--------\nFilter to Python files only:\n\n>>> paths = [\"src/main.py\", \"src/app.ts\", \"README.md\"]\n>>> filtered = apply_language_filter(paths, [\"python\"])\n>>> filtered\n['src/main.py']\n\nMultiple languages:\n\n>>> filtered = apply_language_filter(paths, [\"python\", \"typescript\"])\n>>> filtered\n['src/main.py', 'src/app.ts']\n\nUnknown language (no matches):\n\n>>> filtered = apply_language_filter(paths, [\"cobol\"])\n>>> filtered\n[]\n\nNotes\n-----\nLanguage names are case-insensitive: \"Python\", \"python\", \"PYTHON\" all work.\n\nIf a language is not in LANGUAGE_EXTENSIONS, it's silently ignored (no\nerror raised). This allows forward compatibility if new languages are added\nto the mapping later.\n\nExtension matching is case-sensitive: \".PY\" will NOT match Python (use\nlowercase extensions in path normalization if needed).",
  "is_public": true
}
{
  "path": "mcp_server/scope_utils.py",
  "module": "mcp_server.scope_utils",
  "qualname": "path_matches_glob",
  "name": "path_matches_glob",
  "node_type": "FunctionDef",
  "lineno": 418,
  "col": 0,
  "end_lineno": 476,
  "end_col": 67,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Test if path matches glob pattern.\n\nWrapper around fnmatch.fnmatchcase with path normalization for cross-platform\ncompatibility. Handles both simple patterns (*.py) and recursive patterns\n(**/*.py).\n\nParameters\n----------\npath : str\n    File path to test (typically relative to repo root).\npattern : str\n    Glob pattern (Unix shell-style).\n\nReturns\n-------\nbool\n    True if path matches pattern, False otherwise.\n\nExamples\n--------\nSimple suffix match:\n\n>>> path_matches_glob(\"test.py\", \"*.py\")\nTrue\n>>> path_matches_glob(\"test.ts\", \"*.py\")\nFalse\n\nRecursive pattern:\n\n>>> path_matches_glob(\"src/utils/helpers.py\", \"**/*.py\")\nTrue\n>>> path_matches_glob(\"README.md\", \"**/*.py\")\nFalse\n\nDirectory prefix:\n\n>>> path_matches_glob(\"src/main.py\", \"src/**\")\nTrue\n>>> path_matches_glob(\"lib/util.py\", \"src/**\")\nFalse\n\nNotes\n-----\nfnmatch treats `*` as matching any characters INCLUDING slashes, unlike\nsome glob implementations (e.g., bash) where `*` doesn't match `/`. This\nmakes `**/*.py` and `*/*.py` functionally equivalent in our implementation.\n\nFor more complex patterns (e.g., brace expansion {a,b}), consider using\nthe `wcmatch` library which supports advanced glob features.",
  "is_public": true
}
{
  "path": "mcp_server/search_tool.py",
  "module": "mcp_server.search_tool",
  "qualname": "mcp_server.search_tool",
  "name": "mcp_server.search_tool",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Lightweight search helpers used by the in-process MCP harness.",
  "is_public": true
}
{
  "path": "mcp_server/search_tool.py",
  "module": "mcp_server.search_tool",
  "qualname": "CatalogProtocol",
  "name": "CatalogProtocol",
  "node_type": "ClassDef",
  "lineno": 12,
  "col": 0,
  "end_lineno": 17,
  "end_col": 33,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "Protocol"
  ],
  "docstring": "Protocol describing the catalog surface used by the lightweight MCP tools.",
  "is_public": true
}
{
  "path": "mcp_server/search_tool.py",
  "module": "mcp_server.search_tool",
  "qualname": "CatalogProtocol.query_by_ids",
  "name": "query_by_ids",
  "node_type": "FunctionDef",
  "lineno": 15,
  "col": 4,
  "end_lineno": 17,
  "end_col": 33,
  "parent_qualname": "CatalogProtocol",
  "decorators": [],
  "bases": [],
  "docstring": "Return hydrated chunk rows for the provided identifiers.",
  "is_public": true
}
{
  "path": "mcp_server/search_tool.py",
  "module": "mcp_server.search_tool",
  "qualname": "SearchDeps",
  "name": "SearchDeps",
  "node_type": "ClassDef",
  "lineno": 21,
  "col": 0,
  "end_lineno": 26,
  "end_col": 78,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Dependencies required to execute the light search helper.",
  "is_public": true
}
{
  "path": "mcp_server/search_tool.py",
  "module": "mcp_server.search_tool",
  "qualname": "handle_search",
  "name": "handle_search",
  "node_type": "FunctionDef",
  "lineno": 29,
  "col": 0,
  "end_lineno": 98,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Execute a lightweight search suitable for MCP tests or tooling.\n\nThis function performs a hybrid search combining dense (FAISS) and sparse\n(BM25/SPLADE) retrieval channels, then hydrates results with chunk metadata\nfrom the catalog. It is called by MCP tool handlers to provide search\nfunctionality for testing and lightweight tooling scenarios.\n\nParameters\n----------\ndeps : SearchDeps\n    Search dependencies including catalog, FAISS search function, and sparse\n    search function. Functions may be None if corresponding channels are disabled.\nargs : dict[str, object]\n    Dictionary containing SearchInput fields, typically with \"query\" and\n    \"top_k\" keys.\n\nReturns\n-------\nSearchOutput\n    msgspec-structured payload describing top-k results with metadata,\n    query echo, and limits information.",
  "is_public": true
}
{
  "path": "mcp_server/search_tool.py",
  "module": "mcp_server.search_tool",
  "qualname": "_merge_candidates",
  "name": "_merge_candidates",
  "node_type": "FunctionDef",
  "lineno": 101,
  "col": 0,
  "end_lineno": 129,
  "end_col": 21,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "mcp_server/search_tool.py",
  "module": "mcp_server.search_tool",
  "qualname": "_build_url",
  "name": "_build_url",
  "node_type": "FunctionDef",
  "lineno": 132,
  "col": 0,
  "end_lineno": 148,
  "end_col": 42,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Build a repo:// URL from chunk metadata row.\n\nParameters\n----------\nrow : Mapping[str, object]\n    Chunk metadata dictionary containing uri, start_line, and end_line.\n\nReturns\n-------\nstr\n    URL in format \"repo://{uri}#L{start}-L{end}\" with 1-based line numbers.",
  "is_public": false
}
{
  "path": "mcp_server/search_tool.py",
  "module": "mcp_server.search_tool",
  "qualname": "_build_snippet",
  "name": "_build_snippet",
  "node_type": "FunctionDef",
  "lineno": 151,
  "col": 0,
  "end_lineno": 170,
  "end_col": 24,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Build a text snippet from chunk metadata row.\n\nParameters\n----------\nrow : Mapping[str, object]\n    Chunk metadata dictionary containing preview or content.\n\nReturns\n-------\nstr\n    Text snippet up to 400 characters, preferring preview over content.",
  "is_public": false
}
{
  "path": "mcp_server/search_tool.py",
  "module": "mcp_server.search_tool",
  "qualname": "_normalize_search_input",
  "name": "_normalize_search_input",
  "node_type": "FunctionDef",
  "lineno": 173,
  "col": 0,
  "end_lineno": 200,
  "end_col": 65,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Normalize and validate search tool input arguments.\n\nParameters\n----------\nargs : Mapping[str, object]\n    Raw arguments dictionary containing query, top_k, and filters.\n\nReturns\n-------\nSearchInput\n    Normalized and validated SearchInput object.\n\nRaises\n------\nValueError\n    If query is missing.",
  "is_public": false
}
{
  "path": "mcp_server/search_tool.py",
  "module": "mcp_server.search_tool",
  "qualname": "_coerce_int",
  "name": "_coerce_int",
  "node_type": "FunctionDef",
  "lineno": 203,
  "col": 0,
  "end_lineno": 239,
  "end_col": 20,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Coerce a value to an integer with fallback to default.\n\nThis function attempts to convert various types (bool, int, float, str) to\nan integer, falling back to the default value if conversion fails or the\nvalue is None. Used by input normalization functions to safely coerce\nuser-provided values.\n\nParameters\n----------\nvalue : object\n    Value to coerce to integer.\ndefault : int\n    Default value to return if coercion fails. Defaults to 0.\n\nReturns\n-------\nint\n    Coerced integer value, or default if conversion fails.",
  "is_public": false
}
{
  "path": "mcp_server/server.py",
  "module": "mcp_server.server",
  "qualname": "mcp_server.server",
  "name": "mcp_server.server",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "FastMCP server with QueryScope tools.\n\nImplements full MCP tool catalog for code intelligence.",
  "is_public": true
}
{
  "path": "mcp_server/server.py",
  "module": "mcp_server.server",
  "qualname": "get_context",
  "name": "get_context",
  "node_type": "FunctionDef",
  "lineno": 35,
  "col": 0,
  "end_lineno": 56,
  "end_col": 18,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Extract ApplicationContext from context variable.\n\nThe context is set by middleware in main.py for each request.\nThis allows tool handlers to access ApplicationContext without\nrequiring Request injection (which FastMCP doesn't support).\n\nReturns\n-------\nApplicationContext\n    Application context for the current request.\n\nRaises\n------\nRuntimeError\n    If context is not initialized (should never happen after startup).",
  "is_public": true
}
{
  "path": "mcp_server/server.py",
  "module": "mcp_server.server",
  "qualname": "set_scope",
  "name": "set_scope",
  "node_type": "AsyncFunctionDef",
  "lineno": 63,
  "col": 0,
  "end_lineno": 78,
  "end_col": 60,
  "parent_qualname": null,
  "decorators": [
    "mcp.tool()"
  ],
  "bases": [],
  "docstring": "Set query scope for subsequent operations.\n\nParameters\n----------\nscope : ScopeIn\n    Scope parameters (repos, branches, paths, languages).\n\nReturns\n-------\ndict\n    Effective scope configuration.",
  "is_public": true
}
{
  "path": "mcp_server/server.py",
  "module": "mcp_server.server",
  "qualname": "list_paths",
  "name": "list_paths",
  "node_type": "AsyncFunctionDef",
  "lineno": 86,
  "col": 0,
  "end_lineno": 131,
  "end_col": 9,
  "parent_qualname": null,
  "decorators": [
    "mcp.tool()",
    "handle_adapter_errors(operation='files:list_paths', empty_result={'items': [], 'total': 0, 'truncated': False})"
  ],
  "bases": [],
  "docstring": "List files in scope (async).\n\nError handling is automatic via decorator. All exceptions are caught\nand converted to unified error envelopes with Problem Details.\n\nParameters\n----------\npath : str | None\n    Starting path (defaults to repo root).\ninclude_globs : list[str] | None\n    Glob patterns to include.\nexclude_globs : list[str] | None\n    Glob patterns to exclude.\nlanguages : list[str] | None\n    Programming languages to include.\nmax_results : int\n    Maximum results to return.\n\nReturns\n-------\ndict\n    File listing with paths. On error, returns error envelope with\n    empty result fields and Problem Details.",
  "is_public": true
}
{
  "path": "mcp_server/server.py",
  "module": "mcp_server.server",
  "qualname": "open_file",
  "name": "open_file",
  "node_type": "FunctionDef",
  "lineno": 139,
  "col": 0,
  "end_lineno": 169,
  "end_col": 75,
  "parent_qualname": null,
  "decorators": [
    "mcp.tool()",
    "handle_adapter_errors(operation='files:open_file', empty_result={'path': '', 'content': '', 'lines': 0, 'size': 0})"
  ],
  "bases": [],
  "docstring": "Read file content.\n\nError handling is automatic via decorator. All exceptions are caught\nand converted to unified error envelopes with Problem Details.\n\nParameters\n----------\npath : str\n    File path.\nstart_line : int | None\n    Start line (1-indexed, inclusive).\nend_line : int | None\n    End line (1-indexed, inclusive).\n\nReturns\n-------\ndict\n    File content and metadata. On error, returns error envelope with\n    empty result fields and Problem Details.",
  "is_public": true
}
{
  "path": "mcp_server/server.py",
  "module": "mcp_server.server",
  "qualname": "search_text",
  "name": "search_text",
  "node_type": "AsyncFunctionDef",
  "lineno": 180,
  "col": 0,
  "end_lineno": 227,
  "end_col": 9,
  "parent_qualname": null,
  "decorators": [
    "mcp.tool()",
    "handle_adapter_errors(operation='search:text', empty_result={'matches': [], 'total': 0, 'truncated': False})"
  ],
  "bases": [],
  "docstring": "Fast text search (ripgrep-like).\n\nError handling is automatic via decorator. All exceptions are caught\nand converted to unified error envelopes with Problem Details.\n\nParameters\n----------\nquery : str\n    Search query.\nregex : bool\n    Treat query as regex.\ncase_sensitive : bool\n    Case-sensitive search.\npaths : list[str] | None\n    Paths to search in.\nmax_results : int\n    Maximum results.\n\nReturns\n-------\ndict\n    Search matches. On error, returns error envelope with empty result\n    fields and Problem Details.",
  "is_public": true
}
{
  "path": "mcp_server/server.py",
  "module": "mcp_server.server",
  "qualname": "blame_range",
  "name": "blame_range",
  "node_type": "AsyncFunctionDef",
  "lineno": 238,
  "col": 0,
  "end_lineno": 270,
  "end_col": 85,
  "parent_qualname": null,
  "decorators": [
    "mcp.tool()",
    "handle_adapter_errors(operation='git:blame_range', empty_result={'blame': []})"
  ],
  "bases": [],
  "docstring": "Git blame for line range (async).\n\nError handling is automatic via decorator. All exceptions are caught\nand converted to unified error envelopes with Problem Details.\n\nParameters\n----------\npath : str\n    File path.\nstart_line : int\n    Start line (1-indexed).\nend_line : int\n    End line (1-indexed).\n\nReturns\n-------\ndict\n    Blame entries for each line. On error, returns error envelope with\n    empty result fields and Problem Details.",
  "is_public": true
}
{
  "path": "mcp_server/server.py",
  "module": "mcp_server.server",
  "qualname": "file_history",
  "name": "file_history",
  "node_type": "AsyncFunctionDef",
  "lineno": 278,
  "col": 0,
  "end_lineno": 306,
  "end_col": 71,
  "parent_qualname": null,
  "decorators": [
    "mcp.tool()",
    "handle_adapter_errors(operation='git:file_history', empty_result={'commits': []})"
  ],
  "bases": [],
  "docstring": "Get file commit history (async).\n\nError handling is automatic via decorator. All exceptions are caught\nand converted to unified error envelopes with Problem Details.\n\nParameters\n----------\npath : str\n    File path.\nlimit : int\n    Maximum commits.\n\nReturns\n-------\ndict\n    Commit history. On error, returns error envelope with empty result\n    fields and Problem Details.",
  "is_public": true
}
{
  "path": "mcp_server/server.py",
  "module": "mcp_server.server",
  "qualname": "report_latest_run",
  "name": "report_latest_run",
  "node_type": "FunctionDef",
  "lineno": 310,
  "col": 0,
  "end_lineno": 331,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [
    "mcp.tool(name='report:latest_run')"
  ],
  "bases": [],
  "docstring": "Return metadata about the most recent run report artifact.\n\nReturns\n-------\ndict[str, object]\n    Dictionary containing report metadata. When a report is available,\n    includes keys: \"available\" (True), \"run_id\", \"session_id\", \"markdown_path\",\n    \"json_path\", and \"summary\". When no report is available, returns\n    {\"available\": False}.",
  "is_public": true
}
{
  "path": "mcp_server/server.py",
  "module": "mcp_server.server",
  "qualname": "file_resource",
  "name": "file_resource",
  "node_type": "FunctionDef",
  "lineno": 338,
  "col": 0,
  "end_lineno": 355,
  "end_col": 41,
  "parent_qualname": null,
  "decorators": [
    "mcp.resource('file://{path}')"
  ],
  "bases": [],
  "docstring": "Serve file content as resource.\n\nParameters\n----------\npath : str\n    File path.\n\nReturns\n-------\nstr\n    File content.",
  "is_public": true
}
{
  "path": "mcp_server/server.py",
  "module": "mcp_server.server",
  "qualname": "prompt_code_review",
  "name": "prompt_code_review",
  "node_type": "FunctionDef",
  "lineno": 362,
  "col": 0,
  "end_lineno": 375,
  "end_col": 86,
  "parent_qualname": null,
  "decorators": [
    "mcp.prompt()"
  ],
  "bases": [],
  "docstring": "Code review prompt template.\n\nParameters\n----------\narea : str\n    Code area to review.\n\nReturns\n-------\nstr\n    Prompt template.",
  "is_public": true
}
{
  "path": "mcp_server/server.py",
  "module": "mcp_server.server",
  "qualname": "build_http_app",
  "name": "build_http_app",
  "node_type": "FunctionDef",
  "lineno": 378,
  "col": 0,
  "end_lineno": 413,
  "end_col": 25,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return the FastMCP ASGI app with capability-gated tool registration.\n\nExtended Summary\n----------------\nThis function constructs the FastMCP ASGI application with capability-based\ntool registration. It conditionally imports and registers MCP tools based on\navailable capabilities (symbol search, semantic search). Tools are only\nregistered if their required dependencies are available, enabling graceful\ndegradation when optional components are missing.\n\nParameters\n----------\ncapabilities : Capabilities\n    Capability snapshot indicating which features are available. Used to gate\n    tool registration (e.g., symbol search requires SCIP index, semantic search\n    requires FAISS index).\n\nReturns\n-------\nASGIApp\n    ASGI application implementing the MCP HTTP API with capability-gated tools.\n    The app exposes MCP-compliant endpoints for registered tools.\n\nNotes\n-----\nThis function performs dynamic tool registration based on capabilities. Tools\nare registered by importing their modules, which triggers FastMCP decorator\nregistration. Time complexity: O(1) for app construction, O(tool_count) for\ntool registration where tool_count is the number of available tools.",
  "is_public": true
}
{
  "path": "mcp_server/server_semantic.py",
  "module": "mcp_server.server_semantic",
  "qualname": "mcp_server.server_semantic",
  "name": "mcp_server.server_semantic",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Semantic MCP tool registrations (pure move from server.py).",
  "is_public": true
}
{
  "path": "mcp_server/server_semantic.py",
  "module": "mcp_server.server_semantic",
  "qualname": "deep_research_search",
  "name": "deep_research_search",
  "node_type": "AsyncFunctionDef",
  "lineno": 34,
  "col": 0,
  "end_lineno": 88,
  "end_col": 74,
  "parent_qualname": null,
  "decorators": [
    "mcp.tool(name='search')",
    "handle_adapter_errors(operation='search:deep', empty_result={'results': [], 'queryEcho': '', 'top_k': 0, 'limits': []})"
  ],
  "bases": [],
  "docstring": "Deep-Research compatible semantic search that returns chunk ids.\n\nThis async function provides a Deep-Research compatible search interface that\nexecutes semantic search using FAISS and returns ranked chunk identifiers with\nmetadata. The function constructs MCP tool arguments, creates a timeline for\nobservability, and delegates to the deep_research adapter for execution.\n\nParameters\n----------\nquery : str\n    Search query text. Used to perform semantic similarity search over the\n    indexed codebase. The query is embedded and searched against FAISS vectors.\ntop_k : int | None, optional\n    Maximum number of results to return (default: None). When None, uses the\n    default top_k value (12). The value is clamped to the range [1, 50] before\n    execution. Higher values return more results but increase latency.\nfilters : SearchFilterPayload | None, optional\n    Optional search filters for narrowing results by language, file paths,\n    or symbols (default: None). When None, no filtering is applied. Filters\n    are normalized and applied during post-search hydration.\nrerank : bool, optional\n    Whether to enable exact reranking of candidates (default: True). When True,\n    candidates are reranked using exact similarity scores. When False, uses\n    approximate search results only.\n\nReturns\n-------\nSearchStructuredContent\n    Structured MCP payload with ranked chunk identifiers and metadata. Contains\n    SearchResultItem objects with id, title, url, snippet, score, source, and\n    metadata fields. Results are ranked by relevance score.",
  "is_public": true
}
{
  "path": "mcp_server/server_semantic.py",
  "module": "mcp_server.server_semantic",
  "qualname": "deep_research_fetch",
  "name": "deep_research_fetch",
  "node_type": "AsyncFunctionDef",
  "lineno": 96,
  "col": 0,
  "end_lineno": 135,
  "end_col": 73,
  "parent_qualname": null,
  "decorators": [
    "mcp.tool(name='fetch')",
    "handle_adapter_errors(operation='search:fetch', empty_result={'objects': []})"
  ],
  "bases": [],
  "docstring": "Hydrate chunk ids produced by :func:`deep_research_search`.\n\nThis async function retrieves full chunk content and metadata for chunk IDs\nreturned from a previous search operation. The function constructs MCP tool\narguments, creates a timeline for observability, and delegates to the deep_research\nadapter for execution.\n\nParameters\n----------\nobjectIds : list[str]\n    List of chunk ID strings to hydrate. IDs are normalized to integers and\n    queried from the DuckDB catalog. Missing chunks are omitted from results.\n    Must be non-empty for meaningful results.\nmax_tokens : int | None, optional\n    Maximum token limit for chunk content (default: None). When None, uses the\n    default max_tokens value (4000). The value is clamped to the range [256, 16000]\n    before execution. Used to limit response size and control token usage.\n\nReturns\n-------\nFetchStructuredContent\n    Structured MCP payload containing chunk contents and provenance metadata.\n    Contains FetchObject objects with id, title, url, content, and metadata\n    fields. Chunks are returned in the order specified by objectIds.",
  "is_public": true
}
{
  "path": "mcp_server/server_semantic.py",
  "module": "mcp_server.server_semantic",
  "qualname": "semantic_search",
  "name": "semantic_search",
  "node_type": "AsyncFunctionDef",
  "lineno": 143,
  "col": 0,
  "end_lineno": 186,
  "end_col": 76,
  "parent_qualname": null,
  "decorators": [
    "mcp.tool()",
    "handle_adapter_errors(operation='search:semantic', empty_result={'findings': [], 'answer': '', 'confidence': 0.0})"
  ],
  "bases": [],
  "docstring": "Semantic code search using embeddings.\n\nExtended Summary\n----------------\nThis MCP tool performs semantic code search by embedding the query text,\nsearching the FAISS vector index, and returning ranked code snippets with\nmetadata. It uses the semantic adapter to execute the search pipeline and\nhandles errors gracefully with structured error responses.\n\nParameters\n----------\nquery : str\n    Natural language query describing the code to find (e.g., \"function that\n    parses JSON files\"). The query is embedded and used for vector similarity search.\nlimit : int, optional\n    Maximum number of results to return (default: 20). Higher limits improve\n    recall but increase latency and response size.\n\nReturns\n-------\nAnswerEnvelope\n    Structured semantic search response containing:\n    - findings: list[Finding], ranked code snippets with metadata\n    - answer: str, natural language summary of results\n    - confidence: float, search confidence score (0.0-1.0)\n\nNotes\n-----\nThis tool requires FAISS index and embedding service to be available. Search\nresults are ranked by cosine similarity and include code snippets with location\nmetadata. Time complexity: O(embedding_time + search_time) where search_time\ndepends on index size and limit.",
  "is_public": true
}
{
  "path": "mcp_server/server_semantic.py",
  "module": "mcp_server.server_semantic",
  "qualname": "semantic_search_pro",
  "name": "semantic_search_pro",
  "node_type": "AsyncFunctionDef",
  "lineno": 194,
  "col": 0,
  "end_lineno": 251,
  "end_col": 9,
  "parent_qualname": null,
  "decorators": [
    "mcp.tool()",
    "handle_adapter_errors(operation='search:semantic_pro', empty_result={'findings': [], 'answer': '', 'confidence': 0.0})"
  ],
  "bases": [],
  "docstring": "Two-stage semantic retrieval with optional late interaction and reranker.\n\nExtended Summary\n----------------\nThis MCP tool performs advanced semantic code search using a two-stage pipeline:\nCodeRank (hybrid BM25+SPLADE+FAISS) followed by optional WARP (late interaction)\nand optional LLM reranking. It provides fine-grained control over retrieval\nstages and reranking behavior through options. Used for high-precision code\nsearch when recall and ranking quality are critical.\n\nParameters\n----------\nquery : str\n    Natural language query describing the code to find. The query is used\n    across all retrieval stages (BM25, SPLADE, FAISS, WARP, reranker).\nlimit : int, optional\n    Maximum number of results to return (default: 20). Applied after all\n    stages and reranking.\noptions : semantic_pro_adapter.SemanticProOptions | None, optional\n    Optional configuration for retrieval stages:\n    - use_coderank: bool, enable CodeRank hybrid search (default: True)\n    - use_warp: bool, enable WARP late interaction (default: False)\n    - use_reranker: bool, enable LLM reranking (default: False)\n    - stage_weights: dict[str, float], custom fusion weights\n    - explain: bool, include explanation in response\n    - xtr_k: int, XTR reranker top-k\n    - rerank: RerankOptionPayload, reranker configuration\n\nReturns\n-------\nAnswerEnvelope\n    Structured semantic search response with findings, answer, and confidence.\n    Results are ranked by the final stage (reranker if enabled, otherwise fusion).\n\nNotes\n-----\nThis tool requires FAISS index, BM25 index, SPLADE index, and optionally WARP\nand reranker services. The two-stage pipeline improves recall and ranking quality\nat the cost of higher latency. Time complexity: O(stage1_time + stage2_time + rerank_time).",
  "is_public": true
}
{
  "path": "mcp_server/server_semantic.py",
  "module": "mcp_server.server_semantic",
  "qualname": "telemetry_run_report",
  "name": "telemetry_run_report",
  "node_type": "AsyncFunctionDef",
  "lineno": 255,
  "col": 0,
  "end_lineno": 290,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [
    "mcp.tool()"
  ],
  "bases": [],
  "docstring": "Return the latest run report for the active or requested session.\n\nParameters\n----------\nsession_id : str | None\n    Optional explicit session identifier. Defaults to the current request session.\nrun_id : str | None\n    Optional run identifier when multiple runs exist for a session.\n\nReturns\n-------\ndict[str, Any]\n    JSON-safe run report payload.\n\nRaises\n------\nRuntimeError\n    Raised when no session identifier can be resolved.",
  "is_public": true
}
{
  "path": "mcp_server/server_semantic.py",
  "module": "mcp_server.server_semantic",
  "qualname": "_render_run_report",
  "name": "_render_run_report",
  "node_type": "FunctionDef",
  "lineno": 293,
  "col": 0,
  "end_lineno": 308,
  "end_col": 18,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "mcp_server/server_symbols.py",
  "module": "mcp_server.server_symbols",
  "qualname": "mcp_server.server_symbols",
  "name": "mcp_server.server_symbols",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Symbol MCP tool registrations (pure move from server.py).",
  "is_public": true
}
{
  "path": "mcp_server/server_symbols.py",
  "module": "mcp_server.server_symbols",
  "qualname": "symbol_search",
  "name": "symbol_search",
  "node_type": "FunctionDef",
  "lineno": 16,
  "col": 0,
  "end_lineno": 100,
  "end_col": 54,
  "parent_qualname": null,
  "decorators": [
    "mcp.tool()",
    "handle_adapter_errors(operation='symbols:search', empty_result={'symbols': [], 'total': 0})"
  ],
  "bases": [],
  "docstring": "Search for symbols (functions, classes, etc).\n\nExtended Summary\n----------------\nThis MCP tool performs symbol search by querying the DuckDB catalog for symbol\ndefinitions matching the query string, optional kind filter, and optional language\nfilter. Results are ranked by symbol name length (shorter names first) and\nlimited to 200 matches. Used for finding functions, classes, methods, and other\ncode symbols by name.\n\nParameters\n----------\nquery : str\n    Symbol name or prefix to search for (e.g., \"parse_json\", \"User\"). The search\n    is case-insensitive and matches symbols starting with the query string.\nkind : str | None, optional\n    Optional symbol kind filter (e.g., \"function\", \"class\", \"method\"). If provided,\n    only symbols of this kind are returned.\nlanguage : str | None, optional\n    Optional programming language filter (e.g., \"python\", \"typescript\"). If provided,\n    only symbols from this language are returned.\n\nReturns\n-------\ndict\n    Symbol matches payload containing:\n    - symbols: list[SymbolInfo], matching symbols with name, kind, and location\n    - total: int, number of symbols returned (max 200)\n\nNotes\n-----\nThis tool requires SCIP index and DuckDB catalog to be available. Search is\nperformed via SQL LIKE queries on the symbol_defs table. Results are sorted by\nname length to prioritize shorter, more specific matches. Time complexity: O(1)\nfor SQL query execution.",
  "is_public": true
}
{
  "path": "mcp_server/server_symbols.py",
  "module": "mcp_server.server_symbols",
  "qualname": "definition_at",
  "name": "definition_at",
  "node_type": "FunctionDef",
  "lineno": 108,
  "col": 0,
  "end_lineno": 181,
  "end_col": 9,
  "parent_qualname": null,
  "decorators": [
    "mcp.tool()",
    "handle_adapter_errors(operation='symbols:definition_at', empty_result={'locations': []})"
  ],
  "bases": [],
  "docstring": "Find definition at position.\n\nExtended Summary\n----------------\nThis MCP tool finds the definition of a symbol at a specific file position by\nquerying the DuckDB catalog for symbol occurrences at that location, then\nretrieving the corresponding definition. Used for \"go to definition\" functionality\nin code editors and IDEs.\n\nParameters\n----------\npath : str\n    File path (URI) where the symbol occurs.\nline : int\n    Line number (1-indexed) where the symbol occurs.\ncharacter : int\n    Character offset (0-indexed) within the line where the symbol occurs.\n\nReturns\n-------\ndict\n    Definition locations response containing:\n    - locations: list[dict], definition locations with uri, start_line, start_column,\n      end_line, end_column. Empty list if no definition found.\n\nNotes\n-----\nThis tool requires SCIP index and DuckDB catalog to be available. It performs\ntwo SQL queries: first to find the symbol at the position, then to find its\ndefinition. Time complexity: O(1) for SQL query execution.",
  "is_public": true
}
{
  "path": "mcp_server/server_symbols.py",
  "module": "mcp_server.server_symbols",
  "qualname": "references_at",
  "name": "references_at",
  "node_type": "FunctionDef",
  "lineno": 189,
  "col": 0,
  "end_lineno": 262,
  "end_col": 34,
  "parent_qualname": null,
  "decorators": [
    "mcp.tool()",
    "handle_adapter_errors(operation='symbols:references_at', empty_result={'locations': []})"
  ],
  "bases": [],
  "docstring": "Find references at position.\n\nExtended Summary\n----------------\nThis MCP tool finds all references to a symbol at a specific file position by\nquerying the DuckDB catalog for symbol occurrences, then retrieving all occurrences\nof that symbol. Used for \"find all references\" functionality in code editors and IDEs.\n\nParameters\n----------\npath : str\n    File path (URI) where the symbol occurs.\nline : int\n    Line number (1-indexed) where the symbol occurs.\ncharacter : int\n    Character offset (0-indexed) within the line where the symbol occurs.\n\nReturns\n-------\ndict\n    Reference locations response containing:\n    - locations: list[dict], all reference locations with uri, start_line, start_column,\n      end_line, end_column. Empty list if no references found.\n\nNotes\n-----\nThis tool requires SCIP index and DuckDB catalog to be available. It performs\ntwo SQL queries: first to find the symbol at the position, then to find all\noccurrences of that symbol. Time complexity: O(n) where n is the number of\nreferences (SQL query execution).",
  "is_public": true
}
{
  "path": "mcp_server/service_context.py",
  "module": "mcp_server.service_context",
  "qualname": "mcp_server.service_context",
  "name": "mcp_server.service_context",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Cached application context for MCP tool adapters.\n\nThis module exposes a small facade that lazily creates and caches the\n:class:`~codeintel_rev.app.config_context.ApplicationContext` used by the MCP\nserver tool adapters. The cached context reuses the same configuration and\npath-resolution logic as the FastAPI app and readiness probes because it\nultimately delegates creation to :meth:`ApplicationContext.create`, which reads\nenvironment overrides and resolves paths via\n:func:`~codeintel_rev.app.config_context.resolve_application_paths`.\n\nThe cache ensures heavy resources such as the FAISS index manager and DuckDB\ncatalog are only initialized once per process. Tests and administrative scripts\ncan call :func:`reset_service_context` to clear the cache when environment\nvariables change or when they need fresh dependencies.",
  "is_public": true
}
{
  "path": "mcp_server/service_context.py",
  "module": "mcp_server.service_context",
  "qualname": "_get_cached_context",
  "name": "_get_cached_context",
  "node_type": "FunctionDef",
  "lineno": 31,
  "col": 0,
  "end_lineno": 39,
  "end_col": 34,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return the cached context instance, if any.\n\nReturns\n-------\nApplicationContext | None\n    Previously cached context or ``None`` when not initialized.",
  "is_public": false
}
{
  "path": "mcp_server/service_context.py",
  "module": "mcp_server.service_context",
  "qualname": "_set_cached_context",
  "name": "_set_cached_context",
  "node_type": "FunctionDef",
  "lineno": 42,
  "col": 0,
  "end_lineno": 44,
  "end_col": 37,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Update the cached context reference.",
  "is_public": false
}
{
  "path": "mcp_server/service_context.py",
  "module": "mcp_server.service_context",
  "qualname": "get_service_context",
  "name": "get_service_context",
  "node_type": "FunctionDef",
  "lineno": 47,
  "col": 0,
  "end_lineno": 68,
  "end_col": 17,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return the cached :class:`ApplicationContext` instance.\n\nThe first invocation creates the context via\n:meth:`ApplicationContext.create`. Subsequent calls return the cached\ninstance so that adapters share the same settings, resolved paths, and\nlong-lived clients.\n\nReturns\n-------\nApplicationContext\n    Cached application context instance with settings, resolved paths,\n    and long-lived clients (FAISS manager, vLLM client, DuckDB catalog).",
  "is_public": true
}
{
  "path": "mcp_server/service_context.py",
  "module": "mcp_server.service_context",
  "qualname": "reset_service_context",
  "name": "reset_service_context",
  "node_type": "FunctionDef",
  "lineno": 71,
  "col": 0,
  "end_lineno": 79,
  "end_col": 33,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Clear the cached :class:`ApplicationContext`.\n\nPrimarily intended for tests or scripts that mutate environment variables\nbetween runs. The next call to :func:`get_service_context` will recreate the\ncontext from the latest configuration.",
  "is_public": true
}
{
  "path": "mcp_server/telemetry.py",
  "module": "mcp_server.telemetry",
  "qualname": "mcp_server.telemetry",
  "name": "mcp_server.telemetry",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Telemetry helpers for MCP tools.",
  "is_public": true
}
{
  "path": "mcp_server/telemetry.py",
  "module": "mcp_server.telemetry",
  "qualname": "tool_operation_scope",
  "name": "tool_operation_scope",
  "node_type": "FunctionDef",
  "lineno": 27,
  "col": 0,
  "end_lineno": 163,
  "end_col": 22,
  "parent_qualname": null,
  "decorators": [
    "contextmanager"
  ],
  "bases": [],
  "docstring": "Emit start/end events for an MCP tool and yield the active timeline.\n\nExtended Summary\n----------------\nThis context manager emits timeline events for MCP tool operations, providing\nobservability into tool execution. It yields the active timeline (from context\nor newly created) and emits start/end events with optional attributes. Used\nthroughout MCP tool handlers to track operation timing and context.\n\nParameters\n----------\ntool_name : str\n    Name of the MCP tool being executed (e.g., \"search.semantic\", \"symbols.search\").\n    Used in timeline event names and telemetry.\n**attrs : object\n    Optional keyword arguments to include in timeline events as attributes.\n    Common attributes include query_chars, limit, path, line, character, etc.\n\nYields\n------\nTimeline\n    Active timeline bound to the current session or a new one when absent.\n    The timeline is used to emit operation events and track execution context.\n\nNotes\n-----\nThis context manager integrates with the timeline system to provide structured\nlogging and observability. Events are emitted at context entry and exit with\nduration tracking. Time complexity: O(1) for context setup and event emission.\n\nRaises\n------\nBaseException\n    Any exception raised within the context is caught, recorded on the span\n    with error status, and re-raised using Python's bare ``raise`` statement.\n    The context manager ensures proper span cleanup and error attribution even\n    when exceptions occur. Exceptions propagate to the caller after error recording.\n    Note: Exceptions are re-raised (not directly raised), preserving the original\n    exception traceback and propagating through this context manager.",
  "is_public": true
}
{
  "path": "mcp_server/telemetry.py",
  "module": "mcp_server.telemetry",
  "qualname": "_maybe_render_report",
  "name": "_maybe_render_report",
  "node_type": "FunctionDef",
  "lineno": 166,
  "col": 0,
  "end_lineno": 172,
  "end_col": 65,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "mcp_server/testing.py",
  "module": "mcp_server.testing",
  "qualname": "mcp_server.testing",
  "name": "mcp_server.testing",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Small in-process harness for exercising MCP tools without FastMCP.",
  "is_public": true
}
{
  "path": "mcp_server/testing.py",
  "module": "mcp_server.testing",
  "qualname": "InProcessMCP",
  "name": "InProcessMCP",
  "node_type": "ClassDef",
  "lineno": 12,
  "col": 0,
  "end_lineno": 48,
  "end_col": 52,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Minimal harness for exercising MCP tools without FastMCP wiring.",
  "is_public": true
}
{
  "path": "mcp_server/testing.py",
  "module": "mcp_server.testing",
  "qualname": "InProcessMCP.tools_list",
  "name": "tools_list",
  "node_type": "FunctionDef",
  "lineno": 17,
  "col": 4,
  "end_lineno": 26,
  "end_col": 27,
  "parent_qualname": "InProcessMCP",
  "decorators": [],
  "bases": [],
  "docstring": "Return tool descriptors compatible with MCP /tools/list.\n\nReturns\n-------\nlist[dict[str, Any]]\n    Tool metadata records with JSON Schema payloads.",
  "is_public": true
}
{
  "path": "mcp_server/testing.py",
  "module": "mcp_server.testing",
  "qualname": "InProcessMCP.tools_call",
  "name": "tools_call",
  "node_type": "FunctionDef",
  "lineno": 28,
  "col": 4,
  "end_lineno": 48,
  "end_col": 52,
  "parent_qualname": "InProcessMCP",
  "decorators": [],
  "bases": [],
  "docstring": "Execute a tool locally using the configured dependencies.\n\nThis method dispatches tool execution requests to the call_tool function\nusing the instance's configured dependencies. It is used by in-process MCP\nimplementations for testing and local tool execution without network overhead.\n\nParameters\n----------\nname : str\n    Tool name to execute, typically \"search\" or \"fetch\".\narguments : dict[str, Any]\n    Tool-specific arguments dictionary passed to the handler.\n\nReturns\n-------\ndict[str, Any]\n    Response envelope compatible with MCP containing structuredContent\n    for successful tool execution, or isError flag with error content.",
  "is_public": true
}
{
  "path": "mcp_server/tools/__init__.py",
  "module": "mcp_server.tools",
  "qualname": "mcp_server.tools",
  "name": "mcp_server.tools",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Public tool exports for the CodeIntel MCP server.",
  "is_public": true
}
{
  "path": "mcp_server/tools/gpu_doctor.py",
  "module": "mcp_server.tools.gpu_doctor",
  "qualname": "mcp_server.tools.gpu_doctor",
  "name": "mcp_server.tools.gpu_doctor",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "GPU diagnostics script for PyTorch and FAISS.\n\nTiny GPU diagnostics for PyTorch and FAISS:\n- Initializes CUDA context\n- Runs a small GEMM in torch (cuBLAS path)\n- Runs a tiny FAISS-GPU search (GpuIndexFlatIP)\n\nExits non-zero if --require-gpu is set and a GPU isn't usable.\n\nUsage:\n    python -m codeintel_rev.mcp_server.tools.gpu_doctor\n    python -m codeintel_rev.mcp_server.tools.gpu_doctor --require-gpu\n    python -m codeintel_rev.mcp_server.tools.gpu_doctor --torch-only\n    python -m codeintel_rev.mcp_server.tools.gpu_doctor --faiss-only",
  "is_public": true
}
{
  "path": "mcp_server/tools/gpu_doctor.py",
  "module": "mcp_server.tools.gpu_doctor",
  "qualname": "check_torch",
  "name": "check_torch",
  "node_type": "FunctionDef",
  "lineno": 31,
  "col": 0,
  "end_lineno": 88,
  "end_col": 25,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Check PyTorch CUDA availability and perform smoke test.\n\nParameters\n----------\ndevice_index : int, optional\n    CUDA device index to test (default: 0).\n\nReturns\n-------\ntuple[bool, dict[str, object]]\n    (success, info_dict) where info_dict contains diagnostic information.",
  "is_public": true
}
{
  "path": "mcp_server/tools/gpu_doctor.py",
  "module": "mcp_server.tools.gpu_doctor",
  "qualname": "check_faiss",
  "name": "check_faiss",
  "node_type": "FunctionDef",
  "lineno": 91,
  "col": 0,
  "end_lineno": 141,
  "end_col": 66,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Check FAISS GPU availability and perform smoke test.\n\nReturns\n-------\ntuple[bool, dict[str, object]]\n    (success, info_dict) where info_dict contains diagnostic information.",
  "is_public": true
}
{
  "path": "mcp_server/tools/gpu_doctor.py",
  "module": "mcp_server.tools.gpu_doctor",
  "qualname": "main",
  "name": "main",
  "node_type": "FunctionDef",
  "lineno": 144,
  "col": 0,
  "end_lineno": 192,
  "end_col": 19,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Run GPU diagnostics and print results.\n\nParses command-line arguments and runs GPU checks. Exits with non-zero\nstatus if --require-gpu is set and GPU is not usable.",
  "is_public": true
}
{
  "path": "mcp_server/types.py",
  "module": "mcp_server.types",
  "qualname": "mcp_server.types",
  "name": "mcp_server.types",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Typed DTOs and JSON Schema helpers for MCP search/fetch tools.",
  "is_public": true
}
{
  "path": "mcp_server/types.py",
  "module": "mcp_server.types",
  "qualname": "SearchInput",
  "name": "SearchInput",
  "node_type": "ClassDef",
  "lineno": 12,
  "col": 0,
  "end_lineno": 17,
  "end_col": 41,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "msgspec.Struct"
  ],
  "docstring": "Incoming payload for the lightweight MCP search tool.",
  "is_public": true
}
{
  "path": "mcp_server/types.py",
  "module": "mcp_server.types",
  "qualname": "SearchResultItem",
  "name": "SearchResultItem",
  "node_type": "ClassDef",
  "lineno": 20,
  "col": 0,
  "end_lineno": 29,
  "end_col": 42,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "msgspec.Struct"
  ],
  "docstring": "Single search result entry returned by the lightweight MCP tools.",
  "is_public": true
}
{
  "path": "mcp_server/types.py",
  "module": "mcp_server.types",
  "qualname": "SearchOutput",
  "name": "SearchOutput",
  "node_type": "ClassDef",
  "lineno": 32,
  "col": 0,
  "end_lineno": 38,
  "end_col": 35,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "msgspec.Struct"
  ],
  "docstring": "Structured search response returned to the caller.",
  "is_public": true
}
{
  "path": "mcp_server/types.py",
  "module": "mcp_server.types",
  "qualname": "FetchInput",
  "name": "FetchInput",
  "node_type": "ClassDef",
  "lineno": 41,
  "col": 0,
  "end_lineno": 46,
  "end_col": 65,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "msgspec.Struct"
  ],
  "docstring": "Incoming payload for the lightweight MCP fetch tool.",
  "is_public": true
}
{
  "path": "mcp_server/types.py",
  "module": "mcp_server.types",
  "qualname": "FetchedObject",
  "name": "FetchedObject",
  "node_type": "ClassDef",
  "lineno": 49,
  "col": 0,
  "end_lineno": 56,
  "end_col": 42,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "msgspec.Struct"
  ],
  "docstring": "Hydrated chunk entry returned from fetch operations.",
  "is_public": true
}
{
  "path": "mcp_server/types.py",
  "module": "mcp_server.types",
  "qualname": "FetchOutput",
  "name": "FetchOutput",
  "node_type": "ClassDef",
  "lineno": 59,
  "col": 0,
  "end_lineno": 62,
  "end_col": 32,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "msgspec.Struct"
  ],
  "docstring": "Fetch response wrapping one or more hydrated chunk objects.",
  "is_public": true
}
{
  "path": "mcp_server/types.py",
  "module": "mcp_server.types",
  "qualname": "search_input_schema",
  "name": "search_input_schema",
  "node_type": "FunctionDef",
  "lineno": 65,
  "col": 0,
  "end_lineno": 82,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return the JSON Schema describing search tool inputs.\n\nReturns\n-------\ndict[str, Any]\n    JSON Schema dictionary describing search inputs.",
  "is_public": true
}
{
  "path": "mcp_server/types.py",
  "module": "mcp_server.types",
  "qualname": "search_output_schema",
  "name": "search_output_schema",
  "node_type": "FunctionDef",
  "lineno": 85,
  "col": 0,
  "end_lineno": 118,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return the JSON Schema describing search tool outputs.\n\nReturns\n-------\ndict[str, Any]\n    JSON Schema dictionary describing search outputs.",
  "is_public": true
}
{
  "path": "mcp_server/types.py",
  "module": "mcp_server.types",
  "qualname": "fetch_input_schema",
  "name": "fetch_input_schema",
  "node_type": "FunctionDef",
  "lineno": 121,
  "col": 0,
  "end_lineno": 141,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return the JSON Schema describing fetch tool inputs.\n\nReturns\n-------\ndict[str, Any]\n    JSON Schema dictionary describing fetch inputs.",
  "is_public": true
}
{
  "path": "mcp_server/types.py",
  "module": "mcp_server.types",
  "qualname": "fetch_output_schema",
  "name": "fetch_output_schema",
  "node_type": "FunctionDef",
  "lineno": 144,
  "col": 0,
  "end_lineno": 172,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return the JSON Schema describing fetch tool outputs.\n\nReturns\n-------\ndict[str, Any]\n    JSON Schema dictionary describing fetch outputs.",
  "is_public": true
}
{
  "path": "metrics/__init__.py",
  "module": "metrics",
  "qualname": "metrics",
  "name": "metrics",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Metric registry package.",
  "is_public": true
}
{
  "path": "metrics/registry.py",
  "module": "metrics.registry",
  "qualname": "metrics.registry",
  "name": "metrics.registry",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Central Prometheus metric registry for FAISS/hybrid retrieval.",
  "is_public": true
}
{
  "path": "metrics/registry.py",
  "module": "metrics.registry",
  "qualname": "_stable_u32",
  "name": "_stable_u32",
  "node_type": "FunctionDef",
  "lineno": 218,
  "col": 0,
  "end_lineno": 249,
  "end_col": 12,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return a deterministic 32-bit hash for the provided string.\n\nExtended Summary\n----------------\nThis helper computes a stable 32-bit hash using FNV-1a algorithm. The hash is\ndeterministic (same input produces same output) and is used for generating\nstable metric label values. Used internally by the metrics registry to create\nconsistent label identifiers.\n\nParameters\n----------\nvalue : str\n    String to hash. The string is UTF-8 encoded before hashing.\n\nReturns\n-------\nint\n    Unsigned 32-bit hash of ``value``. The hash is deterministic and stable\n    across Python invocations for the same input string.\n\nNotes\n-----\nThis function implements FNV-1a hash algorithm (32-bit variant). The hash is\nused for generating stable metric label values. Time complexity: O(n) where\nn is the length of the input string.",
  "is_public": false
}
{
  "path": "metrics/registry.py",
  "module": "metrics.registry",
  "qualname": "set_factory_id",
  "name": "set_factory_id",
  "node_type": "FunctionDef",
  "lineno": 252,
  "col": 0,
  "end_lineno": 254,
  "end_col": 53,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Record the current FAISS factory string as a hashed gauge.",
  "is_public": true
}
{
  "path": "metrics/registry.py",
  "module": "metrics.registry",
  "qualname": "set_compile_flags_id",
  "name": "set_compile_flags_id",
  "node_type": "FunctionDef",
  "lineno": 257,
  "col": 0,
  "end_lineno": 259,
  "end_col": 50,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Record FAISS compile options for readiness/diagnostics.",
  "is_public": true
}
{
  "path": "module_utils.py",
  "module": "module_utils",
  "qualname": "module_utils",
  "name": "module_utils",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Helpers for converting between module paths and dotted names.",
  "is_public": true
}
{
  "path": "module_utils.py",
  "module": "module_utils",
  "qualname": "normalize_module_name",
  "name": "normalize_module_name",
  "node_type": "FunctionDef",
  "lineno": 9,
  "col": 0,
  "end_lineno": 31,
  "end_col": 51,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return a dotted module name for a repo-relative path.\n\nParameters\n----------\npath : str\n    Repository-relative file path (e.g., ``src/app/config.py``).\n\nReturns\n-------\nstr\n    Normalized dotted module name (e.g., ``app.config``).",
  "is_public": true
}
{
  "path": "module_utils.py",
  "module": "module_utils",
  "qualname": "module_name_candidates",
  "name": "module_name_candidates",
  "node_type": "FunctionDef",
  "lineno": 34,
  "col": 0,
  "end_lineno": 56,
  "end_col": 16,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return candidate module names (with and without prefix).\n\nParameters\n----------\npath : str\n    Repository-relative file path.\npackage_prefix : str | None\n    Optional package prefix to prepend to module names.\n\nReturns\n-------\nset[str]\n    Candidate module names that map to the provided path.",
  "is_public": true
}
{
  "path": "module_utils.py",
  "module": "module_utils",
  "qualname": "resolve_relative_module",
  "name": "resolve_relative_module",
  "node_type": "FunctionDef",
  "lineno": 59,
  "col": 0,
  "end_lineno": 84,
  "end_col": 50,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Resolve a relative import into an absolute dotted module name.\n\nParameters\n----------\ncurrent : str\n    Current module name (e.g., ``app.config``).\nmodule : str | None\n    Module name from import statement, or None for relative-only imports.\nlevel : int\n    Relative import level (number of dots, e.g., 1 for ``from . import x``).\n\nReturns\n-------\nstr\n    Absolute dotted module string or empty string when unresolved.",
  "is_public": true
}
{
  "path": "module_utils.py",
  "module": "module_utils",
  "qualname": "import_targets_for_entry",
  "name": "import_targets_for_entry",
  "node_type": "FunctionDef",
  "lineno": 87,
  "col": 0,
  "end_lineno": 122,
  "end_col": 18,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return candidate absolute module names for a single import entry.\n\nParameters\n----------\ncurrent_module : str\n    Current module name where the import occurs.\nmodule : str | None\n    Module name from import statement, or None for relative-only imports.\nnames : list[str]\n    List of imported symbol names (for ``from X import Y, Z``).\nlevel : int\n    Relative import level (number of dots).\n\nReturns\n-------\nset[str]\n    Candidate absolute modules referenced by the import entry.",
  "is_public": true
}
{
  "path": "observability/__init__.py",
  "module": "observability",
  "qualname": "observability",
  "name": "observability",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Observability helpers (telemetry + lightweight timelines).",
  "is_public": true
}
{
  "path": "observability/flight_recorder.py",
  "module": "observability.flight_recorder",
  "qualname": "observability.flight_recorder",
  "name": "observability.flight_recorder",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Trace-anchored flight recorder that mirrors run execution timelines.",
  "is_public": true
}
{
  "path": "observability/flight_recorder.py",
  "module": "observability.flight_recorder",
  "qualname": "_data_root",
  "name": "_data_root",
  "node_type": "FunctionDef",
  "lineno": 23,
  "col": 0,
  "end_lineno": 31,
  "end_col": 65,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return the base directory for diagnostic run artifacts.\n\nReturns\n-------\nPath\n    Root directory where run reports are stored.",
  "is_public": false
}
{
  "path": "observability/flight_recorder.py",
  "module": "observability.flight_recorder",
  "qualname": "_date_segment",
  "name": "_date_segment",
  "node_type": "FunctionDef",
  "lineno": 34,
  "col": 0,
  "end_lineno": 50,
  "end_col": 69,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return the YYYYMMDD segment for a run report.\n\nParameters\n----------\nstart_ns : int | None\n    Start timestamp in nanoseconds. If None, uses current UTC time.\n\nReturns\n-------\nstr\n    Date segment used to partition run reports (YYYYMMDD format).",
  "is_public": false
}
{
  "path": "observability/flight_recorder.py",
  "module": "observability.flight_recorder",
  "qualname": "_scrub_value",
  "name": "_scrub_value",
  "node_type": "FunctionDef",
  "lineno": 53,
  "col": 0,
  "end_lineno": 62,
  "end_col": 21,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "observability/flight_recorder.py",
  "module": "observability.flight_recorder",
  "qualname": "_event_start_ns",
  "name": "_event_start_ns",
  "node_type": "FunctionDef",
  "lineno": 65,
  "col": 0,
  "end_lineno": 67,
  "end_col": 49,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "observability/flight_recorder.py",
  "module": "observability.flight_recorder",
  "qualname": "_report_path",
  "name": "_report_path",
  "node_type": "FunctionDef",
  "lineno": 70,
  "col": 0,
  "end_lineno": 103,
  "end_col": 38,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return the filesystem path for a diagnostic run report.\n\nParameters\n----------\nsession_id : str | None\n    Session identifier for partitioning reports. Defaults to \"anonymous\" if None.\nrun_id : str | None\n    Run identifier. Used as filename if provided, otherwise falls back to trace_id.\ntrace_id : str | None\n    Trace identifier. Used as filename if run_id is not provided.\nstarted_ns : int | None\n    Start timestamp in nanoseconds for date segmentation.\nensure_parent : bool\n    If True, creates parent directories if they don't exist.\n\nReturns\n-------\nPath\n    Absolute path to the run report JSON file.",
  "is_public": false
}
{
  "path": "observability/flight_recorder.py",
  "module": "observability.flight_recorder",
  "qualname": "build_report_uri",
  "name": "build_report_uri",
  "node_type": "FunctionDef",
  "lineno": 106,
  "col": 0,
  "end_lineno": 136,
  "end_col": 91,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return the expected diagnostic report path for the provided identifiers.\n\nParameters\n----------\nsession_id : str | None\n    Session identifier for partitioning reports.\nrun_id : str | None\n    Run identifier. Used as filename if provided.\ntrace_id : str | None, optional\n    Trace identifier. Used as filename if run_id is not provided.\nstarted_at : float | None, optional\n    Start timestamp in seconds since epoch. Converted to nanoseconds for\n    date segmentation.\n\nReturns\n-------\nstr | None\n    Absolute path where the run report will be written, or ``None`` when\n    insufficient identifiers are provided.",
  "is_public": true
}
{
  "path": "observability/flight_recorder.py",
  "module": "observability.flight_recorder",
  "qualname": "_RunBuffer",
  "name": "_RunBuffer",
  "node_type": "ClassDef",
  "lineno": 140,
  "col": 0,
  "end_lineno": 149,
  "end_col": 32,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "observability/flight_recorder.py",
  "module": "observability.flight_recorder",
  "qualname": "_FlightRecorder",
  "name": "_FlightRecorder",
  "node_type": "ClassDef",
  "lineno": 152,
  "col": 0,
  "end_lineno": 258,
  "end_col": 40,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Collect spans per-trace and emit ordered JSON reports.",
  "is_public": false
}
{
  "path": "observability/flight_recorder.py",
  "module": "observability.flight_recorder",
  "qualname": "_FlightRecorder.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 155,
  "col": 4,
  "end_lineno": 157,
  "end_col": 37,
  "parent_qualname": "_FlightRecorder",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "observability/flight_recorder.py",
  "module": "observability.flight_recorder",
  "qualname": "_FlightRecorder.on_start",
  "name": "on_start",
  "node_type": "FunctionDef",
  "lineno": 159,
  "col": 4,
  "end_lineno": 180,
  "end_col": 48,
  "parent_qualname": "_FlightRecorder",
  "decorators": [],
  "bases": [],
  "docstring": "Handle span start event and initialize trace buffer.\n\nParameters\n----------\nspan : object\n    OpenTelemetry span object that has started. The span is inspected\n    to extract trace ID, start time, and identity attributes (session_id,\n    run_id) for buffering.",
  "is_public": true
}
{
  "path": "observability/flight_recorder.py",
  "module": "observability.flight_recorder",
  "qualname": "_FlightRecorder.on_end",
  "name": "on_end",
  "node_type": "FunctionDef",
  "lineno": 182,
  "col": 4,
  "end_lineno": 209,
  "end_col": 52,
  "parent_qualname": "_FlightRecorder",
  "decorators": [],
  "bases": [],
  "docstring": "Handle span end event and buffer or flush trace data.\n\nParameters\n----------\nspan : object\n    OpenTelemetry span object that has ended. The span is converted to\n    an event, added to the trace buffer, and flushed if it's the root span.",
  "is_public": true
}
{
  "path": "observability/flight_recorder.py",
  "module": "observability.flight_recorder",
  "qualname": "_FlightRecorder.shutdown",
  "name": "shutdown",
  "node_type": "FunctionDef",
  "lineno": 211,
  "col": 4,
  "end_lineno": 219,
  "end_col": 52,
  "parent_qualname": "_FlightRecorder",
  "decorators": [],
  "bases": [],
  "docstring": "Flush all buffered traces and clean up resources.\n\nThis method is called during shutdown to ensure all pending trace data\nis persisted to disk before the recorder is destroyed.",
  "is_public": true
}
{
  "path": "observability/flight_recorder.py",
  "module": "observability.flight_recorder",
  "qualname": "_FlightRecorder._flush_locked",
  "name": "_flush_locked",
  "node_type": "FunctionDef",
  "lineno": 221,
  "col": 4,
  "end_lineno": 258,
  "end_col": 40,
  "parent_qualname": "_FlightRecorder",
  "decorators": [],
  "bases": [],
  "docstring": "Persist buffered span events for ``trace_id`` to disk.",
  "is_public": false
}
{
  "path": "observability/flight_recorder.py",
  "module": "observability.flight_recorder",
  "qualname": "FlightRecorderSpanProcessor",
  "name": "FlightRecorderSpanProcessor",
  "node_type": "ClassDef",
  "lineno": 261,
  "col": 0,
  "end_lineno": 296,
  "end_col": 19,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Minimal SpanProcessor-compatible shim.",
  "is_public": true
}
{
  "path": "observability/flight_recorder.py",
  "module": "observability.flight_recorder",
  "qualname": "FlightRecorderSpanProcessor.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 264,
  "col": 4,
  "end_lineno": 265,
  "end_col": 33,
  "parent_qualname": "FlightRecorderSpanProcessor",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "observability/flight_recorder.py",
  "module": "observability.flight_recorder",
  "qualname": "FlightRecorderSpanProcessor.on_start",
  "name": "on_start",
  "node_type": "FunctionDef",
  "lineno": 267,
  "col": 4,
  "end_lineno": 270,
  "end_col": 37,
  "parent_qualname": "FlightRecorderSpanProcessor",
  "decorators": [],
  "bases": [],
  "docstring": "Record span start events.",
  "is_public": true
}
{
  "path": "observability/flight_recorder.py",
  "module": "observability.flight_recorder",
  "qualname": "FlightRecorderSpanProcessor.on_end",
  "name": "on_end",
  "node_type": "FunctionDef",
  "lineno": 272,
  "col": 4,
  "end_lineno": 274,
  "end_col": 35,
  "parent_qualname": "FlightRecorderSpanProcessor",
  "decorators": [],
  "bases": [],
  "docstring": "Record span completion events.",
  "is_public": true
}
{
  "path": "observability/flight_recorder.py",
  "module": "observability.flight_recorder",
  "qualname": "FlightRecorderSpanProcessor.shutdown",
  "name": "shutdown",
  "node_type": "FunctionDef",
  "lineno": 276,
  "col": 4,
  "end_lineno": 278,
  "end_col": 33,
  "parent_qualname": "FlightRecorderSpanProcessor",
  "decorators": [],
  "bases": [],
  "docstring": "Flush any buffered traces before shutdown.",
  "is_public": true
}
{
  "path": "observability/flight_recorder.py",
  "module": "observability.flight_recorder",
  "qualname": "FlightRecorderSpanProcessor.force_flush",
  "name": "force_flush",
  "node_type": "FunctionDef",
  "lineno": 280,
  "col": 4,
  "end_lineno": 296,
  "end_col": 19,
  "parent_qualname": "FlightRecorderSpanProcessor",
  "decorators": [],
  "bases": [],
  "docstring": "No-op flush hook required by the SpanProcessor protocol.\n\nParameters\n----------\ntimeout_millis : int | None, optional\n    Timeout in milliseconds (ignored). This parameter is part of the\n    SpanProcessor protocol but is not used in this implementation.\n\nReturns\n-------\nbool\n    Always ``True``.",
  "is_public": true
}
{
  "path": "observability/flight_recorder.py",
  "module": "observability.flight_recorder",
  "qualname": "install_flight_recorder",
  "name": "install_flight_recorder",
  "node_type": "FunctionDef",
  "lineno": 299,
  "col": 0,
  "end_lineno": 316,
  "end_col": 48,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Attach the flight recorder span processor exactly once.",
  "is_public": true
}
{
  "path": "observability/flight_recorder.py",
  "module": "observability.flight_recorder",
  "qualname": "_trace_id",
  "name": "_trace_id",
  "node_type": "FunctionDef",
  "lineno": 319,
  "col": 0,
  "end_lineno": 326,
  "end_col": 34,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "observability/flight_recorder.py",
  "module": "observability.flight_recorder",
  "qualname": "_span_id",
  "name": "_span_id",
  "node_type": "FunctionDef",
  "lineno": 329,
  "col": 0,
  "end_lineno": 336,
  "end_col": 33,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "observability/flight_recorder.py",
  "module": "observability.flight_recorder",
  "qualname": "_update_identities",
  "name": "_update_identities",
  "node_type": "FunctionDef",
  "lineno": 339,
  "col": 0,
  "end_lineno": 364,
  "end_col": 17,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Update buffer with identity attributes from span, returning new buffer if changed.\n\nParameters\n----------\nbuffer : _RunBuffer\n    Current buffer instance.\nspan : object\n    OpenTelemetry span object containing identity attributes.\n\nReturns\n-------\n_RunBuffer\n    Updated buffer instance (new instance if changes were made).",
  "is_public": false
}
{
  "path": "observability/flight_recorder.py",
  "module": "observability.flight_recorder",
  "qualname": "_update_status",
  "name": "_update_status",
  "node_type": "FunctionDef",
  "lineno": 367,
  "col": 0,
  "end_lineno": 405,
  "end_col": 17,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Update buffer status based on span status and events, returning new buffer if changed.\n\nParameters\n----------\nbuffer : _RunBuffer\n    Current buffer instance.\nspan : object\n    OpenTelemetry span object containing status information.\nevent : Mapping[str, Any]\n    Event dictionary containing exception information.\n\nReturns\n-------\n_RunBuffer\n    Updated buffer instance (new instance if status changed).",
  "is_public": false
}
{
  "path": "observability/flight_recorder.py",
  "module": "observability.flight_recorder",
  "qualname": "_is_root_span",
  "name": "_is_root_span",
  "node_type": "FunctionDef",
  "lineno": 408,
  "col": 0,
  "end_lineno": 413,
  "end_col": 22,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "observability/flight_recorder.py",
  "module": "observability.flight_recorder",
  "qualname": "_build_event",
  "name": "_build_event",
  "node_type": "FunctionDef",
  "lineno": 416,
  "col": 0,
  "end_lineno": 442,
  "end_col": 18,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "observability/flight_recorder.py",
  "module": "observability.flight_recorder",
  "qualname": "build_event_summary",
  "name": "build_event_summary",
  "node_type": "FunctionDef",
  "lineno": 445,
  "col": 0,
  "end_lineno": 483,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Build a compact summary describing the recorded events.\n\nParameters\n----------\nevents : Sequence[Mapping[str, object]]\n    Sequence of event dictionaries from the flight recorder. Events are\n    analyzed to extract stage names, warnings, and decision metadata.\n\nReturns\n-------\ndict[str, object]\n    Summary payload containing counts, stage names, warnings, and decisions.",
  "is_public": true
}
{
  "path": "observability/flight_recorder.py",
  "module": "observability.flight_recorder",
  "qualname": "_convert_span_events",
  "name": "_convert_span_events",
  "node_type": "FunctionDef",
  "lineno": 486,
  "col": 0,
  "end_lineno": 497,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "observability/flight_recorder.py",
  "module": "observability.flight_recorder",
  "qualname": "_ts",
  "name": "_ts",
  "node_type": "FunctionDef",
  "lineno": 500,
  "col": 0,
  "end_lineno": 504,
  "end_col": 62,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "observability/ledger.py",
  "module": "observability.ledger",
  "qualname": "observability.ledger",
  "name": "observability.ledger",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Append-only run ledger utilities.",
  "is_public": true
}
{
  "path": "observability/ledger.py",
  "module": "observability.ledger",
  "qualname": "ensure_ledger_root",
  "name": "ensure_ledger_root",
  "node_type": "FunctionDef",
  "lineno": 15,
  "col": 0,
  "end_lineno": 29,
  "end_col": 19,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Ensure the run-ledger root exists and return it.\n\nParameters\n----------\nroot_dir : Path\n    Directory path to ensure exists. Parent directories are created if needed.\n\nReturns\n-------\nPath\n    Absolute path to the ledger root directory.",
  "is_public": true
}
{
  "path": "observability/ledger.py",
  "module": "observability.ledger",
  "qualname": "dated_run_dir",
  "name": "dated_run_dir",
  "node_type": "FunctionDef",
  "lineno": 32,
  "col": 0,
  "end_lineno": 49,
  "end_col": 73,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return the YYYY-MM-DD ledger directory under ``base_dir``.\n\nParameters\n----------\nbase_dir : Path | None\n    Base directory for ledger storage. If None, defaults to \"data\".\nstamp : datetime | None, optional\n    Timestamp to use for date segmentation. If None, uses current UTC time.\n\nReturns\n-------\nPath\n    Resolved path to the YYYY-MM-DD ledger directory under the base directory.",
  "is_public": true
}
{
  "path": "observability/ledger.py",
  "module": "observability.ledger",
  "qualname": "RunLedger",
  "name": "RunLedger",
  "node_type": "ClassDef",
  "lineno": 53,
  "col": 0,
  "end_lineno": 113,
  "end_col": 31,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=False)"
  ],
  "bases": [],
  "docstring": "Append-only JSONL ledger scoped to a single run.\n\nNote: _handle is mutable to support lazy initialization of file handles.\nAll other fields remain immutable after construction.",
  "is_public": true
}
{
  "path": "observability/ledger.py",
  "module": "observability.ledger",
  "qualname": "RunLedger.open",
  "name": "open",
  "node_type": "FunctionDef",
  "lineno": 66,
  "col": 4,
  "end_lineno": 88,
  "end_col": 83,
  "parent_qualname": "RunLedger",
  "decorators": [
    "classmethod"
  ],
  "bases": [],
  "docstring": "Return a ledger instance for ``run_id`` rooted under ``root_dir``.\n\nParameters\n----------\nroot_dir : Path\n    Base directory for ledger storage. The ledger file is created under\n    a date-segmented subdirectory.\nrun_id : str\n    Unique identifier for the run. Used as part of the ledger filename.\nsession_id : str | None\n    Optional session identifier for partitioning ledgers. If None,\n    uses \"anonymous\" as the session identifier.\n\nReturns\n-------\nRunLedger\n    Open ledger bound to the provided run/session identifiers.",
  "is_public": true
}
{
  "path": "observability/ledger.py",
  "module": "observability.ledger",
  "qualname": "RunLedger.append",
  "name": "append",
  "node_type": "FunctionDef",
  "lineno": 90,
  "col": 4,
  "end_lineno": 102,
  "end_col": 22,
  "parent_qualname": "RunLedger",
  "decorators": [],
  "bases": [],
  "docstring": "Append a JSON record to the ledger.",
  "is_public": true
}
{
  "path": "observability/ledger.py",
  "module": "observability.ledger",
  "qualname": "RunLedger.close",
  "name": "close",
  "node_type": "FunctionDef",
  "lineno": 104,
  "col": 4,
  "end_lineno": 113,
  "end_col": 31,
  "parent_qualname": "RunLedger",
  "decorators": [],
  "bases": [],
  "docstring": "Flush and close the ledger handle if it is open.",
  "is_public": true
}
{
  "path": "observability/logs.py",
  "module": "observability.logs",
  "qualname": "observability.logs",
  "name": "observability.logs",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "OpenTelemetry logging bootstrap helpers.",
  "is_public": true
}
{
  "path": "observability/logs.py",
  "module": "observability.logs",
  "qualname": "_should_enable",
  "name": "_should_enable",
  "node_type": "FunctionDef",
  "lineno": 38,
  "col": 0,
  "end_lineno": 44,
  "end_col": 60,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "observability/logs.py",
  "module": "observability.logs",
  "qualname": "_instrument_stdlib_logging",
  "name": "_instrument_stdlib_logging",
  "node_type": "FunctionDef",
  "lineno": 47,
  "col": 0,
  "end_lineno": 63,
  "end_col": 67,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Enable OpenTelemetry's stdlib logging bridge when the package is installed.",
  "is_public": false
}
{
  "path": "observability/logs.py",
  "module": "observability.logs",
  "qualname": "init_otel_logging",
  "name": "init_otel_logging",
  "node_type": "FunctionDef",
  "lineno": 66,
  "col": 0,
  "end_lineno": 114,
  "end_col": 30,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Bridge stdlib logging into OpenTelemetry logs when available.",
  "is_public": true
}
{
  "path": "observability/metrics.py",
  "module": "observability.metrics",
  "qualname": "observability.metrics",
  "name": "observability.metrics",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Telemetry metrics registry and OpenTelemetry Meter bootstrap.",
  "is_public": true
}
{
  "path": "observability/metrics.py",
  "module": "observability.metrics",
  "qualname": "_MetricsState",
  "name": "_MetricsState",
  "node_type": "ClassDef",
  "lineno": 25,
  "col": 0,
  "end_lineno": 30,
  "end_col": 64,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=False)"
  ],
  "bases": [],
  "docstring": "Thread-safe metrics provider state.",
  "is_public": false
}
{
  "path": "observability/metrics.py",
  "module": "observability.metrics",
  "qualname": "_env_flag",
  "name": "_env_flag",
  "node_type": "FunctionDef",
  "lineno": 41,
  "col": 0,
  "end_lineno": 45,
  "end_col": 60,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "observability/metrics.py",
  "module": "observability.metrics",
  "qualname": "_import_module",
  "name": "_import_module",
  "node_type": "FunctionDef",
  "lineno": 48,
  "col": 0,
  "end_lineno": 64,
  "end_col": 19,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Import a module by name, returning None if unavailable.\n\nParameters\n----------\nname : str\n    Module name to import (e.g., \"opentelemetry.sdk.metrics\").\n\nReturns\n-------\nModuleType | None\n    Imported module if available, otherwise None.",
  "is_public": false
}
{
  "path": "observability/metrics.py",
  "module": "observability.metrics",
  "qualname": "_build_metric_views",
  "name": "_build_metric_views",
  "node_type": "FunctionDef",
  "lineno": 67,
  "col": 0,
  "end_lineno": 110,
  "end_col": 16,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "observability/metrics.py",
  "module": "observability.metrics",
  "qualname": "_build_prometheus_reader",
  "name": "_build_prometheus_reader",
  "node_type": "FunctionDef",
  "lineno": 113,
  "col": 0,
  "end_lineno": 124,
  "end_col": 19,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "observability/metrics.py",
  "module": "observability.metrics",
  "qualname": "_start_prometheus_http_server",
  "name": "_start_prometheus_http_server",
  "node_type": "FunctionDef",
  "lineno": 127,
  "col": 0,
  "end_lineno": 155,
  "end_col": 13,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Start Prometheus HTTP server for metrics scraping (idempotent).",
  "is_public": false
}
{
  "path": "observability/metrics.py",
  "module": "observability.metrics",
  "qualname": "_load_metrics_modules",
  "name": "_load_metrics_modules",
  "node_type": "FunctionDef",
  "lineno": 158,
  "col": 0,
  "end_lineno": 176,
  "end_col": 65,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Load all required metrics SDK modules.\n\nReturns\n-------\ntuple[ModuleType, ModuleType, ModuleType, ModuleType] | None\n    Tuple of (sdk, view, export, api) modules if all available, otherwise None.",
  "is_public": false
}
{
  "path": "observability/metrics.py",
  "module": "observability.metrics",
  "qualname": "_build_otlp_reader",
  "name": "_build_otlp_reader",
  "node_type": "FunctionDef",
  "lineno": 179,
  "col": 0,
  "end_lineno": 208,
  "end_col": 15,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Build OTLP metric reader if available.\n\nParameters\n----------\nexport_module : ModuleType\n    OpenTelemetry export module.\nendpoint : str\n    OTLP endpoint URL.\n\nReturns\n-------\nMetricReader | None\n    OTLP reader instance if available, otherwise None.",
  "is_public": false
}
{
  "path": "observability/metrics.py",
  "module": "observability.metrics",
  "qualname": "install_metrics_provider",
  "name": "install_metrics_provider",
  "node_type": "FunctionDef",
  "lineno": 211,
  "col": 0,
  "end_lineno": 258,
  "end_col": 48,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Install a global MeterProvider with OTLP + Prometheus readers.\n\nParameters\n----------\nresource : Resource\n    OpenTelemetry Resource instance containing service metadata.\notlp_endpoint : str | None, optional\n    Optional OTLP endpoint override. Defaults to environment variable.",
  "is_public": true
}
{
  "path": "observability/metrics.py",
  "module": "observability.metrics",
  "qualname": "observe_budget_depths",
  "name": "observe_budget_depths",
  "node_type": "FunctionDef",
  "lineno": 353,
  "col": 0,
  "end_lineno": 356,
  "end_col": 62,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Record per-channel depth decisions.",
  "is_public": true
}
{
  "path": "observability/metrics.py",
  "module": "observability.metrics",
  "qualname": "record_recall",
  "name": "record_recall",
  "node_type": "FunctionDef",
  "lineno": 359,
  "col": 0,
  "end_lineno": 361,
  "end_col": 50,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Record recall@k values produced by offline harnesses.",
  "is_public": true
}
{
  "path": "observability/metrics.py",
  "module": "observability.metrics",
  "qualname": "set_index_version",
  "name": "set_index_version",
  "node_type": "FunctionDef",
  "lineno": 364,
  "col": 0,
  "end_lineno": 383,
  "end_col": 69,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Expose the current index version for dashboards.\n\nParameters\n----------\ncomponent : str\n    Component identifier (\"faiss\", \"bm25\", \"splade\").\nversion : str | None\n    Version string reported by the lifecycle manager. When the version\n    cannot be parsed as a numeric value the gauge is set to ``0``.",
  "is_public": true
}
{
  "path": "observability/otel.py",
  "module": "observability.otel",
  "qualname": "observability.otel",
  "name": "observability.otel",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Optional OpenTelemetry bootstrap helpers.",
  "is_public": true
}
{
  "path": "observability/otel.py",
  "module": "observability.otel",
  "qualname": "_TelemetryState",
  "name": "_TelemetryState",
  "node_type": "ClassDef",
  "lineno": 32,
  "col": 0,
  "end_lineno": 52,
  "end_col": 41,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Mutable telemetry state shared across module functions.",
  "is_public": false
}
{
  "path": "observability/otel.py",
  "module": "observability.otel",
  "qualname": "_TelemetryState.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 45,
  "col": 4,
  "end_lineno": 52,
  "end_col": 41,
  "parent_qualname": "_TelemetryState",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "observability/otel.py",
  "module": "observability.otel",
  "qualname": "SupportsState",
  "name": "SupportsState",
  "node_type": "ClassDef",
  "lineno": 55,
  "col": 0,
  "end_lineno": 58,
  "end_col": 14,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "Protocol"
  ],
  "docstring": "Protocol describing FastAPI-style objects exposing ``state``.",
  "is_public": true
}
{
  "path": "observability/otel.py",
  "module": "observability.otel",
  "qualname": "_TraceHandles",
  "name": "_TraceHandles",
  "node_type": "ClassDef",
  "lineno": 62,
  "col": 0,
  "end_lineno": 68,
  "end_col": 32,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "observability/otel.py",
  "module": "observability.otel",
  "qualname": "_env_flag",
  "name": "_env_flag",
  "node_type": "FunctionDef",
  "lineno": 80,
  "col": 0,
  "end_lineno": 107,
  "end_col": 60,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Check if an environment variable is set to a truthy value.\n\nThis function reads an environment variable and returns True if it's set to\na recognized truthy value (\"1\", \"true\", \"yes\", \"on\"), or returns the default\nvalue if the variable is unset or set to a falsy value.\n\nParameters\n----------\nname : str\n    Environment variable name to check. The variable is read using os.getenv()\n    and compared against truthy values (case-insensitive, whitespace-trimmed).\ndefault : bool, optional\n    Default value to return when the environment variable is unset or not\n    recognized as truthy (default: False). Used to provide fallback behavior\n    when the flag is not explicitly configured.\n\nReturns\n-------\nbool\n    True if the environment variable is set to a truthy value, otherwise\n    returns the default value. Truthy values are \"1\", \"true\", \"yes\", \"on\"\n    (case-insensitive, whitespace-trimmed).",
  "is_public": false
}
{
  "path": "observability/otel.py",
  "module": "observability.otel",
  "qualname": "_sanitize_span_attrs",
  "name": "_sanitize_span_attrs",
  "node_type": "FunctionDef",
  "lineno": 110,
  "col": 0,
  "end_lineno": 116,
  "end_col": 20,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "observability/otel.py",
  "module": "observability.otel",
  "qualname": "_coerce_span_value",
  "name": "_coerce_span_value",
  "node_type": "FunctionDef",
  "lineno": 119,
  "col": 0,
  "end_lineno": 130,
  "end_col": 21,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "observability/otel.py",
  "module": "observability.otel",
  "qualname": "_should_enable",
  "name": "_should_enable",
  "node_type": "FunctionDef",
  "lineno": 133,
  "col": 0,
  "end_lineno": 136,
  "end_col": 58,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "observability/otel.py",
  "module": "observability.otel",
  "qualname": "_optional_import",
  "name": "_optional_import",
  "node_type": "FunctionDef",
  "lineno": 139,
  "col": 0,
  "end_lineno": 143,
  "end_col": 19,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "observability/otel.py",
  "module": "observability.otel",
  "qualname": "_load_trace_modules",
  "name": "_load_trace_modules",
  "node_type": "FunctionDef",
  "lineno": 146,
  "col": 0,
  "end_lineno": 170,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "observability/otel.py",
  "module": "observability.otel",
  "qualname": "_parse_sampler_spec",
  "name": "_parse_sampler_spec",
  "node_type": "FunctionDef",
  "lineno": 173,
  "col": 0,
  "end_lineno": 183,
  "end_col": 22,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "observability/otel.py",
  "module": "observability.otel",
  "qualname": "_build_sampler",
  "name": "_build_sampler",
  "node_type": "FunctionDef",
  "lineno": 186,
  "col": 0,
  "end_lineno": 212,
  "end_col": 15,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "observability/otel.py",
  "module": "observability.otel",
  "qualname": "_build_resource",
  "name": "_build_resource",
  "node_type": "FunctionDef",
  "lineno": 215,
  "col": 0,
  "end_lineno": 247,
  "end_col": 55,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "observability/otel.py",
  "module": "observability.otel",
  "qualname": "_merge_detected_resources",
  "name": "_merge_detected_resources",
  "node_type": "FunctionDef",
  "lineno": 250,
  "col": 0,
  "end_lineno": 290,
  "end_col": 17,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Augment ``resource`` with optional detector-provided attributes.\n\nParameters\n----------\nhandles : _TraceHandles\n    Trace module handles for type checking.\nresource : Resource\n    Base resource to augment.\n\nReturns\n-------\nResource\n    Resource merged with detector-provided metadata.",
  "is_public": false
}
{
  "path": "observability/otel.py",
  "module": "observability.otel",
  "qualname": "_build_provider",
  "name": "_build_provider",
  "node_type": "FunctionDef",
  "lineno": 293,
  "col": 0,
  "end_lineno": 318,
  "end_col": 19,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "observability/otel.py",
  "module": "observability.otel",
  "qualname": "telemetry_enabled",
  "name": "telemetry_enabled",
  "node_type": "FunctionDef",
  "lineno": 321,
  "col": 0,
  "end_lineno": 329,
  "end_col": 33,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return ``True`` when tracing has been configured for this process.\n\nReturns\n-------\nbool\n    ``True`` if telemetry successfully bootstrapped, otherwise ``False``.",
  "is_public": true
}
{
  "path": "observability/otel.py",
  "module": "observability.otel",
  "qualname": "_initialize_tracing_state",
  "name": "_initialize_tracing_state",
  "node_type": "FunctionDef",
  "lineno": 332,
  "col": 0,
  "end_lineno": 347,
  "end_col": 45,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Update application state with telemetry enabled status.\n\nParameters\n----------\napp : SupportsState | None\n    FastAPI application instance (may be None).\nenabled : bool\n    Whether telemetry is enabled.",
  "is_public": false
}
{
  "path": "observability/otel.py",
  "module": "observability.otel",
  "qualname": "_initialize_metrics_provider",
  "name": "_initialize_metrics_provider",
  "node_type": "FunctionDef",
  "lineno": 350,
  "col": 0,
  "end_lineno": 374,
  "end_col": 83,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Initialize metrics provider if enabled.\n\nParameters\n----------\nresource : Resource\n    OpenTelemetry Resource instance.\notlp_endpoint : str | None\n    Optional OTLP endpoint override.",
  "is_public": false
}
{
  "path": "observability/otel.py",
  "module": "observability.otel",
  "qualname": "_initialize_flight_recorder",
  "name": "_initialize_flight_recorder",
  "node_type": "FunctionDef",
  "lineno": 377,
  "col": 0,
  "end_lineno": 390,
  "end_col": 72,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Initialize flight recorder if available.\n\nParameters\n----------\nprovider : object\n    TracerProvider instance.",
  "is_public": false
}
{
  "path": "observability/otel.py",
  "module": "observability.otel",
  "qualname": "init_telemetry",
  "name": "init_telemetry",
  "node_type": "FunctionDef",
  "lineno": 393,
  "col": 0,
  "end_lineno": 456,
  "end_col": 45,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Best-effort OpenTelemetry bootstrap (safe no-op when disabled/unavailable).\n\nParameters\n----------\napp : SupportsState | None, optional\n    FastAPI application instance for storing telemetry state.\nservice_name : str, optional\n    Resource attribute for exported spans. Defaults to ``codeintel_rev``.\nservice_version : str | None, optional\n    Optional semantic version attached to the OpenTelemetry resource.\notlp_endpoint : str | None, optional\n    Override for OTLP HTTP endpoint. When ``None``, uses\n    ``OTEL_EXPORTER_OTLP_ENDPOINT``.\nenable_logging_instrumentation : bool, optional\n    When ``True`` attempts to enable OpenTelemetry logging instrumentation\n    (safe no-op if instrumentation packages are unavailable).\nsampler : str | None, optional\n    Optional sampler specification (e.g., ``parentbased_traceidratio:0.2``).\n    When ``None`` defers to SDK defaults.\ninstall_flight_recorder : bool, optional\n    When ``True`` installs the lightweight flight recorder span processor.",
  "is_public": true
}
{
  "path": "observability/otel.py",
  "module": "observability.otel",
  "qualname": "init_otel",
  "name": "init_otel",
  "node_type": "FunctionDef",
  "lineno": 459,
  "col": 0,
  "end_lineno": 479,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Initialize tracing/metrics using the CODEINTEL_OTEL_* env conventions.",
  "is_public": true
}
{
  "path": "observability/otel.py",
  "module": "observability.otel",
  "qualname": "init_all_telemetry",
  "name": "init_all_telemetry",
  "node_type": "FunctionDef",
  "lineno": 482,
  "col": 0,
  "end_lineno": 503,
  "end_col": 78,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Initialize traces, metrics, and logs in one call.",
  "is_public": true
}
{
  "path": "observability/otel.py",
  "module": "observability.otel",
  "qualname": "as_span",
  "name": "as_span",
  "node_type": "FunctionDef",
  "lineno": 506,
  "col": 0,
  "end_lineno": 531,
  "end_col": 58,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Create a span context that no-ops when telemetry is disabled.\n\nExtended Summary\n----------------\nReturns a context manager that creates an OpenTelemetry span when tracing\nis enabled, or a no-op context manager when disabled. Attributes are\nsanitized (coerced to span-compatible types, truncated if needed) before\nbeing attached to the span.\n\nParameters\n----------\nname : str\n    Span name used for identification in traces.\n**attrs : object\n    Arbitrary keyword arguments converted to span attributes. Values are\n    coerced to str/int/float/bool and truncated if strings exceed max length.\n\nReturns\n-------\nAbstractContextManager[None]\n    Context manager that enters/exits a span when telemetry is enabled,\n    or a no-op context manager when disabled. Always yields None.",
  "is_public": true
}
{
  "path": "observability/otel.py",
  "module": "observability.otel",
  "qualname": "record_span_event",
  "name": "record_span_event",
  "node_type": "FunctionDef",
  "lineno": 534,
  "col": 0,
  "end_lineno": 555,
  "end_col": 87,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Attach ``name`` as an event on the current span when tracing is active.",
  "is_public": true
}
{
  "path": "observability/otel.py",
  "module": "observability.otel",
  "qualname": "_current_span",
  "name": "_current_span",
  "node_type": "FunctionDef",
  "lineno": 558,
  "col": 0,
  "end_lineno": 568,
  "end_col": 19,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "observability/otel.py",
  "module": "observability.otel",
  "qualname": "set_current_span_attrs",
  "name": "set_current_span_attrs",
  "node_type": "FunctionDef",
  "lineno": 571,
  "col": 0,
  "end_lineno": 584,
  "end_col": 20,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Attach attributes to the active span when tracing is enabled.",
  "is_public": true
}
{
  "path": "observability/otel.py",
  "module": "observability.otel",
  "qualname": "_current_span_context",
  "name": "_current_span_context",
  "node_type": "FunctionDef",
  "lineno": 587,
  "col": 0,
  "end_lineno": 597,
  "end_col": 19,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "observability/otel.py",
  "module": "observability.otel",
  "qualname": "current_trace_id",
  "name": "current_trace_id",
  "node_type": "FunctionDef",
  "lineno": 600,
  "col": 0,
  "end_lineno": 613,
  "end_col": 34,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return the hex trace identifier for the active span.\n\nReturns\n-------\nstr | None\n    Hexadecimal trace ID string (32 characters) for the active span, or\n    ``None`` if no active span is available or the trace ID is invalid.",
  "is_public": true
}
{
  "path": "observability/otel.py",
  "module": "observability.otel",
  "qualname": "current_span_id",
  "name": "current_span_id",
  "node_type": "FunctionDef",
  "lineno": 616,
  "col": 0,
  "end_lineno": 629,
  "end_col": 33,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return the hex span identifier for the active span.\n\nReturns\n-------\nstr | None\n    Hexadecimal span ID string (16 characters) for the active span, or\n    ``None`` if no active span is available or the span ID is invalid.",
  "is_public": true
}
{
  "path": "observability/otel.py",
  "module": "observability.otel",
  "qualname": "_install_logging_instrumentation",
  "name": "_install_logging_instrumentation",
  "node_type": "FunctionDef",
  "lineno": 632,
  "col": 0,
  "end_lineno": 643,
  "end_col": 42,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "observability/otel.py",
  "module": "observability.otel",
  "qualname": "instrument_fastapi",
  "name": "instrument_fastapi",
  "node_type": "FunctionDef",
  "lineno": 646,
  "col": 0,
  "end_lineno": 658,
  "end_col": 42,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Instrument FastAPI routes when instrumentation packages are installed.",
  "is_public": true
}
{
  "path": "observability/otel.py",
  "module": "observability.otel",
  "qualname": "instrument_httpx",
  "name": "instrument_httpx",
  "node_type": "FunctionDef",
  "lineno": 661,
  "col": 0,
  "end_lineno": 673,
  "end_col": 40,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Instrument httpx clients when instrumentation packages are installed.",
  "is_public": true
}
{
  "path": "observability/reporting.py",
  "module": "observability.reporting",
  "qualname": "observability.reporting",
  "name": "observability.reporting",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Timeline-based run report builder and CLI helpers.",
  "is_public": true
}
{
  "path": "observability/reporting.py",
  "module": "observability.reporting",
  "qualname": "TimelineRunReport",
  "name": "TimelineRunReport",
  "node_type": "ClassDef",
  "lineno": 22,
  "col": 0,
  "end_lineno": 45,
  "end_col": 9,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Structured summary derived from Timeline JSONL records.",
  "is_public": true
}
{
  "path": "observability/reporting.py",
  "module": "observability.reporting",
  "qualname": "TimelineRunReport.to_dict",
  "name": "to_dict",
  "node_type": "FunctionDef",
  "lineno": 31,
  "col": 4,
  "end_lineno": 45,
  "end_col": 9,
  "parent_qualname": "TimelineRunReport",
  "decorators": [],
  "bases": [],
  "docstring": "Return a JSON-serializable representation of the report.\n\nReturns\n-------\ndict[str, Any]\n    Mapping suitable for JSON serialization.",
  "is_public": true
}
{
  "path": "observability/reporting.py",
  "module": "observability.reporting",
  "qualname": "render_timeline_markdown",
  "name": "render_timeline_markdown",
  "node_type": "FunctionDef",
  "lineno": 48,
  "col": 0,
  "end_lineno": 74,
  "end_col": 46,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return Markdown for the provided :class:`TimelineRunReport`.\n\nThis function renders a timeline run report as Markdown text suitable for\ndisplay in documentation or web interfaces. It is called by CLI commands\nand HTTP endpoints to format telemetry reports for human-readable output.\n\nParameters\n----------\nreport : TimelineRunReport\n    Timeline run report to render as Markdown.\n\nReturns\n-------\nstr\n    Markdown body describing the run including session, run, summary,\n    events, and error information.",
  "is_public": true
}
{
  "path": "observability/reporting.py",
  "module": "observability.reporting",
  "qualname": "timeline_mermaid",
  "name": "timeline_mermaid",
  "node_type": "FunctionDef",
  "lineno": 77,
  "col": 0,
  "end_lineno": 109,
  "end_col": 27,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return a Mermaid diagram that visualizes the recorded events.\n\nParameters\n----------\nreport : TimelineRunReport\n    Timeline report to render.\nmax_events : int, optional\n    Maximum number of events to include before truncating.\n\nReturns\n-------\nstr\n    Mermaid ``graph TD`` diagram describing the timeline.",
  "is_public": true
}
{
  "path": "observability/reporting.py",
  "module": "observability.reporting",
  "qualname": "_ensure_runs_dir",
  "name": "_ensure_runs_dir",
  "node_type": "FunctionDef",
  "lineno": 112,
  "col": 0,
  "end_lineno": 115,
  "end_col": 17,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "observability/reporting.py",
  "module": "observability.reporting",
  "qualname": "render_run_report",
  "name": "render_run_report",
  "node_type": "FunctionDef",
  "lineno": 118,
  "col": 0,
  "end_lineno": 185,
  "end_col": 24,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Render Markdown + JSON artifacts for the provided timeline.\n\nParameters\n----------\ntimeline : Timeline\n    Timeline instance containing events to render. The timeline must be\n    sampled (timeline.sampled == True) or this function will raise\n    RuntimeError.\nout_dir : Path | None, optional\n    Optional output directory for report artifacts (default: None). When\n    None, uses the default runs directory. The directory is created if\n    it doesn't exist.\n\nReturns\n-------\nPath\n    Path to the generated Markdown report file. The report is written to\n    {out_dir}/{run_id}.md, with a corresponding JSON file at\n    {out_dir}/{run_id}.json.\n\nRaises\n------\nRuntimeError\n    Raised when the timeline is not sampled (timeline.sampled == False).\n    Only sampled timelines can be rendered as run reports.\n\nNotes\n-----\nThis function generates both Markdown and JSON artifacts for the timeline.\nThe Markdown report is human-readable and includes event summaries, while\nthe JSON report contains the full event data for programmatic processing.\nThe report metadata is also stored globally for retrieval via\nlatest_run_report().",
  "is_public": true
}
{
  "path": "observability/reporting.py",
  "module": "observability.reporting",
  "qualname": "latest_run_report",
  "name": "latest_run_report",
  "node_type": "FunctionDef",
  "lineno": 188,
  "col": 0,
  "end_lineno": 199,
  "end_col": 40,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return metadata for the most recently rendered run report.\n\nReturns\n-------\ndict[str, object] | None\n    Dictionary containing the most recent run report metadata, or None\n    if no report has been rendered yet. The dictionary includes keys:\n    \"markdown\" (str path), \"json\" (str path), \"session_id\", \"run_id\", and\n    \"summary\". Returns None when no reports have been generated.",
  "is_public": true
}
{
  "path": "observability/reporting.py",
  "module": "observability.reporting",
  "qualname": "build_timeline_run_report",
  "name": "build_timeline_run_report",
  "node_type": "FunctionDef",
  "lineno": 202,
  "col": 0,
  "end_lineno": 256,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Build a run report by parsing Timeline JSONL artifacts.\n\nThis function constructs a TimelineRunReport by loading and parsing Timeline\nJSONL event files from the timeline directory. The function resolves the\ntimeline directory, loads events for the specified session and optional run,\nand builds a structured report containing all events.\n\nParameters\n----------\nsession_id : str\n    Session identifier to load events for. Used to identify the Timeline\n    session directory and filter events. Must match a session directory\n    in the timeline root.\nrun_id : str | None, optional\n    Optional run identifier to filter events for a specific run (default: None).\n    When None, loads all events for the session. When provided, filters\n    events to only those matching the run_id.\ntimeline_dir : Path | None, optional\n    Optional timeline root directory path (default: None). When None, uses\n    the default timeline directory from environment or configuration.\n    Used to locate Timeline JSONL artifact files.\n\nReturns\n-------\nTimelineRunReport\n    Structured run summary derived from Timeline records. The report contains\n    session_id, run_id, and a list of parsed events. Returns an empty report\n    with no events when no matching Timeline files are found.",
  "is_public": true
}
{
  "path": "observability/reporting.py",
  "module": "observability.reporting",
  "qualname": "_resolve_timeline_dir",
  "name": "_resolve_timeline_dir",
  "node_type": "FunctionDef",
  "lineno": 259,
  "col": 0,
  "end_lineno": 264,
  "end_col": 15,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "observability/reporting.py",
  "module": "observability.reporting",
  "qualname": "resolve_timeline_dir",
  "name": "resolve_timeline_dir",
  "node_type": "FunctionDef",
  "lineno": 267,
  "col": 0,
  "end_lineno": 282,
  "end_col": 43,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return the normalized diagnostics directory used for timeline artifacts.\n\nParameters\n----------\ncandidate : Path | None, optional\n    Optional override path supplied by callers. When ``None`` (default),\n    falls back to ``CODEINTEL_DIAG_DIR`` or ``./data/diagnostics``.\n\nReturns\n-------\nPath\n    Absolute path to the diagnostics directory. The directory is created\n    if it does not already exist.",
  "is_public": true
}
{
  "path": "observability/reporting.py",
  "module": "observability.reporting",
  "qualname": "_load_events",
  "name": "_load_events",
  "node_type": "FunctionDef",
  "lineno": 285,
  "col": 0,
  "end_lineno": 302,
  "end_col": 17,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "observability/reporting.py",
  "module": "observability.reporting",
  "qualname": "_summarize_events",
  "name": "_summarize_events",
  "node_type": "FunctionDef",
  "lineno": 305,
  "col": 0,
  "end_lineno": 324,
  "end_col": 31,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "observability/reporting.py",
  "module": "observability.reporting",
  "qualname": "_collect_channel_stats",
  "name": "_collect_channel_stats",
  "node_type": "FunctionDef",
  "lineno": 327,
  "col": 0,
  "end_lineno": 339,
  "end_col": 16,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "observability/reporting.py",
  "module": "observability.reporting",
  "qualname": "_render_markdown_report",
  "name": "_render_markdown_report",
  "node_type": "FunctionDef",
  "lineno": 342,
  "col": 0,
  "end_lineno": 383,
  "end_col": 27,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "observability/run_report.py",
  "module": "observability.run_report",
  "qualname": "observability.run_report",
  "name": "observability.run_report",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Utilities for composing run reports from JSONL ledgers.",
  "is_public": true
}
{
  "path": "observability/run_report.py",
  "module": "observability.run_report",
  "qualname": "LedgerRunReport",
  "name": "LedgerRunReport",
  "node_type": "ClassDef",
  "lineno": 13,
  "col": 0,
  "end_lineno": 20,
  "end_col": 20,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Structured run report derived from a run ledger.",
  "is_public": true
}
{
  "path": "observability/run_report.py",
  "module": "observability.run_report",
  "qualname": "load_ledger",
  "name": "load_ledger",
  "node_type": "FunctionDef",
  "lineno": 23,
  "col": 0,
  "end_lineno": 50,
  "end_col": 18,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return all JSONL records contained in ``path`` (best effort).\n\nParameters\n----------\npath : Path\n    Path to the JSONL ledger file to read.\n\nReturns\n-------\nlist[dict[str, Any]]\n    List of parsed JSON records from the ledger. Returns an empty list if\n    the file doesn't exist or if parsing errors occur (errors are silently\n    skipped).",
  "is_public": true
}
{
  "path": "observability/run_report.py",
  "module": "observability.run_report",
  "qualname": "infer_stop_reason",
  "name": "infer_stop_reason",
  "node_type": "FunctionDef",
  "lineno": 53,
  "col": 0,
  "end_lineno": 74,
  "end_col": 23,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return a human-readable stop reason based on structured step events.\n\nParameters\n----------\nevents : Iterable[Mapping[str, Any]]\n    Sequence of step event dictionaries to analyze for failure status.\n\nReturns\n-------\nstr | None\n    Human-readable stop reason string (format: \"kind:detail\" or \"kind:status\"),\n    or None if no failures are found in the events.",
  "is_public": true
}
{
  "path": "observability/run_report.py",
  "module": "observability.run_report",
  "qualname": "build_run_report",
  "name": "build_run_report",
  "node_type": "FunctionDef",
  "lineno": 77,
  "col": 0,
  "end_lineno": 106,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Compose a report for ``run_id`` using the JSONL ledger at ``ledger_path``.\n\nParameters\n----------\nrun_id : str\n    Run identifier to include in the report.\nledger_path : Path\n    Path to the JSONL ledger file containing step events.\n\nReturns\n-------\nLedgerRunReport\n    Structured report object containing run metadata, stop reason, warnings,\n    and step events.",
  "is_public": true
}
{
  "path": "observability/runpack.py",
  "module": "observability.runpack",
  "qualname": "observability.runpack",
  "name": "observability.runpack",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Helpers for building per-run diagnostic artifacts (\"runpacks\").",
  "is_public": true
}
{
  "path": "observability/runpack.py",
  "module": "observability.runpack",
  "qualname": "_json_bytes",
  "name": "_json_bytes",
  "node_type": "FunctionDef",
  "lineno": 29,
  "col": 0,
  "end_lineno": 30,
  "end_col": 76,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "observability/runpack.py",
  "module": "observability.runpack",
  "qualname": "_write_bytes",
  "name": "_write_bytes",
  "node_type": "FunctionDef",
  "lineno": 33,
  "col": 0,
  "end_lineno": 36,
  "end_col": 32,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "observability/runpack.py",
  "module": "observability.runpack",
  "qualname": "_sanitize_dataclass",
  "name": "_sanitize_dataclass",
  "node_type": "FunctionDef",
  "lineno": 39,
  "col": 0,
  "end_lineno": 49,
  "end_col": 19,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "observability/runpack.py",
  "module": "observability.runpack",
  "qualname": "_settings_summary",
  "name": "_settings_summary",
  "node_type": "FunctionDef",
  "lineno": 52,
  "col": 0,
  "end_lineno": 71,
  "end_col": 18,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "observability/runpack.py",
  "module": "observability.runpack",
  "qualname": "_runtime_facts",
  "name": "_runtime_facts",
  "node_type": "FunctionDef",
  "lineno": 74,
  "col": 0,
  "end_lineno": 96,
  "end_col": 16,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "observability/runpack.py",
  "module": "observability.runpack",
  "qualname": "_context_snapshot",
  "name": "_context_snapshot",
  "node_type": "FunctionDef",
  "lineno": 99,
  "col": 0,
  "end_lineno": 105,
  "end_col": 19,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "observability/runpack.py",
  "module": "observability.runpack",
  "qualname": "_extract_budget",
  "name": "_extract_budget",
  "node_type": "FunctionDef",
  "lineno": 108,
  "col": 0,
  "end_lineno": 120,
  "end_col": 15,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "observability/runpack.py",
  "module": "observability.runpack",
  "qualname": "_structured_report",
  "name": "_structured_report",
  "node_type": "FunctionDef",
  "lineno": 123,
  "col": 0,
  "end_lineno": 135,
  "end_col": 33,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "observability/runpack.py",
  "module": "observability.runpack",
  "qualname": "make_runpack",
  "name": "make_runpack",
  "node_type": "FunctionDef",
  "lineno": 138,
  "col": 0,
  "end_lineno": 236,
  "end_col": 23,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Build a zipped telemetry artifact for ``session_id``/``run_id``.\n\nThis function creates a zip archive containing telemetry artifacts including\ntimeline events, run reports, configuration snapshots, and metadata. It is\ncalled by CLI commands and diagnostic tools to package telemetry data for\noffline analysis and debugging.\n\nParameters\n----------\ncontext : ApplicationContext\n    Application context providing settings and runtime configuration.\nsession_id : str\n    Session identifier to package artifacts for.\nrun_id : str | None\n    Optional run identifier when multiple runs share a session. If None,\n    packages the latest run for the session.\ntrace_id : str | None\n    Optional trace identifier to record in metadata.\nreason : str | None\n    Optional reason stored in metadata explaining why the runpack was created.\n    Defaults to None.\n\nReturns\n-------\nPath\n    Filesystem path to the generated zip archive.",
  "is_public": true
}
{
  "path": "observability/runtime_observer.py",
  "module": "observability.runtime_observer",
  "qualname": "observability.runtime_observer",
  "name": "observability.runtime_observer",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "RuntimeCell observer that writes lifecycle events to the active timeline.",
  "is_public": true
}
{
  "path": "observability/runtime_observer.py",
  "module": "observability.runtime_observer",
  "qualname": "current_run_ledger",
  "name": "current_run_ledger",
  "node_type": "FunctionDef",
  "lineno": 31,
  "col": 0,
  "end_lineno": 40,
  "end_col": 32,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return the run ledger bound to the current context, if any.\n\nReturns\n-------\nRunLedger | None\n    The run ledger bound to the current context variable, or None if no\n    ledger is currently bound.",
  "is_public": true
}
{
  "path": "observability/runtime_observer.py",
  "module": "observability.runtime_observer",
  "qualname": "bind_run_ledger",
  "name": "bind_run_ledger",
  "node_type": "FunctionDef",
  "lineno": 44,
  "col": 0,
  "end_lineno": 50,
  "end_col": 36,
  "parent_qualname": null,
  "decorators": [
    "contextmanager"
  ],
  "bases": [],
  "docstring": "Bind ``ledger`` to the current context for the duration of the block.",
  "is_public": true
}
{
  "path": "observability/runtime_observer.py",
  "module": "observability.runtime_observer",
  "qualname": "TimelineRuntimeObserver",
  "name": "TimelineRuntimeObserver",
  "node_type": "ClassDef",
  "lineno": 53,
  "col": 0,
  "end_lineno": 143,
  "end_col": 79,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "RuntimeCellObserver"
  ],
  "docstring": "Emit runtime cell lifecycle events to the active or fallback timeline.",
  "is_public": true
}
{
  "path": "observability/runtime_observer.py",
  "module": "observability.runtime_observer",
  "qualname": "TimelineRuntimeObserver.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 58,
  "col": 4,
  "end_lineno": 59,
  "end_col": 33,
  "parent_qualname": "TimelineRuntimeObserver",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "observability/runtime_observer.py",
  "module": "observability.runtime_observer",
  "qualname": "TimelineRuntimeObserver._timeline",
  "name": "_timeline",
  "node_type": "FunctionDef",
  "lineno": 61,
  "col": 4,
  "end_lineno": 64,
  "end_col": 51,
  "parent_qualname": "TimelineRuntimeObserver",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "observability/runtime_observer.py",
  "module": "observability.runtime_observer",
  "qualname": "TimelineRuntimeObserver.on_init_start",
  "name": "on_init_start",
  "node_type": "FunctionDef",
  "lineno": 66,
  "col": 4,
  "end_lineno": 82,
  "end_col": 67,
  "parent_qualname": "TimelineRuntimeObserver",
  "decorators": [],
  "bases": [],
  "docstring": "Record runtime initialization start.",
  "is_public": true
}
{
  "path": "observability/runtime_observer.py",
  "module": "observability.runtime_observer",
  "qualname": "TimelineRuntimeObserver.on_init_end",
  "name": "on_init_end",
  "node_type": "FunctionDef",
  "lineno": 84,
  "col": 4,
  "end_lineno": 113,
  "end_col": 13,
  "parent_qualname": "TimelineRuntimeObserver",
  "decorators": [],
  "bases": [],
  "docstring": "Record runtime initialization completion.",
  "is_public": true
}
{
  "path": "observability/runtime_observer.py",
  "module": "observability.runtime_observer",
  "qualname": "TimelineRuntimeObserver.on_close_end",
  "name": "on_close_end",
  "node_type": "FunctionDef",
  "lineno": 115,
  "col": 4,
  "end_lineno": 127,
  "end_col": 13,
  "parent_qualname": "TimelineRuntimeObserver",
  "decorators": [],
  "bases": [],
  "docstring": "Record runtime close completion.",
  "is_public": true
}
{
  "path": "observability/runtime_observer.py",
  "module": "observability.runtime_observer",
  "qualname": "TimelineRuntimeObserver.record_decision",
  "name": "record_decision",
  "node_type": "FunctionDef",
  "lineno": 129,
  "col": 4,
  "end_lineno": 143,
  "end_col": 79,
  "parent_qualname": "TimelineRuntimeObserver",
  "decorators": [],
  "bases": [],
  "docstring": "Emit a decision event for runtime degradations or fallbacks.",
  "is_public": true
}
{
  "path": "observability/semantic_conventions.py",
  "module": "observability.semantic_conventions",
  "qualname": "observability.semantic_conventions",
  "name": "observability.semantic_conventions",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Shared OpenTelemetry semantic convention helpers for CodeIntel.",
  "is_public": true
}
{
  "path": "observability/semantic_conventions.py",
  "module": "observability.semantic_conventions",
  "qualname": "Attrs",
  "name": "Attrs",
  "node_type": "ClassDef",
  "lineno": 10,
  "col": 0,
  "end_lineno": 107,
  "end_col": 46,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Trusted attribute keys used across spans, metrics, and logs.",
  "is_public": true
}
{
  "path": "observability/semantic_conventions.py",
  "module": "observability.semantic_conventions",
  "qualname": "as_kv",
  "name": "as_kv",
  "node_type": "FunctionDef",
  "lineno": 110,
  "col": 0,
  "end_lineno": 125,
  "end_col": 76,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return a dict filtered to values that are not ``None``.\n\nParameters\n----------\n**attrs : object\n    Arbitrary keyword arguments. Values that are ``None`` are excluded\n    from the returned dictionary.\n\nReturns\n-------\ndict[str, object]\n    Dictionary containing only non-None key-value pairs from the input\n    attributes.",
  "is_public": true
}
{
  "path": "observability/semantic_conventions.py",
  "module": "observability.semantic_conventions",
  "qualname": "to_label_str",
  "name": "to_label_str",
  "node_type": "FunctionDef",
  "lineno": 128,
  "col": 0,
  "end_lineno": 150,
  "end_col": 25,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return a deterministic string label for structured values.\n\nParameters\n----------\nvalue : object\n    Value to convert to a string label. Strings are returned as-is.\n    Other types are JSON-serialized (with sorted keys) or converted\n    to string representation if JSON serialization fails.\n\nReturns\n-------\nstr\n    String representation of the value. For strings, returns the value\n    unchanged. For other types, returns JSON-serialized form (with sorted\n    keys) or string representation if JSON serialization fails.",
  "is_public": true
}
{
  "path": "observability/timeline.py",
  "module": "observability.timeline",
  "qualname": "observability.timeline",
  "name": "observability.timeline",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Lightweight per-session timeline recording utilities.",
  "is_public": true
}
{
  "path": "observability/timeline.py",
  "module": "observability.timeline",
  "qualname": "_env_float",
  "name": "_env_float",
  "node_type": "FunctionDef",
  "lineno": 35,
  "col": 0,
  "end_lineno": 43,
  "end_col": 22,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "observability/timeline.py",
  "module": "observability.timeline",
  "qualname": "_env_int",
  "name": "_env_int",
  "node_type": "FunctionDef",
  "lineno": 46,
  "col": 0,
  "end_lineno": 54,
  "end_col": 22,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "observability/timeline.py",
  "module": "observability.timeline",
  "qualname": "_clamp",
  "name": "_clamp",
  "node_type": "FunctionDef",
  "lineno": 57,
  "col": 0,
  "end_lineno": 58,
  "end_col": 40,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "observability/timeline.py",
  "module": "observability.timeline",
  "qualname": "_diagnostics_dir",
  "name": "_diagnostics_dir",
  "node_type": "FunctionDef",
  "lineno": 65,
  "col": 0,
  "end_lineno": 68,
  "end_col": 15,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "observability/timeline.py",
  "module": "observability.timeline",
  "qualname": "_max_field_len",
  "name": "_max_field_len",
  "node_type": "FunctionDef",
  "lineno": 71,
  "col": 0,
  "end_lineno": 72,
  "end_col": 64,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "observability/timeline.py",
  "module": "observability.timeline",
  "qualname": "_FlightRecorder",
  "name": "_FlightRecorder",
  "node_type": "ClassDef",
  "lineno": 75,
  "col": 0,
  "end_lineno": 180,
  "end_col": 73,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Append-only JSONL recorder with sampling and rotation.",
  "is_public": false
}
{
  "path": "observability/timeline.py",
  "module": "observability.timeline",
  "qualname": "_FlightRecorder.should_sample",
  "name": "should_sample",
  "node_type": "FunctionDef",
  "lineno": 81,
  "col": 4,
  "end_lineno": 123,
  "end_col": 55,
  "parent_qualname": "_FlightRecorder",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": "Determine whether to sample this timeline based on sampling rate.\n\nExtended Summary\n----------------\nThis method implements probabilistic sampling for timeline events based on\nthe configured sampling rate (CODEINTEL_DIAG_SAMPLE environment variable).\nSampling reduces I/O overhead and storage costs while maintaining statistical\nrepresentativeness. The method uses cryptographically secure random number\ngeneration to ensure unbiased sampling decisions. Used by new_timeline() to\ndetermine if a timeline should record events.\n\nParameters\n----------\nforce : bool, optional\n    If True, forces sampling regardless of sampling rate (default: False).\n    Used for debugging and critical paths that must always be recorded.\n\nReturns\n-------\nbool\n    True if this timeline should be sampled (events will be recorded),\n    False if sampling should be skipped (events will be discarded). Returns\n    True if force=True, True if sampling rate >= 1.0, False if sampling\n    rate <= 0.0, otherwise probabilistic based on sampling rate.\n\nNotes\n-----\nTime complexity O(1) - single random number generation. Space complexity O(1).\nUses secrets.randbelow() for cryptographically secure random sampling. The\nsampling decision is deterministic per timeline instance (sampled status is\nset once during timeline creation). Sampling rate is clamped to [0.0, 1.0]\nat module load time.",
  "is_public": true
}
{
  "path": "observability/timeline.py",
  "module": "observability.timeline",
  "qualname": "_FlightRecorder._current_file",
  "name": "_current_file",
  "node_type": "FunctionDef",
  "lineno": 126,
  "col": 4,
  "end_lineno": 128,
  "end_col": 59,
  "parent_qualname": "_FlightRecorder",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "observability/timeline.py",
  "module": "observability.timeline",
  "qualname": "_FlightRecorder._rotate_if_needed",
  "name": "_rotate_if_needed",
  "node_type": "FunctionDef",
  "lineno": 131,
  "col": 4,
  "end_lineno": 140,
  "end_col": 82,
  "parent_qualname": "_FlightRecorder",
  "decorators": [
    "classmethod"
  ],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "observability/timeline.py",
  "module": "observability.timeline",
  "qualname": "_FlightRecorder.write",
  "name": "write",
  "node_type": "FunctionDef",
  "lineno": 143,
  "col": 4,
  "end_lineno": 180,
  "end_col": 73,
  "parent_qualname": "_FlightRecorder",
  "decorators": [
    "classmethod"
  ],
  "bases": [],
  "docstring": "Append a JSONL event record to the current timeline file.\n\nExtended Summary\n----------------\nThis method writes a timeline event to the append-only JSONL file for the\ncurrent date. It performs automatic file rotation when the file exceeds\nMAX_BYTES, ensuring files don't grow unbounded. The method is thread-safe\nusing a global lock to prevent concurrent write conflicts. Events are written\nas compact JSON (no whitespace) with UTF-8 encoding. Used by Timeline.event()\nto persist structured observability data.\n\nParameters\n----------\npayload : dict[str, Any]\n    Event payload dictionary containing timeline event data. Must be\n    JSON-serializable. Common fields include: ts (timestamp), type (event\n    type), name (event name), status, session_id, run_id, message, attrs.\n    The payload is scrubbed before serialization to prevent PII leakage.\n\nNotes\n-----\nTime complexity O(n) where n is payload size (JSON serialization + file I/O).\nSpace complexity O(n) for JSON string. Performs file I/O with thread-safe\nlocking. File rotation is atomic (rename operation). Errors are logged but\ndo not propagate (defensive design to prevent timeline failures from affecting\napplication). The method uses append mode to ensure events are never lost\ndue to concurrent writes.",
  "is_public": true
}
{
  "path": "observability/timeline.py",
  "module": "observability.timeline",
  "qualname": "_get_record_payload_fn",
  "name": "_get_record_payload_fn",
  "node_type": "FunctionDef",
  "lineno": 183,
  "col": 0,
  "end_lineno": 207,
  "end_col": 19,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return the cached reporter hook, importing lazily when required.\n\nReturns\n-------\nCallable[[dict[str, object]], None] | None\n    Callable bound to ``record_timeline_payload`` when available, otherwise\n    ``None`` when telemetry reporting is disabled or unavailable.",
  "is_public": false
}
{
  "path": "observability/timeline.py",
  "module": "observability.timeline",
  "qualname": "_scrub_value",
  "name": "_scrub_value",
  "node_type": "FunctionDef",
  "lineno": 210,
  "col": 0,
  "end_lineno": 228,
  "end_col": 17,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "observability/timeline.py",
  "module": "observability.timeline",
  "qualname": "_scrub_attrs",
  "name": "_scrub_attrs",
  "node_type": "FunctionDef",
  "lineno": 231,
  "col": 0,
  "end_lineno": 232,
  "end_col": 70,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "observability/timeline.py",
  "module": "observability.timeline",
  "qualname": "Timeline",
  "name": "Timeline",
  "node_type": "ClassDef",
  "lineno": 236,
  "col": 0,
  "end_lineno": 375,
  "end_col": 36,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=False)"
  ],
  "bases": [],
  "docstring": "Append-only JSONL event recorder for a single session/run pair.",
  "is_public": true
}
{
  "path": "observability/timeline.py",
  "module": "observability.timeline",
  "qualname": "Timeline.event",
  "name": "event",
  "node_type": "FunctionDef",
  "lineno": 245,
  "col": 4,
  "end_lineno": 286,
  "end_col": 66,
  "parent_qualname": "Timeline",
  "decorators": [],
  "bases": [],
  "docstring": "Record a structured event.",
  "is_public": true
}
{
  "path": "observability/timeline.py",
  "module": "observability.timeline",
  "qualname": "Timeline.operation",
  "name": "operation",
  "node_type": "FunctionDef",
  "lineno": 288,
  "col": 4,
  "end_lineno": 319,
  "end_col": 61,
  "parent_qualname": "Timeline",
  "decorators": [],
  "bases": [],
  "docstring": "Return a context manager that surrounds a root operation.\n\nExtended Summary\n----------------\nThis method creates a context manager for tracking root-level operations\n(e.g., \"search\", \"index\", \"publish\"). The context manager emits start/end\nevents with duration tracking and optional attributes. Used to instrument\nhigh-level operations in the application.\n\nParameters\n----------\nname : str\n    Operation name (e.g., \"search\", \"index.build\"). Used in event names\n    and telemetry.\n**attrs : object\n    Optional keyword arguments to include in operation events as attributes.\n    Common attributes include query parameters, result counts, error details.\n\nReturns\n-------\n_TimelineScope\n    Context manager that emits operation start/end events with duration\n    tracking. Events are only emitted if the timeline is sampled.\n\nNotes\n-----\nThis method creates a scoped context manager that tracks operation execution.\nEvents are emitted at context entry and exit with duration in milliseconds.\nTime complexity: O(1) for scope creation, O(1) for event emission.",
  "is_public": true
}
{
  "path": "observability/timeline.py",
  "module": "observability.timeline",
  "qualname": "Timeline.step",
  "name": "step",
  "node_type": "FunctionDef",
  "lineno": 321,
  "col": 4,
  "end_lineno": 353,
  "end_col": 56,
  "parent_qualname": "Timeline",
  "decorators": [],
  "bases": [],
  "docstring": "Return a context manager that surrounds an internal step.\n\nExtended Summary\n----------------\nThis method creates a context manager for tracking internal steps within\noperations (e.g., \"embed\", \"search\", \"hydrate\"). The context manager emits\nstart/end events with duration tracking and optional attributes. Used to\ninstrument sub-operations within larger workflows.\n\nParameters\n----------\nname : str\n    Step name (e.g., \"embed\", \"search.faiss\", \"hydrate.duckdb\"). Used in\n    event names and telemetry.\n**attrs : object\n    Optional keyword arguments to include in step events as attributes.\n    Common attributes include parameters, result counts, performance metrics.\n\nReturns\n-------\n_TimelineScope\n    Context manager emitting step start/end events with duration tracking.\n    Events are only emitted if the timeline is sampled.\n\nNotes\n-----\nThis method creates a scoped context manager that tracks step execution.\nEvents are emitted at context entry and exit with duration in milliseconds.\nSteps are nested within operations for hierarchical observability. Time\ncomplexity: O(1) for scope creation, O(1) for event emission.",
  "is_public": true
}
{
  "path": "observability/timeline.py",
  "module": "observability.timeline",
  "qualname": "Timeline.snapshot",
  "name": "snapshot",
  "node_type": "FunctionDef",
  "lineno": 355,
  "col": 4,
  "end_lineno": 366,
  "end_col": 33,
  "parent_qualname": "Timeline",
  "decorators": [],
  "bases": [],
  "docstring": "Return a shallow copy of the recorded events.\n\nReturns\n-------\nlist[dict[str, object]]\n    Shallow copy of the events list. Each event is a dictionary\n    containing event metadata (name, timestamp, attributes, etc.).\n    Modifications to the returned list do not affect the internal\n    event storage.",
  "is_public": true
}
{
  "path": "observability/timeline.py",
  "module": "observability.timeline",
  "qualname": "Timeline.metadata",
  "name": "metadata",
  "node_type": "FunctionDef",
  "lineno": 369,
  "col": 4,
  "end_lineno": 371,
  "end_col": 29,
  "parent_qualname": "Timeline",
  "decorators": [
    "property"
  ],
  "bases": [],
  "docstring": "Return mutable metadata dictionary associated with this timeline.",
  "is_public": true
}
{
  "path": "observability/timeline.py",
  "module": "observability.timeline",
  "qualname": "Timeline.set_metadata",
  "name": "set_metadata",
  "node_type": "FunctionDef",
  "lineno": 373,
  "col": 4,
  "end_lineno": 375,
  "end_col": 36,
  "parent_qualname": "Timeline",
  "decorators": [],
  "bases": [],
  "docstring": "Update timeline metadata in-place.",
  "is_public": true
}
{
  "path": "observability/timeline.py",
  "module": "observability.timeline",
  "qualname": "_TimelineScope",
  "name": "_TimelineScope",
  "node_type": "ClassDef",
  "lineno": 378,
  "col": 0,
  "end_lineno": 428,
  "end_col": 20,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Context manager that emits start/end events with duration.",
  "is_public": false
}
{
  "path": "observability/timeline.py",
  "module": "observability.timeline",
  "qualname": "_TimelineScope.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 383,
  "col": 4,
  "end_lineno": 393,
  "end_col": 9,
  "parent_qualname": "_TimelineScope",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "observability/timeline.py",
  "module": "observability.timeline",
  "qualname": "_TimelineScope.__enter__",
  "name": "__enter__",
  "node_type": "FunctionDef",
  "lineno": 395,
  "col": 4,
  "end_lineno": 404,
  "end_col": 19,
  "parent_qualname": "_TimelineScope",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "observability/timeline.py",
  "module": "observability.timeline",
  "qualname": "_TimelineScope.__exit__",
  "name": "__exit__",
  "node_type": "FunctionDef",
  "lineno": 406,
  "col": 4,
  "end_lineno": 428,
  "end_col": 20,
  "parent_qualname": "_TimelineScope",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "observability/timeline.py",
  "module": "observability.timeline",
  "qualname": "new_timeline",
  "name": "new_timeline",
  "node_type": "FunctionDef",
  "lineno": 431,
  "col": 0,
  "end_lineno": 473,
  "end_col": 80,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return a new timeline bound to ``session_id``.\n\nExtended Summary\n----------------\nThis function creates a new timeline instance for a session, generating a\nunique run identifier and determining sampling status. Timelines provide\nstructured event logging and observability for request processing. Used\nduring request initialization to create per-request observability context.\n\nParameters\n----------\nsession_id : str | None\n    Session identifier. If None, uses \"anonymous\" as the session identifier.\nrun_id : str | None, optional\n    Optional externally provided run identifier. When ``None`` or empty,\n    a new UUID4 hex string is generated.\nforce : bool, optional\n    If True, forces timeline sampling even if sampling rate would normally\n    skip this session (default: False). Used for debugging and critical paths.\n\nReturns\n-------\nTimeline\n    Timeline configured for the incoming session/run pair. The timeline has\n    a unique run_id and sampled status determined by the flight recorder.\n\nNotes\n-----\nThis function creates a new timeline with a unique run identifier. Sampling\nstatus is determined by the FlightRecorder based on sampling rate and force\nflag. Time complexity: O(1) for timeline creation.",
  "is_public": true
}
{
  "path": "observability/timeline.py",
  "module": "observability.timeline",
  "qualname": "current_timeline",
  "name": "current_timeline",
  "node_type": "FunctionDef",
  "lineno": 476,
  "col": 0,
  "end_lineno": 484,
  "end_col": 30,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return the timeline bound to the current context, if any.\n\nReturns\n-------\nTimeline | None\n    Active timeline for the current context, or ``None`` when unset.",
  "is_public": true
}
{
  "path": "observability/timeline.py",
  "module": "observability.timeline",
  "qualname": "current_or_new_timeline",
  "name": "current_or_new_timeline",
  "node_type": "FunctionDef",
  "lineno": 487,
  "col": 0,
  "end_lineno": 528,
  "end_col": 63,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return the active timeline or create a new one when missing.\n\nExtended Summary\n----------------\nThis function returns the currently active timeline from context, or creates\na new timeline if none exists. Used as a fallback when timeline access is\nneeded but context may not be initialized. Ensures observability is always\navailable even when middleware hasn't set up a timeline.\n\nParameters\n----------\nsession_id : str | None, optional\n    Session identifier to use if creating a new timeline. If None and a new\n    timeline is needed, uses \"anonymous\".\nrun_id : str | None, optional\n    Optional externally supplied run identifier passed to :func:`new_timeline`\n    when a new timeline must be created.\nforce : bool, optional\n    If True, forces timeline sampling when creating a new timeline (default: False).\n\nReturns\n-------\nTimeline\n    Timeline bound to the request (from context) or a freshly created fallback.\n    Always returns a valid timeline instance, never None.\n\nNotes\n-----\nThis function provides a safe way to access timelines when context may not be\ninitialized. It checks context variables first, then falls back to creating\na new timeline. Time complexity: O(1) for context lookup or timeline creation.",
  "is_public": true
}
{
  "path": "observability/timeline.py",
  "module": "observability.timeline",
  "qualname": "bind_timeline",
  "name": "bind_timeline",
  "node_type": "FunctionDef",
  "lineno": 532,
  "col": 0,
  "end_lineno": 564,
  "end_col": 34,
  "parent_qualname": null,
  "decorators": [
    "contextmanager"
  ],
  "bases": [],
  "docstring": "Bind ``timeline`` to the current async/task context.\n\nExtended Summary\n----------------\nThis context manager binds a timeline to the current context variable, making\nit available to `current_timeline()` calls within the context. Used to set\nup timeline context for async operations and background tasks. The timeline\nis automatically unbound when the context exits.\n\nParameters\n----------\ntimeline : Timeline | None\n    Timeline instance to bind to context. If None, unbinds any existing timeline\n    (useful for clearing context).\n\nYields\n------\nNone\n    Control back to the caller with the timeline bound to context. The timeline\n    is available via `current_timeline()` within this context.\n\nNotes\n-----\nThis context manager uses context variables to propagate timelines across async\nboundaries. The timeline is bound at context entry and unbound at exit. Time\ncomplexity: O(1) for context variable operations.",
  "is_public": true
}
{
  "path": "ops/__init__.py",
  "module": "ops",
  "qualname": "ops",
  "name": "ops",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Operations and maintenance scripts.",
  "is_public": true
}
{
  "path": "ops/runtime/__init__.py",
  "module": "ops.runtime",
  "qualname": "ops.runtime",
  "name": "ops.runtime",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Runtime health and validation utilities.",
  "is_public": true
}
{
  "path": "ops/runtime/xtr_open.py",
  "module": "ops.runtime.xtr_open",
  "qualname": "ops.runtime.xtr_open",
  "name": "ops.runtime.xtr_open",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Fail-fast probe for XTR artifacts.\n\nExample failure payload::\n\n    {\n        \"type\": \"https://kgfoundry.dev/problems/resource-unavailable\",\n        \"title\": \"XTR artifacts unavailable\",\n        \"status\": 503,\n        \"detail\": \"Index metadata missing.\",\n        \"runtime\": \"xtr\",\n        \"instance\": \"/ops/runtime/xtr-open\",\n    }",
  "is_public": true
}
{
  "path": "ops/runtime/xtr_open.py",
  "module": "ops.runtime.xtr_open",
  "qualname": "xtr_open",
  "name": "xtr_open",
  "node_type": "FunctionDef",
  "lineno": 53,
  "col": 0,
  "end_lineno": 162,
  "end_col": 66,
  "parent_qualname": null,
  "decorators": [
    "APP.command('xtr-open')"
  ],
  "bases": [],
  "docstring": "Validate that XTR artifacts are present and readable.\n\nExtended Summary\n----------------\nThis CLI command performs a fail-fast probe for XTR (eXtended Token Retrieval)\nartifacts. It validates that the XTR index directory exists, can be opened,\nand is ready for use. The command is used for health checks and deployment\nvalidation. On success, it prints a JSON payload with readiness status and\nmetadata (chunk count, token count, dimension, dtype). On failure, it exits\nwith a non-zero code and prints RFC 9457 Problem Details.\n\nParameters\n----------\nroot : _RootOption, optional\n    Override the configured XTR artifact directory. If None (default), uses\n    the directory resolved from application settings. Type alias for\n    ``Annotated[Path | None, typer.Option(...)]`` for CLI option specification.\n    Defaults to None.\nverbose : _VerboseOption, optional\n    Pretty-print success payloads with indentation. When False (default),\n    outputs compact JSON. Type alias for ``Annotated[bool, typer.Option(...)]``\n    for CLI option specification. Defaults to False.\n\nRaises\n------\ntyper.Exit\n    Raised by Typer to signal successful completion (code=0) or failure\n    (code=1). On failure, the exit includes RFC 9457 Problem Details\n    printed to stderr.\n\nNotes\n-----\nTime complexity O(1) for directory checks; O(I) for index opening where I\nis the cost of loading index metadata. The function performs filesystem I/O\nto validate paths and open the index. Thread-safe if called from a single\nprocess. The function is idempotent - multiple calls with the same inputs\nproduce the same results.\n\nExamples\n--------\n>>> # Validate default XTR directory\n>>> xtr_open(root=None, verbose=False)\n{\"ready\": true, \"limits\": [], \"metadata\": {...}}\n\n>>> # Validate custom directory with verbose output\n>>> xtr_open(root=Path(\"/custom/xtr\"), verbose=True)\n{\n  \"ready\": true,\n  \"limits\": [],\n  \"metadata\": {\n    \"root\": \"/custom/xtr\",\n    \"chunks\": 1000,\n    \"tokens\": 50000,\n    \"dim\": 768,\n    \"dtype\": \"float32\"\n  }\n}",
  "is_public": true
}
{
  "path": "ops/runtime/xtr_open.py",
  "module": "ops.runtime.xtr_open",
  "qualname": "_exit_with_problem",
  "name": "_exit_with_problem",
  "node_type": "FunctionDef",
  "lineno": 165,
  "col": 0,
  "end_lineno": 179,
  "end_col": 28,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "ops/runtime/xtr_open.py",
  "module": "ops.runtime.xtr_open",
  "qualname": "main",
  "name": "main",
  "node_type": "FunctionDef",
  "lineno": 182,
  "col": 0,
  "end_lineno": 184,
  "end_col": 9,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Execute the Typer CLI.",
  "is_public": true
}
{
  "path": "overlay_manager.py",
  "module": "overlay_manager",
  "qualname": "overlay_manager",
  "name": "overlay_manager",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Targeted overlay manager for opt-in stub generation.",
  "is_public": true
}
{
  "path": "overlay_manager.py",
  "module": "overlay_manager",
  "qualname": "OverlayPlan",
  "name": "OverlayPlan",
  "node_type": "ClassDef",
  "lineno": 14,
  "col": 0,
  "end_lineno": 18,
  "end_col": 38,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Plan describing overlays to generate.",
  "is_public": true
}
{
  "path": "overlay_manager.py",
  "module": "overlay_manager",
  "qualname": "select_overlay_candidates",
  "name": "select_overlay_candidates",
  "node_type": "FunctionDef",
  "lineno": 21,
  "col": 0,
  "end_lineno": 59,
  "end_col": 16,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return overlay candidates based on re-exports and typedness.\n\nParameters\n----------\nrows : Iterable[Mapping[str, object]]\n    Module metadata rows to evaluate for overlay generation.\nmax_candidates : int, optional\n    Maximum number of overlay plans to return (defaults to 50).\n\nReturns\n-------\nlist[OverlayPlan]\n    Overlay plans limited to ``max_candidates`` items.",
  "is_public": true
}
{
  "path": "overlay_manager.py",
  "module": "overlay_manager",
  "qualname": "generate_overlay_stub",
  "name": "generate_overlay_stub",
  "node_type": "FunctionDef",
  "lineno": 62,
  "col": 0,
  "end_lineno": 93,
  "end_col": 22,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Write a re-export-only stub for ``plan``.\n\nParameters\n----------\nplan : OverlayPlan\n    Overlay plan describing which exports to generate.\noverlays_root : Path\n    Root directory for generated overlay stubs.\n\nReturns\n-------\nPath\n    Path to the generated stub file.",
  "is_public": true
}
{
  "path": "overlay_manager.py",
  "module": "overlay_manager",
  "qualname": "activate_generated_overlays",
  "name": "activate_generated_overlays",
  "node_type": "FunctionDef",
  "lineno": 96,
  "col": 0,
  "end_lineno": 127,
  "end_col": 20,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Symlink generated overlays into the primary stub path.\n\nParameters\n----------\nplans : Iterable[OverlayPlan]\n    Overlay plans to activate by creating symlinks.\noverlays_root : Path\n    Root directory containing generated overlay stubs.\nstubs_root : Path\n    Target directory where symlinks will be created.\n\nReturns\n-------\nint\n    Number of overlays that were activated.",
  "is_public": true
}
{
  "path": "overlay_manager.py",
  "module": "overlay_manager",
  "qualname": "_safe_int",
  "name": "_safe_int",
  "node_type": "FunctionDef",
  "lineno": 130,
  "col": 0,
  "end_lineno": 154,
  "end_col": 12,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return a best-effort integer conversion.\n\nParameters\n----------\nvalue : object | None\n    Value to convert to integer. Supports int, float, str, bool, or None.\n\nReturns\n-------\nint\n    Normalized integer representation; 0 when conversion fails or value is None.",
  "is_public": false
}
{
  "path": "patches/Supporting Documentation/BM25+SPLADEv3-patchfiles/tools_recall_harness.py",
  "module": "patches.Supporting Documentation.BM25+SPLADEv3-patchfiles.tools_recall_harness",
  "qualname": "patches.Supporting Documentation.BM25+SPLADEv3-patchfiles.tools_recall_harness",
  "name": "patches.Supporting Documentation.BM25+SPLADEv3-patchfiles.tools_recall_harness",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "High-recall harness for BM25 + RM3 and (optionally) SPLADE.\n\nThis script evaluates Recall@K over a query set while sweeping BM25 (k1, b)\nand RM3 configurations. It also supports an *auto* mode that applies the same\nRM3 heuristics used in production to validate toggle decisions.\n\nUsage\n-----\npython tools/recall_harness.py +  --bm25-index ~/indexes/bm25 +  --queries data/queries.jsonl +  --qrels data/qrels.tsv +  --k 10 +  --sweep-k1 0.6,0.9,1.2 +  --sweep-b 0.2,0.4,0.75 +  --rm3 off,10-10-0.5,20-10-0.5 +  --auto-rm3 true +  --outdir runs/2025-11-11\n\nInput formats\n-------------\n* queries.jsonl: one JSON per line: {\"qid\": \"...\", \"text\": \"...\"}\n* qrels.tsv: TREC qrels TSV: qid <tab> docid <tab> rel (rel>0 = relevant)\n\nOutputs\n-------\n* summary.json        : per-configuration Recall@K, MRR@K (optional), decisions\n* decisions.csv       : per-query RM3 decisions in auto mode (enable/disable)\n* runs/*.tsv          : simple runs for debugging\n\nNotes\n-----\n* Requires Pyserini for BM25/RM3. SPLADE evaluation is optional (provide\n  --splade-index and --splade-encoder to enable; used for hybrid oracle).\n* Designed to be run in CI/nightly as a regression guard.",
  "is_public": true
}
{
  "path": "patches/Supporting Documentation/BM25+SPLADEv3-patchfiles/tools_recall_harness.py",
  "module": "patches.Supporting Documentation.BM25+SPLADEv3-patchfiles.tools_recall_harness",
  "qualname": "_read_jsonl",
  "name": "_read_jsonl",
  "node_type": "FunctionDef",
  "lineno": 41,
  "col": 0,
  "end_lineno": 49,
  "end_col": 14,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "patches/Supporting Documentation/BM25+SPLADEv3-patchfiles/tools_recall_harness.py",
  "module": "patches.Supporting Documentation.BM25+SPLADEv3-patchfiles.tools_recall_harness",
  "qualname": "_read_qrels",
  "name": "_read_qrels",
  "node_type": "FunctionDef",
  "lineno": 52,
  "col": 0,
  "end_lineno": 61,
  "end_col": 15,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "patches/Supporting Documentation/BM25+SPLADEv3-patchfiles/tools_recall_harness.py",
  "module": "patches.Supporting Documentation.BM25+SPLADEv3-patchfiles.tools_recall_harness",
  "qualname": "RM3Params",
  "name": "RM3Params",
  "node_type": "ClassDef",
  "lineno": 65,
  "col": 0,
  "end_lineno": 98,
  "end_col": 22,
  "parent_qualname": null,
  "decorators": [
    "dc.dataclass(frozen=True)"
  ],
  "bases": [],
  "docstring": "Parameters for RM3 (Relevance Model 3) query expansion.\n\nRM3 is a pseudo-relevance feedback technique that expands queries using\nterms from top-ranked documents. This dataclass encapsulates the three\nkey parameters that control RM3 behavior.\n\nAttributes\n----------\nfb_docs : int\n    Number of top-ranked documents to use for feedback. Higher values\n    include more documents but may introduce noise. Typical values range\n    from 5 to 20.\nfb_terms : int\n    Number of expansion terms to add to the original query. Higher values\n    add more terms but may dilute query intent. Typical values range from\n    10 to 50.\norig_weight : float\n    Weight given to the original query terms (0.0 to 1.0). Higher values\n    preserve more of the original query intent. Typical values range from\n    0.3 to 0.7. The expansion terms receive weight (1.0 - orig_weight).\n\nNotes\n-----\nRM3 is used to improve recall by expanding queries with relevant terms\nfrom top-ranked documents. The parameters control the trade-off between\nrecall improvement and query drift. Common configurations include\n\"10-10-0.5\" (10 docs, 10 terms, 0.5 weight) and \"20-10-0.5\" (20 docs,\n10 terms, 0.5 weight).",
  "is_public": true
}
{
  "path": "patches/Supporting Documentation/BM25+SPLADEv3-patchfiles/tools_recall_harness.py",
  "module": "patches.Supporting Documentation.BM25+SPLADEv3-patchfiles.tools_recall_harness",
  "qualname": "RM3Heuristics",
  "name": "RM3Heuristics",
  "node_type": "ClassDef",
  "lineno": 101,
  "col": 0,
  "end_lineno": 153,
  "end_col": 19,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Copy of the production heuristic (kept self-contained here).",
  "is_public": true
}
{
  "path": "patches/Supporting Documentation/BM25+SPLADEv3-patchfiles/tools_recall_harness.py",
  "module": "patches.Supporting Documentation.BM25+SPLADEv3-patchfiles.tools_recall_harness",
  "qualname": "RM3Heuristics.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 104,
  "col": 4,
  "end_lineno": 114,
  "end_col": 43,
  "parent_qualname": "RM3Heuristics",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "patches/Supporting Documentation/BM25+SPLADEv3-patchfiles/tools_recall_harness.py",
  "module": "patches.Supporting Documentation.BM25+SPLADEv3-patchfiles.tools_recall_harness",
  "qualname": "RM3Heuristics.should_enable",
  "name": "should_enable",
  "node_type": "FunctionDef",
  "lineno": 116,
  "col": 4,
  "end_lineno": 153,
  "end_col": 19,
  "parent_qualname": "RM3Heuristics",
  "decorators": [],
  "bases": [],
  "docstring": "Determine whether RM3 should be enabled for a given query.\n\nThis method implements production heuristics for deciding when RM3\nquery expansion is beneficial. RM3 is enabled for short queries\n(which benefit from expansion) but disabled for queries containing\nsymbol-like patterns (which are typically precise and don't benefit\nfrom expansion).\n\nParameters\n----------\nq : str\n    The query string to evaluate. The query is tokenized and analyzed\n    for length and symbol-like patterns.\n\nReturns\n-------\nbool\n    True if RM3 should be enabled for this query, False otherwise.\n    Returns True for short queries ( short_query_max_terms tokens)\n    and queries without symbol-like patterns. Returns False for queries\n    containing symbol-like patterns (e.g., \"Class::method\", \"file.path\",\n    \"CamelCase\", \"snake_case123\").\n\nNotes\n-----\nThe heuristic is based on the observation that short queries benefit\nfrom expansion (more recall), while symbol-like queries are typically\nprecise identifiers that don't benefit from expansion and may suffer\nfrom query drift. This matches the production heuristic used in the\nCodeIntel MCP server.",
  "is_public": true
}
{
  "path": "patches/Supporting Documentation/BM25+SPLADEv3-patchfiles/tools_recall_harness.py",
  "module": "patches.Supporting Documentation.BM25+SPLADEv3-patchfiles.tools_recall_harness",
  "qualname": "_lucene_searcher",
  "name": "_lucene_searcher",
  "node_type": "FunctionDef",
  "lineno": 156,
  "col": 0,
  "end_lineno": 165,
  "end_col": 12,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "patches/Supporting Documentation/BM25+SPLADEv3-patchfiles/tools_recall_harness.py",
  "module": "patches.Supporting Documentation.BM25+SPLADEv3-patchfiles.tools_recall_harness",
  "qualname": "_apply_rm3",
  "name": "_apply_rm3",
  "node_type": "FunctionDef",
  "lineno": 168,
  "col": 0,
  "end_lineno": 176,
  "end_col": 9,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "patches/Supporting Documentation/BM25+SPLADEv3-patchfiles/tools_recall_harness.py",
  "module": "patches.Supporting Documentation.BM25+SPLADEv3-patchfiles.tools_recall_harness",
  "qualname": "_recall_at_k",
  "name": "_recall_at_k",
  "node_type": "FunctionDef",
  "lineno": 179,
  "col": 0,
  "end_lineno": 187,
  "end_col": 38,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "patches/Supporting Documentation/BM25+SPLADEv3-patchfiles/tools_recall_harness.py",
  "module": "patches.Supporting Documentation.BM25+SPLADEv3-patchfiles.tools_recall_harness",
  "qualname": "_mrr_at_k",
  "name": "_mrr_at_k",
  "node_type": "FunctionDef",
  "lineno": 190,
  "col": 0,
  "end_lineno": 203,
  "end_col": 40,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "patches/Supporting Documentation/BM25+SPLADEv3-patchfiles/tools_recall_harness.py",
  "module": "patches.Supporting Documentation.BM25+SPLADEv3-patchfiles.tools_recall_harness",
  "qualname": "_parse_rm3_list",
  "name": "_parse_rm3_list",
  "node_type": "FunctionDef",
  "lineno": 206,
  "col": 0,
  "end_lineno": 215,
  "end_col": 14,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "patches/Supporting Documentation/BM25+SPLADEv3-patchfiles/tools_recall_harness.py",
  "module": "patches.Supporting Documentation.BM25+SPLADEv3-patchfiles.tools_recall_harness",
  "qualname": "_write_run",
  "name": "_write_run",
  "node_type": "FunctionDef",
  "lineno": 218,
  "col": 0,
  "end_lineno": 222,
  "end_col": 46,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "patches/Supporting Documentation/BM25+SPLADEv3-patchfiles/tools_recall_harness.py",
  "module": "patches.Supporting Documentation.BM25+SPLADEv3-patchfiles.tools_recall_harness",
  "qualname": "sweep",
  "name": "sweep",
  "node_type": "FunctionDef",
  "lineno": 225,
  "col": 0,
  "end_lineno": 359,
  "end_col": 18,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Sweep BM25 and RM3 configurations and evaluate Recall@K.\n\nThis function performs a grid search over BM25 parameters (k1, b) and RM3\nconfigurations, evaluating Recall@K and MRR@K for each combination. It supports\nboth fixed RM3 configurations and automatic per-query RM3 decisions based\non heuristics. Results are written to the output directory as JSON summaries\nand TSV run files.\n\nParameters\n----------\nindex_dir : Path\n    Path to the BM25 index directory. The index must be compatible with\n    Pyserini's LuceneSearcher format.\nqueries : list[dict]\n    List of query dictionaries, each containing \"qid\" and \"text\" keys.\n    Queries are evaluated against the index to compute recall metrics.\nqrels : dict[str, set[int]]\n    Ground truth relevance judgments. Keys are query IDs (qid), values are\n    sets of relevant document IDs. Used to compute Recall@K and MRR@K.\nk : int\n    The cutoff rank for Recall@K and MRR@K evaluation. Only the top K\n    results are considered when computing recall metrics.\nk1s : Iterable[float]\n    Iterable of BM25 k1 parameter values to sweep. k1 controls term\n    frequency saturation. Typical values range from 0.6 to 1.5.\nbs : Iterable[float]\n    Iterable of BM25 b parameter values to sweep. b controls length\n    normalization. Typical values range from 0.2 to 0.75.\nrm3s : Iterable[RM3Params | None]\n    Iterable of RM3 parameter configurations to sweep. None values\n    indicate RM3 is disabled. Each RM3Params instance specifies\n    fb_docs, fb_terms, and orig_weight.\nauto_rm3 : bool\n    If True, enables automatic per-query RM3 decisions using heuristics.\n    When enabled, RM3 is applied selectively based on query characteristics\n    (short queries get RM3, symbol-like queries don't). When False, uses\n    the fixed RM3 configurations from rm3s.\noutdir : Path\n    Output directory for results. The directory is created if it doesn't\n    exist. Results include summary.json (best and all configurations),\n    decisions.csv (per-query RM3 decisions when auto_rm3=True), and\n    run files (TSV format) for each configuration.\n\nReturns\n-------\ndict\n    Summary dictionary containing \"best\" (best configuration by Recall@K)\n    and \"all\" (all configurations sorted by Recall@K descending). Each\n    configuration entry includes \"tag\" (configuration metadata), \"recall_at_k\"\n    (Recall@K score), and \"mrr_at_k\" (MRR@K score).\n\nNotes\n-----\nThis function performs a full grid search over all combinations of k1, b,\nand RM3 configurations. For each combination, it runs all queries and\ncomputes recall metrics. When auto_rm3 is enabled, RM3 decisions are\nmade per-query using RM3Heuristics.should_enable(). Results are written\nto disk for analysis and debugging. The function is designed for batch\nevaluation and regression testing in CI/nightly jobs.",
  "is_public": true
}
{
  "path": "patches/Supporting Documentation/BM25+SPLADEv3-patchfiles/tools_recall_harness.py",
  "module": "patches.Supporting Documentation.BM25+SPLADEv3-patchfiles.tools_recall_harness",
  "qualname": "main",
  "name": "main",
  "node_type": "FunctionDef",
  "lineno": 362,
  "col": 0,
  "end_lineno": 422,
  "end_col": 48,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Main entry point for the recall harness script.\n\nThis function parses command-line arguments, loads queries and relevance\njudgments, parses parameter sweep specifications, and invokes the sweep\nfunction to evaluate BM25 and RM3 configurations. The best configuration\n(by Recall@K) is printed to stdout as JSON.\n\nParameters\n----------\nNone\n    All parameters are provided via command-line arguments:\n    --bm25-index: Path to BM25 index directory (required)\n    --queries: Path to queries JSONL file (required)\n    --qrels: Path to relevance judgments TSV file (required)\n    --k: Recall@K cutoff (default: 10)\n    --sweep-k1: Comma-separated k1 values (default: \"0.9,1.2\")\n    --sweep-b: Comma-separated b values (default: \"0.4,0.75\")\n    --rm3: Comma-separated RM3 specs, e.g., \"off,10-10-0.5\" (default: \"off,10-10-0.5\")\n    --auto-rm3: Enable automatic per-query RM3 (default: \"true\")\n    --outdir: Output directory for results (required)\n\nNotes\n-----\nThis script is designed to be run from the command line for batch\nevaluation and regression testing. It supports both fixed RM3 configurations\nand automatic per-query RM3 decisions. The output directory contains\nsummary.json (all configurations), decisions.csv (per-query RM3 decisions\nwhen auto_rm3 is enabled), and run files (TSV format) for each configuration.",
  "is_public": true
}
{
  "path": "plugins/__init__.py",
  "module": "plugins",
  "qualname": "plugins",
  "name": "plugins",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Plugin surfaces for pluggable retrieval channels.",
  "is_public": true
}
{
  "path": "plugins/builtins.py",
  "module": "plugins.builtins",
  "qualname": "plugins.builtins",
  "name": "plugins.builtins",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Built-in retrieval channel implementations (BM25, SPLADE).",
  "is_public": true
}
{
  "path": "plugins/builtins.py",
  "module": "plugins.builtins",
  "qualname": "bm25_factory",
  "name": "bm25_factory",
  "node_type": "FunctionDef",
  "lineno": 20,
  "col": 0,
  "end_lineno": 49,
  "end_col": 32,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return the built-in BM25 channel.\n\nExtended Summary\n----------------\nThis factory function creates a BM25 (Best Matching 25) retrieval channel\nusing the built-in BM25 index. BM25 is a sparse retrieval method that ranks\ndocuments based on term frequency and inverse document frequency. Used in\nhybrid search pipelines to provide keyword-based retrieval alongside dense\nvector search.\n\nParameters\n----------\ncontext : ChannelContext\n    Channel context providing BM25 index path and configuration. The context\n    must have a valid BM25 index directory.\n\nReturns\n-------\nChannel\n    Channel implementation wrapping the BM25 provider. The channel performs\n    BM25 retrieval and returns ranked document hits.\n\nNotes\n-----\nThis factory is registered as a built-in channel plugin. The BM25 channel\nrequires a BM25 index to be available in the context. Time complexity: O(n)\nfor BM25 search where n is the number of documents in the index.",
  "is_public": true
}
{
  "path": "plugins/builtins.py",
  "module": "plugins.builtins",
  "qualname": "splade_factory",
  "name": "splade_factory",
  "node_type": "FunctionDef",
  "lineno": 52,
  "col": 0,
  "end_lineno": 82,
  "end_col": 34,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return the built-in SPLADE impact channel.\n\nExtended Summary\n----------------\nThis factory function creates a SPLADE (Sparse Lexical and Expansion) retrieval\nchannel using the built-in SPLADE index. SPLADE is a learned sparse retrieval\nmethod that generates high-dimensional sparse vectors with learned term weights.\nUsed in hybrid search pipelines to provide learned sparse retrieval alongside\ndense vector search.\n\nParameters\n----------\ncontext : ChannelContext\n    Channel context providing SPLADE index path and configuration. The context\n    must have a valid SPLADE index directory.\n\nReturns\n-------\nChannel\n    Channel implementation wrapping the SPLADE provider. The channel performs\n    SPLADE retrieval and returns ranked document hits.\n\nNotes\n-----\nThis factory is registered as a built-in channel plugin. The SPLADE channel\nrequires a SPLADE index to be available in the context. SPLADE provides better\nsemantic matching than BM25 while maintaining sparse retrieval efficiency. Time\ncomplexity: O(n) for SPLADE search where n is the number of documents in the index.",
  "is_public": true
}
{
  "path": "plugins/builtins.py",
  "module": "plugins.builtins",
  "qualname": "_BM25Channel",
  "name": "_BM25Channel",
  "node_type": "ClassDef",
  "lineno": 85,
  "col": 0,
  "end_lineno": 211,
  "end_col": 27,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "Channel"
  ],
  "docstring": null,
  "is_public": false
}
{
  "path": "plugins/builtins.py",
  "module": "plugins.builtins",
  "qualname": "_BM25Channel.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 90,
  "col": 4,
  "end_lineno": 97,
  "end_col": 27,
  "parent_qualname": "_BM25Channel",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "plugins/builtins.py",
  "module": "plugins.builtins",
  "qualname": "_BM25Channel.search",
  "name": "search",
  "node_type": "FunctionDef",
  "lineno": 99,
  "col": 4,
  "end_lineno": 152,
  "end_col": 73,
  "parent_qualname": "_BM25Channel",
  "decorators": [],
  "bases": [],
  "docstring": "Perform BM25 search and return ranked document hits.\n\nExtended Summary\n----------------\nThis method executes BM25 (Best Matching 25) keyword-based search using the\nbuilt-in BM25 provider. It ensures the provider is initialized, performs the\nsearch operation, and returns ranked results. BM25 is a sparse retrieval\nmethod that ranks documents based on term frequency and inverse document\nfrequency, providing effective keyword matching for code search. Used in\nhybrid search pipelines to complement dense vector search with keyword\nsignals.\n\nParameters\n----------\nquery : str\n    Search query string. Will be tokenized and processed by the BM25 provider.\n    Supports natural language queries and code-like queries (identifiers,\n    keywords).\nlimit : int\n    Maximum number of results to return. Must be positive. Results are\n    ranked by BM25 score in descending order.\n\nReturns\n-------\nSequence[SearchHit]\n    Ranked sequence of channel hits containing document IDs and BM25 scores.\n    Results are sorted by score descending. Length is min(limit, total_documents).\n\nRaises\n------\nChannelError\n    If the BM25 provider is unavailable (disabled, initialization failed,\n    missing assets) or if search execution fails (provider errors, I/O errors).\n\nNotes\n-----\nTime complexity O(n * m) where n is query terms and m is documents matching\nquery terms. Space complexity O(k) where k is limit (result storage). Performs\nI/O to read BM25 index files. Thread-safe if provider is initialized (provider\ninitialization is protected by lock). The method lazily initializes the provider\non first search call. Returns empty sequence if limit <= 0.",
  "is_public": true
}
{
  "path": "plugins/builtins.py",
  "module": "plugins.builtins",
  "qualname": "_BM25Channel._ensure_provider",
  "name": "_ensure_provider",
  "node_type": "FunctionDef",
  "lineno": 154,
  "col": 4,
  "end_lineno": 211,
  "end_col": 27,
  "parent_qualname": "_BM25Channel",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "plugins/builtins.py",
  "module": "plugins.builtins",
  "qualname": "_SpladeChannel",
  "name": "_SpladeChannel",
  "node_type": "ClassDef",
  "lineno": 214,
  "col": 0,
  "end_lineno": 316,
  "end_col": 27,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "Channel"
  ],
  "docstring": null,
  "is_public": false
}
{
  "path": "plugins/builtins.py",
  "module": "plugins.builtins",
  "qualname": "_SpladeChannel.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 219,
  "col": 4,
  "end_lineno": 226,
  "end_col": 27,
  "parent_qualname": "_SpladeChannel",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "plugins/builtins.py",
  "module": "plugins.builtins",
  "qualname": "_SpladeChannel.search",
  "name": "search",
  "node_type": "FunctionDef",
  "lineno": 228,
  "col": 4,
  "end_lineno": 283,
  "end_col": 73,
  "parent_qualname": "_SpladeChannel",
  "decorators": [],
  "bases": [],
  "docstring": "Perform SPLADE search and return ranked document hits.\n\nExtended Summary\n----------------\nThis method executes SPLADE (Sparse Lexical and Expansion) learned sparse\nretrieval using the built-in SPLADE provider. It ensures the provider is\ninitialized, encodes the query into a high-dimensional sparse vector, performs\nsparse retrieval against the SPLADE index, and returns ranked results. SPLADE\nprovides better semantic matching than BM25 while maintaining sparse retrieval\nefficiency. Used in hybrid search pipelines to complement dense vector search\nwith learned sparse signals.\n\nParameters\n----------\nquery : str\n    Search query string. Will be tokenized, encoded into sparse vector, and\n    matched against the SPLADE index. Supports natural language queries with\n    semantic understanding.\nlimit : int\n    Maximum number of results to return. Must be positive. Results are\n    ranked by SPLADE score in descending order.\n\nReturns\n-------\nSequence[SearchHit]\n    Ranked sequence of channel hits containing document IDs and SPLADE scores.\n    Results are sorted by score descending. Length is min(limit, total_documents).\n\nRaises\n------\nChannelError\n    If the SPLADE provider is unavailable (disabled, initialization failed,\n    missing assets) or if search execution fails (provider errors, ONNX runtime\n    errors, I/O errors).\n\nNotes\n-----\nTime complexity O(n * m) where n is query tokens and m is documents in index.\nSpace complexity O(k) where k is limit (result storage). Performs I/O to read\nSPLADE index files and ONNX model inference for query encoding. Thread-safe if\nprovider is initialized (provider initialization is protected by lock). The method\nlazily initializes the provider on first search call. Returns empty sequence if\nlimit <= 0.",
  "is_public": true
}
{
  "path": "plugins/builtins.py",
  "module": "plugins.builtins",
  "qualname": "_SpladeChannel._ensure_provider",
  "name": "_ensure_provider",
  "node_type": "FunctionDef",
  "lineno": 285,
  "col": 4,
  "end_lineno": 316,
  "end_col": 27,
  "parent_qualname": "_SpladeChannel",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "plugins/builtins.py",
  "module": "plugins.builtins",
  "qualname": "_resolve_path",
  "name": "_resolve_path",
  "node_type": "FunctionDef",
  "lineno": 319,
  "col": 0,
  "end_lineno": 323,
  "end_col": 44,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "plugins/builtins.py",
  "module": "plugins.builtins",
  "qualname": "_classify_skip_reason",
  "name": "_classify_skip_reason",
  "node_type": "FunctionDef",
  "lineno": 326,
  "col": 0,
  "end_lineno": 332,
  "end_col": 27,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "plugins/channels.py",
  "module": "plugins.channels",
  "qualname": "plugins.channels",
  "name": "plugins.channels",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Channel plugin contracts for hybrid retrieval.",
  "is_public": true
}
{
  "path": "plugins/channels.py",
  "module": "plugins.channels",
  "qualname": "ChannelContext",
  "name": "ChannelContext",
  "node_type": "ClassDef",
  "lineno": 24,
  "col": 0,
  "end_lineno": 29,
  "end_col": 44,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Context passed to channel factories when they are constructed.",
  "is_public": true
}
{
  "path": "plugins/channels.py",
  "module": "plugins.channels",
  "qualname": "Channel",
  "name": "Channel",
  "node_type": "ClassDef",
  "lineno": 32,
  "col": 0,
  "end_lineno": 41,
  "end_col": 11,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "Protocol"
  ],
  "docstring": "Retrieval channel plugin interface.",
  "is_public": true
}
{
  "path": "plugins/channels.py",
  "module": "plugins.channels",
  "qualname": "Channel.search",
  "name": "search",
  "node_type": "FunctionDef",
  "lineno": 39,
  "col": 4,
  "end_lineno": 41,
  "end_col": 11,
  "parent_qualname": "Channel",
  "decorators": [],
  "bases": [],
  "docstring": "Return channel hits for ``query`` with per-channel cutoff ``limit``.",
  "is_public": true
}
{
  "path": "plugins/channels.py",
  "module": "plugins.channels",
  "qualname": "ChannelError",
  "name": "ChannelError",
  "node_type": "ClassDef",
  "lineno": 44,
  "col": 0,
  "end_lineno": 49,
  "end_col": 28,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "RuntimeError"
  ],
  "docstring": "Raised by channels when they cannot satisfy a search request.",
  "is_public": true
}
{
  "path": "plugins/channels.py",
  "module": "plugins.channels",
  "qualname": "ChannelError.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 47,
  "col": 4,
  "end_lineno": 49,
  "end_col": 28,
  "parent_qualname": "ChannelError",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "plugins/registry.py",
  "module": "plugins.registry",
  "qualname": "plugins.registry",
  "name": "plugins.registry",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Entry-point driven registry for retrieval channels.",
  "is_public": true
}
{
  "path": "plugins/registry.py",
  "module": "plugins.registry",
  "qualname": "ChannelRegistry",
  "name": "ChannelRegistry",
  "node_type": "ClassDef",
  "lineno": 19,
  "col": 0,
  "end_lineno": 110,
  "end_col": 36,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Registry that discovers channel plugins via Python entry points.",
  "is_public": true
}
{
  "path": "plugins/registry.py",
  "module": "plugins.registry",
  "qualname": "ChannelRegistry.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 22,
  "col": 4,
  "end_lineno": 23,
  "end_col": 39,
  "parent_qualname": "ChannelRegistry",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "plugins/registry.py",
  "module": "plugins.registry",
  "qualname": "ChannelRegistry.discover",
  "name": "discover",
  "node_type": "FunctionDef",
  "lineno": 26,
  "col": 4,
  "end_lineno": 69,
  "end_col": 30,
  "parent_qualname": "ChannelRegistry",
  "decorators": [
    "classmethod"
  ],
  "bases": [],
  "docstring": "Return a registry populated by entry-point factories.\n\nExtended Summary\n----------------\nThis class method discovers channel plugins via Python entry points and\ncreates a registry containing all successfully loaded channels. It iterates\nthrough entry points in the \"codeintel_rev.channels\" group, loads factory\nfunctions, instantiates channels, and collects them into a registry. Used\nduring application startup to auto-discover available retrieval channels.\n\nParameters\n----------\ncontext : ChannelContext\n    Channel context providing index paths and configuration. Passed to\n    each factory function during channel instantiation.\n\nReturns\n-------\nChannelRegistry\n    Registry containing every channel whose factory loaded successfully.\n    Channels that fail to load are logged and skipped.\n\nNotes\n-----\nThis method performs dynamic plugin discovery via entry points. Factory\nfailures are logged but don't stop discovery. Time complexity: O(n) where\nn is the number of entry points in the channel group.",
  "is_public": true
}
{
  "path": "plugins/registry.py",
  "module": "plugins.registry",
  "qualname": "ChannelRegistry.from_channels",
  "name": "from_channels",
  "node_type": "FunctionDef",
  "lineno": 72,
  "col": 4,
  "end_lineno": 100,
  "end_col": 34,
  "parent_qualname": "ChannelRegistry",
  "decorators": [
    "classmethod"
  ],
  "bases": [],
  "docstring": "Construct a registry from an explicit channel list.\n\nExtended Summary\n----------------\nThis class method creates a registry from an explicitly provided sequence\nof channels. Used for testing and when programmatic channel configuration\nis preferred over entry point discovery. The channels are stored in the\norder provided.\n\nParameters\n----------\nchannels : Sequence[Channel]\n    Explicit sequence of channel instances to include in the registry.\n    Channels are stored in the order provided.\n\nReturns\n-------\nChannelRegistry\n    Registry containing the provided channel sequence. The registry\n    provides access to channels via the `channels()` method.\n\nNotes\n-----\nThis method creates a registry without entry point discovery. Useful for\ntesting and programmatic configuration. Time complexity: O(n) where n is\nthe number of channels.",
  "is_public": true
}
{
  "path": "plugins/registry.py",
  "module": "plugins.registry",
  "qualname": "ChannelRegistry.channels",
  "name": "channels",
  "node_type": "FunctionDef",
  "lineno": 102,
  "col": 4,
  "end_lineno": 110,
  "end_col": 36,
  "parent_qualname": "ChannelRegistry",
  "decorators": [],
  "bases": [],
  "docstring": "Return the known channels.\n\nReturns\n-------\ntuple[Channel, ...]\n    Tuple of registered channel instances.",
  "is_public": true
}
{
  "path": "plugins/registry.py",
  "module": "plugins.registry",
  "qualname": "_iter_entry_points",
  "name": "_iter_entry_points",
  "node_type": "FunctionDef",
  "lineno": 113,
  "col": 0,
  "end_lineno": 137,
  "end_col": 25,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return entry points for the channel group across Python versions.\n\nReturns\n-------\nIterable[EntryPoint]\n    Iterable of entry point definitions for channel plugins.",
  "is_public": false
}
{
  "path": "plugins/registry.py",
  "module": "plugins.registry",
  "qualname": "_load_factory",
  "name": "_load_factory",
  "node_type": "FunctionDef",
  "lineno": 140,
  "col": 0,
  "end_lineno": 177,
  "end_col": 18,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return a callable factory if the entry point loads successfully.\n\nExtended Summary\n----------------\nThis helper loads a channel factory function from a Python entry point. It\nattempts to load the entry point's target (module:function), validates that\nit's callable, and returns it. Used during channel discovery to load factory\nfunctions from plugin entry points.\n\nParameters\n----------\nentry_point : EntryPoint\n    Python entry point definition pointing to a channel factory function.\n    The entry point target should be a callable that accepts ChannelContext\n    and returns a Channel instance.\n\nReturns\n-------\nCallable[[ChannelContext], Channel] | None\n    Factory function if loading succeeds, None if loading fails (module not\n    found, function not found, not callable, etc.). Failures are logged.\n\nNotes\n-----\nThis helper defensively handles entry point loading failures. Import errors\nand validation failures are caught and logged, allowing discovery to continue\nwith other entry points. Time complexity: O(1) for entry point loading.",
  "is_public": false
}
{
  "path": "polars_support.py",
  "module": "polars_support",
  "qualname": "polars_support",
  "name": "polars_support",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Helpers for optional polars exports.",
  "is_public": true
}
{
  "path": "polars_support.py",
  "module": "polars_support",
  "qualname": "resolve_polars_frame_factory",
  "name": "resolve_polars_frame_factory",
  "node_type": "FunctionDef",
  "lineno": 15,
  "col": 0,
  "end_lineno": 47,
  "end_col": 15,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return a DataFrame factory that works across polars versions.\n\nThis function attempts to resolve a DataFrame factory function that works\nacross different polars versions. It first checks for the legacy ``data_frame``\nhelper (available in older polars releases), then falls back to the canonical\n``DataFrame`` constructor (available in newer versions). Returns None if neither\nis available, allowing callers to select alternative serialization strategies.\n\nParameters\n----------\npolars : PolarsModule\n    Polars module object (typically from lazy import or gate_import). Used to\n    access polars API methods (data_frame, DataFrame). The module must expose\n    at least one of these methods for the function to return a factory.\n\nReturns\n-------\nPolarsFrameFactory | None\n    Callable DataFrame constructor when available (either legacy data_frame\n    helper or canonical DataFrame constructor), otherwise None. When None, callers\n    should use alternative serialization strategies (e.g., manual DataFrame\n    construction or different serialization formats).",
  "is_public": true
}
{
  "path": "rerank/__init__.py",
  "module": "rerank",
  "qualname": "rerank",
  "name": "rerank",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Late-interaction reranker interfaces.",
  "is_public": true
}
{
  "path": "rerank/base.py",
  "module": "rerank.base",
  "qualname": "rerank.base",
  "name": "rerank.base",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Shared reranker interfaces and request/response types.",
  "is_public": true
}
{
  "path": "rerank/base.py",
  "module": "rerank.base",
  "qualname": "ScoredDoc",
  "name": "ScoredDoc",
  "node_type": "ClassDef",
  "lineno": 13,
  "col": 0,
  "end_lineno": 17,
  "end_col": 16,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Document identifier + score pair.",
  "is_public": true
}
{
  "path": "rerank/base.py",
  "module": "rerank.base",
  "qualname": "RerankResult",
  "name": "RerankResult",
  "node_type": "ClassDef",
  "lineno": 21,
  "col": 0,
  "end_lineno": 25,
  "end_col": 16,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Result emitted by rerankers.",
  "is_public": true
}
{
  "path": "rerank/base.py",
  "module": "rerank.base",
  "qualname": "RerankRequest",
  "name": "RerankRequest",
  "node_type": "ClassDef",
  "lineno": 29,
  "col": 0,
  "end_lineno": 35,
  "end_col": 25,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Structured rerank invocation.",
  "is_public": true
}
{
  "path": "rerank/base.py",
  "module": "rerank.base",
  "qualname": "Reranker",
  "name": "Reranker",
  "node_type": "ClassDef",
  "lineno": 38,
  "col": 0,
  "end_lineno": 46,
  "end_col": 11,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "Protocol"
  ],
  "docstring": "Protocol implemented by pluggable rerankers.",
  "is_public": true
}
{
  "path": "rerank/base.py",
  "module": "rerank.base",
  "qualname": "Reranker.rescore",
  "name": "rescore",
  "node_type": "FunctionDef",
  "lineno": 44,
  "col": 4,
  "end_lineno": 46,
  "end_col": 11,
  "parent_qualname": "Reranker",
  "decorators": [],
  "bases": [],
  "docstring": "Return rescored documents ordered by relevance.",
  "is_public": true
}
{
  "path": "rerank/xtr.py",
  "module": "rerank.xtr",
  "qualname": "rerank.xtr",
  "name": "rerank.xtr",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "XTR-backed reranker implementation.",
  "is_public": true
}
{
  "path": "rerank/xtr.py",
  "module": "rerank.xtr",
  "qualname": "XTRReranker",
  "name": "XTRReranker",
  "node_type": "ClassDef",
  "lineno": 13,
  "col": 0,
  "end_lineno": 73,
  "end_col": 9,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "Reranker"
  ],
  "docstring": "Rerank hits using the XTR MaxSim scorer.",
  "is_public": true
}
{
  "path": "rerank/xtr.py",
  "module": "rerank.xtr",
  "qualname": "XTRReranker.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 19,
  "col": 4,
  "end_lineno": 20,
  "end_col": 27,
  "parent_qualname": "XTRReranker",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "rerank/xtr.py",
  "module": "rerank.xtr",
  "qualname": "XTRReranker.rescore",
  "name": "rescore",
  "node_type": "FunctionDef",
  "lineno": 22,
  "col": 4,
  "end_lineno": 73,
  "end_col": 9,
  "parent_qualname": "XTRReranker",
  "decorators": [],
  "bases": [],
  "docstring": "Return docs rescored by XTR MaxSim.\n\nExtended Summary\n----------------\nThis method rescores documents using XTR (Cross-Transformer Reranking) MaxSim\nalgorithm. It takes candidate documents from the request, queries the XTR\nindex for similarity scores, and returns documents sorted by reranker scores.\nIf the XTR index is unavailable or the request is empty, returns documents\nwith original scores. Used in semantic search pipelines to improve ranking\nquality through learned reranking.\n\nParameters\n----------\nrequest : RerankRequest\n    Reranking request containing query text, candidate documents, top_k limit,\n    and explain flag. Documents are rescored using XTR MaxSim similarity.\n\nReturns\n-------\nSequence[RerankResult]\n    Documents ordered by reranker scores (highest first). Each result contains\n    doc_id and score. If XTR index is unavailable, returns documents with\n    original scores.\n\nNotes\n-----\nThis method performs XTR reranking by querying the XTR index for similarity\nscores between the query and candidate documents. Results are sorted by score\nin descending order. Time complexity: O(k * rerank_time) where k is top_k and\nrerank_time depends on XTR index size.",
  "is_public": true
}
{
  "path": "retrieval/__init__.py",
  "module": "retrieval",
  "qualname": "retrieval",
  "name": "retrieval",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Hybrid retrieval algorithms for the CodeIntel MCP stack.",
  "is_public": true
}
{
  "path": "retrieval/boosters.py",
  "module": "retrieval.boosters",
  "qualname": "retrieval.boosters",
  "name": "retrieval.boosters",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Score boosters applied after fusion.",
  "is_public": true
}
{
  "path": "retrieval/boosters.py",
  "module": "retrieval.boosters",
  "qualname": "RecencyConfig",
  "name": "RecencyConfig",
  "node_type": "ClassDef",
  "lineno": 39,
  "col": 0,
  "end_lineno": 47,
  "end_col": 39,
  "parent_qualname": null,
  "decorators": [
    "dataclass(frozen=True)"
  ],
  "bases": [],
  "docstring": "Configuration parameters controlling recency boosts.",
  "is_public": true
}
{
  "path": "retrieval/boosters.py",
  "module": "retrieval.boosters",
  "qualname": "_now",
  "name": "_now",
  "node_type": "FunctionDef",
  "lineno": 50,
  "col": 0,
  "end_lineno": 51,
  "end_col": 22,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "retrieval/boosters.py",
  "module": "retrieval.boosters",
  "qualname": "_exp_decay",
  "name": "_exp_decay",
  "node_type": "FunctionDef",
  "lineno": 54,
  "col": 0,
  "end_lineno": 57,
  "end_col": 45,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "retrieval/boosters.py",
  "module": "retrieval.boosters",
  "qualname": "_safe_identifier",
  "name": "_safe_identifier",
  "node_type": "FunctionDef",
  "lineno": 60,
  "col": 0,
  "end_lineno": 64,
  "end_col": 16,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "retrieval/boosters.py",
  "module": "retrieval.boosters",
  "qualname": "_normalize_ids",
  "name": "_normalize_ids",
  "node_type": "FunctionDef",
  "lineno": 67,
  "col": 0,
  "end_lineno": 74,
  "end_col": 21,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "retrieval/boosters.py",
  "module": "retrieval.boosters",
  "qualname": "_create_recency_view",
  "name": "_create_recency_view",
  "node_type": "FunctionDef",
  "lineno": 77,
  "col": 0,
  "end_lineno": 86,
  "end_col": 56,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "retrieval/boosters.py",
  "module": "retrieval.boosters",
  "qualname": "_populate_id_table",
  "name": "_populate_id_table",
  "node_type": "FunctionDef",
  "lineno": 89,
  "col": 0,
  "end_lineno": 91,
  "end_col": 97,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "retrieval/boosters.py",
  "module": "retrieval.boosters",
  "qualname": "_fetch_commit_ts_duckdb",
  "name": "_fetch_commit_ts_duckdb",
  "node_type": "FunctionDef",
  "lineno": 94,
  "col": 0,
  "end_lineno": 138,
  "end_col": 17,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "retrieval/boosters.py",
  "module": "retrieval.boosters",
  "qualname": "apply_recency_boost",
  "name": "apply_recency_boost",
  "node_type": "FunctionDef",
  "lineno": 141,
  "col": 0,
  "end_lineno": 203,
  "end_col": 31,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return a new doc list with an exponential recency boost applied.\n\nParameters\n----------\ndocs : list[HybridResultDoc]\n    Ranked documents to boost.\ncfg : RecencyConfig\n    Recency boosting configuration.\nduckdb_manager : DuckDBManagerType | None, optional\n    DuckDB manager used to look up commit timestamps when ``commit_ts_lookup``\n    is not provided. Must be an instance of ``DuckDBManager`` when DuckDB\n    is available, or None when DuckDB is not installed.\ncommit_ts_lookup : Callable[[Iterable[str]], Mapping[str, float]] | None, optional\n    Custom lookup function that maps chunk IDs to commit timestamps.\n\nReturns\n-------\ntuple[list[HybridResultDoc], int]\n    Boosted documents (preserving order) and the number of documents whose\n    scores changed due to the recency multiplier.",
  "is_public": true
}
{
  "path": "retrieval/boosters.py",
  "module": "retrieval.boosters",
  "qualname": "apply_recency_boost._lookup",
  "name": "_lookup",
  "node_type": "FunctionDef",
  "lineno": 178,
  "col": 8,
  "end_lineno": 179,
  "end_col": 70,
  "parent_qualname": "apply_recency_boost",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "retrieval/fusion/__init__.py",
  "module": "retrieval.fusion",
  "qualname": "retrieval.fusion",
  "name": "retrieval.fusion",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Fusion helpers for multi-channel retrieval.",
  "is_public": true
}
{
  "path": "retrieval/fusion/weighted_rrf.py",
  "module": "retrieval.fusion.weighted_rrf",
  "qualname": "retrieval.fusion.weighted_rrf",
  "name": "retrieval.fusion.weighted_rrf",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Weighted reciprocal rank fusion utilities.",
  "is_public": true
}
{
  "path": "retrieval/fusion/weighted_rrf.py",
  "module": "retrieval.fusion.weighted_rrf",
  "qualname": "fuse_weighted_rrf",
  "name": "fuse_weighted_rrf",
  "node_type": "FunctionDef",
  "lineno": 10,
  "col": 0,
  "end_lineno": 87,
  "end_col": 25,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Apply weighted RRF across runs and return fused docs plus contributions.\n\nExtended Summary\n----------------\nThis function performs weighted Reciprocal Rank Fusion (RRF) across multiple\nretrieval channels, combining ranked lists with channel-specific weights. It computes\nfused scores using the RRF formula (weight * 1/(k + rank)) and tracks contribution\nmetadata showing which channels contributed to each document's final score. This is\nused in hybrid search pipelines to combine results from different retrieval methods\n(e.g., dense vectors, sparse BM25, semantic search) into a single ranked list.\n\nParameters\n----------\nruns : Mapping[str, Sequence[SearchHit]]\n    Dictionary mapping channel names to their ranked hit lists. Each channel\n    provides a sequence of SearchHit objects with doc_id, rank, and score.\n    Empty sequences are skipped.\nweights : Mapping[str, float]\n    Dictionary mapping channel names to their fusion weights. Channels not\n    present in weights default to weight 1.0. Channels with weight 0.0 are\n    excluded from fusion.\nk : int\n    RRF constant used in the formula 1/(k + rank). Larger k values reduce the\n    impact of rank differences. Typical values range from 20 to 100.\nlimit : int\n    Maximum number of fused documents to return. Must be positive. Results are\n    sorted by fused score in descending order and truncated to this limit.\n\nReturns\n-------\ntuple[list[HybridResultDoc], dict[str, list[tuple[str, int, float]]]]\n    Two-element tuple containing:\n    - List of HybridResultDoc objects with fused scores, sorted descending\n    - Dictionary mapping doc_id to list of (channel, rank, score) contributions\n\nRaises\n------\nValueError\n    If limit is not positive. This ensures the function returns at least one\n    result when limit > 0.\n\nNotes\n-----\nTime complexity O(C * N) where C is channel count and N is average hits per channel.\nSpace complexity O(N) for fused scores and contributions. The function performs\nno I/O and has no side effects. Thread-safe as it operates on input data only.\nRRF formula: fused_score = sum(weight[channel] * 1/(k + rank[channel])) for all channels.",
  "is_public": true
}
{
  "path": "retrieval/gating.py",
  "module": "retrieval.gating",
  "qualname": "retrieval.gating",
  "name": "retrieval.gating",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Adaptive gating helpers for multi-stage retrieval pipelines.",
  "is_public": true
}
{
  "path": "retrieval/gating.py",
  "module": "retrieval.gating",
  "qualname": "StageGateConfig",
  "name": "StageGateConfig",
  "node_type": "ClassDef",
  "lineno": 23,
  "col": 0,
  "end_lineno": 54,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Configuration inputs for deciding whether to invoke a follow-up stage.",
  "is_public": true
}
{
  "path": "retrieval/gating.py",
  "module": "retrieval.gating",
  "qualname": "should_run_secondary_stage",
  "name": "should_run_secondary_stage",
  "node_type": "FunctionDef",
  "lineno": 72,
  "col": 0,
  "end_lineno": 156,
  "end_col": 92,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return a gating decision for a downstream stage based on upstream signals.\n\nExtended Summary\n----------------\nThis function implements adaptive gating logic for multi-stage retrieval pipelines,\ndeciding whether to run expensive secondary stages (e.g., reranking, late interaction)\nbased on upstream performance signals. It evaluates candidate count, elapsed time budget,\nand score margin to determine if the secondary stage would provide sufficient value.\nThis prevents unnecessary computation when upstream results are already high-quality or\nwhen time budgets are exceeded, improving overall pipeline efficiency.\n\nParameters\n----------\nsignals : StageSignals\n    Performance signals from the upstream stage, including candidate count, elapsed\n    time, and score distribution. Used to assess whether secondary stage is warranted.\nconfig : StageGateConfig\n    Gating configuration specifying thresholds for candidate count, margin, and time\n    budget. Defines the decision criteria for running the secondary stage.\n\nReturns\n-------\nStageDecision\n    Decision object describing whether the stage should run and why. Contains\n    should_run boolean, reason string, and optional notes explaining the decision.\n    Reasons include: \"no_candidates\", \"insufficient_candidates\", \"upstream_budget_exceeded\",\n    \"high_margin\", \"within_budget\".\n\nNotes\n-----\nTime complexity O(1) for decision logic. Space complexity O(1) aside from the\nStageDecision object. The function performs no I/O and has no side effects.\nThread-safe as it operates on input data only. Decision logic prioritizes:\n1. Candidate availability (must have candidates)\n2. Time budget (must not exceed budget)\n3. Score margin (high margin suggests good results already)",
  "is_public": true
}
{
  "path": "retrieval/gating.py",
  "module": "retrieval.gating",
  "qualname": "should_run_secondary_stage._emit",
  "name": "_emit",
  "node_type": "FunctionDef",
  "lineno": 117,
  "col": 4,
  "end_lineno": 136,
  "end_col": 23,
  "parent_qualname": "should_run_secondary_stage",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "retrieval/gating.py",
  "module": "retrieval.gating",
  "qualname": "QueryProfile",
  "name": "QueryProfile",
  "node_type": "ClassDef",
  "lineno": 160,
  "col": 0,
  "end_lineno": 208,
  "end_col": 26,
  "parent_qualname": null,
  "decorators": [
    "dataclass(frozen=True)"
  ],
  "bases": [],
  "docstring": "Query characteristics profile for adaptive retrieval gating.\n\nExtended Summary\n----------------\nEncapsulates computed features of a search query used to make adaptive\ndecisions about retrieval budgets and RM3 expansion. Features include\ntoken statistics, code-like patterns, and ambiguity indicators that help\ndetermine whether a query is literal (code-focused), vague (natural language),\nor ambiguous (unclear intent).\n\nAttributes\n----------\nlength : int\n    Number of tokens in the query after tokenization.\nunique_ratio : float\n    Ratio of unique tokens to total tokens (0.0 to 1.0). Higher values\n    indicate more diverse vocabulary.\ncode_token_ratio : float\n    Ratio of tokens matching code-like patterns (0.0 to 1.0). Higher values\n    suggest code-focused queries.\ndigit_ratio : float\n    Ratio of tokens containing digits (0.0 to 1.0). Higher values suggest\n    numeric identifiers or literals.\nsymbol_ratio : float\n    Ratio of non-alphanumeric symbols in the query string (0.0 to 1.0).\n    Higher values suggest code syntax or special characters.\noov_ratio : float\n    Out-of-vocabulary ratio (1.0 - code_token_ratio). Higher values suggest\n    natural language terms.\nlooks_literal : bool\n    True if query appears code-focused (high code_token_ratio, digit_ratio,\n    or symbol_ratio).\nlooks_vague : bool\n    True if query appears vague or natural language (short, low code_token_ratio).\nambiguity_score : float\n    Ambiguity score (0.0 to 1.0). Higher values indicate unclear query intent.\n    Computed from length, code_token_ratio, and oov_ratio.",
  "is_public": true
}
{
  "path": "retrieval/gating.py",
  "module": "retrieval.gating",
  "qualname": "BudgetDecision",
  "name": "BudgetDecision",
  "node_type": "ClassDef",
  "lineno": 212,
  "col": 0,
  "end_lineno": 239,
  "end_col": 21,
  "parent_qualname": null,
  "decorators": [
    "dataclass(frozen=True)"
  ],
  "bases": [],
  "docstring": "Retrieval budget decision for multi-stage search pipelines.\n\nExtended Summary\n----------------\nEncapsulates adaptive budget decisions for hybrid retrieval pipelines.\nDetermines how many results to fetch from each retrieval channel (semantic,\nBM25, SPLADE) and whether to enable RM3 query expansion. Decisions are\nbased on query profile characteristics to optimize recall and latency.\n\nAttributes\n----------\nper_channel_depths : dict[str, int]\n    Dictionary mapping channel names (\"semantic\", \"bm25\", \"splade\") to\n    result depths (number of results to fetch). Higher depths improve recall\n    but increase latency.\nrrf_k : int\n    Reciprocal Rank Fusion (RRF) parameter controlling how many results to\n    combine from all channels. Higher values improve recall but increase\n    computation.\nrm3_enabled : bool\n    Whether RM3 query expansion is enabled for this query. RM3 improves\n    recall for ambiguous queries but adds latency.",
  "is_public": true
}
{
  "path": "retrieval/gating.py",
  "module": "retrieval.gating",
  "qualname": "_tokenize",
  "name": "_tokenize",
  "node_type": "FunctionDef",
  "lineno": 246,
  "col": 0,
  "end_lineno": 247,
  "end_col": 72,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "retrieval/gating.py",
  "module": "retrieval.gating",
  "qualname": "_code_like_count",
  "name": "_code_like_count",
  "node_type": "FunctionDef",
  "lineno": 250,
  "col": 0,
  "end_lineno": 256,
  "end_col": 16,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "retrieval/gating.py",
  "module": "retrieval.gating",
  "qualname": "analyze_query",
  "name": "analyze_query",
  "node_type": "FunctionDef",
  "lineno": 259,
  "col": 0,
  "end_lineno": 328,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Analyze query characteristics to build a query profile.\n\nExtended Summary\n----------------\nTokenizes the query and computes statistical features (token counts, ratios,\npattern matches) to determine query characteristics. Classifies queries as\nliteral (code-focused), vague (natural language), or ambiguous based on\nheuristics. The profile is used to make adaptive retrieval budget decisions.\n\nParameters\n----------\nquery : str\n    Search query string to analyze.\ncfg : StageGateConfig\n    Configuration containing code token patterns and thresholds for\n    classification.\n\nReturns\n-------\nQueryProfile\n    Query profile with computed features (length, ratios, flags, ambiguity\n    score) used for adaptive gating decisions.\n\nNotes\n-----\nTime O(n) where n is query length. Tokenization uses whitespace splitting.\nCode token matching uses regex patterns. Classification heuristics are\ndeterministic and fast.",
  "is_public": true
}
{
  "path": "retrieval/gating.py",
  "module": "retrieval.gating",
  "qualname": "decide_budgets",
  "name": "decide_budgets",
  "node_type": "FunctionDef",
  "lineno": 331,
  "col": 0,
  "end_lineno": 406,
  "end_col": 19,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Decide retrieval budgets based on query profile.\n\nExtended Summary\n----------------\nDetermines adaptive retrieval budgets (channel depths, RRF k, RM3 enablement)\nbased on query profile characteristics. Uses different budget presets for\nliteral queries (code-focused), vague queries (natural language), and default\nqueries. RM3 expansion is enabled for queries within length bounds and\nambiguity thresholds.\n\nParameters\n----------\nprofile : QueryProfile\n    Query profile with computed characteristics (length, ratios, flags).\ncfg : StageGateConfig\n    Configuration containing budget presets and RM3 thresholds.\n\nReturns\n-------\nBudgetDecision\n    Budget decision with per-channel depths, RRF k parameter, and RM3\n    enablement flag. Returns default budgets if query-aware budgets are\n    disabled in config.",
  "is_public": true
}
{
  "path": "retrieval/gating.py",
  "module": "retrieval.gating",
  "qualname": "describe_budget_decision",
  "name": "describe_budget_decision",
  "node_type": "FunctionDef",
  "lineno": 409,
  "col": 0,
  "end_lineno": 445,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Serialize query profile and budget decision to a dictionary.\n\nExtended Summary\n----------------\nConverts query profile and budget decision into a dictionary format suitable\nfor logging, metrics, or API responses. Includes rounded ratios and all\ndecision parameters for observability and debugging.\n\nParameters\n----------\nprofile : QueryProfile\n    Query profile with computed characteristics.\ndecision : BudgetDecision\n    Budget decision with channel depths, RRF k, and RM3 flag.\n\nReturns\n-------\ndict[str, object]\n    Dictionary containing query profile fields (length, ratios rounded to\n    3 decimals) and budget decision fields (per_channel_depths, rrf_k,\n    rm3_enabled). Used for logging and observability.",
  "is_public": true
}
{
  "path": "retrieval/hybrid.py",
  "module": "retrieval.hybrid",
  "qualname": "retrieval.hybrid",
  "name": "retrieval.hybrid",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Hybrid retrieval with RRF fusion.\n\nFuses results from BM25, SPLADE, and FAISS using Reciprocal Rank Fusion.",
  "is_public": true
}
{
  "path": "retrieval/hybrid.py",
  "module": "retrieval.hybrid",
  "qualname": "reciprocal_rank_fusion",
  "name": "reciprocal_rank_fusion",
  "node_type": "FunctionDef",
  "lineno": 16,
  "col": 0,
  "end_lineno": 61,
  "end_col": 33,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Fuse multiple ranked lists using RRF.\n\nParameters\n----------\nresult_lists : Sequence[Sequence[SearchHit]]\n    Lists of search hits from different retrieval systems.\nk : int\n    RRF K parameter (higher = more weight to lower ranks).\ntop_k : int\n    Number of results to return.\n\nReturns\n-------\nlist[tuple[str, float]]\n    Fused results as (doc_id, rrf_score) sorted by score descending.\n\nNotes\n-----\nRRF score for document d is:\n    RRF(d) = sum over all systems S of: 1 / (k + rank_S(d))\n\nwhere rank_S(d) is the rank of d in system S (1-indexed).",
  "is_public": true
}
{
  "path": "retrieval/hybrid.py",
  "module": "retrieval.hybrid",
  "qualname": "create_hit_list",
  "name": "create_hit_list",
  "node_type": "FunctionDef",
  "lineno": 64,
  "col": 0,
  "end_lineno": 88,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Create SearchHit list from retrieval results.\n\nParameters\n----------\ndoc_ids : Sequence[str]\n    Document IDs in rank order.\nscores : Sequence[float]\n    Scores for each document.\nsource : str\n    Source identifier (e.g., \"bm25\", \"faiss\").\n\nReturns\n-------\nlist[SearchHit]\n    Search hits with ranks.",
  "is_public": true
}
{
  "path": "retrieval/mcp_search.py",
  "module": "retrieval.mcp_search",
  "qualname": "retrieval.mcp_search",
  "name": "retrieval.mcp_search",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Deep-Research compatible search/fetch orchestration helpers.",
  "is_public": true
}
{
  "path": "retrieval/mcp_search.py",
  "module": "retrieval.mcp_search",
  "qualname": "EmbeddingClient",
  "name": "EmbeddingClient",
  "node_type": "ClassDef",
  "lineno": 46,
  "col": 0,
  "end_lineno": 51,
  "end_col": 11,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "Protocol"
  ],
  "docstring": "Protocol describing the minimal embedder surface needed for search.",
  "is_public": true
}
{
  "path": "retrieval/mcp_search.py",
  "module": "retrieval.mcp_search",
  "qualname": "EmbeddingClient.embed_single",
  "name": "embed_single",
  "node_type": "FunctionDef",
  "lineno": 49,
  "col": 4,
  "end_lineno": 51,
  "end_col": 11,
  "parent_qualname": "EmbeddingClient",
  "decorators": [],
  "bases": [],
  "docstring": "Return a single embedding vector for ``text``.",
  "is_public": true
}
{
  "path": "retrieval/mcp_search.py",
  "module": "retrieval.mcp_search",
  "qualname": "IndexConfigLike",
  "name": "IndexConfigLike",
  "node_type": "ClassDef",
  "lineno": 54,
  "col": 0,
  "end_lineno": 81,
  "end_col": 11,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "Protocol"
  ],
  "docstring": "PEP 544 view of the index configuration needed by MCP search.",
  "is_public": true
}
{
  "path": "retrieval/mcp_search.py",
  "module": "retrieval.mcp_search",
  "qualname": "IndexConfigLike.vec_dim",
  "name": "vec_dim",
  "node_type": "FunctionDef",
  "lineno": 58,
  "col": 4,
  "end_lineno": 68,
  "end_col": 11,
  "parent_qualname": "IndexConfigLike",
  "decorators": [
    "property"
  ],
  "bases": [],
  "docstring": "Return the vector dimension for embeddings.\n\nReturns\n-------\nint\n    The dimension of embedding vectors used by the FAISS index.\n    This value must match the dimension of vectors produced by\n    the embedding service and stored in the index.",
  "is_public": true
}
{
  "path": "retrieval/mcp_search.py",
  "module": "retrieval.mcp_search",
  "qualname": "IndexConfigLike.faiss_nprobe",
  "name": "faiss_nprobe",
  "node_type": "FunctionDef",
  "lineno": 71,
  "col": 4,
  "end_lineno": 81,
  "end_col": 11,
  "parent_qualname": "IndexConfigLike",
  "decorators": [
    "property"
  ],
  "bases": [],
  "docstring": "Return the FAISS nprobe parameter for approximate search.\n\nReturns\n-------\nint\n    The number of inverted list clusters to probe during approximate\n    nearest neighbor search. Higher values improve recall at the cost\n    of latency. Used to configure FAISS index search behavior.",
  "is_public": true
}
{
  "path": "retrieval/mcp_search.py",
  "module": "retrieval.mcp_search",
  "qualname": "LimitsConfigLike",
  "name": "LimitsConfigLike",
  "node_type": "ClassDef",
  "lineno": 84,
  "col": 0,
  "end_lineno": 115,
  "end_col": 11,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "Protocol"
  ],
  "docstring": "PEP 544 view of server limit configuration.",
  "is_public": true
}
{
  "path": "retrieval/mcp_search.py",
  "module": "retrieval.mcp_search",
  "qualname": "LimitsConfigLike.max_results",
  "name": "max_results",
  "node_type": "FunctionDef",
  "lineno": 88,
  "col": 4,
  "end_lineno": 99,
  "end_col": 11,
  "parent_qualname": "LimitsConfigLike",
  "decorators": [
    "property"
  ],
  "bases": [],
  "docstring": "Return the maximum number of results allowed per search request.\n\nReturns\n-------\nint\n    The maximum number of results that can be returned from a single\n    search request. Used to enforce resource limits and prevent excessive\n    result sets. Search requests requesting more than this value will be\n    capped at this limit.",
  "is_public": true
}
{
  "path": "retrieval/mcp_search.py",
  "module": "retrieval.mcp_search",
  "qualname": "LimitsConfigLike.semantic_overfetch_multiplier",
  "name": "semantic_overfetch_multiplier",
  "node_type": "FunctionDef",
  "lineno": 102,
  "col": 4,
  "end_lineno": 115,
  "end_col": 11,
  "parent_qualname": "LimitsConfigLike",
  "decorators": [
    "property"
  ],
  "bases": [],
  "docstring": "Return the multiplier for semantic search overfetch when filters are active.\n\nReturns\n-------\nint\n    Multiplier applied to the requested top_k when post-filtering is\n    enabled (path filters, language filters, or symbol filters). Used\n    to fetch more candidates than requested to account for results that\n    will be filtered out. For example, if top_k=10 and multiplier=3,\n    the search will fetch 30 candidates to ensure enough results survive\n    post-filtering.",
  "is_public": true
}
{
  "path": "retrieval/mcp_search.py",
  "module": "retrieval.mcp_search",
  "qualname": "SearchSettings",
  "name": "SearchSettings",
  "node_type": "ClassDef",
  "lineno": 118,
  "col": 0,
  "end_lineno": 129,
  "end_col": 11,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "Protocol"
  ],
  "docstring": "Protocol for the subset of :class:`~codeintel_rev.config.settings.Settings`.",
  "is_public": true
}
{
  "path": "retrieval/mcp_search.py",
  "module": "retrieval.mcp_search",
  "qualname": "SearchSettings.index",
  "name": "index",
  "node_type": "FunctionDef",
  "lineno": 122,
  "col": 4,
  "end_lineno": 124,
  "end_col": 11,
  "parent_qualname": "SearchSettings",
  "decorators": [
    "property"
  ],
  "bases": [],
  "docstring": "Return immutable index configuration.",
  "is_public": true
}
{
  "path": "retrieval/mcp_search.py",
  "module": "retrieval.mcp_search",
  "qualname": "SearchSettings.limits",
  "name": "limits",
  "node_type": "FunctionDef",
  "lineno": 127,
  "col": 4,
  "end_lineno": 129,
  "end_col": 11,
  "parent_qualname": "SearchSettings",
  "decorators": [
    "property"
  ],
  "bases": [],
  "docstring": "Return immutable server limit configuration.",
  "is_public": true
}
{
  "path": "retrieval/mcp_search.py",
  "module": "retrieval.mcp_search",
  "qualname": "CatalogLike",
  "name": "CatalogLike",
  "node_type": "ClassDef",
  "lineno": 132,
  "col": 0,
  "end_lineno": 152,
  "end_col": 11,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "Protocol"
  ],
  "docstring": "DuckDB catalog surface used by the MCP tools.",
  "is_public": true
}
{
  "path": "retrieval/mcp_search.py",
  "module": "retrieval.mcp_search",
  "qualname": "CatalogLike.query_by_ids",
  "name": "query_by_ids",
  "node_type": "FunctionDef",
  "lineno": 135,
  "col": 4,
  "end_lineno": 137,
  "end_col": 11,
  "parent_qualname": "CatalogLike",
  "decorators": [],
  "bases": [],
  "docstring": "Return chunk rows for the provided ids.",
  "is_public": true
}
{
  "path": "retrieval/mcp_search.py",
  "module": "retrieval.mcp_search",
  "qualname": "CatalogLike.query_by_filters",
  "name": "query_by_filters",
  "node_type": "FunctionDef",
  "lineno": 139,
  "col": 4,
  "end_lineno": 148,
  "end_col": 11,
  "parent_qualname": "CatalogLike",
  "decorators": [],
  "bases": [],
  "docstring": "Return filtered chunk rows for the provided ids.",
  "is_public": true
}
{
  "path": "retrieval/mcp_search.py",
  "module": "retrieval.mcp_search",
  "qualname": "CatalogLike.get_structure_annotations",
  "name": "get_structure_annotations",
  "node_type": "FunctionDef",
  "lineno": 150,
  "col": 4,
  "end_lineno": 152,
  "end_col": 11,
  "parent_qualname": "CatalogLike",
  "decorators": [],
  "bases": [],
  "docstring": "Return structural overlays for ``ids`` when available.",
  "is_public": true
}
{
  "path": "retrieval/mcp_search.py",
  "module": "retrieval.mcp_search",
  "qualname": "VectorIndex",
  "name": "VectorIndex",
  "node_type": "ClassDef",
  "lineno": 155,
  "col": 0,
  "end_lineno": 176,
  "end_col": 11,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "Protocol"
  ],
  "docstring": "FAISS manager surface consumed by MCP search.",
  "is_public": true
}
{
  "path": "retrieval/mcp_search.py",
  "module": "retrieval.mcp_search",
  "qualname": "VectorIndex.get_runtime_tuning",
  "name": "get_runtime_tuning",
  "node_type": "FunctionDef",
  "lineno": 162,
  "col": 4,
  "end_lineno": 164,
  "end_col": 11,
  "parent_qualname": "VectorIndex",
  "decorators": [],
  "bases": [],
  "docstring": "Return runtime FAISS tuning metadata.",
  "is_public": true
}
{
  "path": "retrieval/mcp_search.py",
  "module": "retrieval.mcp_search",
  "qualname": "VectorIndex.search",
  "name": "search",
  "node_type": "FunctionDef",
  "lineno": 166,
  "col": 4,
  "end_lineno": 176,
  "end_col": 11,
  "parent_qualname": "VectorIndex",
  "decorators": [],
  "bases": [],
  "docstring": "Perform ANN search and return (distances, ids).",
  "is_public": true
}
{
  "path": "retrieval/mcp_search.py",
  "module": "retrieval.mcp_search",
  "qualname": "SearchFilters",
  "name": "SearchFilters",
  "node_type": "ClassDef",
  "lineno": 180,
  "col": 0,
  "end_lineno": 261,
  "end_col": 9,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Normalized filter payload for the MCP search tool.",
  "is_public": true
}
{
  "path": "retrieval/mcp_search.py",
  "module": "retrieval.mcp_search",
  "qualname": "SearchFilters.from_payload",
  "name": "from_payload",
  "node_type": "FunctionDef",
  "lineno": 189,
  "col": 4,
  "end_lineno": 224,
  "end_col": 9,
  "parent_qualname": "SearchFilters",
  "decorators": [
    "classmethod"
  ],
  "bases": [],
  "docstring": "Normalize the incoming JSON payload into immutable tuples.\n\nThis class method converts a JSON payload dictionary (from MCP tool arguments)\ninto a SearchFilters instance with immutable tuple-backed sequences. The method\nhandles missing keys gracefully, normalizes string lists, and validates filter\nvalues. Used to convert MCP search filter payloads into typed filter objects.\n\nParameters\n----------\npayload : Mapping[str, Sequence[str]] | SearchFilterPayload | None\n    Optional JSON payload dictionary containing filter keys: \"lang\" (languages),\n    \"include\" (include paths), \"exclude\" (exclude paths), \"symbols\" (symbol\n    filters). Values are sequences of strings that are normalized and converted\n    to tuples. When None or empty, returns a SearchFilters instance with empty\n    tuples (no filters). Can accept either Mapping[str, Sequence[str]] or\n    SearchFilterPayload TypedDict format.\n\nReturns\n-------\nSearchFilters\n    SearchFilters instance with normalized filter tuples. All filter fields\n    (languages, include, exclude, symbols) are immutable tuples, even when\n    the payload is empty or missing keys.",
  "is_public": true
}
{
  "path": "retrieval/mcp_search.py",
  "module": "retrieval.mcp_search",
  "qualname": "SearchFilters.has_path_filters",
  "name": "has_path_filters",
  "node_type": "FunctionDef",
  "lineno": 227,
  "col": 4,
  "end_lineno": 235,
  "end_col": 49,
  "parent_qualname": "SearchFilters",
  "decorators": [
    "property"
  ],
  "bases": [],
  "docstring": "Return ``True`` when include/exclude filters are present.\n\nReturns\n-------\nbool\n    ``True`` when include/exclude filters were provided.",
  "is_public": true
}
{
  "path": "retrieval/mcp_search.py",
  "module": "retrieval.mcp_search",
  "qualname": "SearchFilters.has_language_filters",
  "name": "has_language_filters",
  "node_type": "FunctionDef",
  "lineno": 238,
  "col": 4,
  "end_lineno": 246,
  "end_col": 35,
  "parent_qualname": "SearchFilters",
  "decorators": [
    "property"
  ],
  "bases": [],
  "docstring": "Return ``True`` when language filters are present.\n\nReturns\n-------\nbool\n    ``True`` when the filter payload includes languages.",
  "is_public": true
}
{
  "path": "retrieval/mcp_search.py",
  "module": "retrieval.mcp_search",
  "qualname": "SearchFilters.describe",
  "name": "describe",
  "node_type": "FunctionDef",
  "lineno": 248,
  "col": 4,
  "end_lineno": 261,
  "end_col": 9,
  "parent_qualname": "SearchFilters",
  "decorators": [],
  "bases": [],
  "docstring": "Return a JSON-safe description for structured logging.\n\nReturns\n-------\ndict[str, object]\n    Mapping containing canonical filter fields.",
  "is_public": true
}
{
  "path": "retrieval/mcp_search.py",
  "module": "retrieval.mcp_search",
  "qualname": "SearchRequest",
  "name": "SearchRequest",
  "node_type": "ClassDef",
  "lineno": 265,
  "col": 0,
  "end_lineno": 271,
  "end_col": 26,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Search invocation parameters.",
  "is_public": true
}
{
  "path": "retrieval/mcp_search.py",
  "module": "retrieval.mcp_search",
  "qualname": "SearchResult",
  "name": "SearchResult",
  "node_type": "ClassDef",
  "lineno": 275,
  "col": 0,
  "end_lineno": 284,
  "end_col": 31,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Single search result entry.",
  "is_public": true
}
{
  "path": "retrieval/mcp_search.py",
  "module": "retrieval.mcp_search",
  "qualname": "SearchResponse",
  "name": "SearchResponse",
  "node_type": "ClassDef",
  "lineno": 288,
  "col": 0,
  "end_lineno": 294,
  "end_col": 21,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Structured search response returned to MCP adapters.",
  "is_public": true
}
{
  "path": "retrieval/mcp_search.py",
  "module": "retrieval.mcp_search",
  "qualname": "HydrationPayload",
  "name": "HydrationPayload",
  "node_type": "ClassDef",
  "lineno": 298,
  "col": 0,
  "end_lineno": 302,
  "end_col": 51,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Bundle of hydrated rows and structural annotations.",
  "is_public": true
}
{
  "path": "retrieval/mcp_search.py",
  "module": "retrieval.mcp_search",
  "qualname": "SearchDependencies",
  "name": "SearchDependencies",
  "node_type": "ClassDef",
  "lineno": 306,
  "col": 0,
  "end_lineno": 317,
  "end_col": 29,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Dependency bundle consumed by :func:`run_search`.",
  "is_public": true
}
{
  "path": "retrieval/mcp_search.py",
  "module": "retrieval.mcp_search",
  "qualname": "FetchRequest",
  "name": "FetchRequest",
  "node_type": "ClassDef",
  "lineno": 321,
  "col": 0,
  "end_lineno": 325,
  "end_col": 19,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Fetch invocation parameters.",
  "is_public": true
}
{
  "path": "retrieval/mcp_search.py",
  "module": "retrieval.mcp_search",
  "qualname": "FetchObjectResult",
  "name": "FetchObjectResult",
  "node_type": "ClassDef",
  "lineno": 329,
  "col": 0,
  "end_lineno": 336,
  "end_col": 31,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Single hydrated chunk.",
  "is_public": true
}
{
  "path": "retrieval/mcp_search.py",
  "module": "retrieval.mcp_search",
  "qualname": "FetchResponse",
  "name": "FetchResponse",
  "node_type": "ClassDef",
  "lineno": 340,
  "col": 0,
  "end_lineno": 343,
  "end_col": 36,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Structured fetch response used by MCP adapters.",
  "is_public": true
}
{
  "path": "retrieval/mcp_search.py",
  "module": "retrieval.mcp_search",
  "qualname": "FetchDependencies",
  "name": "FetchDependencies",
  "node_type": "ClassDef",
  "lineno": 347,
  "col": 0,
  "end_lineno": 352,
  "end_col": 29,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Dependency bundle for :func:`run_fetch`.",
  "is_public": true
}
{
  "path": "retrieval/mcp_search.py",
  "module": "retrieval.mcp_search",
  "qualname": "run_search",
  "name": "run_search",
  "node_type": "FunctionDef",
  "lineno": 355,
  "col": 0,
  "end_lineno": 515,
  "end_col": 9,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Execute FAISS search  DuckDB hydration and return MCP-ready results.\n\nThis function orchestrates the complete search workflow: embeds the query text,\nexecutes FAISS approximate nearest neighbor search, optionally reranks candidates\nwith exact similarity, hydrates chunk metadata from DuckDB, applies post-search\nfilters, and builds ranked results. The function records metrics (latency, postfilter\ndensity) and writes pool rows for trace analysis.\n\nParameters\n----------\nrequest : SearchRequest\n    Search request containing query text, top_k (number of results), rerank flag,\n    and optional filters (languages, paths, symbols). Used to configure search\n    behavior and result filtering.\ndeps : SearchDependencies\n    Search dependencies providing FAISS manager, embedding client, DuckDB catalog,\n    settings, timeline, and pool directory. Used to execute search operations and\n    hydrate results. The dependencies must be initialized and ready for use.\n\nReturns\n-------\nSearchResponse\n    Dataclass containing search hits and diagnostic metadata. Includes query_echo\n    (original query), top_k (requested results), results (ranked SearchResult objects\n    with chunk metadata and scores), and limits (resource limits applied during search).",
  "is_public": true
}
{
  "path": "retrieval/mcp_search.py",
  "module": "retrieval.mcp_search",
  "qualname": "run_fetch",
  "name": "run_fetch",
  "node_type": "FunctionDef",
  "lineno": 518,
  "col": 0,
  "end_lineno": 576,
  "end_col": 45,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Hydrate chunk content and metadata for the MCP fetch tool.\n\nThis function retrieves full chunk content and metadata for a list of chunk IDs\nfrom the DuckDB catalog. The function queries the catalog, builds FetchObjectResult\nobjects with content and metadata, applies max_tokens limits, and records metrics\n(latency, token counts). Used to hydrate chunk IDs returned from search operations.\n\nParameters\n----------\nrequest : FetchRequest\n    Fetch request containing object_ids (list of chunk IDs to hydrate) and\n    max_tokens (optional token limit). Used to query the catalog and limit response\n    size. Empty object_ids return an empty response immediately.\ndeps : FetchDependencies\n    Fetch dependencies providing DuckDB catalog, settings, and timeline. Used to\n    query chunk metadata and record observability events. The catalog must be\n    initialized and ready for queries.\n\nReturns\n-------\nFetchResponse\n    Dataclass containing hydrated chunk objects. Includes a list of FetchObjectResult\n    objects with chunk_id, title, url, content, and metadata fields. Chunks are\n    returned in the order specified by request.object_ids, with missing chunks\n    omitted. Content is truncated to max_tokens when specified.",
  "is_public": true
}
{
  "path": "retrieval/mcp_search.py",
  "module": "retrieval.mcp_search",
  "qualname": "_normalize_str_list",
  "name": "_normalize_str_list",
  "node_type": "FunctionDef",
  "lineno": 584,
  "col": 0,
  "end_lineno": 587,
  "end_col": 73,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "retrieval/mcp_search.py",
  "module": "retrieval.mcp_search",
  "qualname": "_embed_query",
  "name": "_embed_query",
  "node_type": "FunctionDef",
  "lineno": 590,
  "col": 0,
  "end_lineno": 609,
  "end_col": 20,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "retrieval/mcp_search.py",
  "module": "retrieval.mcp_search",
  "qualname": "_compute_fanout",
  "name": "_compute_fanout",
  "node_type": "FunctionDef",
  "lineno": 612,
  "col": 0,
  "end_lineno": 618,
  "end_col": 74,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "retrieval/mcp_search.py",
  "module": "retrieval.mcp_search",
  "qualname": "_build_runtime_overrides",
  "name": "_build_runtime_overrides",
  "node_type": "FunctionDef",
  "lineno": 621,
  "col": 0,
  "end_lineno": 645,
  "end_col": 47,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return FAISS runtime overrides derived from the rerank flag.\n\nThis helper function constructs FAISS runtime overrides based on the rerank\nconfiguration. When rerank is disabled, returns overrides that set k_factor=1.0\nto disable candidate expansion (since exact reranking won't be performed). When\nrerank is enabled, returns None to use default overrides (which enable expansion).\n\nParameters\n----------\nrerank : bool\n    Whether exact reranking is enabled. When False, returns overrides with\n    k_factor=1.0 to disable candidate expansion. When True, returns None\n    to use default overrides that enable expansion for reranking.\n\nReturns\n-------\nSearchRuntimeOverrides | None\n    Runtime overrides with k_factor=1.0 when rerank is False (disables expansion),\n    otherwise None (uses default overrides that enable expansion for reranking).\n    The overrides are applied to FAISS search to control candidate retrieval.",
  "is_public": false
}
{
  "path": "retrieval/mcp_search.py",
  "module": "retrieval.mcp_search",
  "qualname": "_flatten_ids",
  "name": "_flatten_ids",
  "node_type": "FunctionDef",
  "lineno": 648,
  "col": 0,
  "end_lineno": 651,
  "end_col": 83,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "retrieval/mcp_search.py",
  "module": "retrieval.mcp_search",
  "qualname": "_flatten_scores",
  "name": "_flatten_scores",
  "node_type": "FunctionDef",
  "lineno": 654,
  "col": 0,
  "end_lineno": 657,
  "end_col": 60,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "retrieval/mcp_search.py",
  "module": "retrieval.mcp_search",
  "qualname": "_hydrate_chunks",
  "name": "_hydrate_chunks",
  "node_type": "FunctionDef",
  "lineno": 660,
  "col": 0,
  "end_lineno": 681,
  "end_col": 20,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "retrieval/mcp_search.py",
  "module": "retrieval.mcp_search",
  "qualname": "_build_results",
  "name": "_build_results",
  "node_type": "FunctionDef",
  "lineno": 684,
  "col": 0,
  "end_lineno": 713,
  "end_col": 18,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "retrieval/mcp_search.py",
  "module": "retrieval.mcp_search",
  "qualname": "_matches_symbols",
  "name": "_matches_symbols",
  "node_type": "FunctionDef",
  "lineno": 716,
  "col": 0,
  "end_lineno": 720,
  "end_col": 61,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "retrieval/mcp_search.py",
  "module": "retrieval.mcp_search",
  "qualname": "_build_metadata",
  "name": "_build_metadata",
  "node_type": "FunctionDef",
  "lineno": 723,
  "col": 0,
  "end_lineno": 745,
  "end_col": 19,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "retrieval/mcp_search.py",
  "module": "retrieval.mcp_search",
  "qualname": "_build_hit_reasons",
  "name": "_build_hit_reasons",
  "node_type": "FunctionDef",
  "lineno": 748,
  "col": 0,
  "end_lineno": 767,
  "end_col": 18,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "retrieval/mcp_search.py",
  "module": "retrieval.mcp_search",
  "qualname": "_build_title",
  "name": "_build_title",
  "node_type": "FunctionDef",
  "lineno": 770,
  "col": 0,
  "end_lineno": 774,
  "end_col": 67,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "retrieval/mcp_search.py",
  "module": "retrieval.mcp_search",
  "qualname": "_build_url",
  "name": "_build_url",
  "node_type": "FunctionDef",
  "lineno": 777,
  "col": 0,
  "end_lineno": 781,
  "end_col": 69,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "retrieval/mcp_search.py",
  "module": "retrieval.mcp_search",
  "qualname": "_build_snippet",
  "name": "_build_snippet",
  "node_type": "FunctionDef",
  "lineno": 784,
  "col": 0,
  "end_lineno": 789,
  "end_col": 24,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "retrieval/mcp_search.py",
  "module": "retrieval.mcp_search",
  "qualname": "_truncate_content",
  "name": "_truncate_content",
  "node_type": "FunctionDef",
  "lineno": 792,
  "col": 0,
  "end_lineno": 797,
  "end_col": 30,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "retrieval/mcp_search.py",
  "module": "retrieval.mcp_search",
  "qualname": "_build_fetch_metadata",
  "name": "_build_fetch_metadata",
  "node_type": "FunctionDef",
  "lineno": 800,
  "col": 0,
  "end_lineno": 808,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "retrieval/mcp_search.py",
  "module": "retrieval.mcp_search",
  "qualname": "_write_pool_rows",
  "name": "_write_pool_rows",
  "node_type": "FunctionDef",
  "lineno": 811,
  "col": 0,
  "end_lineno": 850,
  "end_col": 85,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "retrieval/mcp_search.py",
  "module": "retrieval.mcp_search",
  "qualname": "_record_postfilter_density",
  "name": "_record_postfilter_density",
  "node_type": "FunctionDef",
  "lineno": 853,
  "col": 0,
  "end_lineno": 857,
  "end_col": 48,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "retrieval/mcp_search.py",
  "module": "retrieval.mcp_search",
  "qualname": "_log_search_completion",
  "name": "_log_search_completion",
  "node_type": "FunctionDef",
  "lineno": 860,
  "col": 0,
  "end_lineno": 877,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "retrieval/mcp_search.py",
  "module": "retrieval.mcp_search",
  "qualname": "_coerce_int",
  "name": "_coerce_int",
  "node_type": "FunctionDef",
  "lineno": 880,
  "col": 0,
  "end_lineno": 892,
  "end_col": 12,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "retrieval/mcp_search.py",
  "module": "retrieval.mcp_search",
  "qualname": "_string_sequence",
  "name": "_string_sequence",
  "node_type": "FunctionDef",
  "lineno": 895,
  "col": 0,
  "end_lineno": 898,
  "end_col": 13,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "retrieval/mcp_search.py",
  "module": "retrieval.mcp_search",
  "qualname": "_repair_single_result",
  "name": "_repair_single_result",
  "node_type": "FunctionDef",
  "lineno": 901,
  "col": 0,
  "end_lineno": 913,
  "end_col": 82,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "retrieval/mcp_search.py",
  "module": "retrieval.mcp_search",
  "qualname": "_resolve_snippet",
  "name": "_resolve_snippet",
  "node_type": "FunctionDef",
  "lineno": 916,
  "col": 0,
  "end_lineno": 923,
  "end_col": 20,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "retrieval/mcp_search.py",
  "module": "retrieval.mcp_search",
  "qualname": "_merge_metadata",
  "name": "_merge_metadata",
  "node_type": "FunctionDef",
  "lineno": 926,
  "col": 0,
  "end_lineno": 952,
  "end_col": 28,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "retrieval/mcp_search.py",
  "module": "retrieval.mcp_search",
  "qualname": "_RepairStats",
  "name": "_RepairStats",
  "node_type": "ClassDef",
  "lineno": 956,
  "col": 0,
  "end_lineno": 961,
  "end_col": 16,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Aggregate counters describing validator repairs.",
  "is_public": false
}
{
  "path": "retrieval/mcp_search.py",
  "module": "retrieval.mcp_search",
  "qualname": "post_search_validate_and_fill",
  "name": "post_search_validate_and_fill",
  "node_type": "FunctionDef",
  "lineno": 964,
  "col": 0,
  "end_lineno": 1006,
  "end_col": 87,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Ensure MCP results have required metadata, dropping corrupt rows.\n\nThis function validates and repairs search results by ensuring each item has\nrequired metadata fields (URI, line ranges, content) from the hydration payload.\nIt is called after search execution to ensure result quality and completeness\nbefore returning results to clients.\n\nParameters\n----------\nitems : Sequence[SearchResult]\n    Sequence of search result items to validate and repair.\nhydration : HydrationPayload\n    Payload containing chunk metadata rows keyed by chunk ID, used to fill\n    missing fields in search results.\n\nReturns\n-------\ntuple[list[SearchResult], _RepairStats]\n    Tuple of repaired results and aggregate statistics describing how many\n    rows were inspected, repaired, or dropped.",
  "is_public": true
}
{
  "path": "retrieval/rerank_flat.py",
  "module": "retrieval.rerank_flat",
  "qualname": "retrieval.rerank_flat",
  "name": "retrieval.rerank_flat",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Exact reranking utilities for FAISS candidates.",
  "is_public": true
}
{
  "path": "retrieval/rerank_flat.py",
  "module": "retrieval.rerank_flat",
  "qualname": "_perform_exact_rerank",
  "name": "_perform_exact_rerank",
  "node_type": "FunctionDef",
  "lineno": 27,
  "col": 0,
  "end_lineno": 150,
  "end_col": 22,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Hydrate embeddings for candidate ids and compute exact similarities.\n\nThis function performs exact reranking of approximate nearest neighbor (ANN)\nsearch candidates by retrieving the original embeddings from the catalog and\ncomputing exact similarity scores (inner product or cosine similarity). The\ncandidates are then sorted by exact similarity and the top-k results are\nreturned. This improves recall compared to using approximate distances from\nthe FAISS index.\n\nThe function handles missing embeddings gracefully by returning sentinel values\n(minimum float32 for scores, -1 for IDs) when embeddings are not found in the\ncatalog. Invalid candidate IDs (negative values) are filtered out before\nsimilarity computation.\n\nParameters\n----------\ncatalog : DuckDBCatalog\n    Catalog instance providing get_embeddings_by_ids() method for batch\n    embedding retrieval. The catalog must contain embeddings for the candidate\n    chunk IDs.\nqueries : np.ndarray\n    Query vectors shaped `(B, dim)` or `(dim,)` where B is the batch size and\n    dim is the embedding dimension. Automatically reshaped to 2D if 1D.\n    Dtype should be float32 or convertible to float32.\ncandidate_ids : np.ndarray\n    Candidate chunk identifiers shaped `(B, K')` where B matches the query\n    batch size and K' is the number of candidates per query (typically larger\n    than top_k). Dtype should be int64 or convertible to int64. Negative IDs\n    are treated as invalid and filtered out.\ntop_k : int\n    Number of top results to return per query after reranking. Must be positive.\n    The function returns the top-k candidates sorted by exact similarity score\n    (descending order).\nmetric : str, optional\n    Similarity metric to use for exact computation. ``\"ip\"`` (inner product)\n    by default, which computes dot product between query and candidate vectors.\n    ``\"cos\"`` (cosine similarity) normalizes both queries and candidates to\n    unit length before computing inner product. Defaults to ``\"ip\"``.\n\nReturns\n-------\nnp.ndarray\n    Scores array with shape `(B, top_k)`, dtype float32. Exact similarity\n    scores (inner product or cosine similarity) for the top-k reranked candidates.\n    Scores are sorted in descending order (highest similarity first). Missing\n    or invalid candidates are filled with minimum float32 value.\nnp.ndarray\n    IDs array with shape `(B, top_k)`, dtype int64. Chunk identifiers\n    corresponding to the top-k reranked candidates. Missing or invalid\n    candidates are filled with -1.\n\nRaises\n------\nValueError\n    Raised in the following cases:\n    - ``top_k <= 0``: top_k must be positive for rerank operations\n    - ``candidate_ids`` shape mismatch: candidate_ids must be shaped (B, K')\n      and aligned with query batch size B\n    - Embedding dimension mismatch: retrieved embeddings have different\n      dimension than query vectors\n    - Effective top_k <= 0: occurs when k_prime (number of candidates) is\n      zero or negative after filtering\n\nNotes\n-----\nThis function performs exact similarity computation which is more accurate\nthan approximate distances but slower. Time complexity: O(B * K' * dim) for\nsimilarity computation plus O(B * K' * log(K')) for sorting. The function\nhandles missing embeddings gracefully by returning sentinel values rather\nthan raising exceptions. When no embeddings are found for any candidate IDs,\nthe function returns arrays filled with sentinel values (minimum scores, -1 IDs)\nwith shape (B, min(top_k, K')). Thread-safe if the catalog instance is\nthread-safe. The function uses einsum for efficient batch similarity computation\nand argpartition for efficient top-k selection.",
  "is_public": false
}
{
  "path": "retrieval/rerank_flat.py",
  "module": "retrieval.rerank_flat",
  "qualname": "_normalize_queries",
  "name": "_normalize_queries",
  "node_type": "FunctionDef",
  "lineno": 153,
  "col": 0,
  "end_lineno": 184,
  "end_col": 20,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Normalize query vectors to 2D array format for batch processing.\n\nThis helper function ensures query vectors are in the correct shape for\nbatch similarity computation. Single query vectors (1D) are reshaped to\n2D with batch size 1, while batch queries (2D) are passed through unchanged.\nThe function also ensures float32 dtype for consistent computation.\n\nParameters\n----------\nqueries : np.ndarray\n    Query vectors of shape `(B, dim)` or `(dim,)` where B is the batch size\n    and dim is the embedding dimension. Dtype is converted to float32 if needed.\n\nReturns\n-------\nnp.ndarray\n    Normalized query matrix with shape `(B, dim)` where B >= 1. Single queries\n    are reshaped to `(1, dim)`. Dtype is float32. The array is ready for\n    batch similarity computation with candidate vectors.\n\nNotes\n-----\nThis function is part of the exact reranking pipeline and ensures consistent\ninput format for downstream processing. Time complexity: O(B * dim) for dtype\nconversion and reshaping. The function performs no I/O operations and is\nthread-safe.",
  "is_public": false
}
{
  "path": "retrieval/rerank_flat.py",
  "module": "retrieval.rerank_flat",
  "qualname": "_prepare_candidate_matrix",
  "name": "_prepare_candidate_matrix",
  "node_type": "FunctionDef",
  "lineno": 187,
  "col": 0,
  "end_lineno": 230,
  "end_col": 21,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Validate and prepare candidate ID matrix for embedding retrieval.\n\nThis helper function validates that candidate IDs are in the correct 2D format\nand aligned with the query batch size. It ensures dtype is int64 for consistent\nID handling and raises ValueError if the shape is invalid. This validation\nprevents downstream errors during embedding lookup and similarity computation.\n\nParameters\n----------\ncandidate_ids : np.ndarray\n    Candidate chunk identifiers of any shape. Will be converted to int64 dtype\n    and validated to ensure 2D shape `(batch_size, K')` where batch_size matches\n    the query batch size.\nbatch_size : int\n    Expected batch size (number of queries). The first dimension of candidate_ids\n    must match this value. Used to validate alignment between queries and candidates.\n\nReturns\n-------\nnp.ndarray\n    Validated candidate ID matrix with shape `(batch_size, K')` and dtype int64.\n    The matrix is ready for embedding retrieval and similarity computation.\n\nRaises\n------\nValueError\n    Raised when candidate_ids is not 2D or when the batch dimension doesn't\n    match the expected batch_size. This ensures queries and candidates are\n    properly aligned for batch processing.\n\nNotes\n-----\nThis function is part of the exact reranking pipeline and performs input\nvalidation before expensive embedding retrieval operations. Time complexity:\nO(1) for shape validation plus O(n) for dtype conversion where n is the\nnumber of candidate IDs. The function performs no I/O operations and is\nthread-safe.",
  "is_public": false
}
{
  "path": "retrieval/rerank_flat.py",
  "module": "retrieval.rerank_flat",
  "qualname": "_hydrate_embeddings",
  "name": "_hydrate_embeddings",
  "node_type": "FunctionDef",
  "lineno": 233,
  "col": 0,
  "end_lineno": 286,
  "end_col": 38,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Retrieve embeddings from catalog for valid candidate IDs.\n\nThis helper function performs batch embedding retrieval from the DuckDB catalog\nfor all valid (non-negative) candidate chunk IDs. It filters out invalid IDs,\ndeduplicates IDs to minimize catalog queries, and builds a lookup dictionary\nmapping chunk IDs to their embedding vectors. This lookup enables efficient\nvector assembly during candidate vector construction.\n\nParameters\n----------\ncatalog : DuckDBCatalog\n    DuckDB catalog instance providing get_embeddings_by_ids() method for batch\n    embedding retrieval. The catalog must contain embeddings for the candidate\n    chunk IDs. Missing embeddings are handled gracefully (empty lookup returned).\ncandidates : np.ndarray\n    Candidate chunk ID matrix with shape `(batch, K')` and dtype int64. Invalid\n    IDs (negative values) are automatically filtered out before catalog query.\n    The function extracts unique IDs to minimize redundant catalog lookups.\n\nReturns\n-------\ndict[int, np.ndarray]\n    Lookup dictionary mapping chunk IDs to their embedding vectors. Keys are\n    integer chunk IDs; values are float32 numpy arrays with shape `(dim,)`\n    where dim is the embedding dimension. Empty dictionary when no valid IDs\n    exist or no embeddings are found in the catalog.\nint\n    Embedding dimension (number of features per vector). Returns 0 when no\n    embeddings are retrieved. Used to validate dimension consistency with\n    query vectors and allocate candidate vector arrays.\n\nNotes\n-----\nThis function is part of the exact reranking pipeline and performs the critical\nstep of retrieving original embeddings for exact similarity computation. Time\ncomplexity: O(n) for filtering and deduplication plus O(m) for catalog query\nwhere n is the number of candidate IDs and m is the number of unique IDs. The\nfunction performs database I/O via the catalog and is thread-safe if the catalog\ninstance is thread-safe. Missing embeddings are handled gracefully - the function\nreturns an empty lookup rather than raising exceptions, allowing the caller to\nhandle missing data appropriately.",
  "is_public": false
}
{
  "path": "retrieval/rerank_flat.py",
  "module": "retrieval.rerank_flat",
  "qualname": "_build_candidate_vectors",
  "name": "_build_candidate_vectors",
  "node_type": "FunctionDef",
  "lineno": 289,
  "col": 0,
  "end_lineno": 355,
  "end_col": 26,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Assemble candidate embedding vectors from lookup dictionary.\n\nThis helper function constructs a 3D array of candidate embedding vectors\nby mapping chunk IDs from the candidate matrix to their corresponding\nembeddings in the lookup dictionary. It maintains the batch and candidate\nstructure while filling in embedding vectors. A boolean mask tracks which\npositions have valid embeddings, enabling downstream similarity computation\nto handle missing embeddings gracefully.\n\nParameters\n----------\ncandidates : np.ndarray\n    Candidate chunk ID matrix with shape `(batch, width)` and dtype int64.\n    Each element is a chunk ID that maps to an embedding in the lookup\n    dictionary. Negative IDs are skipped (treated as invalid).\nembedding_lookup : dict[int, np.ndarray]\n    Dictionary mapping chunk IDs to their embedding vectors. Keys are integer\n    chunk IDs; values are float32 numpy arrays with shape `(dim,)`. Missing\n    IDs result in zero-filled vectors with corresponding filled mask set to False.\ndim : int\n    Embedding dimension (number of features per vector). Used to allocate\n    the candidate vector array with shape `(batch, width, dim)`. Must match\n    the dimension of vectors in embedding_lookup.\n\nReturns\n-------\nnp.ndarray\n    Candidate embedding vectors with shape `(batch, width, dim)` and dtype\n    float32. Each position `[b, k, :]` contains the embedding vector for\n    candidate ID `candidates[b, k]` if available, otherwise zeros. The vectors\n    are ready for batch similarity computation with query vectors.\nnp.ndarray\n    Boolean mask with shape `(batch, width)` indicating which positions have\n    valid embeddings. True indicates the embedding was found in the lookup\n    dictionary; False indicates missing or invalid embedding (zero-filled).\n    Used to mask invalid similarities during computation.\n\nNotes\n-----\nThis function is part of the exact reranking pipeline and performs the vector\nassembly step before similarity computation. Time complexity: O(batch * width)\nfor iterating through candidate IDs and dictionary lookups. The function\nperforms no I/O operations and is thread-safe. Missing embeddings result in\nzero-filled vectors rather than raising exceptions, allowing graceful handling\nof incomplete data during reranking.",
  "is_public": false
}
{
  "path": "retrieval/rerank_flat.py",
  "module": "retrieval.rerank_flat",
  "qualname": "_compute_similarity",
  "name": "_compute_similarity",
  "node_type": "FunctionDef",
  "lineno": 358,
  "col": 0,
  "end_lineno": 424,
  "end_col": 15,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Compute batch similarity scores between queries and candidate vectors.\n\nThis helper function computes exact similarity scores (inner product or cosine\nsimilarity) between query vectors and candidate embedding vectors. It supports\ntwo metrics: \"ip\" (inner product) for fast computation and \"cos\" (cosine\nsimilarity) for normalized similarity. The function uses einsum for efficient\nbatch computation and masks invalid embeddings (missing vectors) with minimum\nfloat32 values to exclude them from top-k selection.\n\nParameters\n----------\nquery_mat : np.ndarray\n    Query vectors with shape `(batch, dim)` and dtype float32. Each row represents\n    one query vector. The queries are broadcast to match candidate vector dimensions\n    for batch similarity computation.\nvectors : np.ndarray\n    Candidate embedding vectors with shape `(batch, width, dim)` and dtype float32.\n    Each position `[b, k, :]` contains an embedding vector for candidate k in\n    batch b. Missing embeddings are zero-filled (handled via filled mask).\nfilled : np.ndarray\n    Boolean mask with shape `(batch, width)` indicating valid embeddings. True\n    indicates the embedding vector is valid; False indicates missing/invalid\n    (zero-filled). Used to mask similarities for invalid candidates.\nmetric : str\n    Similarity metric to use: \"ip\" for inner product (dot product) or \"cos\" for\n    cosine similarity (normalized inner product). Cosine similarity normalizes\n    both queries and candidates to unit length before computation.\n\nReturns\n-------\nnp.ndarray\n    Similarity scores with shape `(batch, width)` and dtype float32. Each element\n    `[b, k]` contains the similarity score between query `b` and candidate `k`.\n    Scores are inner products (range depends on vector magnitudes) or cosine\n    similarities (range [-1, 1] after normalization). Invalid candidates (filled[b, k]\n    == False) have scores set to minimum float32 value to exclude them from top-k.\n\nNotes\n-----\nThis function is part of the exact reranking pipeline and performs the core\nsimilarity computation step. Time complexity: O(batch * width * dim) for einsum\ncomputation plus O(batch * width * dim) for cosine normalization when metric=\"cos\".\nThe function uses einsum for efficient batch operations and broadcasting to avoid\nexplicit loops. Invalid embeddings are masked rather than raising exceptions,\nallowing graceful handling of missing data. Thread-safe and performs no I/O\noperations. Cosine similarity uses epsilon (1e-9) to prevent division by zero.",
  "is_public": false
}
{
  "path": "retrieval/rerank_flat.py",
  "module": "retrieval.rerank_flat",
  "qualname": "_effective_top_k",
  "name": "_effective_top_k",
  "node_type": "FunctionDef",
  "lineno": 427,
  "col": 0,
  "end_lineno": 474,
  "end_col": 16,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Compute effective top-k value bounded by available candidates.\n\nThis helper function computes the effective number of results to return,\nensuring it doesn't exceed the number of available candidates. It validates\nthat the effective k is positive, preventing downstream errors during top-k\nselection. This is necessary because the number of candidates may be smaller\nthan the requested top_k (e.g., when filtering invalid IDs or when few\ncandidates exist).\n\nParameters\n----------\nrequested : int\n    Requested number of top results (top_k parameter). Must be positive.\n    This is the desired number of results per query.\navailable : int\n    Number of available candidates (width of candidate matrix). This may be\n    smaller than requested if candidates were filtered or if the candidate\n    matrix is narrow. Must be non-negative.\n\nReturns\n-------\nint\n    Effective top-k value, computed as min(requested, available). This is\n    the actual number of results that can be returned, bounded by available\n    candidates. Always positive (validated before return).\n\nRaises\n------\nValueError\n    Raised when the effective top_k is zero or negative. This occurs when\n    both requested and available are zero, or when available is negative\n    (should not happen in normal operation). Prevents downstream errors in\n    top-k selection operations.\n\nNotes\n-----\nThis function is part of the exact reranking pipeline and performs bounds\nchecking before expensive top-k selection operations. Time complexity: O(1)\nfor min computation and validation. The function performs no I/O operations\nand is thread-safe. This validation ensures that argpartition and sorting\noperations receive valid k values.",
  "is_public": false
}
{
  "path": "retrieval/rerank_flat.py",
  "module": "retrieval.rerank_flat",
  "qualname": "_select_topk",
  "name": "_select_topk",
  "node_type": "FunctionDef",
  "lineno": 477,
  "col": 0,
  "end_lineno": 533,
  "end_col": 98,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Select top-k candidates by similarity score with efficient partial sorting.\n\nThis helper function performs efficient top-k selection using argpartition for\nO(n) partial sorting followed by full sorting of the top-k subset. It selects\nthe k highest-scoring candidates per query, sorts them by score (descending),\nand returns both the sorted scores and corresponding candidate IDs. This two-phase\napproach (partition + sort) is more efficient than full sorting when k << n.\n\nParameters\n----------\ncandidates : np.ndarray\n    Candidate chunk ID matrix with shape `(batch, width)` and dtype int64.\n    Each element is a chunk ID corresponding to a similarity score in the\n    similarities array. Used to retrieve IDs for top-k selected candidates.\nsimilarities : np.ndarray\n    Similarity scores with shape `(batch, width)` and dtype float32. Each element\n    `[b, k]` contains the similarity score between query `b` and candidate `k`.\n    Scores are used to select the top-k candidates per query (highest scores).\ntop_k : int\n    Number of top candidates to select per query. Must be positive and <= width.\n    The function returns the top-k highest-scoring candidates sorted by score\n    (descending order).\n\nReturns\n-------\nnp.ndarray\n    Top-k similarity scores with shape `(batch, top_k)` and dtype float32.\n    Scores are sorted in descending order (highest similarity first) within each\n    query. Each row contains the k highest scores for that query.\nnp.ndarray\n    Top-k candidate IDs with shape `(batch, top_k)` and dtype int64. IDs correspond\n    to the top-k scores and are aligned with the scores array. Each row contains\n    the k chunk IDs with highest similarity scores for that query.\n\nNotes\n-----\nThis function is part of the exact reranking pipeline and performs the final\nselection step before returning results. Time complexity: O(batch * width) for\nargpartition plus O(batch * top_k * log(top_k)) for sorting the top-k subset.\nThis is more efficient than full sorting O(batch * width * log(width)) when\ntop_k << width. The function uses argpartition for efficient partial sorting\nand argsort for final ordering. Thread-safe and performs no I/O operations.\nThe function ensures consistent dtype (float32 for scores, int64 for IDs) for\ndownstream compatibility.",
  "is_public": false
}
{
  "path": "retrieval/rerank_flat.py",
  "module": "retrieval.rerank_flat",
  "qualname": "_empty_result",
  "name": "_empty_result",
  "node_type": "FunctionDef",
  "lineno": 536,
  "col": 0,
  "end_lineno": 579,
  "end_col": 30,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Create sentinel result arrays for empty or failed reranking operations.\n\nThis helper function creates placeholder result arrays filled with sentinel\nvalues when reranking cannot be performed (e.g., no valid candidates, no\nembeddings found). The sentinel values (minimum float32 for scores, -1 for\nIDs) clearly indicate missing results and allow downstream code to handle\nempty results gracefully without raising exceptions.\n\nParameters\n----------\nbatch : int\n    Batch size (number of queries). Used to create result arrays with the\n    correct first dimension. Must be positive.\nwidth : int\n    Width of result arrays (number of results per query). Typically set to\n    min(top_k, available_candidates) to match expected output shape. Must be\n    positive.\n\nReturns\n-------\nnp.ndarray\n    Sentinel scores array with shape `(batch, width)` and dtype float32.\n    All values are set to minimum float32 (np.finfo(np.float32).min) to\n    indicate missing/invalid results. This ensures these positions are excluded\n    from any meaningful similarity comparisons.\nnp.ndarray\n    Sentinel IDs array with shape `(batch, width)` and dtype int64. All values\n    are set to -1 to indicate missing/invalid chunk identifiers. This sentinel\n    value is clearly distinguishable from valid chunk IDs (which are non-negative).\n\nNotes\n-----\nThis function is part of the exact reranking pipeline and provides graceful\nfallback when reranking cannot be performed. Time complexity: O(batch * width)\nfor array allocation and filling. The function performs no I/O operations and\nis thread-safe. Sentinel values are chosen to be clearly invalid (minimum float,\nnegative ID) so downstream code can easily detect and handle empty results.\nThis allows the reranking pipeline to return consistent shapes even when no\nvalid results are available.",
  "is_public": false
}
{
  "path": "retrieval/rerank_flat.py",
  "module": "retrieval.rerank_flat",
  "qualname": "FlatReranker",
  "name": "FlatReranker",
  "node_type": "ClassDef",
  "lineno": 582,
  "col": 0,
  "end_lineno": 640,
  "end_col": 9,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Rerank ANN candidates using exact similarities from DuckDB embeddings.",
  "is_public": true
}
{
  "path": "retrieval/rerank_flat.py",
  "module": "retrieval.rerank_flat",
  "qualname": "FlatReranker.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 585,
  "col": 4,
  "end_lineno": 587,
  "end_col": 29,
  "parent_qualname": "FlatReranker",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "retrieval/rerank_flat.py",
  "module": "retrieval.rerank_flat",
  "qualname": "FlatReranker.rerank",
  "name": "rerank",
  "node_type": "FunctionDef",
  "lineno": 589,
  "col": 4,
  "end_lineno": 640,
  "end_col": 9,
  "parent_qualname": "FlatReranker",
  "decorators": [],
  "bases": [],
  "docstring": "Return exact similarity scores and chunk ids.\n\nThis method performs exact reranking of candidate chunk IDs by computing\nexact similarity scores between query vectors and candidate embeddings\nretrieved from the catalog. It delegates to the internal reranking\nimplementation using the configured similarity metric (inner product or\ncosine similarity). The method returns the top-k reranked candidates\nsorted by exact similarity score.\n\nParameters\n----------\nqueries : np.ndarray\n    Query vectors with shape `(B, dim)` or `(dim,)` where B is the batch\n    size and dim is the embedding dimension. Automatically reshaped to 2D\n    if 1D. Dtype should be float32 or convertible to float32.\ncandidate_ids : np.ndarray\n    Candidate chunk identifiers with shape `(B, K')` where B matches the\n    query batch size and K' is the number of candidates per query. Dtype\n    should be int64 or convertible to int64. Negative IDs are treated as\n    invalid and filtered out.\ntop_k : int\n    Number of top results to return per query after reranking. Must be\n    positive. The method returns the top-k candidates sorted by exact\n    similarity score (descending order).\n\nReturns\n-------\nnp.ndarray\n    Reranked similarity scores with shape `(B, top_k)` and dtype float32.\n    Scores are exact similarity values (inner product or cosine similarity\n    depending on configured metric) sorted in descending order (highest\n    similarity first). Missing or invalid candidates are filled with\n    minimum float32 value.\nnp.ndarray\n    Reranked chunk IDs with shape `(B, top_k)` and dtype int64. IDs\n    correspond to the top-k scores and are aligned with the scores array.\n    Missing or invalid candidates are filled with -1.",
  "is_public": true
}
{
  "path": "retrieval/rerank_flat.py",
  "module": "retrieval.rerank_flat",
  "qualname": "exact_rerank",
  "name": "exact_rerank",
  "node_type": "FunctionDef",
  "lineno": 643,
  "col": 0,
  "end_lineno": 702,
  "end_col": 63,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Backward-compatible helper delegating to :class:`FlatReranker`.\n\nThis function provides a backward-compatible interface to exact reranking\nfunctionality. It creates a FlatReranker instance with the specified metric\nand delegates to its rerank() method. This function maintains compatibility\nwith existing code that calls exact_rerank() directly rather than using the\nFlatReranker class interface.\n\nParameters\n----------\ncatalog : DuckDBCatalog\n    DuckDB catalog instance providing embedding retrieval via\n    get_embeddings_by_ids(). The catalog must contain embeddings for the\n    candidate chunk IDs.\nqueries : np.ndarray\n    Query vectors with shape `(B, dim)` or `(dim,)` where B is the batch size\n    and dim is the embedding dimension. Automatically reshaped to 2D if 1D.\n    Dtype should be float32 or convertible to float32.\ncandidate_ids : np.ndarray\n    Candidate chunk identifiers with shape `(B, K')` where B matches the query\n    batch size and K' is the number of candidates per query. Dtype should be\n    int64 or convertible to int64. Negative IDs are treated as invalid.\ntop_k : int\n    Number of top results to return per query after reranking. Must be positive.\n    The function returns the top-k candidates sorted by exact similarity score.\nmetric : str, optional\n    Similarity metric to use: \"ip\" (inner product) or \"cos\" (cosine similarity).\n    Defaults to \"ip\". Cosine similarity normalizes both queries and candidates\n    to unit length before computation.\n\nReturns\n-------\nnp.ndarray\n    Reranked similarity scores with shape `(B, top_k)` and dtype float32.\n    Scores are exact similarity values sorted in descending order (highest\n    similarity first). Missing or invalid candidates are filled with minimum\n    float32 value.\nnp.ndarray\n    Reranked chunk IDs with shape `(B, top_k)` and dtype int64. IDs correspond\n    to the top-k scores and are aligned with the scores array. Missing or\n    invalid candidates are filled with -1.\n\nNotes\n-----\nThis function is a convenience wrapper around FlatReranker for backward\ncompatibility. New code should prefer using FlatReranker directly for better\nperformance (avoids creating a new instance on each call). The function\n    delegates all processing to FlatReranker.rerank() and returns the same\n    results. Thread-safe if the catalog instance is thread-safe.",
  "is_public": true
}
{
  "path": "retrieval/rm3_heuristics.py",
  "module": "retrieval.rm3_heuristics",
  "qualname": "retrieval.rm3_heuristics",
  "name": "retrieval.rm3_heuristics",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Heuristics for toggling RM3 pseudo-relevance feedback per query.",
  "is_public": true
}
{
  "path": "retrieval/rm3_heuristics.py",
  "module": "retrieval.rm3_heuristics",
  "qualname": "RM3Params",
  "name": "RM3Params",
  "node_type": "ClassDef",
  "lineno": 13,
  "col": 0,
  "end_lineno": 18,
  "end_col": 28,
  "parent_qualname": null,
  "decorators": [
    "dataclass(frozen=True)"
  ],
  "bases": [],
  "docstring": "Default RM3 parameters used when pseudo-relevance feedback is enabled.",
  "is_public": true
}
{
  "path": "retrieval/rm3_heuristics.py",
  "module": "retrieval.rm3_heuristics",
  "qualname": "RM3Heuristics",
  "name": "RM3Heuristics",
  "node_type": "ClassDef",
  "lineno": 21,
  "col": 0,
  "end_lineno": 123,
  "end_col": 35,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Lightweight heuristics to decide when RM3 should be enabled for a query.",
  "is_public": true
}
{
  "path": "retrieval/rm3_heuristics.py",
  "module": "retrieval.rm3_heuristics",
  "qualname": "RM3Heuristics.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 65,
  "col": 4,
  "end_lineno": 82,
  "end_col": 60,
  "parent_qualname": "RM3Heuristics",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "retrieval/rm3_heuristics.py",
  "module": "retrieval.rm3_heuristics",
  "qualname": "RM3Heuristics._tokenize",
  "name": "_tokenize",
  "node_type": "FunctionDef",
  "lineno": 85,
  "col": 4,
  "end_lineno": 86,
  "end_col": 87,
  "parent_qualname": "RM3Heuristics",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "retrieval/rm3_heuristics.py",
  "module": "retrieval.rm3_heuristics",
  "qualname": "RM3Heuristics._looks_symbolic",
  "name": "_looks_symbolic",
  "node_type": "FunctionDef",
  "lineno": 88,
  "col": 4,
  "end_lineno": 89,
  "end_col": 53,
  "parent_qualname": "RM3Heuristics",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "retrieval/rm3_heuristics.py",
  "module": "retrieval.rm3_heuristics",
  "qualname": "RM3Heuristics.should_enable",
  "name": "should_enable",
  "node_type": "FunctionDef",
  "lineno": 91,
  "col": 4,
  "end_lineno": 112,
  "end_col": 65,
  "parent_qualname": "RM3Heuristics",
  "decorators": [],
  "bases": [],
  "docstring": "Return ``True`` when RM3 should be used for ``query``.\n\nParameters\n----------\nquery : str\n    Search query string to evaluate.\n\nReturns\n-------\nbool\n    True if RM3 should be enabled based on query characteristics (short\n    queries, presence of head terms, non-symbolic queries), False otherwise.",
  "is_public": true
}
{
  "path": "retrieval/rm3_heuristics.py",
  "module": "retrieval.rm3_heuristics",
  "qualname": "RM3Heuristics.parameters",
  "name": "parameters",
  "node_type": "FunctionDef",
  "lineno": 114,
  "col": 4,
  "end_lineno": 123,
  "end_col": 35,
  "parent_qualname": "RM3Heuristics",
  "decorators": [],
  "bases": [],
  "docstring": "Return the RM3 parameters associated with this heuristic.\n\nReturns\n-------\nRM3Params\n    RM3 parameter configuration (expansion terms, original query weight,\n    etc.) used when RM3 is enabled.",
  "is_public": true
}
{
  "path": "retrieval/telemetry.py",
  "module": "retrieval.telemetry",
  "qualname": "retrieval.telemetry",
  "name": "retrieval.telemetry",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Stage-level telemetry helpers used by multi-stage retrieval pipelines.",
  "is_public": true
}
{
  "path": "retrieval/telemetry.py",
  "module": "retrieval.telemetry",
  "qualname": "StageTiming",
  "name": "StageTiming",
  "node_type": "ClassDef",
  "lineno": 17,
  "col": 0,
  "end_lineno": 38,
  "end_col": 9,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Snapshot describing how long a stage took relative to its budget.",
  "is_public": true
}
{
  "path": "retrieval/telemetry.py",
  "module": "retrieval.telemetry",
  "qualname": "StageTiming.as_payload",
  "name": "as_payload",
  "node_type": "FunctionDef",
  "lineno": 25,
  "col": 4,
  "end_lineno": 38,
  "end_col": 9,
  "parent_qualname": "StageTiming",
  "decorators": [],
  "bases": [],
  "docstring": "Return a JSON-friendly payload for inclusion in envelopes.\n\nReturns\n-------\ndict[str, float | int | bool | str | None]\n    Mapping containing stage timing metadata.",
  "is_public": true
}
{
  "path": "retrieval/telemetry.py",
  "module": "retrieval.telemetry",
  "qualname": "_TimerRuntime",
  "name": "_TimerRuntime",
  "node_type": "ClassDef",
  "lineno": 41,
  "col": 0,
  "end_lineno": 79,
  "end_col": 31,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Mutable stopwatch backing the frozen stage timer.",
  "is_public": false
}
{
  "path": "retrieval/telemetry.py",
  "module": "retrieval.telemetry",
  "qualname": "_TimerRuntime.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 46,
  "col": 4,
  "end_lineno": 49,
  "end_col": 28,
  "parent_qualname": "_TimerRuntime",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "retrieval/telemetry.py",
  "module": "retrieval.telemetry",
  "qualname": "_TimerRuntime.stop",
  "name": "stop",
  "node_type": "FunctionDef",
  "lineno": 51,
  "col": 4,
  "end_lineno": 79,
  "end_col": 31,
  "parent_qualname": "_TimerRuntime",
  "decorators": [],
  "bases": [],
  "docstring": "Stop the timer and compute elapsed duration.\n\nExtended Summary\n----------------\nThis method stops the timer by computing the elapsed time since start\nand marking the timer as stopped. The duration is computed in milliseconds\nusing high-resolution monotonic time for accuracy. If the timer is already\nstopped, returns the previously computed duration (idempotent). Used by\n_StageTimer to capture stage execution times for telemetry.\n\nReturns\n-------\nfloat\n    Elapsed duration in milliseconds. Returns the previously computed\n    duration if the timer was already stopped (idempotent operation).\n\nNotes\n-----\nTime complexity O(1) - single time calculation. Space complexity O(1).\nUses time.perf_counter() for high-resolution monotonic time. The method is\nidempotent: calling stop() multiple times returns the same duration. Thread-safe\nif used within a single thread context (not designed for concurrent access).",
  "is_public": true
}
{
  "path": "retrieval/telemetry.py",
  "module": "retrieval.telemetry",
  "qualname": "_StageTimer",
  "name": "_StageTimer",
  "node_type": "ClassDef",
  "lineno": 83,
  "col": 0,
  "end_lineno": 143,
  "end_col": 9,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "retrieval/telemetry.py",
  "module": "retrieval.telemetry",
  "qualname": "_StageTimer.stop",
  "name": "stop",
  "node_type": "FunctionDef",
  "lineno": 88,
  "col": 4,
  "end_lineno": 106,
  "end_col": 28,
  "parent_qualname": "_StageTimer",
  "decorators": [],
  "bases": [],
  "docstring": "Stop the stage timer and finalize duration measurement.\n\nExtended Summary\n----------------\nThis method stops the underlying timer runtime, finalizing the duration\nmeasurement. The timer is automatically stopped when exiting the track_stage()\ncontext manager, but can be manually stopped earlier if needed. After stopping,\nthe timer can still be converted to StageTiming via snapshot(). Used to\nexplicitly finalize timing measurements before context exit.\n\nNotes\n-----\nTime complexity O(1) - delegates to runtime stop(). Space complexity O(1).\nThe method is idempotent: calling stop() multiple times is safe. The timer\nis automatically stopped by track_stage() context manager on exit, so manual\nstopping is typically unnecessary.",
  "is_public": true
}
{
  "path": "retrieval/telemetry.py",
  "module": "retrieval.telemetry",
  "qualname": "_StageTimer.snapshot",
  "name": "snapshot",
  "node_type": "FunctionDef",
  "lineno": 108,
  "col": 4,
  "end_lineno": 143,
  "end_col": 9,
  "parent_qualname": "_StageTimer",
  "decorators": [],
  "bases": [],
  "docstring": "Capture a timing snapshot with budget comparison.\n\nExtended Summary\n----------------\nThis method creates a StageTiming snapshot containing the stage name, elapsed\nduration, budget (if set), and whether the budget was exceeded. The snapshot\nis used for telemetry and observability, enabling performance monitoring and\nbudget-based gating decisions. The timer is stopped (if not already stopped)\nbefore creating the snapshot to ensure accurate duration measurement.\n\nReturns\n-------\nStageTiming\n    Immutable timing snapshot containing:\n    - name: Stage identifier\n    - duration_ms: Elapsed time in milliseconds\n    - budget_ms: Optional time budget in milliseconds\n    - exceeded_budget: Boolean indicating if duration exceeded budget\n\nNotes\n-----\nTime complexity O(1) - single stop() call plus object creation. Space\ncomplexity O(1) for the StageTiming object. The method stops the timer if\nnot already stopped, ensuring accurate duration measurement. Budget comparison\nis performed using simple numeric comparison (duration > budget_ms). The snapshot\nis immutable and can be safely stored or passed to telemetry functions.",
  "is_public": true
}
{
  "path": "retrieval/telemetry.py",
  "module": "retrieval.telemetry",
  "qualname": "track_stage",
  "name": "track_stage",
  "node_type": "FunctionDef",
  "lineno": 147,
  "col": 0,
  "end_lineno": 190,
  "end_col": 20,
  "parent_qualname": null,
  "decorators": [
    "contextmanager"
  ],
  "bases": [],
  "docstring": "Context manager yielding a timer that can be converted into StageTiming.\n\nExtended Summary\n----------------\nThis context manager provides stage-level timing and observability for retrieval\npipeline stages. It creates a timer that automatically captures start/stop times\nand can be converted to StageTiming objects for telemetry. The timer tracks\nelapsed time and compares it against an optional budget, enabling performance\nmonitoring and budget-based gating decisions. This is used throughout the retrieval\npipeline to instrument stage execution times.\n\nParameters\n----------\nname : str\n    Stage name identifier for telemetry and logging. Used to label metrics and\n    identify the stage in observability dashboards.\nbudget_ms : int | None, optional\n    Optional time budget in milliseconds. If provided, the timer compares elapsed\n    time against this budget. Used for adaptive gating decisions. Defaults to None.\n\nYields\n------\n_StageTimer\n    Timer instance used to capture duration metrics. The timer is automatically\n    started when entering the context and stopped when exiting. Can be converted\n    to StageTiming via timer.as_timing().\n\nNotes\n-----\nTime complexity O(1) for timer operations. Space complexity O(1) aside from the\ntimer object. The function performs no I/O but captures system time via\ntime.monotonic(). Thread-safe if used within a single thread context. The timer\nis automatically stopped even if an exception occurs within the context.",
  "is_public": true
}
{
  "path": "retrieval/telemetry.py",
  "module": "retrieval.telemetry",
  "qualname": "record_stage_metric",
  "name": "record_stage_metric",
  "node_type": "FunctionDef",
  "lineno": 201,
  "col": 0,
  "end_lineno": 223,
  "end_col": 9,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Record the provided ``timing`` in Prometheus metrics.",
  "is_public": true
}
{
  "path": "retrieval/telemetry.py",
  "module": "retrieval.telemetry",
  "qualname": "record_stage_decision",
  "name": "record_stage_decision",
  "node_type": "FunctionDef",
  "lineno": 226,
  "col": 0,
  "end_lineno": 238,
  "end_col": 11,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Increment the stage decision counter for the given outcome.",
  "is_public": true
}
{
  "path": "retrieval/types.py",
  "module": "retrieval.types",
  "qualname": "retrieval.types",
  "name": "retrieval.types",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Shared retrieval dataclasses for multi-stage pipelines.",
  "is_public": true
}
{
  "path": "retrieval/types.py",
  "module": "retrieval.types",
  "qualname": "SearchHit",
  "name": "SearchHit",
  "node_type": "ClassDef",
  "lineno": 15,
  "col": 0,
  "end_lineno": 23,
  "end_col": 63,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Single retrieval hit emitted by FAISS/BM25/SPLADE/XTR stages.",
  "is_public": true
}
{
  "path": "retrieval/types.py",
  "module": "retrieval.types",
  "qualname": "SearchPoolRow",
  "name": "SearchPoolRow",
  "node_type": "ClassDef",
  "lineno": 27,
  "col": 0,
  "end_lineno": 35,
  "end_col": 60,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Structured row recorded in evaluator pools.",
  "is_public": true
}
{
  "path": "retrieval/types.py",
  "module": "retrieval.types",
  "qualname": "HybridResultDoc",
  "name": "HybridResultDoc",
  "node_type": "ClassDef",
  "lineno": 39,
  "col": 0,
  "end_lineno": 43,
  "end_col": 16,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Final fused result produced by weighted RRF.",
  "is_public": true
}
{
  "path": "retrieval/types.py",
  "module": "retrieval.types",
  "qualname": "HybridSearchResult",
  "name": "HybridSearchResult",
  "node_type": "ClassDef",
  "lineno": 47,
  "col": 0,
  "end_lineno": 54,
  "end_col": 46,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Container for fused docs alongside explainability metadata.",
  "is_public": true
}
{
  "path": "retrieval/types.py",
  "module": "retrieval.types",
  "qualname": "StageSignals",
  "name": "StageSignals",
  "node_type": "ClassDef",
  "lineno": 58,
  "col": 0,
  "end_lineno": 76,
  "end_col": 55,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Signals gathered from a stage for downstream gating decisions.",
  "is_public": true
}
{
  "path": "retrieval/types.py",
  "module": "retrieval.types",
  "qualname": "StageSignals.margin",
  "name": "margin",
  "node_type": "FunctionDef",
  "lineno": 66,
  "col": 4,
  "end_lineno": 76,
  "end_col": 55,
  "parent_qualname": "StageSignals",
  "decorators": [],
  "bases": [],
  "docstring": "Return score gap between best and runner-up when available.\n\nReturns\n-------\nfloat | None\n    Score margin or ``None`` when insufficient data exists.",
  "is_public": true
}
{
  "path": "retrieval/types.py",
  "module": "retrieval.types",
  "qualname": "StageDecision",
  "name": "StageDecision",
  "node_type": "ClassDef",
  "lineno": 80,
  "col": 0,
  "end_lineno": 85,
  "end_col": 31,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Decision emitted by gating logic describing whether to run the stage.",
  "is_public": true
}
{
  "path": "risk_hotspots.py",
  "module": "risk_hotspots",
  "qualname": "risk_hotspots",
  "name": "risk_hotspots",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Hotspot scoring utilities.",
  "is_public": true
}
{
  "path": "risk_hotspots.py",
  "module": "risk_hotspots",
  "qualname": "compute_hotspot_score",
  "name": "compute_hotspot_score",
  "node_type": "FunctionDef",
  "lineno": 29,
  "col": 0,
  "end_lineno": 59,
  "end_col": 37,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Compute a heuristic hotspot score for a module record.\n\nParameters\n----------\nrecord : dict[str, Any]\n    Module metadata dictionary containing metrics such as fan_in, fan_out,\n    complexity, type_errors, untyped_defs, covered_lines_ratio, and path.\n\nReturns\n-------\nfloat\n    Score in the range ``[0, 10]`` representing relative risk.",
  "is_public": true
}
{
  "path": "risk_hotspots.py",
  "module": "risk_hotspots",
  "qualname": "_git_churn",
  "name": "_git_churn",
  "node_type": "FunctionDef",
  "lineno": 63,
  "col": 0,
  "end_lineno": 94,
  "end_col": 16,
  "parent_qualname": null,
  "decorators": [
    "lru_cache(maxsize=2048)"
  ],
  "bases": [],
  "docstring": "Return the number of commits touching ``path``.\n\nThis function queries Git history to count the number of commits that modified\na specific file path. The function uses GitPython when available, or returns\nzero when Git is unavailable or the repository cannot be accessed.\n\nParameters\n----------\npath : str\n    Repository-relative file path to query commit history for. The path is\n    used to filter Git commits that modified this specific file. Must be a\n    valid path within the repository.\n\nReturns\n-------\nint\n    Number of commits that touched the specified path. Returns 0 when Git is\n    unavailable, the repository cannot be opened, or the path has no commit\n    history. Used as a churn metric for risk hotspot analysis.",
  "is_public": false
}
{
  "path": "risk_hotspots.py",
  "module": "risk_hotspots",
  "qualname": "_open_repo",
  "name": "_open_repo",
  "node_type": "FunctionDef",
  "lineno": 98,
  "col": 0,
  "end_lineno": 113,
  "end_col": 19,
  "parent_qualname": null,
  "decorators": [
    "lru_cache(maxsize=1)"
  ],
  "bases": [],
  "docstring": "Open project Git repository for analytics.\n\nReturns\n-------\nGitRepoType | None\n    Git repository handle or ``None`` if GitPython unavailable.",
  "is_public": false
}
{
  "path": "risk_hotspots.py",
  "module": "risk_hotspots",
  "qualname": "_repo_root",
  "name": "_repo_root",
  "node_type": "FunctionDef",
  "lineno": 117,
  "col": 0,
  "end_lineno": 125,
  "end_col": 46,
  "parent_qualname": null,
  "decorators": [
    "lru_cache(maxsize=1)"
  ],
  "bases": [],
  "docstring": "Return repository root path.\n\nReturns\n-------\nPath\n    Absolute path to the repository root (two levels up from this file).",
  "is_public": false
}
{
  "path": "runtime/__init__.py",
  "module": "runtime",
  "qualname": "runtime",
  "name": "runtime",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Runtime helpers for mutable, closeable state.",
  "is_public": true
}
{
  "path": "runtime/cells.py",
  "module": "runtime.cells",
  "qualname": "runtime.cells",
  "name": "runtime.cells",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Thread-safe runtime cell primitive for mutable subsystems.",
  "is_public": true
}
{
  "path": "runtime/cells.py",
  "module": "runtime.cells",
  "qualname": "RuntimeCellCloseResult",
  "name": "RuntimeCellCloseResult",
  "node_type": "ClassDef",
  "lineno": 31,
  "col": 0,
  "end_lineno": 39,
  "end_col": 27,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Immutable payload describing close outcome.",
  "is_public": true
}
{
  "path": "runtime/cells.py",
  "module": "runtime.cells",
  "qualname": "RuntimeCellInitContext",
  "name": "RuntimeCellInitContext",
  "node_type": "ClassDef",
  "lineno": 43,
  "col": 0,
  "end_lineno": 48,
  "end_col": 29,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Request-scoped metadata captured during initialization.",
  "is_public": true
}
{
  "path": "runtime/cells.py",
  "module": "runtime.cells",
  "qualname": "RuntimeCellInitResult",
  "name": "RuntimeCellInitResult",
  "node_type": "ClassDef",
  "lineno": 52,
  "col": 0,
  "end_lineno": 61,
  "end_col": 42,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Immutable payload describing initialization outcome.",
  "is_public": true
}
{
  "path": "runtime/cells.py",
  "module": "runtime.cells",
  "qualname": "_seed_allowed",
  "name": "_seed_allowed",
  "node_type": "FunctionDef",
  "lineno": 64,
  "col": 0,
  "end_lineno": 67,
  "end_col": 61,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "runtime/cells.py",
  "module": "runtime.cells",
  "qualname": "RuntimeCellObserver",
  "name": "RuntimeCellObserver",
  "node_type": "ClassDef",
  "lineno": 71,
  "col": 0,
  "end_lineno": 87,
  "end_col": 65,
  "parent_qualname": null,
  "decorators": [
    "runtime_checkable"
  ],
  "bases": [
    "Protocol"
  ],
  "docstring": "Protocol for observing RuntimeCell lifecycle events.",
  "is_public": true
}
{
  "path": "runtime/cells.py",
  "module": "runtime.cells",
  "qualname": "RuntimeCellObserver.on_init_start",
  "name": "on_init_start",
  "node_type": "FunctionDef",
  "lineno": 74,
  "col": 4,
  "end_lineno": 81,
  "end_col": 50,
  "parent_qualname": "RuntimeCellObserver",
  "decorators": [],
  "bases": [],
  "docstring": "Invoke before initialization begins.",
  "is_public": true
}
{
  "path": "runtime/cells.py",
  "module": "runtime.cells",
  "qualname": "RuntimeCellObserver.on_init_end",
  "name": "on_init_end",
  "node_type": "FunctionDef",
  "lineno": 83,
  "col": 4,
  "end_lineno": 84,
  "end_col": 68,
  "parent_qualname": "RuntimeCellObserver",
  "decorators": [],
  "bases": [],
  "docstring": "Handle completion (success/failure) of initialization.",
  "is_public": true
}
{
  "path": "runtime/cells.py",
  "module": "runtime.cells",
  "qualname": "RuntimeCellObserver.on_close_end",
  "name": "on_close_end",
  "node_type": "FunctionDef",
  "lineno": 86,
  "col": 4,
  "end_lineno": 87,
  "end_col": 65,
  "parent_qualname": "RuntimeCellObserver",
  "decorators": [],
  "bases": [],
  "docstring": "Handle completion (success/failure) of ``close()``.",
  "is_public": true
}
{
  "path": "runtime/cells.py",
  "module": "runtime.cells",
  "qualname": "NullRuntimeCellObserver",
  "name": "NullRuntimeCellObserver",
  "node_type": "ClassDef",
  "lineno": 90,
  "col": 0,
  "end_lineno": 113,
  "end_col": 17,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "No-op observer used when instrumentation is disabled.",
  "is_public": true
}
{
  "path": "runtime/cells.py",
  "module": "runtime.cells",
  "qualname": "NullRuntimeCellObserver.on_init_start",
  "name": "on_init_start",
  "node_type": "FunctionDef",
  "lineno": 95,
  "col": 4,
  "end_lineno": 103,
  "end_col": 45,
  "parent_qualname": "NullRuntimeCellObserver",
  "decorators": [],
  "bases": [],
  "docstring": "No-op observer hook.",
  "is_public": true
}
{
  "path": "runtime/cells.py",
  "module": "runtime.cells",
  "qualname": "NullRuntimeCellObserver.on_init_end",
  "name": "on_init_end",
  "node_type": "FunctionDef",
  "lineno": 105,
  "col": 4,
  "end_lineno": 108,
  "end_col": 17,
  "parent_qualname": "NullRuntimeCellObserver",
  "decorators": [],
  "bases": [],
  "docstring": "No-op observer hook.",
  "is_public": true
}
{
  "path": "runtime/cells.py",
  "module": "runtime.cells",
  "qualname": "NullRuntimeCellObserver.on_close_end",
  "name": "on_close_end",
  "node_type": "FunctionDef",
  "lineno": 110,
  "col": 4,
  "end_lineno": 113,
  "end_col": 17,
  "parent_qualname": "NullRuntimeCellObserver",
  "decorators": [],
  "bases": [],
  "docstring": "No-op observer hook.",
  "is_public": true
}
{
  "path": "runtime/cells.py",
  "module": "runtime.cells",
  "qualname": "RuntimeCell",
  "name": "RuntimeCell",
  "node_type": "ClassDef",
  "lineno": 117,
  "col": 0,
  "end_lineno": 626,
  "end_col": 9,
  "parent_qualname": null,
  "decorators": [
    "final"
  ],
  "bases": [],
  "docstring": "Thread-safe lazy holder for mutable runtime state with single-flight init.",
  "is_public": true
}
{
  "path": "runtime/cells.py",
  "module": "runtime.cells",
  "qualname": "RuntimeCell.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 139,
  "col": 4,
  "end_lineno": 162,
  "end_col": 63,
  "parent_qualname": "RuntimeCell",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "runtime/cells.py",
  "module": "runtime.cells",
  "qualname": "RuntimeCell.__repr__",
  "name": "__repr__",
  "node_type": "FunctionDef",
  "lineno": 164,
  "col": 4,
  "end_lineno": 172,
  "end_col": 71,
  "parent_qualname": "RuntimeCell",
  "decorators": [],
  "bases": [],
  "docstring": "Return a concise representation without exposing payload internals.\n\nReturns\n-------\nstr\n    Debug-friendly representation.",
  "is_public": false
}
{
  "path": "runtime/cells.py",
  "module": "runtime.cells",
  "qualname": "RuntimeCell.__bool__",
  "name": "__bool__",
  "node_type": "FunctionDef",
  "lineno": 174,
  "col": 4,
  "end_lineno": 182,
  "end_col": 38,
  "parent_qualname": "RuntimeCell",
  "decorators": [],
  "bases": [],
  "docstring": "Return ``True`` when the cell currently holds a value.\n\nReturns\n-------\nbool\n    ``True`` when a payload is cached.",
  "is_public": false
}
{
  "path": "runtime/cells.py",
  "module": "runtime.cells",
  "qualname": "RuntimeCell.peek",
  "name": "peek",
  "node_type": "FunctionDef",
  "lineno": 184,
  "col": 4,
  "end_lineno": 193,
  "end_col": 30,
  "parent_qualname": "RuntimeCell",
  "decorators": [],
  "bases": [],
  "docstring": "Return the cached payload without triggering initialization.\n\nReturns\n-------\nT | None\n    Cached payload when present, otherwise ``None``.",
  "is_public": true
}
{
  "path": "runtime/cells.py",
  "module": "runtime.cells",
  "qualname": "RuntimeCell.configure_observer",
  "name": "configure_observer",
  "node_type": "FunctionDef",
  "lineno": 195,
  "col": 4,
  "end_lineno": 198,
  "end_col": 37,
  "parent_qualname": "RuntimeCell",
  "decorators": [],
  "bases": [],
  "docstring": "Attach an observer that receives lifecycle callbacks.",
  "is_public": true
}
{
  "path": "runtime/cells.py",
  "module": "runtime.cells",
  "qualname": "RuntimeCell.configure_adjuster",
  "name": "configure_adjuster",
  "node_type": "FunctionDef",
  "lineno": 200,
  "col": 4,
  "end_lineno": 206,
  "end_col": 37,
  "parent_qualname": "RuntimeCell",
  "decorators": [],
  "bases": [],
  "docstring": "Attach a factory adjuster that can wrap the initializer.",
  "is_public": true
}
{
  "path": "runtime/cells.py",
  "module": "runtime.cells",
  "qualname": "RuntimeCell.get_or_initialize",
  "name": "get_or_initialize",
  "node_type": "FunctionDef",
  "lineno": 208,
  "col": 4,
  "end_lineno": 286,
  "end_col": 9,
  "parent_qualname": "RuntimeCell",
  "decorators": [],
  "bases": [],
  "docstring": "Return or initialize the payload with single-flight semantics.\n\nExtended Summary\n----------------\nThis method returns the cached payload if available, or initializes it using\nthe provided factory function with single-flight semantics (only one thread\ninitializes at a time). It handles cooldown periods, waits for initialization,\nand tracks generation numbers to detect stale values. Used to lazily initialize\nruntime resources (FAISS indexes, hybrid search, etc.) with thread-safe\ncaching and error recovery.\n\nParameters\n----------\nfactory : Callable[[], T]\n    Factory function that creates the payload instance. Called only when\n    initialization is needed. The factory is adjusted by the factory adjuster\n    before invocation.\n\nReturns\n-------\nT\n    Cached payload instance. The instance is thread-safe and shared across\n    all callers until the cell is closed or reset.\n\nRaises\n------\nRuntimeError\n    Raised when generation tracking becomes inconsistent (defensive check).\n    Also raised when the initialization generation is missing (should not occur\n    in normal operation).\nBaseException\n    Any exception stored in the cell from a previous initialization failure\n    is re-raised during cooldown periods. The exception is stored in\n    `_cooldown_error` (typed as Exception | None) and re-raised via the\n    `cooldown_error` variable (typed as BaseException | None) when cooldown\n    periods are active. The specific exception type depends on what was raised\n    during the previous initialization attempt (e.g., RuntimeError,\n    RuntimeUnavailableError, RuntimeLifecycleError, or any other BaseException\n    subclass). The exception is re-raised using `raise cooldown_error` where\n    `cooldown_error` is a variable containing the stored exception. Note: The\n    exception is re-raised using a variable, so pydoclint may flag this as\n    DOC503, but the exception is correctly propagated and documented.\n\nNotes\n-----\nThis method implements single-flight initialization: only one thread initializes\nwhile others wait. It handles cooldown periods after failures and tracks generation\nnumbers to detect stale values. Time complexity: O(1) when cached, O(init_time)\nwhen initialization is needed.",
  "is_public": true
}
{
  "path": "runtime/cells.py",
  "module": "runtime.cells",
  "qualname": "RuntimeCell.seed",
  "name": "seed",
  "node_type": "FunctionDef",
  "lineno": 288,
  "col": 4,
  "end_lineno": 316,
  "end_col": 40,
  "parent_qualname": "RuntimeCell",
  "decorators": [],
  "bases": [],
  "docstring": "Inject a payload for tests when the cell is empty.\n\nParameters\n----------\nvalue : T\n    Payload instance to cache for subsequent calls.\n\nRaises\n------\nRuntimeError\n    If seeding is attempted outside a test context or the cell is already\n    initialized.",
  "is_public": true
}
{
  "path": "runtime/cells.py",
  "module": "runtime.cells",
  "qualname": "RuntimeCell.close",
  "name": "close",
  "node_type": "FunctionDef",
  "lineno": 318,
  "col": 4,
  "end_lineno": 442,
  "end_col": 13,
  "parent_qualname": "RuntimeCell",
  "decorators": [],
  "bases": [],
  "docstring": "Clear the payload and attempt to release runtime resources.\n\nParameters\n----------\nsilent : bool, optional\n    When ``True`` (default), disposal errors are logged and suppressed.\n    When ``False``, exceptions raised by the payload's disposal propagate.\n\nRaises\n------\nAttributeError\n    Propagated when ``silent=False`` and the payload lacks a close method.\nOSError\n    Propagated when ``silent=False`` and file/resource cleanup fails.\nRuntimeError\n    Propagated when ``silent=False`` and runtime state errors occur.\nException\n    Any other exception raised by the payload's disposal is propagated when\n    ``silent=False``. When ``silent=True`` (default), all exceptions are caught\n    and logged.",
  "is_public": true
}
{
  "path": "runtime/cells.py",
  "module": "runtime.cells",
  "qualname": "RuntimeCell.invalidate",
  "name": "invalidate",
  "node_type": "FunctionDef",
  "lineno": 444,
  "col": 4,
  "end_lineno": 446,
  "end_col": 20,
  "parent_qualname": "RuntimeCell",
  "decorators": [],
  "bases": [],
  "docstring": "Mark the cached payload as stale and schedule lazy re-initialization.",
  "is_public": true
}
{
  "path": "runtime/cells.py",
  "module": "runtime.cells",
  "qualname": "RuntimeCell.record_failure",
  "name": "record_failure",
  "node_type": "FunctionDef",
  "lineno": 448,
  "col": 4,
  "end_lineno": 458,
  "end_col": 40,
  "parent_qualname": "RuntimeCell",
  "decorators": [],
  "bases": [],
  "docstring": "Cache a failure result to avoid hot-looping initialization attempts.",
  "is_public": true
}
{
  "path": "runtime/cells.py",
  "module": "runtime.cells",
  "qualname": "RuntimeCell._resolve_disposer",
  "name": "_resolve_disposer",
  "node_type": "FunctionDef",
  "lineno": 461,
  "col": 4,
  "end_lineno": 479,
  "end_col": 26,
  "parent_qualname": "RuntimeCell",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "runtime/cells.py",
  "module": "runtime.cells",
  "qualname": "RuntimeCell._resolve_disposer._run_close",
  "name": "_run_close",
  "node_type": "FunctionDef",
  "lineno": 466,
  "col": 12,
  "end_lineno": 467,
  "end_col": 32,
  "parent_qualname": "RuntimeCell._resolve_disposer",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "runtime/cells.py",
  "module": "runtime.cells",
  "qualname": "RuntimeCell._resolve_disposer._run_exit",
  "name": "_run_exit",
  "node_type": "FunctionDef",
  "lineno": 475,
  "col": 12,
  "end_lineno": 476,
  "end_col": 47,
  "parent_qualname": "RuntimeCell._resolve_disposer",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "runtime/cells.py",
  "module": "runtime.cells",
  "qualname": "RuntimeCell._adjust_factory",
  "name": "_adjust_factory",
  "node_type": "FunctionDef",
  "lineno": 481,
  "col": 4,
  "end_lineno": 482,
  "end_col": 70,
  "parent_qualname": "RuntimeCell",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "runtime/cells.py",
  "module": "runtime.cells",
  "qualname": "RuntimeCell._capture_init_context",
  "name": "_capture_init_context",
  "node_type": "FunctionDef",
  "lineno": 485,
  "col": 4,
  "end_lineno": 495,
  "end_col": 9,
  "parent_qualname": "RuntimeCell",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "runtime/cells.py",
  "module": "runtime.cells",
  "qualname": "RuntimeCell._next_generation_locked",
  "name": "_next_generation_locked",
  "node_type": "FunctionDef",
  "lineno": 497,
  "col": 4,
  "end_lineno": 499,
  "end_col": 39,
  "parent_qualname": "RuntimeCell",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "runtime/cells.py",
  "module": "runtime.cells",
  "qualname": "RuntimeCell._clear_cooldown_locked",
  "name": "_clear_cooldown_locked",
  "node_type": "FunctionDef",
  "lineno": 501,
  "col": 4,
  "end_lineno": 503,
  "end_col": 35,
  "parent_qualname": "RuntimeCell",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "runtime/cells.py",
  "module": "runtime.cells",
  "qualname": "RuntimeCell._cooldown_error_locked",
  "name": "_cooldown_error_locked",
  "node_type": "FunctionDef",
  "lineno": 505,
  "col": 4,
  "end_lineno": 512,
  "end_col": 55,
  "parent_qualname": "RuntimeCell",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "runtime/cells.py",
  "module": "runtime.cells",
  "qualname": "RuntimeCell._wait_for_initializer",
  "name": "_wait_for_initializer",
  "node_type": "FunctionDef",
  "lineno": 514,
  "col": 4,
  "end_lineno": 537,
  "end_col": 35,
  "parent_qualname": "RuntimeCell",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "runtime/cells.py",
  "module": "runtime.cells",
  "qualname": "RuntimeCell._run_initializer",
  "name": "_run_initializer",
  "node_type": "FunctionDef",
  "lineno": 539,
  "col": 4,
  "end_lineno": 556,
  "end_col": 22,
  "parent_qualname": "RuntimeCell",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "runtime/cells.py",
  "module": "runtime.cells",
  "qualname": "RuntimeCell._handle_init_success",
  "name": "_handle_init_success",
  "node_type": "FunctionDef",
  "lineno": 558,
  "col": 4,
  "end_lineno": 592,
  "end_col": 9,
  "parent_qualname": "RuntimeCell",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "runtime/cells.py",
  "module": "runtime.cells",
  "qualname": "RuntimeCell._handle_init_failure",
  "name": "_handle_init_failure",
  "node_type": "FunctionDef",
  "lineno": 594,
  "col": 4,
  "end_lineno": 626,
  "end_col": 9,
  "parent_qualname": "RuntimeCell",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "runtime/factory_adjustment.py",
  "module": "runtime.factory_adjustment",
  "qualname": "runtime.factory_adjustment",
  "name": "runtime.factory_adjustment",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Factory adjustment hooks for RuntimeCell initialization.",
  "is_public": true
}
{
  "path": "runtime/factory_adjustment.py",
  "module": "runtime.factory_adjustment",
  "qualname": "FactoryAdjuster",
  "name": "FactoryAdjuster",
  "node_type": "ClassDef",
  "lineno": 13,
  "col": 0,
  "end_lineno": 43,
  "end_col": 11,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "Protocol"
  ],
  "docstring": "Protocol for wrapping runtime cell factory functions.",
  "is_public": true
}
{
  "path": "runtime/factory_adjustment.py",
  "module": "runtime.factory_adjustment",
  "qualname": "FactoryAdjuster.adjust",
  "name": "adjust",
  "node_type": "FunctionDef",
  "lineno": 16,
  "col": 4,
  "end_lineno": 43,
  "end_col": 11,
  "parent_qualname": "FactoryAdjuster",
  "decorators": [],
  "bases": [],
  "docstring": "Return a possibly wrapped factory for the given runtime.\n\nExtended Summary\n----------------\nThis protocol method adjusts factory functions for runtime cells by wrapping\nthem with tuning hooks. Implementations may apply runtime-specific configuration\n(e.g., FAISS nprobe, hybrid search weights) after object creation. Used by\nRuntimeCell to customize runtime initialization based on application settings.\n\nParameters\n----------\ncell : str\n    Runtime cell identifier (e.g., \"coderank-faiss\", \"hybrid\", \"xtr\"). Used\n    to determine which tuning hooks to apply.\nfactory : Callable[[], T]\n    Original factory function that creates the runtime object. May be wrapped\n    or returned unchanged.\n\nReturns\n-------\nCallable[[], T]\n    Factory callable invoked by :class:`RuntimeCell`. May be the original\n    factory or a wrapped version that applies tuning hooks.",
  "is_public": true
}
{
  "path": "runtime/factory_adjustment.py",
  "module": "runtime.factory_adjustment",
  "qualname": "NoopFactoryAdjuster",
  "name": "NoopFactoryAdjuster",
  "node_type": "ClassDef",
  "lineno": 47,
  "col": 0,
  "end_lineno": 71,
  "end_col": 22,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Default adjuster that returns the original factory.",
  "is_public": true
}
{
  "path": "runtime/factory_adjustment.py",
  "module": "runtime.factory_adjustment",
  "qualname": "NoopFactoryAdjuster.adjust",
  "name": "adjust",
  "node_type": "FunctionDef",
  "lineno": 50,
  "col": 4,
  "end_lineno": 71,
  "end_col": 22,
  "parent_qualname": "NoopFactoryAdjuster",
  "decorators": [],
  "bases": [],
  "docstring": "Return ``factory`` unchanged.\n\nExtended Summary\n----------------\nThis no-op adjuster returns the factory function unchanged without applying\nany tuning hooks. Used when factory adjustment is disabled or not needed.\n\nParameters\n----------\ncell : str\n    Runtime cell identifier (unused by this adjuster).\nfactory : Callable[[], T]\n    Original factory function to return unchanged.\n\nReturns\n-------\nCallable[[], T]\n    Original factory callable, returned without modification.",
  "is_public": true
}
{
  "path": "runtime/factory_adjustment.py",
  "module": "runtime.factory_adjustment",
  "qualname": "DefaultFactoryAdjuster",
  "name": "DefaultFactoryAdjuster",
  "node_type": "ClassDef",
  "lineno": 75,
  "col": 0,
  "end_lineno": 222,
  "end_col": 19,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Reference adjuster that tunes common runtimes after creation.",
  "is_public": true
}
{
  "path": "runtime/factory_adjustment.py",
  "module": "runtime.factory_adjustment",
  "qualname": "DefaultFactoryAdjuster.adjust",
  "name": "adjust",
  "node_type": "FunctionDef",
  "lineno": 86,
  "col": 4,
  "end_lineno": 118,
  "end_col": 22,
  "parent_qualname": "DefaultFactoryAdjuster",
  "decorators": [],
  "bases": [],
  "docstring": "Return a wrapped factory when tuning hooks are known.\n\nExtended Summary\n----------------\nThis adjuster wraps factory functions with runtime-specific tuning hooks based\non the cell identifier. It applies FAISS tuning (nprobe, GPU preference), hybrid\nsearch tuning (RRF k, channel weights), or XTR tuning based on the cell name.\nUsed to customize runtime initialization from application settings.\n\nParameters\n----------\ncell : str\n    Runtime cell identifier (e.g., \"coderank-faiss\", \"hybrid\", \"xtr\"). Determines\n    which tuning hooks to apply. Underscores are normalized to hyphens.\nfactory : Callable[[], T]\n    Original factory function that creates the runtime object. Wrapped with\n    tuning hooks if the cell matches known patterns.\n\nReturns\n-------\nCallable[[], T]\n    Either the original factory (if no tuning hooks match) or a wrapped factory\n    that applies runtime-specific configuration after object creation.",
  "is_public": true
}
{
  "path": "runtime/factory_adjustment.py",
  "module": "runtime.factory_adjustment",
  "qualname": "DefaultFactoryAdjuster._wrap_faiss",
  "name": "_wrap_faiss",
  "node_type": "FunctionDef",
  "lineno": 120,
  "col": 4,
  "end_lineno": 158,
  "end_col": 23,
  "parent_qualname": "DefaultFactoryAdjuster",
  "decorators": [],
  "bases": [],
  "docstring": "Apply FAISS-specific tuning hooks.\n\nExtended Summary\n----------------\nThis helper wraps a FAISS factory function with tuning hooks that apply\nnprobe and GPU preference settings after object creation. It handles both\nsetter methods and attribute assignment, suppressing errors if tuning fails.\n\nParameters\n----------\nbase : Callable[[], T]\n    Original FAISS factory function that creates the FAISS manager or index.\n\nReturns\n-------\nCallable[[], T]\n    Wrapped factory that enforces FAISS settings (nprobe, GPU preference)\n    after object creation. Tuning failures are suppressed.",
  "is_public": false
}
{
  "path": "runtime/factory_adjustment.py",
  "module": "runtime.factory_adjustment",
  "qualname": "DefaultFactoryAdjuster._wrap_faiss._wrapped",
  "name": "_wrapped",
  "node_type": "FunctionDef",
  "lineno": 141,
  "col": 8,
  "end_lineno": 156,
  "end_col": 33,
  "parent_qualname": "DefaultFactoryAdjuster._wrap_faiss",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "runtime/factory_adjustment.py",
  "module": "runtime.factory_adjustment",
  "qualname": "DefaultFactoryAdjuster._wrap_hybrid",
  "name": "_wrap_hybrid",
  "node_type": "FunctionDef",
  "lineno": 160,
  "col": 4,
  "end_lineno": 200,
  "end_col": 23,
  "parent_qualname": "DefaultFactoryAdjuster",
  "decorators": [],
  "bases": [],
  "docstring": "Apply hybrid-channel tuning hooks.\n\nExtended Summary\n----------------\nThis helper wraps a hybrid search factory function with tuning hooks that\napply RRF (Reciprocal Rank Fusion) k and channel weights (BM25, SPLADE) after\nobject creation. It handles setter methods and suppresses errors if tuning fails.\n\nParameters\n----------\nbase : Callable[[], T]\n    Original hybrid search factory function that creates the hybrid search manager.\n\nReturns\n-------\nCallable[[], T]\n    Wrapped factory that applies hybrid search settings (RRF k, BM25 weight,\n    SPLADE weight) after object creation. Tuning failures are suppressed.",
  "is_public": false
}
{
  "path": "runtime/factory_adjustment.py",
  "module": "runtime.factory_adjustment",
  "qualname": "DefaultFactoryAdjuster._wrap_hybrid._wrapped",
  "name": "_wrapped",
  "node_type": "FunctionDef",
  "lineno": 181,
  "col": 8,
  "end_lineno": 198,
  "end_col": 33,
  "parent_qualname": "DefaultFactoryAdjuster._wrap_hybrid",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "runtime/factory_adjustment.py",
  "module": "runtime.factory_adjustment",
  "qualname": "DefaultFactoryAdjuster._wrap_xtr",
  "name": "_wrap_xtr",
  "node_type": "FunctionDef",
  "lineno": 203,
  "col": 4,
  "end_lineno": 222,
  "end_col": 19,
  "parent_qualname": "DefaultFactoryAdjuster",
  "decorators": [
    "staticmethod"
  ],
  "bases": [],
  "docstring": "Return the base factory; placeholder for future tuning.\n\nExtended Summary\n----------------\nThis static helper is a placeholder for future XTR tuning hooks. Currently\nreturns the factory unchanged, but may be extended to apply XTR-specific\nconfiguration in the future.\n\nParameters\n----------\nbase : Callable[[], T]\n    Original XTR factory function that creates the XTR index or manager.\n\nReturns\n-------\nCallable[[], T]\n    Unmodified factory. Future versions may wrap with XTR tuning hooks.",
  "is_public": false
}
{
  "path": "runtime/factory_adjustment.py",
  "module": "runtime.factory_adjustment",
  "qualname": "SuppressException",
  "name": "SuppressException",
  "node_type": "ClassDef",
  "lineno": 225,
  "col": 0,
  "end_lineno": 237,
  "end_col": 19,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Context manager that suppresses adjustment failures.",
  "is_public": true
}
{
  "path": "runtime/factory_adjustment.py",
  "module": "runtime.factory_adjustment",
  "qualname": "SuppressException.__enter__",
  "name": "__enter__",
  "node_type": "FunctionDef",
  "lineno": 228,
  "col": 4,
  "end_lineno": 229,
  "end_col": 19,
  "parent_qualname": "SuppressException",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "runtime/factory_adjustment.py",
  "module": "runtime.factory_adjustment",
  "qualname": "SuppressException.__exit__",
  "name": "__exit__",
  "node_type": "FunctionDef",
  "lineno": 231,
  "col": 4,
  "end_lineno": 237,
  "end_col": 19,
  "parent_qualname": "SuppressException",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "runtime/request_context.py",
  "module": "runtime.request_context",
  "qualname": "runtime.request_context",
  "name": "runtime.request_context",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Shared request-scoped context variables for runtime components.\n\nThese context variables are defined in the runtime package so that both\nmiddleware layers and lower-level runtime primitives (like :mod:`runtime.cells`)\ncan exchange session metadata without introducing circular imports between the\n``codeintel_rev.app`` and ``codeintel_rev.runtime`` packages.",
  "is_public": true
}
{
  "path": "telemetry/__init__.py",
  "module": "telemetry",
  "qualname": "telemetry",
  "name": "telemetry",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Phase-0 telemetry helpers (tracing, metrics, logging, run reports).",
  "is_public": true
}
{
  "path": "telemetry/context.py",
  "module": "telemetry.context",
  "qualname": "telemetry.context",
  "name": "telemetry.context",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Context variable helpers for telemetry metadata.",
  "is_public": true
}
{
  "path": "telemetry/context.py",
  "module": "telemetry.context",
  "qualname": "current_session",
  "name": "current_session",
  "node_type": "FunctionDef",
  "lineno": 48,
  "col": 0,
  "end_lineno": 56,
  "end_col": 31,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return the session identifier stored in context.\n\nReturns\n-------\nstr | None\n    Session ID when bound, otherwise ``None``.",
  "is_public": true
}
{
  "path": "telemetry/context.py",
  "module": "telemetry.context",
  "qualname": "current_run_id",
  "name": "current_run_id",
  "node_type": "FunctionDef",
  "lineno": 59,
  "col": 0,
  "end_lineno": 67,
  "end_col": 27,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return the active run identifier (alias of the current trace ID).\n\nReturns\n-------\nstr | None\n    Run identifier when telemetry has been initialised, otherwise ``None``.",
  "is_public": true
}
{
  "path": "telemetry/context.py",
  "module": "telemetry.context",
  "qualname": "_set_run_id",
  "name": "_set_run_id",
  "node_type": "FunctionDef",
  "lineno": 70,
  "col": 0,
  "end_lineno": 73,
  "end_col": 16,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "telemetry/context.py",
  "module": "telemetry.context",
  "qualname": "set_request_stage",
  "name": "set_request_stage",
  "node_type": "FunctionDef",
  "lineno": 76,
  "col": 0,
  "end_lineno": 89,
  "end_col": 31,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Bind the current pipeline stage to the context.\n\nParameters\n----------\nstage : str | None\n    Stage label to store (``None`` clears the stage).\n\nReturns\n-------\ncontextvars.Token[str | None]\n    Token used to restore the previous stage.",
  "is_public": true
}
{
  "path": "telemetry/context.py",
  "module": "telemetry.context",
  "qualname": "current_stage",
  "name": "current_stage",
  "node_type": "FunctionDef",
  "lineno": 92,
  "col": 0,
  "end_lineno": 100,
  "end_col": 26,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return the stage currently executing within the request.\n\nReturns\n-------\nstr | None\n    Stage label or ``None`` when unset.",
  "is_public": true
}
{
  "path": "telemetry/context.py",
  "module": "telemetry.context",
  "qualname": "telemetry_context",
  "name": "telemetry_context",
  "node_type": "FunctionDef",
  "lineno": 104,
  "col": 0,
  "end_lineno": 123,
  "end_col": 32,
  "parent_qualname": null,
  "decorators": [
    "contextmanager"
  ],
  "bases": [],
  "docstring": "Bind telemetry identifiers to the current context.",
  "is_public": true
}
{
  "path": "telemetry/context.py",
  "module": "telemetry.context",
  "qualname": "attach_context_attrs",
  "name": "attach_context_attrs",
  "node_type": "FunctionDef",
  "lineno": 126,
  "col": 0,
  "end_lineno": 155,
  "end_col": 17,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return attributes merged with current telemetry identifiers.\n\nParameters\n----------\nbase : Mapping[str, Any] | None\n    Optional attributes to copy before telemetry keys are injected.\n\nReturns\n-------\ndict[str, object]\n    Attribute dictionary containing telemetry metadata.",
  "is_public": true
}
{
  "path": "telemetry/context.py",
  "module": "telemetry.context",
  "qualname": "telemetry_metadata",
  "name": "telemetry_metadata",
  "node_type": "FunctionDef",
  "lineno": 158,
  "col": 0,
  "end_lineno": 175,
  "end_col": 18,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return telemetry metadata (session/run IDs) for response envelopes.\n\nReturns\n-------\ndict[str, str] | None\n    ``{\"session_id\": \"...\", \"run_id\": \"...\"}`` when telemetry is active, else ``None``.",
  "is_public": true
}
{
  "path": "telemetry/decorators.py",
  "module": "telemetry.decorators",
  "qualname": "telemetry.decorators",
  "name": "telemetry.decorators",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Decorators for consistent span/timeline instrumentation.",
  "is_public": true
}
{
  "path": "telemetry/decorators.py",
  "module": "telemetry.decorators",
  "qualname": "_NullSpan",
  "name": "_NullSpan",
  "node_type": "ClassDef",
  "lineno": 22,
  "col": 4,
  "end_lineno": 92,
  "end_col": 46,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Minimal span stub used when OpenTelemetry is unavailable.",
  "is_public": false
}
{
  "path": "telemetry/decorators.py",
  "module": "telemetry.decorators",
  "qualname": "_NullSpan.set_attribute",
  "name": "set_attribute",
  "node_type": "FunctionDef",
  "lineno": 27,
  "col": 8,
  "end_lineno": 49,
  "end_col": 45,
  "parent_qualname": "_NullSpan",
  "decorators": [],
  "bases": [],
  "docstring": "Store an attribute in the span's attribute dictionary.\n\nThis method stores key-value pairs in the span's attributes dictionary,\nproviding a minimal implementation that preserves attribute data even\nwhen OpenTelemetry is unavailable.\n\nParameters\n----------\nkey : object\n    Attribute key (converted to string). Used as the dictionary key\n    for storing the attribute value.\nvalue : object\n    Attribute value to store. Can be any object type. Stored in the\n    attributes dictionary for later inspection or debugging.\n\nNotes\n-----\nThis is a minimal stub implementation that stores attributes locally\ninstead of sending them to OpenTelemetry. Real span implementations\nwould send attributes to distributed tracing backends.",
  "is_public": true
}
{
  "path": "telemetry/decorators.py",
  "module": "telemetry.decorators",
  "qualname": "_NullSpan.record_exception",
  "name": "record_exception",
  "node_type": "FunctionDef",
  "lineno": 51,
  "col": 8,
  "end_lineno": 70,
  "end_col": 72,
  "parent_qualname": "_NullSpan",
  "decorators": [],
  "bases": [],
  "docstring": "Record exception information in the span's attributes.\n\nThis method stores the exception type name in the span's attributes\ndictionary, providing a minimal implementation for exception tracking\nwhen OpenTelemetry is unavailable.\n\nParameters\n----------\nexception : BaseException\n    Exception instance to record. The exception's type name is stored\n    in the attributes dictionary under the key \"last_exception\".\n\nNotes\n-----\nThis is a minimal stub implementation that stores only the exception\ntype name. Real span implementations would record full exception\ndetails (type, message, stack trace) for distributed tracing.",
  "is_public": true
}
{
  "path": "telemetry/decorators.py",
  "module": "telemetry.decorators",
  "qualname": "_NullSpan.set_status",
  "name": "set_status",
  "node_type": "FunctionDef",
  "lineno": 72,
  "col": 8,
  "end_lineno": 92,
  "end_col": 46,
  "parent_qualname": "_NullSpan",
  "decorators": [],
  "bases": [],
  "docstring": "Set the span status in the span's attributes.\n\nThis method stores the status object in the span's attributes dictionary,\nproviding a minimal implementation for status tracking when OpenTelemetry\nis unavailable.\n\nParameters\n----------\nstatus : object\n    Status object to store. Typically a Status instance with a code\n    attribute (e.g., Status(StatusCode.ERROR)). Stored in the attributes\n    dictionary under the key \"status\".\n\nNotes\n-----\nThis is a minimal stub implementation that stores the status locally.\nReal span implementations would set the span status in OpenTelemetry,\nmarking spans as OK, ERROR, etc. for trace visualization.",
  "is_public": true
}
{
  "path": "telemetry/decorators.py",
  "module": "telemetry.decorators",
  "qualname": "_SpanContext",
  "name": "_SpanContext",
  "node_type": "ClassDef",
  "lineno": 94,
  "col": 4,
  "end_lineno": 99,
  "end_col": 24,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "telemetry/decorators.py",
  "module": "telemetry.decorators",
  "qualname": "_SpanContext.__enter__",
  "name": "__enter__",
  "node_type": "FunctionDef",
  "lineno": 95,
  "col": 8,
  "end_lineno": 96,
  "end_col": 30,
  "parent_qualname": "_SpanContext",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "telemetry/decorators.py",
  "module": "telemetry.decorators",
  "qualname": "_SpanContext.__exit__",
  "name": "__exit__",
  "node_type": "FunctionDef",
  "lineno": 98,
  "col": 8,
  "end_lineno": 99,
  "end_col": 24,
  "parent_qualname": "_SpanContext",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "telemetry/decorators.py",
  "module": "telemetry.decorators",
  "qualname": "_NoopTracer",
  "name": "_NoopTracer",
  "node_type": "ClassDef",
  "lineno": 101,
  "col": 4,
  "end_lineno": 137,
  "end_col": 33,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "telemetry/decorators.py",
  "module": "telemetry.decorators",
  "qualname": "_NoopTracer.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 102,
  "col": 8,
  "end_lineno": 103,
  "end_col": 35,
  "parent_qualname": "_NoopTracer",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "telemetry/decorators.py",
  "module": "telemetry.decorators",
  "qualname": "_NoopTracer.start_as_current_span",
  "name": "start_as_current_span",
  "node_type": "FunctionDef",
  "lineno": 105,
  "col": 8,
  "end_lineno": 137,
  "end_col": 33,
  "parent_qualname": "_NoopTracer",
  "decorators": [],
  "bases": [],
  "docstring": "Create a no-op span context manager.\n\nThis method is part of the no-op tracer implementation used when\nOpenTelemetry is unavailable. It accepts any arguments but returns\na null span context that does nothing, allowing code to use span\ncontext managers without checking for tracer availability.\n\nParameters\n----------\n*_args : object\n    Variable positional arguments (ignored). In real OpenTelemetry\n    tracers, this would include span name and other configuration.\n**_kwargs : object\n    Variable keyword arguments (ignored). In real OpenTelemetry\n    tracers, this would include span kind, attributes, etc.\n\nReturns\n-------\n_SpanContext\n    A null span context manager that does nothing. The context\n    manager can be used in `with` statements but has no effect.\n    The internal span counter is incremented for debugging purposes.\n\nNotes\n-----\nThis is a stub implementation that provides API compatibility\nwithout requiring OpenTelemetry to be installed. Real tracer\nimplementations would create and return active OpenTelemetry spans\nthat record timing and attributes.",
  "is_public": true
}
{
  "path": "telemetry/decorators.py",
  "module": "telemetry.decorators",
  "qualname": "_SpanKindEnum",
  "name": "_SpanKindEnum",
  "node_type": "ClassDef",
  "lineno": 139,
  "col": 4,
  "end_lineno": 144,
  "end_col": 27,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "telemetry/decorators.py",
  "module": "telemetry.decorators",
  "qualname": "_StatusCodeEnum",
  "name": "_StatusCodeEnum",
  "node_type": "ClassDef",
  "lineno": 146,
  "col": 4,
  "end_lineno": 147,
  "end_col": 23,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "telemetry/decorators.py",
  "module": "telemetry.decorators",
  "qualname": "_StatusStub",
  "name": "_StatusStub",
  "node_type": "ClassDef",
  "lineno": 150,
  "col": 4,
  "end_lineno": 151,
  "end_col": 20,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "telemetry/decorators.py",
  "module": "telemetry.decorators",
  "qualname": "_record_stage_latency",
  "name": "_record_stage_latency",
  "node_type": "FunctionDef",
  "lineno": 180,
  "col": 0,
  "end_lineno": 185,
  "end_col": 69,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Record latency for a retrieval stage.",
  "is_public": false
}
{
  "path": "telemetry/decorators.py",
  "module": "telemetry.decorators",
  "qualname": "_emit_checkpoint",
  "name": "_emit_checkpoint",
  "node_type": "FunctionDef",
  "lineno": 199,
  "col": 0,
  "end_lineno": 244,
  "end_col": 14,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Emit a checkpoint event for telemetry reporting.\n\nThis internal helper emits checkpoint events to the telemetry reporter\nmodule. Checkpoints are used to track stage-level status (success/failure)\nand reasons for state changes. The function gracefully handles cases where\nthe reporter module is unavailable.\n\nParameters\n----------\nstage : str | None\n    Stage identifier for the checkpoint. When None, no checkpoint is\n    emitted. Used to identify which stage the checkpoint belongs to\n    (e.g., \"search.faiss\", \"search.bm25\").\nok : bool\n    Boolean flag indicating checkpoint status. True indicates success,\n    False indicates failure or error condition.\nreason : str | None, optional\n    Optional reason string explaining the checkpoint status. Included\n    in the checkpoint payload when provided. Used to provide context\n    for success or failure conditions.\nattrs : Mapping[str, object]\n    Additional attributes to include in the checkpoint payload. These\n    attributes are merged with the checkpoint metadata and included\n    in the telemetry event.\n\nNotes\n-----\nThis function imports the reporter module dynamically to avoid circular\ndependencies. If the import fails or the reporter is unavailable, the\nfunction silently returns without emitting a checkpoint. This ensures\nthat telemetry failures don't break application functionality.",
  "is_public": false
}
{
  "path": "telemetry/decorators.py",
  "module": "telemetry.decorators",
  "qualname": "_set_span_attributes",
  "name": "_set_span_attributes",
  "node_type": "FunctionDef",
  "lineno": 247,
  "col": 0,
  "end_lineno": 278,
  "end_col": 47,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Set attributes on an OpenTelemetry span from a mapping.\n\nThis helper function sets span attributes from a dictionary, converting\nvalues to appropriate types for OpenTelemetry. Only primitive types\n(bool, int, float, str) are set directly; None values are converted to\nthe string \"null\"; other types are converted to strings.\n\nParameters\n----------\nspan : SpanType\n    OpenTelemetry span to set attributes on. The span must be active\n    and writable. Can be either a real OpenTelemetry Span or a _NullSpan\n    stub when OpenTelemetry is unavailable.\nattrs : Mapping[str, object]\n    Dictionary of attribute key-value pairs to set on the span. Keys\n    are attribute names (strings), values are converted to appropriate\n    types (primitives preserved, None -> \"null\", others -> str).\n\nNotes\n-----\nOpenTelemetry spans only accept primitive types (bool, int, float, str)\nas attribute values. This function handles type conversion automatically,\nensuring all attributes are set correctly regardless of input types.",
  "is_public": false
}
{
  "path": "telemetry/decorators.py",
  "module": "telemetry.decorators",
  "qualname": "_span_scope",
  "name": "_span_scope",
  "node_type": "FunctionDef",
  "lineno": 282,
  "col": 0,
  "end_lineno": 346,
  "end_col": 50,
  "parent_qualname": null,
  "decorators": [
    "contextmanager"
  ],
  "bases": [],
  "docstring": "Create a context manager for OpenTelemetry span and timeline step coordination.\n\nThis internal helper creates a coordinated context for both OpenTelemetry\nspan tracing and timeline step recording. It ensures that spans and steps\nare created together, attributes are synchronized, and stage context is\nproperly managed.\n\nParameters\n----------\nname : str\n    Name for both the OpenTelemetry span and timeline step. Used to\n    identify the operation in both tracing systems.\nkind : str\n    Span kind identifier (e.g., \"internal\", \"server\", \"client\"). Used\n    to determine the OpenTelemetry SpanKind. Must be a key in\n    _SPAN_KINDS mapping or defaults to INTERNAL.\nbase_attrs : Mapping[str, object]\n    Base attributes to attach to both the span and step. These attributes\n    are enriched with context attributes (request ID, session ID, etc.)\n    before being applied.\nstage : str | None, optional\n    Optional stage identifier for request stage tracking. When provided,\n    sets the request stage context variable for the duration of the scope.\n    Used to track which stage of request processing is active.\n\nYields\n------\ntuple[SpanType, dict[str, object]]\n    Tuple containing:\n    - The active OpenTelemetry span (for setting attributes, recording\n      exceptions, etc.). Can be either a real OpenTelemetry Span or a\n      _NullSpan stub when OpenTelemetry is unavailable.\n    - The enriched telemetry attributes dictionary (for use in timeline\n      steps or additional span attributes)\n\nNotes\n-----\nThis function coordinates two observability systems: OpenTelemetry spans\n(for distributed tracing) and timeline steps (for session-level event\ntracking). Both are created together and share the same attributes and\nlifecycle. The stage parameter enables request-level stage tracking for\nmulti-stage operations (e.g., search stages).",
  "is_public": false
}
{
  "path": "telemetry/decorators.py",
  "module": "telemetry.decorators",
  "qualname": "_record_exception",
  "name": "_record_exception",
  "node_type": "FunctionDef",
  "lineno": 349,
  "col": 0,
  "end_lineno": 379,
  "end_col": 42,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Record an exception on an OpenTelemetry span and mark it as an error.\n\nThis helper function records an exception on a span and sets the span\nstatus to ERROR. Used to ensure exceptions are properly captured in\ndistributed traces.\n\nParameters\n----------\nspan : SpanType\n    OpenTelemetry span to record the exception on. The span must be\n    active and writable. Can be either a real OpenTelemetry Span or a\n    _NullSpan stub when OpenTelemetry is unavailable.\nexc : BaseException\n    Exception instance to record. The exception's type, message, and\n    stack trace are captured in the span.\n\nNotes\n-----\nThis function both records the exception details (type, message, stack)\nand sets the span status to ERROR, ensuring that error conditions are\nclearly visible in trace visualizations. Used by error handling code\nin decorators and context managers.",
  "is_public": false
}
{
  "path": "telemetry/decorators.py",
  "module": "telemetry.decorators",
  "qualname": "span_context",
  "name": "span_context",
  "node_type": "FunctionDef",
  "lineno": 383,
  "col": 0,
  "end_lineno": 468,
  "end_col": 74,
  "parent_qualname": null,
  "decorators": [
    "contextmanager"
  ],
  "bases": [],
  "docstring": "Create a span/timeline scope for the wrapped block.\n\nThis context manager creates an OpenTelemetry span and timeline step for\ninstrumenting code execution. It sets up span attributes, records exceptions,\nemits checkpoints (if enabled), and records stage latency metrics. The context\nmanager ensures proper span lifecycle management and error handling.\n\nParameters\n----------\nname : str\n    Span name used for OpenTelemetry tracing and timeline steps. Should be\n    descriptive and identify the operation being traced (e.g., \"search\",\n    \"embed_batch\").\nkind : str, optional\n    Span kind indicating the role of the span: \"internal\" (default), \"server\",\n    \"client\", \"producer\", or \"consumer\". Determines how the span appears in\n    distributed tracing views.\nattrs : Mapping[str, object] | None, optional\n    Additional attributes to attach to the span. Attributes are merged with\n    context attributes (request ID, stage, etc.) and set on the OpenTelemetry\n    span. None values are converted to \"null\" strings.\nstage : str | None, optional\n    Stage identifier for pipeline instrumentation. If provided, records stage\n    latency metrics and can emit checkpoints (if emit_checkpoint is True).\n    Used for tracking pipeline execution stages.\nemit_checkpoint : bool, optional\n    Whether to emit checkpoint events for the stage (defaults to False).\n    When True, emits success/failure checkpoints with stage metadata. Requires\n    stage to be provided.\n\nYields\n------\ntuple[SpanType, dict[str, object]]\n    Tuple containing:\n    - SpanType: The active OpenTelemetry span for adding custom attributes or\n      recording events. Can be either a real OpenTelemetry Span or a _NullSpan\n      stub when OpenTelemetry is unavailable.\n    - dict[str, object]: Merged attribute dictionary combining provided attrs\n      with context attributes (request ID, stage, etc.)\n\nNotes\n-----\nThis context manager integrates OpenTelemetry tracing with timeline recording\nand Prometheus metrics. It automatically records exceptions, sets span status,\nand records stage latency. The context manager is thread-safe if the underlying\ntracing infrastructure is thread-safe. Stage latency is recorded only when\nstage is provided.\n\nRaises\n------\nBaseException\n    Any exception raised within the context is caught, recorded on the span\n    with error status, and re-raised using Python's bare ``raise`` statement.\n    The context manager ensures proper span cleanup and error attribution even\n    when exceptions occur. Exceptions propagate to the caller after error\n    recording and checkpoint emission (if enabled). Note: Exceptions are\n    re-raised (not directly raised), preserving the original exception traceback\n    and propagating through this context manager.",
  "is_public": true
}
{
  "path": "telemetry/decorators.py",
  "module": "telemetry.decorators",
  "qualname": "trace_span",
  "name": "trace_span",
  "node_type": "FunctionDef",
  "lineno": 471,
  "col": 0,
  "end_lineno": 620,
  "end_col": 20,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Wrap callable execution in an OpenTelemetry span + timeline step.\n\nThis decorator function creates a decorator that wraps callables (functions\nor coroutines) with OpenTelemetry span and timeline instrumentation. The\ndecorator automatically detects async vs sync functions and creates appropriate\nwrappers. All execution within the decorated callable is traced with spans,\ntimeline steps, and optional checkpoints.\n\nParameters\n----------\nname : str\n    Span name used for OpenTelemetry tracing and timeline steps. Should be\n    descriptive and identify the operation being traced (e.g., \"search\",\n    \"embed_batch\").\nkind : str, optional\n    Span kind indicating the role of the span: \"internal\" (default), \"server\",\n    \"client\", \"producer\", or \"consumer\". Determines how the span appears in\n    distributed tracing views.\nattrs : Mapping[str, object] | None, optional\n    Additional attributes to attach to the span. Attributes are merged with\n    context attributes and set on the OpenTelemetry span. None values are\n    converted to \"null\" strings.\nstage : str | None, optional\n    Stage identifier for pipeline instrumentation. If provided, records stage\n    latency metrics and can emit checkpoints (if emit_checkpoint is True).\n    Used for tracking pipeline execution stages.\nemit_checkpoint : bool, optional\n    Whether to emit checkpoint events for the stage (defaults to False).\n    When True, emits success/failure checkpoints with stage metadata. Requires\n    stage to be provided.\n\nReturns\n-------\nCallable[[F], F]\n    Decorator function that wraps callables with span/timeline instrumentation.\n    The decorator preserves the original function's signature and metadata via\n    functools.wraps(). Async functions are wrapped with async wrappers; sync\n    functions are wrapped with sync wrappers.",
  "is_public": true
}
{
  "path": "telemetry/decorators.py",
  "module": "telemetry.decorators",
  "qualname": "trace_span.decorator",
  "name": "decorator",
  "node_type": "FunctionDef",
  "lineno": 520,
  "col": 4,
  "end_lineno": 618,
  "end_col": 38,
  "parent_qualname": "trace_span",
  "decorators": [],
  "bases": [],
  "docstring": "Wrap a callable with OpenTelemetry span and timeline instrumentation.\n\nThis nested function creates a decorator that wraps the target callable\n(function or coroutine) with span_context() to create an OpenTelemetry\nspan and timeline step. The decorator automatically detects whether the\ncallable is async or sync and creates the appropriate wrapper.\n\nParameters\n----------\nfunc : F\n    Callable to wrap (function or coroutine function). The callable is\n    wrapped to execute within a span_context() scope, creating spans and\n    timeline steps automatically.\n\nReturns\n-------\nF\n    Wrapped callable that executes within span/timeline instrumentation.\n    Async functions return an async wrapper; sync functions return a\n    sync wrapper. The wrapper preserves the original function's signature\n    and metadata via functools.wraps().\n\nNotes\n-----\nThis decorator function is returned by trace_span() and is applied to\nthe target callable. It uses inspect.iscoroutinefunction() to detect\nasync functions and creates appropriate wrappers. The wrapper executes\nthe original function within a span_context() scope, ensuring all\nexecution is traced. Thread-safe if span_context() is thread-safe.",
  "is_public": true
}
{
  "path": "telemetry/decorators.py",
  "module": "telemetry.decorators",
  "qualname": "trace_span.decorator.async_wrapper",
  "name": "async_wrapper",
  "node_type": "AsyncFunctionDef",
  "lineno": 555,
  "col": 12,
  "end_lineno": 583,
  "end_col": 60,
  "parent_qualname": "trace_span.decorator",
  "decorators": [
    "functools.wraps(func)"
  ],
  "bases": [],
  "docstring": "Async wrapper that executes coroutine within span context.\n\nThis nested async function wraps coroutine execution in a\nspan_context() scope, creating OpenTelemetry spans and timeline\nsteps for async operations. It awaits the original coroutine\nand returns its result.\n\nParameters\n----------\n*args : object\n    Positional arguments passed to the original coroutine.\n**kwargs : object\n    Keyword arguments passed to the original coroutine.\n\nReturns\n-------\nobject\n    Result returned by the original coroutine. The result is\n    passed through unchanged after span/timeline instrumentation.",
  "is_public": true
}
{
  "path": "telemetry/decorators.py",
  "module": "telemetry.decorators",
  "qualname": "trace_span.decorator.sync_wrapper",
  "name": "sync_wrapper",
  "node_type": "FunctionDef",
  "lineno": 588,
  "col": 8,
  "end_lineno": 616,
  "end_col": 44,
  "parent_qualname": "trace_span.decorator",
  "decorators": [
    "functools.wraps(func)"
  ],
  "bases": [],
  "docstring": "Sync wrapper that executes function within span context.\n\nThis nested function wraps synchronous function execution in a\nspan_context() scope, creating OpenTelemetry spans and timeline\nsteps for sync operations. It calls the original function and\nreturns its result.\n\nParameters\n----------\n*args : object\n    Positional arguments passed to the original function.\n**kwargs : object\n    Keyword arguments passed to the original function.\n\nReturns\n-------\nobject\n    Result returned by the original function. The result is passed\n    through unchanged after span/timeline instrumentation.",
  "is_public": true
}
{
  "path": "telemetry/decorators.py",
  "module": "telemetry.decorators",
  "qualname": "trace_step",
  "name": "trace_step",
  "node_type": "FunctionDef",
  "lineno": 623,
  "col": 0,
  "end_lineno": 668,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Specialized decorator that records checkpoints for pipeline stages.\n\nThis decorator is a convenience wrapper around trace_span() that automatically\nenables checkpoint emission for pipeline stage instrumentation. It sets the\nstage name as both the span name and stage identifier, and enables checkpoint\nemission to track stage success/failure. This is useful for instrumenting\npipeline stages that need checkpoint tracking.\n\nParameters\n----------\nstage : str\n    Stage identifier used as both span name and stage name. Should identify\n    the pipeline stage being instrumented (e.g., \"index_load\", \"search_execute\").\n    Checkpoints are automatically emitted for this stage.\nattrs : Mapping[str, object] | None, optional\n    Additional attributes to attach to the span. Attributes are merged with\n    context attributes and the stage name. None values are converted to \"null\"\n    strings.\nkind : str, optional\n    Span kind indicating the role of the span: \"internal\" (default), \"server\",\n    \"client\", \"producer\", or \"consumer\". Determines how the span appears in\n    distributed tracing views.\n\nReturns\n-------\nCallable[[F], F]\n    Decorator function that wraps callables with span/timeline instrumentation\n    and checkpoint emission. The decorator preserves the original function's\n    signature and metadata. Checkpoints are emitted automatically on success\n    or failure.",
  "is_public": true
}
{
  "path": "telemetry/decorators.py",
  "module": "telemetry.decorators",
  "qualname": "emit_event",
  "name": "emit_event",
  "node_type": "FunctionDef",
  "lineno": 671,
  "col": 0,
  "end_lineno": 812,
  "end_col": 20,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Emit a :class:`StepEvent` reflecting the wrapped callable's outcome.\n\nParameters\n----------\nop : str\n    Operation name to include in the step event kind (format: \"{component}.{op}\").\ncomponent : str\n    Component name to include in the step event kind (format: \"{component}.{op}\").\npayload_factory : Callable[[tuple[object, ...], dict[str, object], object | None], Mapping[str, object]] | None, optional\n    Optional factory function to build custom payload from function arguments,\n    keyword arguments, and return value. If None, uses default payload extraction.\n\nReturns\n-------\nCallable[[F], F]\n    Decorator wrapping the target callable with structured step emission.",
  "is_public": true
}
{
  "path": "telemetry/decorators.py",
  "module": "telemetry.decorators",
  "qualname": "emit_event.decorator",
  "name": "decorator",
  "node_type": "FunctionDef",
  "lineno": 698,
  "col": 4,
  "end_lineno": 810,
  "end_col": 38,
  "parent_qualname": "emit_event",
  "decorators": [],
  "bases": [],
  "docstring": "Wrap the target callable with step event emission.\n\nParameters\n----------\nfunc : F\n    Function or coroutine function to wrap with step event emission.\n\nReturns\n-------\nF\n    Wrapped function that emits step events on completion or failure.",
  "is_public": true
}
{
  "path": "telemetry/decorators.py",
  "module": "telemetry.decorators",
  "qualname": "emit_event.decorator.async_wrapper",
  "name": "async_wrapper",
  "node_type": "AsyncFunctionDef",
  "lineno": 715,
  "col": 12,
  "end_lineno": 759,
  "end_col": 29,
  "parent_qualname": "emit_event.decorator",
  "decorators": [
    "functools.wraps(func)"
  ],
  "bases": [],
  "docstring": "Async wrapper that emits step events for async functions.\n\nParameters\n----------\n*args : object\n    Positional arguments passed to the wrapped function.\n**kwargs : object\n    Keyword arguments passed to the wrapped function.\n\nReturns\n-------\nobject\n    Return value from the wrapped async function.\n\nRaises\n------\nBaseException\n    Any exception raised by the wrapped function is re-raised after\n    emitting a failed step event.",
  "is_public": true
}
{
  "path": "telemetry/decorators.py",
  "module": "telemetry.decorators",
  "qualname": "emit_event.decorator.sync_wrapper",
  "name": "sync_wrapper",
  "node_type": "FunctionDef",
  "lineno": 764,
  "col": 8,
  "end_lineno": 808,
  "end_col": 25,
  "parent_qualname": "emit_event.decorator",
  "decorators": [
    "functools.wraps(func)"
  ],
  "bases": [],
  "docstring": "Sync wrapper that emits step events for synchronous functions.\n\nParameters\n----------\n*args : object\n    Positional arguments passed to the wrapped function.\n**kwargs : object\n    Keyword arguments passed to the wrapped function.\n\nReturns\n-------\nobject\n    Return value from the wrapped function.\n\nRaises\n------\nBaseException\n    Any exception raised by the wrapped function is re-raised after\n    emitting a failed step event.",
  "is_public": true
}
{
  "path": "telemetry/decorators.py",
  "module": "telemetry.decorators",
  "qualname": "_build_step_payload",
  "name": "_build_step_payload",
  "node_type": "FunctionDef",
  "lineno": 815,
  "col": 0,
  "end_lineno": 828,
  "end_col": 17,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "telemetry/decorators.py",
  "module": "telemetry.decorators",
  "qualname": "_with_duration",
  "name": "_with_duration",
  "node_type": "FunctionDef",
  "lineno": 831,
  "col": 0,
  "end_lineno": 834,
  "end_col": 18,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "telemetry/events.py",
  "module": "telemetry.events",
  "qualname": "telemetry.events",
  "name": "telemetry.events",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Typed event helpers shared across telemetry modules.",
  "is_public": true
}
{
  "path": "telemetry/events.py",
  "module": "telemetry.events",
  "qualname": "RunCheckpoint",
  "name": "RunCheckpoint",
  "node_type": "ClassDef",
  "lineno": 20,
  "col": 0,
  "end_lineno": 40,
  "end_col": 22,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Structured checkpoint emitted after significant pipeline stages.",
  "is_public": true
}
{
  "path": "telemetry/events.py",
  "module": "telemetry.events",
  "qualname": "RunCheckpoint.to_event_attrs",
  "name": "to_event_attrs",
  "node_type": "FunctionDef",
  "lineno": 28,
  "col": 4,
  "end_lineno": 40,
  "end_col": 22,
  "parent_qualname": "RunCheckpoint",
  "decorators": [],
  "bases": [],
  "docstring": "Return a JSON-ready dictionary for downstream stores.\n\nReturns\n-------\ndict[str, Any]\n    Attribute dictionary describing the checkpoint.",
  "is_public": true
}
{
  "path": "telemetry/events.py",
  "module": "telemetry.events",
  "qualname": "TimelineEvent",
  "name": "TimelineEvent",
  "node_type": "ClassDef",
  "lineno": 44,
  "col": 0,
  "end_lineno": 54,
  "end_col": 25,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Normalized representation of a timeline entry.",
  "is_public": true
}
{
  "path": "telemetry/events.py",
  "module": "telemetry.events",
  "qualname": "checkpoint_event",
  "name": "checkpoint_event",
  "node_type": "FunctionDef",
  "lineno": 57,
  "col": 0,
  "end_lineno": 90,
  "end_col": 78,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Create a RunCheckpoint instance.\n\nThis function constructs a RunCheckpoint event for tracking pipeline execution\nstages. Checkpoints record success/failure status, optional reason messages,\nand additional attributes for observability and debugging.\n\nParameters\n----------\nstage : str\n    Stage identifier for the checkpoint (e.g., \"index.build\", \"search.execute\").\n    Used to identify which pipeline stage the checkpoint represents.\nok : bool\n    Success status flag. True indicates the stage completed successfully,\n    False indicates failure or error condition.\nreason : str | None, optional\n    Optional reason message explaining the checkpoint status (default: None).\n    Typically used to provide error messages or success summaries. Included\n    in the checkpoint payload when provided.\n**attrs : object\n    Additional keyword arguments to include as checkpoint attributes. All\n    attributes are merged into the checkpoint's attrs dictionary for extended\n    context and debugging information.\n\nReturns\n-------\nRunCheckpoint\n    Structured checkpoint payload containing stage, ok status, reason, and\n    attributes. The checkpoint is suitable for serialization and timeline\n    recording.",
  "is_public": true
}
{
  "path": "telemetry/events.py",
  "module": "telemetry.events",
  "qualname": "coerce_event",
  "name": "coerce_event",
  "node_type": "FunctionDef",
  "lineno": 93,
  "col": 0,
  "end_lineno": 125,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Coerce a raw timeline payload into :class:`TimelineEvent`.\n\nThis function converts a raw dictionary payload into a normalized TimelineEvent\nby extracting required fields (session_id, run_id, ts, type, name, status) and\napplying default values for missing fields. The function handles type coercion\nand ensures all fields are properly formatted.\n\nParameters\n----------\npayload : Mapping[str, Any]\n    Raw timeline event payload dictionary. Expected keys include session_id,\n    run_id, ts (timestamp), type, name, status, and optional attrs. Missing\n    values are replaced with defaults (empty strings, 0.0 for timestamp, \"ok\"\n    for status).\n\nReturns\n-------\nTimelineEvent\n    Normalized timeline event with all required fields populated. The event\n    is constructed from the payload with type coercion and default value\n    handling for missing fields.",
  "is_public": true
}
{
  "path": "telemetry/events.py",
  "module": "telemetry.events",
  "qualname": "RunEventRecord",
  "name": "RunEventRecord",
  "node_type": "ClassDef",
  "lineno": 129,
  "col": 0,
  "end_lineno": 147,
  "end_col": 63,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Structured representation of a run-level event.",
  "is_public": true
}
{
  "path": "telemetry/events.py",
  "module": "telemetry.events",
  "qualname": "normalize_run_event",
  "name": "normalize_run_event",
  "node_type": "FunctionDef",
  "lineno": 150,
  "col": 0,
  "end_lineno": 191,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return a :class:`RunEventRecord` from ``payload`` with defaults applied.\n\nParameters\n----------\npayload : Mapping[str, Any]\n    Raw event payload dictionary. Expected keys include ts, session_id, run_id,\n    status, kind, detail, warnings, error_code, and error_context. Missing keys\n    are filled with defaults.\n\nReturns\n-------\nRunEventRecord\n    Normalized run event structure with defaults applied.",
  "is_public": true
}
{
  "path": "telemetry/events.py",
  "module": "telemetry.events",
  "qualname": "normalize_run_event._tuple",
  "name": "_tuple",
  "node_type": "FunctionDef",
  "lineno": 166,
  "col": 4,
  "end_lineno": 171,
  "end_col": 17,
  "parent_qualname": "normalize_run_event",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "telemetry/events.py",
  "module": "telemetry.events",
  "qualname": "_maybe_str",
  "name": "_maybe_str",
  "node_type": "FunctionDef",
  "lineno": 194,
  "col": 0,
  "end_lineno": 197,
  "end_col": 21,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "telemetry/logging.py",
  "module": "telemetry.logging",
  "qualname": "telemetry.logging",
  "name": "telemetry.logging",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Structured logging bridge + optional OTLP exporter.",
  "is_public": true
}
{
  "path": "telemetry/logging.py",
  "module": "telemetry.logging",
  "qualname": "install_structured_logging",
  "name": "install_structured_logging",
  "node_type": "FunctionDef",
  "lineno": 14,
  "col": 0,
  "end_lineno": 26,
  "end_col": 9,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Install JSON logging and delegate OpenTelemetry export to observability stack.",
  "is_public": true
}
{
  "path": "telemetry/otel_metrics.py",
  "module": "telemetry.otel_metrics",
  "qualname": "telemetry.otel_metrics",
  "name": "telemetry.otel_metrics",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Compatibility layer exposing Prometheus-like helpers backed by OpenTelemetry.",
  "is_public": true
}
{
  "path": "telemetry/otel_metrics.py",
  "module": "telemetry.otel_metrics",
  "qualname": "CounterHandle",
  "name": "CounterHandle",
  "node_type": "ClassDef",
  "lineno": 26,
  "col": 0,
  "end_lineno": 37,
  "end_col": 60,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Lightweight handle mutating a counter with pre-bound attributes.",
  "is_public": true
}
{
  "path": "telemetry/otel_metrics.py",
  "module": "telemetry.otel_metrics",
  "qualname": "CounterHandle.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 31,
  "col": 4,
  "end_lineno": 33,
  "end_col": 75,
  "parent_qualname": "CounterHandle",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "telemetry/otel_metrics.py",
  "module": "telemetry.otel_metrics",
  "qualname": "CounterHandle.inc",
  "name": "inc",
  "node_type": "FunctionDef",
  "lineno": 35,
  "col": 4,
  "end_lineno": 37,
  "end_col": 60,
  "parent_qualname": "CounterHandle",
  "decorators": [],
  "bases": [],
  "docstring": "Increment the underlying counter.",
  "is_public": true
}
{
  "path": "telemetry/otel_metrics.py",
  "module": "telemetry.otel_metrics",
  "qualname": "HistogramHandle",
  "name": "HistogramHandle",
  "node_type": "ClassDef",
  "lineno": 40,
  "col": 0,
  "end_lineno": 51,
  "end_col": 63,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Histogram view that records values with pre-bound attributes.",
  "is_public": true
}
{
  "path": "telemetry/otel_metrics.py",
  "module": "telemetry.otel_metrics",
  "qualname": "HistogramHandle.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 45,
  "col": 4,
  "end_lineno": 47,
  "end_col": 75,
  "parent_qualname": "HistogramHandle",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "telemetry/otel_metrics.py",
  "module": "telemetry.otel_metrics",
  "qualname": "HistogramHandle.observe",
  "name": "observe",
  "node_type": "FunctionDef",
  "lineno": 49,
  "col": 4,
  "end_lineno": 51,
  "end_col": 63,
  "parent_qualname": "HistogramHandle",
  "decorators": [],
  "bases": [],
  "docstring": "Record ``value`` on the histogram.",
  "is_public": true
}
{
  "path": "telemetry/otel_metrics.py",
  "module": "telemetry.otel_metrics",
  "qualname": "CounterLike",
  "name": "CounterLike",
  "node_type": "ClassDef",
  "lineno": 54,
  "col": 0,
  "end_lineno": 95,
  "end_col": 39,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Counter facade exposing `.inc()` and `.labels().inc()`.",
  "is_public": true
}
{
  "path": "telemetry/otel_metrics.py",
  "module": "telemetry.otel_metrics",
  "qualname": "CounterLike.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 59,
  "col": 4,
  "end_lineno": 68,
  "end_col": 66,
  "parent_qualname": "CounterLike",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "telemetry/otel_metrics.py",
  "module": "telemetry.otel_metrics",
  "qualname": "CounterLike.labels",
  "name": "labels",
  "node_type": "FunctionDef",
  "lineno": 70,
  "col": 4,
  "end_lineno": 91,
  "end_col": 53,
  "parent_qualname": "CounterLike",
  "decorators": [],
  "bases": [],
  "docstring": "Return a handle bound to ``attributes``.\n\nReturns\n-------\nCounterHandle\n    Handle that records metrics with the provided attributes.\n\nRaises\n------\nValueError\n    Raised when a required attribute is missing.",
  "is_public": true
}
{
  "path": "telemetry/otel_metrics.py",
  "module": "telemetry.otel_metrics",
  "qualname": "CounterLike.inc",
  "name": "inc",
  "node_type": "FunctionDef",
  "lineno": 93,
  "col": 4,
  "end_lineno": 95,
  "end_col": 39,
  "parent_qualname": "CounterLike",
  "decorators": [],
  "bases": [],
  "docstring": "Increment the counter without attributes.",
  "is_public": true
}
{
  "path": "telemetry/otel_metrics.py",
  "module": "telemetry.otel_metrics",
  "qualname": "HistogramLike",
  "name": "HistogramLike",
  "node_type": "ClassDef",
  "lineno": 98,
  "col": 0,
  "end_lineno": 173,
  "end_col": 33,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Histogram facade exposing `.observe()` and `.labels().observe()`.",
  "is_public": true
}
{
  "path": "telemetry/otel_metrics.py",
  "module": "telemetry.otel_metrics",
  "qualname": "HistogramLike.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 103,
  "col": 4,
  "end_lineno": 120,
  "end_col": 68,
  "parent_qualname": "HistogramLike",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "telemetry/otel_metrics.py",
  "module": "telemetry.otel_metrics",
  "qualname": "HistogramLike.labels",
  "name": "labels",
  "node_type": "FunctionDef",
  "lineno": 122,
  "col": 4,
  "end_lineno": 143,
  "end_col": 55,
  "parent_qualname": "HistogramLike",
  "decorators": [],
  "bases": [],
  "docstring": "Return a histogram handle for ``attributes``.\n\nReturns\n-------\nHistogramHandle\n    Handle used to record values with the provided attributes.\n\nRaises\n------\nValueError\n    Raised when a required attribute is missing.",
  "is_public": true
}
{
  "path": "telemetry/otel_metrics.py",
  "module": "telemetry.otel_metrics",
  "qualname": "HistogramLike.observe",
  "name": "observe",
  "node_type": "FunctionDef",
  "lineno": 145,
  "col": 4,
  "end_lineno": 147,
  "end_col": 43,
  "parent_qualname": "HistogramLike",
  "decorators": [],
  "bases": [],
  "docstring": "Record ``value`` against the histogram.",
  "is_public": true
}
{
  "path": "telemetry/otel_metrics.py",
  "module": "telemetry.otel_metrics",
  "qualname": "HistogramLike.record",
  "name": "record",
  "node_type": "FunctionDef",
  "lineno": 149,
  "col": 4,
  "end_lineno": 173,
  "end_col": 33,
  "parent_qualname": "HistogramLike",
  "decorators": [],
  "bases": [],
  "docstring": "Record ``value`` with optional attributes.\n\nThis method provides a Prometheus-like API for recording histogram values\nwith attributes. If attributes are provided, they are used to create a\nlabeled handle. If no attributes are provided, the default handle is used.\n\nParameters\n----------\nvalue : float\n    Value to record in the histogram.\nattributes : Mapping[str, object] | None, optional\n    Optional attributes dictionary. If provided, must contain all required\n    label names. Defaults to None (uses default handle).\n\nNotes\n-----\nWhen attributes are provided, this method calls ``labels()`` which may raise\n``ValueError`` if required label names are missing from the attributes dict.",
  "is_public": true
}
{
  "path": "telemetry/otel_metrics.py",
  "module": "telemetry.otel_metrics",
  "qualname": "_GaugeEntry",
  "name": "_GaugeEntry",
  "node_type": "ClassDef",
  "lineno": 177,
  "col": 0,
  "end_lineno": 179,
  "end_col": 22,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "telemetry/otel_metrics.py",
  "module": "telemetry.otel_metrics",
  "qualname": "GaugeHandle",
  "name": "GaugeHandle",
  "node_type": "ClassDef",
  "lineno": 182,
  "col": 0,
  "end_lineno": 193,
  "end_col": 47,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Gauge handle supporting ``set`` semantics.",
  "is_public": true
}
{
  "path": "telemetry/otel_metrics.py",
  "module": "telemetry.otel_metrics",
  "qualname": "GaugeHandle.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 187,
  "col": 4,
  "end_lineno": 189,
  "end_col": 23,
  "parent_qualname": "GaugeHandle",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "telemetry/otel_metrics.py",
  "module": "telemetry.otel_metrics",
  "qualname": "GaugeHandle.set",
  "name": "set",
  "node_type": "FunctionDef",
  "lineno": 191,
  "col": 4,
  "end_lineno": 193,
  "end_col": 47,
  "parent_qualname": "GaugeHandle",
  "decorators": [],
  "bases": [],
  "docstring": "Set the gauge to ``value``.",
  "is_public": true
}
{
  "path": "telemetry/otel_metrics.py",
  "module": "telemetry.otel_metrics",
  "qualname": "GaugeLike",
  "name": "GaugeLike",
  "node_type": "ClassDef",
  "lineno": 196,
  "col": 0,
  "end_lineno": 294,
  "end_col": 27,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Gauge facade backed by an ObservableGauge.",
  "is_public": true
}
{
  "path": "telemetry/otel_metrics.py",
  "module": "telemetry.otel_metrics",
  "qualname": "GaugeLike.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 201,
  "col": 4,
  "end_lineno": 220,
  "end_col": 80,
  "parent_qualname": "GaugeLike",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "telemetry/otel_metrics.py",
  "module": "telemetry.otel_metrics",
  "qualname": "GaugeLike.labels",
  "name": "labels",
  "node_type": "FunctionDef",
  "lineno": 222,
  "col": 4,
  "end_lineno": 239,
  "end_col": 37,
  "parent_qualname": "GaugeLike",
  "decorators": [],
  "bases": [],
  "docstring": "Return a handle for ``attributes``.\n\nReturns\n-------\nGaugeHandle\n    Handle that controls the gauge entry for the provided attributes.\n\nRaises\n------\nValueError\n    Raised when a required attribute is missing.",
  "is_public": true
}
{
  "path": "telemetry/otel_metrics.py",
  "module": "telemetry.otel_metrics",
  "qualname": "GaugeLike.set",
  "name": "set",
  "node_type": "FunctionDef",
  "lineno": 241,
  "col": 4,
  "end_lineno": 243,
  "end_col": 48,
  "parent_qualname": "GaugeLike",
  "decorators": [],
  "bases": [],
  "docstring": "Set the gauge without attributes.",
  "is_public": true
}
{
  "path": "telemetry/otel_metrics.py",
  "module": "telemetry.otel_metrics",
  "qualname": "GaugeLike._key_from_attributes",
  "name": "_key_from_attributes",
  "node_type": "FunctionDef",
  "lineno": 245,
  "col": 4,
  "end_lineno": 268,
  "end_col": 25,
  "parent_qualname": "GaugeLike",
  "decorators": [],
  "bases": [],
  "docstring": "Return a canonical attribute key tuple.\n\nReturns\n-------\ntuple[tuple[str, object], ...]\n    Normalized attribute tuple keyed by label name.\n\nRaises\n------\nValueError\n    Raised when a required attribute is missing.",
  "is_public": false
}
{
  "path": "telemetry/otel_metrics.py",
  "module": "telemetry.otel_metrics",
  "qualname": "GaugeLike.set_value",
  "name": "set_value",
  "node_type": "FunctionDef",
  "lineno": 270,
  "col": 4,
  "end_lineno": 278,
  "end_col": 38,
  "parent_qualname": "GaugeLike",
  "decorators": [],
  "bases": [],
  "docstring": "Store ``value`` for the attribute tuple.",
  "is_public": true
}
{
  "path": "telemetry/otel_metrics.py",
  "module": "telemetry.otel_metrics",
  "qualname": "GaugeLike._observe",
  "name": "_observe",
  "node_type": "FunctionDef",
  "lineno": 280,
  "col": 4,
  "end_lineno": 294,
  "end_col": 27,
  "parent_qualname": "GaugeLike",
  "decorators": [],
  "bases": [],
  "docstring": "Return the latest gauge observations.\n\nReturns\n-------\nlist[Observation]\n    Snapshot of the most recent gauge values.",
  "is_public": false
}
{
  "path": "telemetry/otel_metrics.py",
  "module": "telemetry.otel_metrics",
  "qualname": "build_counter",
  "name": "build_counter",
  "node_type": "FunctionDef",
  "lineno": 297,
  "col": 0,
  "end_lineno": 309,
  "end_col": 81,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return a CounterLike backed by OpenTelemetry.\n\nReturns\n-------\nCounterLike\n    Counter interface used across the codebase.",
  "is_public": true
}
{
  "path": "telemetry/otel_metrics.py",
  "module": "telemetry.otel_metrics",
  "qualname": "build_histogram",
  "name": "build_histogram",
  "node_type": "FunctionDef",
  "lineno": 312,
  "col": 0,
  "end_lineno": 333,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return a HistogramLike backed by OpenTelemetry.\n\nReturns\n-------\nHistogramLike\n    Histogram interface used across the codebase.",
  "is_public": true
}
{
  "path": "telemetry/otel_metrics.py",
  "module": "telemetry.otel_metrics",
  "qualname": "build_gauge",
  "name": "build_gauge",
  "node_type": "FunctionDef",
  "lineno": 336,
  "col": 0,
  "end_lineno": 355,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return an ObservableGauge facade.\n\nReturns\n-------\nGaugeLike\n    Gauge interface used across the codebase.",
  "is_public": true
}
{
  "path": "telemetry/reporter.py",
  "module": "telemetry.reporter",
  "qualname": "telemetry.reporter",
  "name": "telemetry.reporter",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "In-memory run report builder fed by timeline events.",
  "is_public": true
}
{
  "path": "telemetry/reporter.py",
  "module": "telemetry.reporter",
  "qualname": "_env_retention",
  "name": "_env_retention",
  "node_type": "FunctionDef",
  "lineno": 49,
  "col": 0,
  "end_lineno": 55,
  "end_col": 36,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "telemetry/reporter.py",
  "module": "telemetry.reporter",
  "qualname": "_infer_stop_reason_from_events",
  "name": "_infer_stop_reason_from_events",
  "node_type": "FunctionDef",
  "lineno": 58,
  "col": 0,
  "end_lineno": 69,
  "end_col": 22,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "telemetry/reporter.py",
  "module": "telemetry.reporter",
  "qualname": "_default_budget_snapshot",
  "name": "_default_budget_snapshot",
  "node_type": "FunctionDef",
  "lineno": 72,
  "col": 0,
  "end_lineno": 86,
  "end_col": 19,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "telemetry/reporter.py",
  "module": "telemetry.reporter",
  "qualname": "_checkpoint_hit",
  "name": "_checkpoint_hit",
  "node_type": "FunctionDef",
  "lineno": 89,
  "col": 0,
  "end_lineno": 99,
  "end_col": 16,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "telemetry/reporter.py",
  "module": "telemetry.reporter",
  "qualname": "_checkpoint_summaries",
  "name": "_checkpoint_summaries",
  "node_type": "FunctionDef",
  "lineno": 102,
  "col": 0,
  "end_lineno": 120,
  "end_col": 20,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "telemetry/reporter.py",
  "module": "telemetry.reporter",
  "qualname": "_compute_ops_coverage",
  "name": "_compute_ops_coverage",
  "node_type": "FunctionDef",
  "lineno": 123,
  "col": 0,
  "end_lineno": 137,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "telemetry/reporter.py",
  "module": "telemetry.reporter",
  "qualname": "_normalize_stage_event",
  "name": "_normalize_stage_event",
  "node_type": "FunctionDef",
  "lineno": 148,
  "col": 0,
  "end_lineno": 174,
  "end_col": 15,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Normalize event kind to a stage label.\n\nThis function maps event kind strings to normalized stage labels used in\nrun reports. It is called during stage summary construction to identify\nwhich stage an event belongs to. Used by telemetry reporting to group\nevents by retrieval stage.\n\nParameters\n----------\nkind : str | None\n    Event kind string to normalize, or None.\n\nReturns\n-------\nstr | None\n    Normalized stage label (e.g., \"gather\", \"fuse\", \"hydrate\", \"rerank\"),\n    or None if the kind does not match any known stage.",
  "is_public": false
}
{
  "path": "telemetry/reporter.py",
  "module": "telemetry.reporter",
  "qualname": "_build_stage_summary",
  "name": "_build_stage_summary",
  "node_type": "FunctionDef",
  "lineno": 177,
  "col": 0,
  "end_lineno": 245,
  "end_col": 33,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return ordered stage summaries and the last completed stage.\n\nParameters\n----------\nrecord : RunRecord\n    Run record containing structured step events.\n\nReturns\n-------\ntuple[list[RunReportStage], str | None]\n    Ordered stage summaries alongside the name of the last completed stage,\n    or ``None`` when no stage completed.",
  "is_public": false
}
{
  "path": "telemetry/reporter.py",
  "module": "telemetry.reporter",
  "qualname": "_budgets_from_timeline",
  "name": "_budgets_from_timeline",
  "node_type": "FunctionDef",
  "lineno": 248,
  "col": 0,
  "end_lineno": 269,
  "end_col": 15,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "telemetry/reporter.py",
  "module": "telemetry.reporter",
  "qualname": "RunRecord",
  "name": "RunRecord",
  "node_type": "ClassDef",
  "lineno": 273,
  "col": 0,
  "end_lineno": 311,
  "end_col": 9,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=False)"
  ],
  "bases": [],
  "docstring": "Mutable storage for a sampled run.",
  "is_public": true
}
{
  "path": "telemetry/reporter.py",
  "module": "telemetry.reporter",
  "qualname": "RunRecord.clone",
  "name": "clone",
  "node_type": "FunctionDef",
  "lineno": 290,
  "col": 4,
  "end_lineno": 311,
  "end_col": 9,
  "parent_qualname": "RunRecord",
  "decorators": [],
  "bases": [],
  "docstring": "Return a shallow copy suitable for read-only processing.\n\nReturns\n-------\nRunRecord\n    Independent copy of this record.",
  "is_public": true
}
{
  "path": "telemetry/reporter.py",
  "module": "telemetry.reporter",
  "qualname": "RunReport",
  "name": "RunReport",
  "node_type": "ClassDef",
  "lineno": 315,
  "col": 0,
  "end_lineno": 360,
  "end_col": 9,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Structured run summary consumable by humans and automation.",
  "is_public": true
}
{
  "path": "telemetry/reporter.py",
  "module": "telemetry.reporter",
  "qualname": "RunReport.to_dict",
  "name": "to_dict",
  "node_type": "FunctionDef",
  "lineno": 335,
  "col": 4,
  "end_lineno": 360,
  "end_col": 9,
  "parent_qualname": "RunReport",
  "decorators": [],
  "bases": [],
  "docstring": "Return a JSON-serializable representation.\n\nReturns\n-------\ndict[str, Any]\n    Dictionary containing all report fields.",
  "is_public": true
}
{
  "path": "telemetry/reporter.py",
  "module": "telemetry.reporter",
  "qualname": "RunReportStore",
  "name": "RunReportStore",
  "node_type": "ClassDef",
  "lineno": 363,
  "col": 0,
  "end_lineno": 517,
  "end_col": 33,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Thread-safe circular buffer of run data.",
  "is_public": true
}
{
  "path": "telemetry/reporter.py",
  "module": "telemetry.reporter",
  "qualname": "RunReportStore.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 366,
  "col": 4,
  "end_lineno": 370,
  "end_col": 37,
  "parent_qualname": "RunReportStore",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "telemetry/reporter.py",
  "module": "telemetry.reporter",
  "qualname": "RunReportStore._ensure_record",
  "name": "_ensure_record",
  "node_type": "FunctionDef",
  "lineno": 372,
  "col": 4,
  "end_lineno": 380,
  "end_col": 21,
  "parent_qualname": "RunReportStore",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "telemetry/reporter.py",
  "module": "telemetry.reporter",
  "qualname": "RunReportStore._trim_locked",
  "name": "_trim_locked",
  "node_type": "FunctionDef",
  "lineno": 382,
  "col": 4,
  "end_lineno": 385,
  "end_col": 43,
  "parent_qualname": "RunReportStore",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "telemetry/reporter.py",
  "module": "telemetry.reporter",
  "qualname": "RunReportStore.start_run",
  "name": "start_run",
  "node_type": "FunctionDef",
  "lineno": 387,
  "col": 4,
  "end_lineno": 401,
  "end_col": 63,
  "parent_qualname": "RunReportStore",
  "decorators": [],
  "bases": [],
  "docstring": "Register or update the metadata for a run record.",
  "is_public": true
}
{
  "path": "telemetry/reporter.py",
  "module": "telemetry.reporter",
  "qualname": "RunReportStore.record_event",
  "name": "record_event",
  "node_type": "FunctionDef",
  "lineno": 403,
  "col": 4,
  "end_lineno": 422,
  "end_col": 96,
  "parent_qualname": "RunReportStore",
  "decorators": [],
  "bases": [],
  "docstring": "Append a timeline event to the stored history.",
  "is_public": true
}
{
  "path": "telemetry/reporter.py",
  "module": "telemetry.reporter",
  "qualname": "RunReportStore.record_checkpoint",
  "name": "record_checkpoint",
  "node_type": "FunctionDef",
  "lineno": 424,
  "col": 4,
  "end_lineno": 430,
  "end_col": 49,
  "parent_qualname": "RunReportStore",
  "decorators": [],
  "bases": [],
  "docstring": "Persist a structured checkpoint emitted by decorators.",
  "is_public": true
}
{
  "path": "telemetry/reporter.py",
  "module": "telemetry.reporter",
  "qualname": "RunReportStore.record_structured_event",
  "name": "record_structured_event",
  "node_type": "FunctionDef",
  "lineno": 432,
  "col": 4,
  "end_lineno": 440,
  "end_col": 58,
  "parent_qualname": "RunReportStore",
  "decorators": [],
  "bases": [],
  "docstring": "Record structured telemetry payloads for the given run.",
  "is_public": true
}
{
  "path": "telemetry/reporter.py",
  "module": "telemetry.reporter",
  "qualname": "RunReportStore.finalize",
  "name": "finalize",
  "node_type": "FunctionDef",
  "lineno": 442,
  "col": 4,
  "end_lineno": 474,
  "end_col": 46,
  "parent_qualname": "RunReportStore",
  "decorators": [],
  "bases": [],
  "docstring": "Finish a run and emit metrics once.",
  "is_public": true
}
{
  "path": "telemetry/reporter.py",
  "module": "telemetry.reporter",
  "qualname": "RunReportStore.get_run",
  "name": "get_run",
  "node_type": "FunctionDef",
  "lineno": 476,
  "col": 4,
  "end_lineno": 517,
  "end_col": 33,
  "parent_qualname": "RunReportStore",
  "decorators": [],
  "bases": [],
  "docstring": "Return a cloned run record for the session/run combination.\n\nThis method retrieves a run record from the store for the specified session\nand optional run identifier. When run_id is None, returns the most recent\nrun for the session. The returned record is a shallow copy to prevent\nexternal modifications.\n\nParameters\n----------\nsession_id : str\n    Session identifier to search for. Used to filter run records by session.\n    The method searches for runs associated with this session.\nrun_id : str | None, optional\n    Optional run identifier to retrieve a specific run (default: None).\n    When None, returns the most recent run for the session by searching\n    the order deque in reverse. When provided, retrieves the exact run\n    matching both session_id and run_id.\n\nReturns\n-------\nRunRecord | None\n    Shallow copy of the stored run record, or None when no matching run\n    is found. The record contains events, checkpoints, and metadata for\n    the requested run.",
  "is_public": true
}
{
  "path": "telemetry/reporter.py",
  "module": "telemetry.reporter",
  "qualname": "start_run",
  "name": "start_run",
  "node_type": "FunctionDef",
  "lineno": 523,
  "col": 0,
  "end_lineno": 538,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Register a run at request ingress.",
  "is_public": true
}
{
  "path": "telemetry/reporter.py",
  "module": "telemetry.reporter",
  "qualname": "finalize_run",
  "name": "finalize_run",
  "node_type": "FunctionDef",
  "lineno": 541,
  "col": 0,
  "end_lineno": 556,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Mark the run as complete/partial/error.",
  "is_public": true
}
{
  "path": "telemetry/reporter.py",
  "module": "telemetry.reporter",
  "qualname": "record_timeline_payload",
  "name": "record_timeline_payload",
  "node_type": "FunctionDef",
  "lineno": 559,
  "col": 0,
  "end_lineno": 561,
  "end_col": 56,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Subscribe to timeline events.",
  "is_public": true
}
{
  "path": "telemetry/reporter.py",
  "module": "telemetry.reporter",
  "qualname": "record_step_payload",
  "name": "record_step_payload",
  "node_type": "FunctionDef",
  "lineno": 564,
  "col": 0,
  "end_lineno": 566,
  "end_col": 53,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Record structured step events for inclusion in run reports.",
  "is_public": true
}
{
  "path": "telemetry/reporter.py",
  "module": "telemetry.reporter",
  "qualname": "emit_checkpoint",
  "name": "emit_checkpoint",
  "node_type": "FunctionDef",
  "lineno": 569,
  "col": 0,
  "end_lineno": 583,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Capture a stage checkpoint tied to the current request.",
  "is_public": true
}
{
  "path": "telemetry/reporter.py",
  "module": "telemetry.reporter",
  "qualname": "_build_operations",
  "name": "_build_operations",
  "node_type": "FunctionDef",
  "lineno": 586,
  "col": 0,
  "end_lineno": 622,
  "end_col": 28,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "telemetry/reporter.py",
  "module": "telemetry.reporter",
  "qualname": "_collect",
  "name": "_collect",
  "node_type": "FunctionDef",
  "lineno": 625,
  "col": 0,
  "end_lineno": 643,
  "end_col": 20,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "telemetry/reporter.py",
  "module": "telemetry.reporter",
  "qualname": "build_report",
  "name": "build_report",
  "node_type": "FunctionDef",
  "lineno": 646,
  "col": 0,
  "end_lineno": 725,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Build a run report for the provided session/run identifiers.\n\nThis function aggregates telemetry data from stored run records and builds\na comprehensive RunReport containing operations, steps, decisions, warnings,\nerrors, and checkpoints. The function retrieves the run record from the\nstore and processes events to generate the report.\n\nParameters\n----------\ncontext : ApplicationContext\n    Application context containing runtime configuration and state. Used to\n    access application metadata and configuration for the report. The context\n    provides information about the application instance that generated the run.\nsession_id : str\n    Session identifier to retrieve run data for. Used to identify the\n    telemetry session containing the run report. Must match a session in\n    the run report store.\nrun_id : str | None, optional\n    Optional run identifier to retrieve a specific run report (default: None).\n    When None, retrieves the most recent run for the session. When provided,\n    retrieves the exact run matching both session_id and run_id.\n\nReturns\n-------\nRunReport | None\n    Aggregated run report containing operations, steps, decisions, warnings,\n    errors, and checkpoints, or None when no matching run data exists in\n    the store. The report is suitable for serialization and display.",
  "is_public": true
}
{
  "path": "telemetry/reporter.py",
  "module": "telemetry.reporter",
  "qualname": "build_run_report_v2",
  "name": "build_run_report_v2",
  "node_type": "FunctionDef",
  "lineno": 728,
  "col": 0,
  "end_lineno": 809,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return a compact stage-centric report for ``session_id``/``run_id``.\n\nParameters\n----------\nsession_id : str\n    Session identifier to summarize.\nrun_id : str | None, optional\n    Specific run identifier. When ``None``, the most recent run is used.\n\nReturns\n-------\nRunReportV2 | None\n    Compact run summary when available, otherwise ``None``.",
  "is_public": true
}
{
  "path": "telemetry/reporter.py",
  "module": "telemetry.reporter",
  "qualname": "report_to_json",
  "name": "report_to_json",
  "node_type": "FunctionDef",
  "lineno": 812,
  "col": 0,
  "end_lineno": 859,
  "end_col": 18,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return JSON-serializable payload for the report.\n\nThis function converts a RunReport object into a JSON-serializable dictionary\nby calling the report's to_dict() method. The resulting dictionary can be\nserialized to JSON for API responses or storage.\n\nParameters\n----------\nreport : RunReport\n    Run report object to convert to JSON format. The report contains\n    operations, steps, decisions, warnings, errors, and checkpoints that\n    are serialized into the dictionary.\n\nReturns\n-------\ndict[str, Any]\n    JSON-ready dictionary representation of the report. The dictionary\n    contains all report fields in a format suitable for JSON serialization.\n    Can be used with json.dumps() or FastAPI JSONResponse.",
  "is_public": true
}
{
  "path": "telemetry/reporter.py",
  "module": "telemetry.reporter",
  "qualname": "RunReportStage",
  "name": "RunReportStage",
  "node_type": "ClassDef",
  "lineno": 863,
  "col": 0,
  "end_lineno": 892,
  "end_col": 9,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Normalized stage summary for RunReportV2.",
  "is_public": true
}
{
  "path": "telemetry/reporter.py",
  "module": "telemetry.reporter",
  "qualname": "RunReportStage.as_dict",
  "name": "as_dict",
  "node_type": "FunctionDef",
  "lineno": 875,
  "col": 4,
  "end_lineno": 892,
  "end_col": 9,
  "parent_qualname": "RunReportStage",
  "decorators": [],
  "bases": [],
  "docstring": "Return a JSON-serializable representation of the stage.\n\nReturns\n-------\ndict[str, object]\n    Stage summary payload.",
  "is_public": true
}
{
  "path": "telemetry/reporter.py",
  "module": "telemetry.reporter",
  "qualname": "RunReportV2",
  "name": "RunReportV2",
  "node_type": "ClassDef",
  "lineno": 896,
  "col": 0,
  "end_lineno": 933,
  "end_col": 9,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Compact narrative describing key retrieval stages.",
  "is_public": true
}
{
  "path": "telemetry/reporter.py",
  "module": "telemetry.reporter",
  "qualname": "RunReportV2.as_dict",
  "name": "as_dict",
  "node_type": "FunctionDef",
  "lineno": 912,
  "col": 4,
  "end_lineno": 933,
  "end_col": 9,
  "parent_qualname": "RunReportV2",
  "decorators": [],
  "bases": [],
  "docstring": "Return a JSON-serializable payload for the V2 report.\n\nReturns\n-------\ndict[str, object]\n    Serialized report dictionary.",
  "is_public": true
}
{
  "path": "telemetry/reporter.py",
  "module": "telemetry.reporter",
  "qualname": "render_mermaid",
  "name": "render_mermaid",
  "node_type": "FunctionDef",
  "lineno": 936,
  "col": 0,
  "end_lineno": 971,
  "end_col": 27,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return a Mermaid graph describing stage checkpoints.\n\nThis function renders a run report as a Mermaid flowchart diagram showing\nthe sequence of stage checkpoints and their status. It is called by HTTP\nendpoints and CLI commands to visualize run execution flow.\n\nParameters\n----------\nreport : RunReport\n    Run report containing checkpoint data to visualize.\n\nReturns\n-------\nstr\n    Mermaid ``graph TD`` describing the run's checkpoints with node labels\n    showing stage names, status (OK/FAILED), and optional reason messages.",
  "is_public": true
}
{
  "path": "telemetry/reporter.py",
  "module": "telemetry.reporter",
  "qualname": "render_markdown",
  "name": "render_markdown",
  "node_type": "FunctionDef",
  "lineno": 974,
  "col": 0,
  "end_lineno": 1048,
  "end_col": 27,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Render the report as Markdown.\n\nThis function converts a RunReport object into a human-readable Markdown\nstring. The function formats operations, steps, decisions, warnings, errors,\nand checkpoints into structured Markdown sections suitable for display in\ndocumentation or web interfaces.\n\nParameters\n----------\nreport : RunReport\n    Run report object to render as Markdown. The report contains telemetry\n    data, metrics, and execution details that are formatted into Markdown\n    sections with headers, lists, and tables.\n\nReturns\n-------\nstr\n    Markdown-formatted summary string containing all report sections.\n    The string includes headers, lists, and formatted data suitable for\n    rendering in Markdown viewers or conversion to HTML.",
  "is_public": true
}
{
  "path": "telemetry/reporter.py",
  "module": "telemetry.reporter",
  "qualname": "render_markdown._append_section",
  "name": "_append_section",
  "node_type": "FunctionDef",
  "lineno": 997,
  "col": 4,
  "end_lineno": 1001,
  "end_col": 29,
  "parent_qualname": "render_markdown",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "telemetry/reporter.py",
  "module": "telemetry.reporter",
  "qualname": "_format_markdown_header",
  "name": "_format_markdown_header",
  "node_type": "FunctionDef",
  "lineno": 1051,
  "col": 0,
  "end_lineno": 1074,
  "end_col": 16,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Format report header section.\n\nParameters\n----------\nreport : RunReportV2\n    Report to format.\n\nReturns\n-------\nlist[str]\n    Header lines.",
  "is_public": false
}
{
  "path": "telemetry/reporter.py",
  "module": "telemetry.reporter",
  "qualname": "_format_markdown_stages",
  "name": "_format_markdown_stages",
  "node_type": "FunctionDef",
  "lineno": 1077,
  "col": 0,
  "end_lineno": 1097,
  "end_col": 16,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Format stages section.\n\nParameters\n----------\nreport : RunReportV2\n    Report to format.\n\nReturns\n-------\nlist[str]\n    Stage lines.",
  "is_public": false
}
{
  "path": "telemetry/reporter.py",
  "module": "telemetry.reporter",
  "qualname": "_format_markdown_timeline",
  "name": "_format_markdown_timeline",
  "node_type": "FunctionDef",
  "lineno": 1100,
  "col": 0,
  "end_lineno": 1123,
  "end_col": 16,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Format timeline section.\n\nParameters\n----------\nreport : RunReportV2\n    Report to format.\n\nReturns\n-------\nlist[str]\n    Timeline lines.",
  "is_public": false
}
{
  "path": "telemetry/reporter.py",
  "module": "telemetry.reporter",
  "qualname": "_format_markdown_events",
  "name": "_format_markdown_events",
  "node_type": "FunctionDef",
  "lineno": 1126,
  "col": 0,
  "end_lineno": 1148,
  "end_col": 16,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Format discrete events section.\n\nParameters\n----------\nreport : RunReportV2\n    Report to format.\n\nReturns\n-------\nlist[str]\n    Event lines.",
  "is_public": false
}
{
  "path": "telemetry/reporter.py",
  "module": "telemetry.reporter",
  "qualname": "render_markdown_v2",
  "name": "render_markdown_v2",
  "node_type": "FunctionDef",
  "lineno": 1151,
  "col": 0,
  "end_lineno": 1193,
  "end_col": 27,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Render a RunReportV2 payload as Markdown text.\n\nThis function formats a compact stage-centric run report as Markdown suitable\nfor display in documentation or web interfaces. It is called by HTTP endpoints\nand CLI commands to provide human-readable run summaries.\n\nParameters\n----------\nreport : RunReportV2\n    Compact run report containing stages, warnings, and metadata.\n\nReturns\n-------\nstr\n    Markdown-formatted representation of the V2 report including run ID,\n    trace ID, session ID, stage summaries, and warnings.",
  "is_public": true
}
{
  "path": "telemetry/steps.py",
  "module": "telemetry.steps",
  "qualname": "telemetry.steps",
  "name": "telemetry.steps",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Structured step event helpers.",
  "is_public": true
}
{
  "path": "telemetry/steps.py",
  "module": "telemetry.steps",
  "qualname": "StepEvent",
  "name": "StepEvent",
  "node_type": "ClassDef",
  "lineno": 32,
  "col": 0,
  "end_lineno": 38,
  "end_col": 44,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Immutable representation of a discrete pipeline step.",
  "is_public": true
}
{
  "path": "telemetry/steps.py",
  "module": "telemetry.steps",
  "qualname": "_now_iso",
  "name": "_now_iso",
  "node_type": "FunctionDef",
  "lineno": 41,
  "col": 0,
  "end_lineno": 42,
  "end_col": 43,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "telemetry/steps.py",
  "module": "telemetry.steps",
  "qualname": "emit_step",
  "name": "emit_step",
  "node_type": "FunctionDef",
  "lineno": 45,
  "col": 0,
  "end_lineno": 82,
  "end_col": 72,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Emit a structured step event to the current sinks.",
  "is_public": true
}
{
  "path": "telemetry/steps.py",
  "module": "telemetry.steps",
  "qualname": "_record_structured_event",
  "name": "_record_structured_event",
  "node_type": "FunctionDef",
  "lineno": 85,
  "col": 0,
  "end_lineno": 101,
  "end_col": 78,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "typedness.py",
  "module": "typedness",
  "qualname": "typedness",
  "name": "typedness",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Typedness utilities that build on Pyrefly/Pyright summaries.",
  "is_public": true
}
{
  "path": "typedness.py",
  "module": "typedness",
  "qualname": "FileTypeSignals",
  "name": "FileTypeSignals",
  "node_type": "ClassDef",
  "lineno": 13,
  "col": 0,
  "end_lineno": 22,
  "end_col": 60,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Joined Pyrefly/Pyright error counts for a single file.",
  "is_public": true
}
{
  "path": "typedness.py",
  "module": "typedness",
  "qualname": "FileTypeSignals.total",
  "name": "total",
  "node_type": "FunctionDef",
  "lineno": 20,
  "col": 4,
  "end_lineno": 22,
  "end_col": 60,
  "parent_qualname": "FileTypeSignals",
  "decorators": [
    "property"
  ],
  "bases": [],
  "docstring": "Return the max error count across all sources.",
  "is_public": true
}
{
  "path": "typedness.py",
  "module": "typedness",
  "qualname": "collect_type_signals",
  "name": "collect_type_signals",
  "node_type": "FunctionDef",
  "lineno": 25,
  "col": 0,
  "end_lineno": 64,
  "end_col": 18,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Collect Pyrefly/Pyright diagnostics keyed by file path.\n\nParameters\n----------\npyrefly_report : str | None, optional\n    Path to a Pyrefly JSON/JSONL report. When None, Pyrefly is not queried.\npyright_json : str | None, optional\n    Directory or file path passed through to ``collect_pyright``. When None,\n    Pyright is not queried.\n\nReturns\n-------\ndict[str, FileTypeSignals]\n    Mapping of normalized file paths to joined error counts.",
  "is_public": true
}
{
  "path": "typedness.py",
  "module": "typedness",
  "qualname": "annotation_ratio",
  "name": "annotation_ratio",
  "node_type": "FunctionDef",
  "lineno": 67,
  "col": 0,
  "end_lineno": 84,
  "end_col": 5,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Return per-module annotation ratios derived from :class:`ModuleIndex`.\n\nParameters\n----------\nmodule_index : ModuleIndex\n    Parsed module metadata produced by ``index_module``.\n\nReturns\n-------\ndict[str, float]\n    Mapping with ``\"params\"`` and ``\"returns\"`` ratios clamped to ``[0.0, 1.0]``.",
  "is_public": true
}
{
  "path": "typing.py",
  "module": "typing",
  "qualname": "typing",
  "name": "typing",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Typing faade for codeintel_rev heavy optional dependencies.\n\nThis module centralizes numpy-style array aliases and exposes a wrapper around\n``kgfoundry_common.typing.gate_import`` that is aware of the local heavy\ndependency policy. Keeping aliases and dependency metadata in one place lets\nlint/type tooling (PR-E) and runtime helpers share the same source of truth.",
  "is_public": true
}
{
  "path": "typing.py",
  "module": "typing",
  "qualname": "gate_import",
  "name": "gate_import",
  "node_type": "FunctionDef",
  "lineno": 48,
  "col": 0,
  "end_lineno": 88,
  "end_col": 75,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Resolve ``module_name`` lazily using the heavy dependency policy.\n\nExtended Summary\n----------------\nThis function provides lazy import resolution for heavy optional dependencies\n(e.g., numpy, fastapi, FAISS) using the shared gate helper. It validates\nmodule availability, checks minimum version requirements, and provides helpful\nerror messages if dependencies are missing. Used throughout the codebase to\nsafely import optional dependencies without breaking on minimal installations.\n\nParameters\n----------\nmodule_name : str\n    Name of the module to import (e.g., \"numpy\", \"faiss\"). The module must\n    be registered in the heavy dependency registry.\npurpose : str\n    Human-readable purpose description for the import (e.g., \"vector operations\",\n    \"FAISS index management\"). Used in error messages if the module is unavailable.\nmin_version : str | None, optional\n    Optional minimum version requirement (e.g., \"1.24.0\"). If provided, the\n    module version is validated against this requirement.\n\nReturns\n-------\nobject\n    Imported module or attribute returned by the shared gate helper. The return\n    type depends on the module structure.\n\nNotes\n-----\nThis function delegates to the base gate helper from kgfoundry_common.typing.\nIt provides a consistent API for lazy imports across the codebase. Time\ncomplexity: O(1) for cached imports, O(import_time) for first-time imports.",
  "is_public": true
}
{
  "path": "typing.py",
  "module": "typing",
  "qualname": "TorchDeviceProperties",
  "name": "TorchDeviceProperties",
  "node_type": "ClassDef",
  "lineno": 91,
  "col": 0,
  "end_lineno": 94,
  "end_col": 21,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "Protocol"
  ],
  "docstring": "Subset of torch.cuda device properties accessed by diagnostics.",
  "is_public": true
}
{
  "path": "typing.py",
  "module": "typing",
  "qualname": "TorchCudaAPI",
  "name": "TorchCudaAPI",
  "node_type": "ClassDef",
  "lineno": 97,
  "col": 0,
  "end_lineno": 191,
  "end_col": 11,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "Protocol"
  ],
  "docstring": "Minimal CUDA API surface used throughout the codebase.",
  "is_public": true
}
{
  "path": "typing.py",
  "module": "typing",
  "qualname": "TorchCudaAPI.is_available",
  "name": "is_available",
  "node_type": "FunctionDef",
  "lineno": 100,
  "col": 4,
  "end_lineno": 108,
  "end_col": 11,
  "parent_qualname": "TorchCudaAPI",
  "decorators": [],
  "bases": [],
  "docstring": "Check if CUDA is available on the system.\n\nReturns\n-------\nbool\n    True if CUDA is available and can be used, False otherwise.",
  "is_public": true
}
{
  "path": "typing.py",
  "module": "typing",
  "qualname": "TorchCudaAPI.device_count",
  "name": "device_count",
  "node_type": "FunctionDef",
  "lineno": 110,
  "col": 4,
  "end_lineno": 118,
  "end_col": 11,
  "parent_qualname": "TorchCudaAPI",
  "decorators": [],
  "bases": [],
  "docstring": "Get the number of available CUDA devices.\n\nReturns\n-------\nint\n    Number of CUDA-capable GPUs available on the system.",
  "is_public": true
}
{
  "path": "typing.py",
  "module": "typing",
  "qualname": "TorchCudaAPI.current_device",
  "name": "current_device",
  "node_type": "FunctionDef",
  "lineno": 120,
  "col": 4,
  "end_lineno": 128,
  "end_col": 11,
  "parent_qualname": "TorchCudaAPI",
  "decorators": [],
  "bases": [],
  "docstring": "Get the index of the currently selected CUDA device.\n\nReturns\n-------\nint\n    Index of the currently active CUDA device (0-based).",
  "is_public": true
}
{
  "path": "typing.py",
  "module": "typing",
  "qualname": "TorchCudaAPI.get_device_name",
  "name": "get_device_name",
  "node_type": "FunctionDef",
  "lineno": 130,
  "col": 4,
  "end_lineno": 143,
  "end_col": 11,
  "parent_qualname": "TorchCudaAPI",
  "decorators": [],
  "bases": [],
  "docstring": "Get the name of a CUDA device.\n\nParameters\n----------\nindex : int\n    Device index (0-based) to query.\n\nReturns\n-------\nstr\n    Human-readable device name (e.g., \"NVIDIA GeForce RTX 3090\").",
  "is_public": true
}
{
  "path": "typing.py",
  "module": "typing",
  "qualname": "TorchCudaAPI.get_device_capability",
  "name": "get_device_capability",
  "node_type": "FunctionDef",
  "lineno": 145,
  "col": 4,
  "end_lineno": 159,
  "end_col": 11,
  "parent_qualname": "TorchCudaAPI",
  "decorators": [],
  "bases": [],
  "docstring": "Get the compute capability of a CUDA device.\n\nParameters\n----------\nindex : int\n    Device index (0-based) to query.\n\nReturns\n-------\ntuple[int, int]\n    Tuple of (major, minor) compute capability version (e.g., (8, 6)\n    for compute capability 8.6).",
  "is_public": true
}
{
  "path": "typing.py",
  "module": "typing",
  "qualname": "TorchCudaAPI.get_device_properties",
  "name": "get_device_properties",
  "node_type": "FunctionDef",
  "lineno": 161,
  "col": 4,
  "end_lineno": 175,
  "end_col": 11,
  "parent_qualname": "TorchCudaAPI",
  "decorators": [],
  "bases": [],
  "docstring": "Get properties of a CUDA device.\n\nParameters\n----------\nindex : int\n    Device index (0-based) to query.\n\nReturns\n-------\nTorchDeviceProperties\n    Device properties object containing memory information and other\n    device characteristics.",
  "is_public": true
}
{
  "path": "typing.py",
  "module": "typing",
  "qualname": "TorchCudaAPI.synchronize",
  "name": "synchronize",
  "node_type": "FunctionDef",
  "lineno": 177,
  "col": 4,
  "end_lineno": 183,
  "end_col": 11,
  "parent_qualname": "TorchCudaAPI",
  "decorators": [],
  "bases": [],
  "docstring": "Synchronize all CUDA operations on the current device.\n\nBlocks until all CUDA operations on the current device have completed.\nUsed to ensure operations are finished before proceeding.",
  "is_public": true
}
{
  "path": "typing.py",
  "module": "typing",
  "qualname": "TorchCudaAPI.init",
  "name": "init",
  "node_type": "FunctionDef",
  "lineno": 185,
  "col": 4,
  "end_lineno": 191,
  "end_col": 11,
  "parent_qualname": "TorchCudaAPI",
  "decorators": [],
  "bases": [],
  "docstring": "Initialize CUDA runtime.\n\nPerforms one-time initialization of the CUDA runtime. Safe to call\nmultiple times (idempotent).",
  "is_public": true
}
{
  "path": "typing.py",
  "module": "typing",
  "qualname": "TorchTensor",
  "name": "TorchTensor",
  "node_type": "ClassDef",
  "lineno": 194,
  "col": 0,
  "end_lineno": 240,
  "end_col": 11,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "Protocol"
  ],
  "docstring": "Tensor operations invoked inside diagnostics.",
  "is_public": true
}
{
  "path": "typing.py",
  "module": "typing",
  "qualname": "TorchTensor.__matmul__",
  "name": "__matmul__",
  "node_type": "FunctionDef",
  "lineno": 197,
  "col": 4,
  "end_lineno": 210,
  "end_col": 11,
  "parent_qualname": "TorchTensor",
  "decorators": [],
  "bases": [],
  "docstring": "Matrix multiplication operator.\n\nParameters\n----------\nother : TorchTensor\n    Right-hand operand for matrix multiplication.\n\nReturns\n-------\nTorchTensor\n    Result tensor from matrix multiplication.",
  "is_public": false
}
{
  "path": "typing.py",
  "module": "typing",
  "qualname": "TorchTensor.transpose",
  "name": "transpose",
  "node_type": "FunctionDef",
  "lineno": 213,
  "col": 4,
  "end_lineno": 215,
  "end_col": 11,
  "parent_qualname": "TorchTensor",
  "decorators": [
    "property"
  ],
  "bases": [],
  "docstring": "Transpose property mirroring ``torch.Tensor.T``.",
  "is_public": true
}
{
  "path": "typing.py",
  "module": "typing",
  "qualname": "TorchTensor.__getattr__",
  "name": "__getattr__",
  "node_type": "FunctionDef",
  "lineno": 217,
  "col": 4,
  "end_lineno": 219,
  "end_col": 11,
  "parent_qualname": "TorchTensor",
  "decorators": [],
  "bases": [],
  "docstring": "Return torch-style transpose alias.",
  "is_public": false
}
{
  "path": "typing.py",
  "module": "typing",
  "qualname": "TorchTensor.sum",
  "name": "sum",
  "node_type": "FunctionDef",
  "lineno": 221,
  "col": 4,
  "end_lineno": 229,
  "end_col": 11,
  "parent_qualname": "TorchTensor",
  "decorators": [],
  "bases": [],
  "docstring": "Sum all elements of the tensor.\n\nReturns\n-------\nTorchTensor\n    Scalar tensor containing the sum of all elements.",
  "is_public": true
}
{
  "path": "typing.py",
  "module": "typing",
  "qualname": "TorchTensor.item",
  "name": "item",
  "node_type": "FunctionDef",
  "lineno": 231,
  "col": 4,
  "end_lineno": 240,
  "end_col": 11,
  "parent_qualname": "TorchTensor",
  "decorators": [],
  "bases": [],
  "docstring": "Extract scalar value from single-element tensor.\n\nReturns\n-------\nfloat\n    Python scalar value extracted from the tensor. Raises ValueError\n    if the tensor contains more than one element.",
  "is_public": true
}
{
  "path": "typing.py",
  "module": "typing",
  "qualname": "TorchModule",
  "name": "TorchModule",
  "node_type": "ClassDef",
  "lineno": 243,
  "col": 0,
  "end_lineno": 258,
  "end_col": 11,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "Protocol"
  ],
  "docstring": "Subset of torch's module-level API we rely on.",
  "is_public": true
}
{
  "path": "typing.py",
  "module": "typing",
  "qualname": "TorchModule.device",
  "name": "device",
  "node_type": "FunctionDef",
  "lineno": 248,
  "col": 4,
  "end_lineno": 250,
  "end_col": 11,
  "parent_qualname": "TorchModule",
  "decorators": [],
  "bases": [],
  "docstring": "Create a device object from name string.",
  "is_public": true
}
{
  "path": "typing.py",
  "module": "typing",
  "qualname": "TorchModule.randn",
  "name": "randn",
  "node_type": "FunctionDef",
  "lineno": 252,
  "col": 4,
  "end_lineno": 254,
  "end_col": 11,
  "parent_qualname": "TorchModule",
  "decorators": [],
  "bases": [],
  "docstring": "Generate random tensor with standard normal distribution.",
  "is_public": true
}
{
  "path": "typing.py",
  "module": "typing",
  "qualname": "TorchModule.matmul",
  "name": "matmul",
  "node_type": "FunctionDef",
  "lineno": 256,
  "col": 4,
  "end_lineno": 258,
  "end_col": 11,
  "parent_qualname": "TorchModule",
  "decorators": [],
  "bases": [],
  "docstring": "Matrix multiplication of two tensors.",
  "is_public": true
}
{
  "path": "typing.py",
  "module": "typing",
  "qualname": "FaissStandardGpuResources",
  "name": "FaissStandardGpuResources",
  "node_type": "ClassDef",
  "lineno": 261,
  "col": 0,
  "end_lineno": 262,
  "end_col": 40,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "Protocol"
  ],
  "docstring": "GPU resource handle for FAISS.",
  "is_public": true
}
{
  "path": "typing.py",
  "module": "typing",
  "qualname": "FaissGpuClonerOptions",
  "name": "FaissGpuClonerOptions",
  "node_type": "ClassDef",
  "lineno": 265,
  "col": 0,
  "end_lineno": 270,
  "end_col": 35,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "Protocol"
  ],
  "docstring": "Options controlling FAISS GPU cloning behavior.",
  "is_public": true
}
{
  "path": "typing.py",
  "module": "typing",
  "qualname": "FaissGpuClonerOptions.__init__",
  "name": "__init__",
  "node_type": "FunctionDef",
  "lineno": 270,
  "col": 4,
  "end_lineno": 270,
  "end_col": 35,
  "parent_qualname": "FaissGpuClonerOptions",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "typing.py",
  "module": "typing",
  "qualname": "FaissIndex",
  "name": "FaissIndex",
  "node_type": "ClassDef",
  "lineno": 273,
  "col": 0,
  "end_lineno": 276,
  "end_col": 15,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "Protocol"
  ],
  "docstring": "Minimal FAISS index surface used in diagnostics.",
  "is_public": true
}
{
  "path": "typing.py",
  "module": "typing",
  "qualname": "FaissGpuIndexFlatIP",
  "name": "FaissGpuIndexFlatIP",
  "node_type": "ClassDef",
  "lineno": 279,
  "col": 0,
  "end_lineno": 288,
  "end_col": 11,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "FaissIndex",
    "Protocol"
  ],
  "docstring": "GPU FAISS index used for smoke testing.",
  "is_public": true
}
{
  "path": "typing.py",
  "module": "typing",
  "qualname": "FaissGpuIndexFlatIP.add",
  "name": "add",
  "node_type": "FunctionDef",
  "lineno": 282,
  "col": 4,
  "end_lineno": 284,
  "end_col": 11,
  "parent_qualname": "FaissGpuIndexFlatIP",
  "decorators": [],
  "bases": [],
  "docstring": "Add vectors to the index.",
  "is_public": true
}
{
  "path": "typing.py",
  "module": "typing",
  "qualname": "FaissGpuIndexFlatIP.search",
  "name": "search",
  "node_type": "FunctionDef",
  "lineno": 286,
  "col": 4,
  "end_lineno": 288,
  "end_col": 11,
  "parent_qualname": "FaissGpuIndexFlatIP",
  "decorators": [],
  "bases": [],
  "docstring": "Search for k nearest neighbors.",
  "is_public": true
}
{
  "path": "typing.py",
  "module": "typing",
  "qualname": "FaissModule",
  "name": "FaissModule",
  "node_type": "ClassDef",
  "lineno": 291,
  "col": 0,
  "end_lineno": 327,
  "end_col": 11,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "Protocol"
  ],
  "docstring": "Subset of the FAISS module accessed via gate_import.",
  "is_public": true
}
{
  "path": "typing.py",
  "module": "typing",
  "qualname": "FaissModule._ResourceCtor",
  "name": "_ResourceCtor",
  "node_type": "ClassDef",
  "lineno": 294,
  "col": 4,
  "end_lineno": 295,
  "end_col": 60,
  "parent_qualname": "FaissModule",
  "decorators": [],
  "bases": [
    "Protocol"
  ],
  "docstring": null,
  "is_public": false
}
{
  "path": "typing.py",
  "module": "typing",
  "qualname": "FaissModule._ResourceCtor.__call__",
  "name": "__call__",
  "node_type": "FunctionDef",
  "lineno": 295,
  "col": 8,
  "end_lineno": 295,
  "end_col": 60,
  "parent_qualname": "FaissModule._ResourceCtor",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "typing.py",
  "module": "typing",
  "qualname": "FaissModule._IndexCtor",
  "name": "_IndexCtor",
  "node_type": "ClassDef",
  "lineno": 297,
  "col": 4,
  "end_lineno": 300,
  "end_col": 37,
  "parent_qualname": "FaissModule",
  "decorators": [],
  "bases": [
    "Protocol"
  ],
  "docstring": null,
  "is_public": false
}
{
  "path": "typing.py",
  "module": "typing",
  "qualname": "FaissModule._IndexCtor.__call__",
  "name": "__call__",
  "node_type": "FunctionDef",
  "lineno": 298,
  "col": 8,
  "end_lineno": 300,
  "end_col": 37,
  "parent_qualname": "FaissModule._IndexCtor",
  "decorators": [],
  "bases": [],
  "docstring": null,
  "is_public": false
}
{
  "path": "typing.py",
  "module": "typing",
  "qualname": "FaissModule.get_num_gpus",
  "name": "get_num_gpus",
  "node_type": "FunctionDef",
  "lineno": 307,
  "col": 4,
  "end_lineno": 309,
  "end_col": 11,
  "parent_qualname": "FaissModule",
  "decorators": [],
  "bases": [],
  "docstring": "Return the number of available GPUs.",
  "is_public": true
}
{
  "path": "typing.py",
  "module": "typing",
  "qualname": "FaissModule.normalize_l2",
  "name": "normalize_l2",
  "node_type": "FunctionDef",
  "lineno": 311,
  "col": 4,
  "end_lineno": 313,
  "end_col": 11,
  "parent_qualname": "FaissModule",
  "decorators": [],
  "bases": [],
  "docstring": "Normalize vectors using L2 norm in-place.",
  "is_public": true
}
{
  "path": "typing.py",
  "module": "typing",
  "qualname": "FaissModule.__getattr__",
  "name": "__getattr__",
  "node_type": "FunctionDef",
  "lineno": 315,
  "col": 4,
  "end_lineno": 317,
  "end_col": 11,
  "parent_qualname": "FaissModule",
  "decorators": [],
  "bases": [],
  "docstring": "Provide FAISS-compatible alias for ``normalize_L2``.",
  "is_public": false
}
{
  "path": "typing.py",
  "module": "typing",
  "qualname": "FaissModule.index_cpu_to_gpu",
  "name": "index_cpu_to_gpu",
  "node_type": "FunctionDef",
  "lineno": 319,
  "col": 4,
  "end_lineno": 327,
  "end_col": 11,
  "parent_qualname": "FaissModule",
  "decorators": [],
  "bases": [],
  "docstring": "Clone CPU index to GPU.",
  "is_public": true
}
{
  "path": "typing.py",
  "module": "typing",
  "qualname": "NumpyRandomState",
  "name": "NumpyRandomState",
  "node_type": "ClassDef",
  "lineno": 330,
  "col": 0,
  "end_lineno": 348,
  "end_col": 11,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "Protocol"
  ],
  "docstring": "Random state wrapper for numpy.random.",
  "is_public": true
}
{
  "path": "typing.py",
  "module": "typing",
  "qualname": "NumpyRandomState.randn",
  "name": "randn",
  "node_type": "FunctionDef",
  "lineno": 333,
  "col": 4,
  "end_lineno": 348,
  "end_col": 11,
  "parent_qualname": "NumpyRandomState",
  "decorators": [],
  "bases": [],
  "docstring": "Generate random array from standard normal distribution.\n\nParameters\n----------\n*shape : int\n    Variable-length shape arguments defining the output array dimensions\n    (e.g., randn(3, 4) creates a 3x4 array).\n\nReturns\n-------\nNDArrayF32\n    Random array with specified shape, sampled from standard normal\n    distribution (mean=0, std=1), dtype float32.",
  "is_public": true
}
{
  "path": "typing.py",
  "module": "typing",
  "qualname": "NumpyRandomNamespace",
  "name": "NumpyRandomNamespace",
  "node_type": "ClassDef",
  "lineno": 351,
  "col": 0,
  "end_lineno": 372,
  "end_col": 11,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "Protocol"
  ],
  "docstring": "Namespace for numpy.random helpers.",
  "is_public": true
}
{
  "path": "typing.py",
  "module": "typing",
  "qualname": "NumpyRandomNamespace.random_state",
  "name": "random_state",
  "node_type": "FunctionDef",
  "lineno": 354,
  "col": 4,
  "end_lineno": 368,
  "end_col": 11,
  "parent_qualname": "NumpyRandomNamespace",
  "decorators": [],
  "bases": [],
  "docstring": "Create a random state generator with fixed seed.\n\nParameters\n----------\nseed : int\n    Random seed value for reproducible random number generation.\n\nReturns\n-------\nNumpyRandomState\n    Random state instance initialized with the given seed, providing\n    methods for generating random arrays with reproducible sequences.",
  "is_public": true
}
{
  "path": "typing.py",
  "module": "typing",
  "qualname": "NumpyRandomNamespace.__getattr__",
  "name": "__getattr__",
  "node_type": "FunctionDef",
  "lineno": 370,
  "col": 4,
  "end_lineno": 372,
  "end_col": 11,
  "parent_qualname": "NumpyRandomNamespace",
  "decorators": [],
  "bases": [],
  "docstring": "Expose numpy-style ``RandomState`` constructor.",
  "is_public": false
}
{
  "path": "typing.py",
  "module": "typing",
  "qualname": "NumpyLinalgNamespace",
  "name": "NumpyLinalgNamespace",
  "node_type": "ClassDef",
  "lineno": 375,
  "col": 0,
  "end_lineno": 397,
  "end_col": 11,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "Protocol"
  ],
  "docstring": "Namespace for numpy.linalg helpers.",
  "is_public": true
}
{
  "path": "typing.py",
  "module": "typing",
  "qualname": "NumpyLinalgNamespace.norm",
  "name": "norm",
  "node_type": "FunctionDef",
  "lineno": 378,
  "col": 4,
  "end_lineno": 397,
  "end_col": 11,
  "parent_qualname": "NumpyLinalgNamespace",
  "decorators": [],
  "bases": [],
  "docstring": "Compute vector or matrix norm along specified axis.\n\nParameters\n----------\narray : NDArrayF32\n    Input array to compute norm for, dtype float32.\naxis : int\n    Axis along which to compute the norm. If negative, counts from the last axis.\nkeepdims : bool\n    If True, keep reduced dimensions with size 1 in the result. If False,\n    remove reduced dimensions.\n\nReturns\n-------\nNDArrayF32\n    Norm values computed along the specified axis, dtype float32. Shape\n    depends on input shape and keepdims parameter.",
  "is_public": true
}
{
  "path": "typing.py",
  "module": "typing",
  "qualname": "NumpyModule",
  "name": "NumpyModule",
  "node_type": "ClassDef",
  "lineno": 400,
  "col": 0,
  "end_lineno": 404,
  "end_col": 32,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "Protocol"
  ],
  "docstring": "Enough of numpy's surface for lazy imports.",
  "is_public": true
}
{
  "path": "typing.py",
  "module": "typing",
  "qualname": "PolarsDataFrame",
  "name": "PolarsDataFrame",
  "node_type": "ClassDef",
  "lineno": 407,
  "col": 0,
  "end_lineno": 425,
  "end_col": 11,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "Protocol"
  ],
  "docstring": "Subset of polars.DataFrame used for Parquet exports.",
  "is_public": true
}
{
  "path": "typing.py",
  "module": "typing",
  "qualname": "PolarsDataFrame.write_parquet",
  "name": "write_parquet",
  "node_type": "FunctionDef",
  "lineno": 410,
  "col": 4,
  "end_lineno": 425,
  "end_col": 11,
  "parent_qualname": "PolarsDataFrame",
  "decorators": [],
  "bases": [],
  "docstring": "Write DataFrame to Parquet format.\n\nParameters\n----------\nfile : str | PathLike[str]\n    File system path (string or path-like object) where the Parquet file\n    will be written. The file will be created or overwritten.\n\nNotes\n-----\nThis method writes the DataFrame contents to a Parquet file using efficient\ncolumnar storage format. The method may raise IOError if the file cannot\nbe written (e.g., permission denied, disk full).",
  "is_public": true
}
{
  "path": "typing.py",
  "module": "typing",
  "qualname": "PolarsModule",
  "name": "PolarsModule",
  "node_type": "ClassDef",
  "lineno": 428,
  "col": 0,
  "end_lineno": 453,
  "end_col": 11,
  "parent_qualname": null,
  "decorators": [],
  "bases": [
    "Protocol"
  ],
  "docstring": "Minimal polars API used within optional export helpers.",
  "is_public": true
}
{
  "path": "typing.py",
  "module": "typing",
  "qualname": "PolarsModule.data_frame",
  "name": "data_frame",
  "node_type": "FunctionDef",
  "lineno": 434,
  "col": 4,
  "end_lineno": 447,
  "end_col": 11,
  "parent_qualname": "PolarsModule",
  "decorators": [],
  "bases": [],
  "docstring": "Create a DataFrame from a sequence of mappings.\n\nParameters\n----------\ndata : Sequence[Mapping[str, object]]\n    Sequence of dictionary-like objects to convert to a DataFrame.\n\nReturns\n-------\nPolarsDataFrame\n    DataFrame instance containing the provided data.",
  "is_public": true
}
{
  "path": "typing.py",
  "module": "typing",
  "qualname": "PolarsModule.__getattr__",
  "name": "__getattr__",
  "node_type": "FunctionDef",
  "lineno": 449,
  "col": 4,
  "end_lineno": 453,
  "end_col": 11,
  "parent_qualname": "PolarsModule",
  "decorators": [],
  "bases": [],
  "docstring": "Expose polars ``DataFrame`` constructor alias.",
  "is_public": false
}
{
  "path": "uses_builder.py",
  "module": "uses_builder",
  "qualname": "uses_builder",
  "name": "uses_builder",
  "node_type": "Module",
  "lineno": 1,
  "col": 0,
  "end_lineno": null,
  "end_col": null,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "SCIP-based symbol use graph helpers.",
  "is_public": true
}
{
  "path": "uses_builder.py",
  "module": "uses_builder",
  "qualname": "UseGraph",
  "name": "UseGraph",
  "node_type": "ClassDef",
  "lineno": 16,
  "col": 0,
  "end_lineno": 21,
  "end_col": 37,
  "parent_qualname": null,
  "decorators": [
    "dataclass(slots=True, frozen=True)"
  ],
  "bases": [],
  "docstring": "Definition-to-use relationships summarised by file.",
  "is_public": true
}
{
  "path": "uses_builder.py",
  "module": "uses_builder",
  "qualname": "build_use_graph",
  "name": "build_use_graph",
  "node_type": "FunctionDef",
  "lineno": 24,
  "col": 0,
  "end_lineno": 57,
  "end_col": 86,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Build a use graph from SCIP occurrences.\n\nParameters\n----------\nindex : SCIPIndex\n    SCIP index containing symbol definitions and occurrences.\n\nReturns\n-------\nUseGraph\n    Definition-to-use relationships derived from the SCIP index.",
  "is_public": true
}
{
  "path": "uses_builder.py",
  "module": "uses_builder",
  "qualname": "write_use_graph",
  "name": "write_use_graph",
  "node_type": "FunctionDef",
  "lineno": 60,
  "col": 0,
  "end_lineno": 83,
  "end_col": 39,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Persist use graph edges to Parquet (or JSONL fallback).\n\nParameters\n----------\nuse_graph : UseGraph\n    Graph to serialize.\npath : str | Path\n    Destination file path.",
  "is_public": true
}
{
  "path": "uses_builder.py",
  "module": "uses_builder",
  "qualname": "_is_definition",
  "name": "_is_definition",
  "node_type": "FunctionDef",
  "lineno": 86,
  "col": 0,
  "end_lineno": 103,
  "end_col": 16,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Check if any role indicates a definition.\n\nParameters\n----------\nroles : list[str]\n    List of role strings to check.\n\nReturns\n-------\nbool\n    True if any role contains \"definition\" or ends with \"def\", False otherwise.",
  "is_public": false
}
{
  "path": "uses_builder.py",
  "module": "uses_builder",
  "qualname": "_write_parquet",
  "name": "_write_parquet",
  "node_type": "FunctionDef",
  "lineno": 106,
  "col": 0,
  "end_lineno": 130,
  "end_col": 15,
  "parent_qualname": null,
  "decorators": [],
  "bases": [],
  "docstring": "Write records via polars when available.\n\nParameters\n----------\nrecords : list[dict[str, str]]\n    List of dictionary records to write.\ntarget : Path\n    File system path for the output Parquet file.\n\nReturns\n-------\nbool\n    True if polars is available and write succeeded, False otherwise.",
  "is_public": false
}
