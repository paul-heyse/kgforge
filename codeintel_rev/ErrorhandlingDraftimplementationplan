Absolutely—here’s a precise, step-by-step implementation plan tailored to your `codeintel_rev` tree in `paul-heyse/kgfoundry`. I focused on the four areas your note calls out (metrics boilerplate, path resolution reuse, unimplemented tools, and tests/contracts) and wrote the plan so a junior dev can pick it up and ship in small PRs.

Below I reference the actual files in your repo so you can see exactly where to change what (e.g., `codeintel_rev/mcp_server/adapters/text_search.py`, `.../semantic.py`, `.../adapters/files.py`, `.../adapters/history.py`, `.../mcp_server/service_context.py`, `.../mcp_server/scope_utils.py`, `.../mcp_server/error_handling.py`, `.../app/config_context.py`, and the `tests/codeintel_rev/*` suite).

---

# Phase 0 — Ground rules (done once)

**Branching & guardrails**

* Create a feature branch: `feat/refactor-crosscutting`.
* Keep changes small: 4 PRs (P1–P4) matching phases below.
* Each PR must:

  * Update/extend tests in `tests/codeintel_rev/*`
  * Touch **only** the adapter files you refactor and shared modules
  * Include a migration note (`codeintel_rev/CHANGELOG.md` section “Internal refactors”)

**Style & import policy**

* New shared modules live under `codeintel_rev/mcp_server/common/`:

  * `observability.py` (metrics + stopwatches)
  * `path_utils.py` (repo-safe path resolution)
  * (optional) `logging.py` thin wrapper for structured logs
* Adapters import from `mcp_server.common` (not from each other).
* Keep public adapter functions stable (avoid breaking server contracts).

---

# Phase 1 — DRY up metrics & observation boilerplate

### Current pain

* The adapters (see `mcp_server/adapters/text_search.py` and `.../semantic.py`) carry **duplicated** `_NoopObservation` classes and `_observe` context managers to time operations.
* Each module repeats the same “is metrics enabled?” checks.

### Target design

Create a unified, dependency-free helper you can import anywhere:

**`codeintel_rev/mcp_server/common/observability.py`**

```python
from __future__ import annotations
from contextlib import contextmanager
from time import monotonic
from typing import Mapping, Iterable, Optional
import logging

log = logging.getLogger(__name__)

# A tiny interface your MetricsProvider must satisfy
class MetricsTimer:
    # e.g., Prometheus Summary/Histogram .labels(...).time() pattern
    def time(self, **labels):  # returns a context manager
        raise NotImplementedError

class Metrics:
    # provide a registry of named timers/counters
    def timer(self, name: str) -> MetricsTimer: ...
    def counter(self, name: str): ...

class _NoopTimer:
    def time(self, **labels):
        @contextmanager
        def _noop():
            yield
        return _noop()

class _NoopMetrics:
    def timer(self, name: str) -> MetricsTimer:
        return _NoopTimer()
    def counter(self, name: str):
        class _NoopCounter:
            def inc(self, *a, **k): pass
        return _NoopCounter()

# Compute one flag once per process.
METRICS_ENABLED = True  # flip with env in app startup if needed
DEFAULT_METRICS: Metrics = _NoopMetrics()  # replaced at startup if available

def install_metrics(registry: Metrics) -> None:
    """Call once at app startup when real metrics exist."""
    global DEFAULT_METRICS
    DEFAULT_METRICS = registry

@contextmanager
def observe_duration(
    operation: str,
    component: str,
    metrics: Optional[Metrics] = None,
    extra_labels: Optional[Mapping[str, str]] = None,
):
    """
    Usage:
        with observe_duration("search", "text_search"):
            ...  # your work
    """
    m = metrics or DEFAULT_METRICS
    labels = dict(operation=operation, component=component)
    if extra_labels:
        labels.update(extra_labels)
    if METRICS_ENABLED:
        with m.timer("adapter_duration_seconds").time(**labels):
            yield
    else:
        # lightweight fallback for dev
        start = monotonic()
        try:
            yield
        finally:
            dur = monotonic() - start
            log.debug("observe_duration", extra=dict(labels=labels, seconds=dur))
```

**What to change in adapters**

1. Replace in both:

   * `codeintel_rev/mcp_server/adapters/text_search.py`
   * `codeintel_rev/mcp_server/adapters/semantic.py`

   Remove duplicate `_NoopObservation` and local `_observe`. At top, import:

```python
from mcp_server.common.observability import observe_duration
```

2. Wrap major operations:

```python
with observe_duration("search", "text_search", extra_labels={"kind":"bm25"}):
    # existing search code
```

3. (Optional) In your ASGI app startup (`codeintel_rev/app/main.py` or wherever you wire app), if you have Prometheus metrics, call `install_metrics(real_registry)` once.

**Acceptance**

* Grep for `_NoopObservation` and `_observe` returns **zero results** across repo.
* Benchmarks in `tests/codeintel_rev/benchmarks/test_async_adapters.py` still pass.
* Add a small unit test: `tests/codeintel_rev/test_observability_noop.py` verifying `observe_duration` yields and logs when METRICS is disabled.

---

# Phase 2 — Centralize path resolution & error surface

### Current pain

* Both the **files** and **history** adapters implement their own homelab of:

  * `expanduser`, `resolve()` logic
  * repo root truncation / “path outside repository” protection
  * repeated string errors for “not a dir”/“not found”

See:

* `codeintel_rev/mcp_server/adapters/files.py`
* `codeintel_rev/mcp_server/adapters/history.py`
* Helpers exist in `codeintel_rev/mcp_server/service_context.py` and `.../scope_utils.py`, but aren’t used consistently.

### Target design

**`codeintel_rev/mcp_server/common/path_utils.py`**

```python
from __future__ import annotations
from dataclasses import dataclass
from pathlib import Path
from typing import Iterable, Literal

class PathOutsideRepository(Exception): ...
class PathNotFound(Exception): ...
class PathNotDirectory(Exception): ...

@dataclass(frozen=True)
class RepoRoot:
    root: Path  # absolute, resolved

    @staticmethod
    def from_str(p: str) -> "RepoRoot":
        return RepoRoot(root=Path(p).expanduser().resolve())

def resolve_within_repo(
    root: RepoRoot,
    user_path: str | Path,
    must_exist: bool = True,
    require_dir: bool | None = None,       # None: don't check, True: must be dir, False: must be file
) -> Path:
    """
    Expand ~, resolve symlinks, and enforce repo confinement.
    Raises PathOutsideRepository / PathNotFound / PathNotDirectory as needed.
    """
    p = Path(user_path).expanduser()
    # Allow relative paths to be relative to root
    if not p.is_absolute():
        p = root.root / p
    rp = p.resolve()

    try:
        rp.relative_to(root.root)
    except ValueError:
        raise PathOutsideRepository(f"{rp} escapes repository {root.root}")

    if must_exist and not rp.exists():
        raise PathNotFound(f"{rp} (resolved from {user_path}) not found")

    if require_dir is True and not rp.is_dir():
        raise PathNotDirectory(f"{rp} is not a directory")
    if require_dir is False and not rp.is_file():
        raise PathNotFound(f"{rp} is not a file")

    return rp
```

**Adapter changes**

* In `mcp_server/adapters/files.py` and `.../history.py`, replace local expand/resolve/try/except with:

```python
from mcp_server.common.path_utils import RepoRoot, resolve_within_repo, PathOutsideRepository, PathNotFound, PathNotDirectory
from mcp_server.service_context import get_repo_root  # if you have it; else wire from config_context

root = RepoRoot.from_str(get_repo_root())  # or pull from config context
path = resolve_within_repo(root, user_path, must_exist=True, require_dir=True)
```

* Normalize error handling through your existing `mcp_server/error_handling.py` so API outputs are consistent:

  * Map `PathOutsideRepository` → 400 (`detail.code: "path_outside_repo"`)
  * Map `PathNotFound` → 404
  * Map `PathNotDirectory` → 400

**Tests to update/add**

* Update `codeintel_rev/tests/test_files_adapter.py`, `tests/codeintel_rev/test_history_adapter.py`, and `codeintel_rev/tests/test_service_context_paths.py`:

  * Add parameterized cases for:

    * `~/` and `~user` expansion
    * Relative paths like `./src`, `../` blocked
    * Dir vs file checks
  * Assert on normalized error response bodies (structure & codes).
* Add small unit tests for `path_utils` in `codeintel_rev/tests/test_path_utils.py`.

**Acceptance**

* No more direct `Path(...).expanduser().resolve()` sprinkled in adapters.
* Only `resolve_within_repo` is used for adapter path input.
* Error JSON shapes match across `files` and `history`.

---

# Phase 3 — Make unimplemented tools explicit and pluggable

### Current pain

* The MCP server stubs out `symbol_search`, `definition_at`, and `references_at` with friendly text responses. Users see “not yet implemented”, but server code does the UX choice and business logic inline.

See:

* `codeintel_rev/mcp_server/server.py` (tool definitions)
* Related adapters missing/incomplete under `mcp_server/adapters/` for symbolics.

### Target design

1. Introduce **one** placeholder module that server tools defer to:

   * `codeintel_rev/mcp_server/adapters/symbols.py`

**`adapters/symbols.py`**

```python
import logging
log = logging.getLogger(__name__)

def symbol_search(query: str, kind: str | None = None, language: str | None = None) -> list[dict]:
    log.warning("symbol_search called but not implemented", extra={"query": query, "kind": kind, "lang": language})
    raise NotImplementedError("symbol_search not implemented")

def definition_at(path: str, line: int, character: int, commit: str | None = None) -> list[dict]:
    log.warning("definition_at called but not implemented", extra={"path": path, "line": line, "character": character, "commit": commit})
    raise NotImplementedError("definition_at not implemented")

def references_at(path: str, line: int, character: int, commit: str | None = None) -> list[dict]:
    log.warning("references_at called but not implemented", extra={"path": path, "line": line, "character": character, "commit": commit})
    raise NotImplementedError("references_at not implemented")
```

2. Wire the server tools to call these functions and **let the adapter raise**. The server layer should NOT swallow with a “message string”; instead, rely on your standardized error mapper (`error_handling.py`) to convert `NotImplementedError` → clear tool error.

3. Add a **Dev-visible log & metric**:

   * Log: `WARNING` with the input fields (as above).
   * Metric: increment a counter (`mcp_unimplemented_calls_total`, label=name) via `observability.py` if you want.

4. (Optional) Sketch future implementation path:

   * a) Basic: integrate with LSP server (pyright/tsserver) per repo path for on-the-fly def/ref.
   * b) Scalable: precompute SCIP/LSIF index and answer via symbol graph service.
   * Keep this in a design doc, not in the server.

**Tests**

* New: `tests/codeintel_rev/test_symbol_stubs.py`:

  * Call each tool and assert you receive a structured error with `code` “not_implemented” (or whatever you map).
  * Assert a `WARNING` log appears.

**Acceptance**

* All stubs live **only** in `adapters/symbols.py`.
* Server tools are thin and consistent.
* Logs + errors are standardized; no user-facing “string body” divergences.

---

# Phase 4 — Tests & interface contracts

### Scope

* Any refactor that consolidates cross-cutting code must update tests and the **API contract** where applicable.

### What to change

**1) Tests**

* Update affected suites:

  * `tests/codeintel_rev/test_text_search_adapter.py`, `.../test_semantic_adapter.py`

    * Ensure they still time the same operations (metric coverage is not required; just don’t crash).
  * `tests/codeintel_rev/test_files_adapter.py`, `.../test_history_adapter.py`

    * Assert standard error bodies from `error_handling.py` for path errors.
  * New: `test_symbol_stubs.py` (above).
  * Ensure smoke/integration tests still run:

    * `tests/codeintel_rev/test_integration_full.py`
    * `tests/codeintel_rev/test_mcp_server.py`
    * `tests/codeintel_rev/test_app_lifespan.py`

**2) Error mapping consistency**

* In `mcp_server/error_handling.py`:

  * Add mappings for the new exceptions:

    * `PathOutsideRepository` → 400, `code: "path_outside_repo"`
    * `PathNotFound` → 404, `code: "path_not_found"`
    * `PathNotDirectory` → 400, `code: "path_not_directory"`
    * `NotImplementedError` → 501, `code: "not_implemented"`
  * Ensure **all** adapters raise exceptions (don’t build error JSON there).

**3) Docstring + hints**

* Keep docstrings and type hints updated; your project already leans “pyright strict”—don’t regress.
* If you added `mcp_server/common/observability.py` and `.../path_utils.py`, add line-level docstrings and function signatures (TypedDicts where useful).

**Acceptance**

* `pytest -q` is green locally and in CI.
* Contracts visible in server tool docs remain consistent (input/outputs). Only **error** shapes are normalized.

---

# Pull Request plan and diffs (summary)

### P1: Observability

* Add `mcp_server/common/observability.py`
* Replace local `_observe` usages in:

  * `mcp_server/adapters/text_search.py`
  * `mcp_server/adapters/semantic.py`
* Add tests: `test_observability_noop.py` (tiny)

### P2: Path utils

* Add `mcp_server/common/path_utils.py`
* Replace path logic in:

  * `mcp_server/adapters/files.py`
  * `mcp_server/adapters/history.py`
* Extend `error_handling.py` for path exceptions
* Update tests:

  * `test_files_adapter.py`, `test_history_adapter.py`
  * `test_service_context_paths.py`
  * New: `test_path_utils.py`

### P3: Symbol tool stubs cleanup

* Add `mcp_server/adapters/symbols.py`
* Update `mcp_server/server.py` tools to call into the adapter
* Extend `error_handling.py` to map `NotImplementedError`
* Add tests: `test_symbol_stubs.py`

### P4: Sweep & docs

* Remove dead code (any `_NoopObservation` artifacts)
* Ensure `pyproject.toml` lints/formatters pass
* Update `codeintel_rev/README.md` (developer section):

  * “How to use observability timers”
  * “Path APIs & allowed inputs”
  * “Unimplemented tools behavior”

---

# “Best in class” polish (options)

These are fast wins you can add once the refactor lands:

* **Consistent labels** for metrics:

  * `operation` (e.g., `search`, `open_file`, `file_history`)
  * `component` (e.g., `text_search`, `history_adapter`)
  * Domain labels (`repo`, `backend`) only if cheap to gather

* **Structured logging**

  * Adopt one logging entry-point in `mcp_server/common/logging.py` that sets JSON format, adds request IDs if available.
  * Use `log.warning("symbol_search called but not implemented", extra={...})` shape consistently.

* **Errata page for clients**

  * Short Markdown in `codeintel_rev/docs/ERRORS.md` listing common errors (`path_outside_repo`, `not_implemented`) so client teams know what to expect.

---

# What you’ll see change in the tree

```
codeintel_rev/
  mcp_server/
    common/
      observability.py        ← new
      path_utils.py           ← new
    adapters/
      files.py                ← imports path_utils; no local expanduser/resolve
      history.py              ← imports path_utils
      text_search.py          ← imports observe_duration; no local _observe
      semantic.py             ← imports observe_duration; no local _observe
      symbols.py              ← new: central stubs
    error_handling.py         ← maps new exception types
    service_context.py        ← (unchanged) used to get repo_root if desired

  tests/codeintel_rev/
    test_observability_noop.py      ← new
    test_path_utils.py              ← new
    test_symbol_stubs.py            ← new
    test_files_adapter.py           ← updated error shapes
    test_history_adapter.py         ← updated error shapes
    test_service_context_paths.py   ← align messages
```

---

# Risks & rollback

* **Risk:** different adapters hand-rolled slightly different error texts.

  * **Mitigation:** adapter code must *raise*, not format JSON; mapper does the uniform message.

* **Risk:** someone relied on the “string message” for unimplemented tools.

  * **Mitigation:** P3 returns a structured 501 with `code: "not_implemented"`. Keep a short note in `CHANGELOG.md`. If you need to preserve legacy text, include it as `detail.message` in the error body.

---

# Done criteria (exec-level)

* **Observability**: All adapter timing flows through one helper; repeated code removed.
* **Maintainability**: Path handling unified, repo boundaries consistently enforced, single place to change policy.
* **Clarity**: Unimplemented tools emit a clearly structured error and log a warning; the place to implement is obvious (`adapters/symbols.py`).
* **Quality**: Test suite updated; contracts verified; error shapes consistent.

---

If you want, I can draft the tiny PRs (P1–P4) as diffs next.
