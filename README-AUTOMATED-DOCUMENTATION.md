# Automated Documentation System

This repo ships with a fully automated documentation stack that keeps
API references, module docstrings, package READMEs, navigation maps, and symbol indices
in sync with the codebase. This guide provides exhaustive detail about the documentation
generation pipeline, explaining every component, tool, and step in the process.

> **TL;DR**
>
> 1. Install extras: `pip install -e ".[docs]"`
> 2. Regenerate all documentation: `tools/update_docs.sh`
> 3. Pre-commit enforces docstring formatting, coverage, linting, and navmap validation automatically.
>
> The single script `tools/update_docs.sh` orchestrates the complete end-to-end documentation
> generation workflow, producing Sphinx HTML/JSON, symbol indices, navigation maps, and MkDocs sites.

---

## Table of Contents

### Quick Navigation
- **[Getting Started](#getting-started)** - TL;DR and prerequisites
- **[Master Orchestration Script](#master-orchestration-script-toolsupdatedocssh)** - The main entry point
- **[The Complete Pipeline](#the-complete-documentation-pipeline)** - All 8 documentation stages

### Detailed Sections

#### Core Documentation
1. **[Master Orchestration Script](#master-orchestration-script-toolsupdatedocssh)**
   - [Script Overview](#script-overview)
   - [Pre-Flight Checks](#pre-flight-checks)
   - [Environment Setup](#environment-setup)
   - [Clean Slate Initialization](#clean-slate-initialization)
   - [Execution Pipeline](#execution-pipeline)
   - [Post-Execution Status](#post-execution-status)

2. **[The Complete Documentation Pipeline](#the-complete-documentation-pipeline)**
   - [Stage 0: Clean Slate](#stage-0-clean-slate)
   - [Stage 1: Docstring Generation](#stage-1-docstring-generation-make-docstrings)
   - [Stage 2: README Generation](#stage-2-readme-generation-make-readmes)
   - [Stage 3: NavMap Update](#stage-3-navmap-update-python-toolsupdate_navmapspy)
   - [Stage 4: NavMap Index Build](#stage-4-navmap-index-build-python-toolsnavmapbuild_navmappy)
   - [Stage 5: NavMap Validation](#stage-5-navmap-validation-python-toolsnavmapcheck_navmappy)
   - [Stage 6: Example Tests](#stage-6-example-tests-xdoctest)
   - [Stage 7: Test Map Build](#stage-7-test-map-build-python-toolsdocsbuild_test_mappy)
   - [Stage 8: Observability Scan](#stage-8-observability-scan-python-toolsdocsscan_observabilitypy)
   - [Stage 9: Schema Export](#stage-9-schema-export-python-toolsdocsexport_schemaspy)
   - [Stage 10: Graph Build](#stage-10-graph-build-python-toolsdocsbuild_graphspy)
   - [Stage 11: Sphinx HTML Build](#stage-11-sphinx-html-build-make-html)
   - [Stage 12: Sphinx JSON Build](#stage-12-sphinx-json-build-make-json)
   - [Stage 13: Symbol Index Build](#stage-13-symbol-index-build-make-symbols)
   - [Stage 14: MkDocs Build](#stage-14-mkdocs-build-optional)

#### Troubleshooting & Operations
3. **[Error Handling & Troubleshooting](#error-handling--troubleshooting)**
   - [Understanding Exit Codes](#understanding-exit-codes)
   - [Common Failure Scenarios & Recovery](#common-failure-scenarios--recovery)
   - [Stage Dependency Chain](#stage-dependency-chain)
   - [What Happens on Failure](#what-happens-on-failure)
   - [Running Individual Stages Manually](#running-individual-stages-manually)

4. **[Common Workflows](#common-workflows)**
   - [Workflow 1: Add New Python Module](#workflow-1-add-new-python-module)
   - [Workflow 2: Update Function Signature](#workflow-2-update-function-signature)
   - [Workflow 3: Add Navigation Structure](#workflow-3-add-navigation-structure)
   - [Workflow 4: Fix Docstring Style Issues](#workflow-4-fix-docstring-style-issues)
   - [Workflow 5: Regenerate Only READMEs](#workflow-5-regenerate-only-readmes)
   - [Workflow 6: Validate Documentation Quality](#workflow-6-validate-documentation-quality)

5. **[Performance Characteristics](#performance-characteristics)**
   - [Typical Execution Times](#typical-execution-times)
   - [Optimization Tips](#optimization-tips)

6. **[Integration Points](#integration-points)**
   - [Pre-Commit Hooks](#pre-commit-hooks)
   - [CI/CD Integration](#cicd-integration)
   - [Local Development](#local-development)

#### Architecture & Reference
7. **[Architecture & Design Decisions](#architecture--design-decisions)**
   - [Why Multiple Documentation Formats?](#why-multiple-documentation-formats)
   - [Why NavMaps?](#why-navmaps)
   - [Why Two-Stage Docstring Generation?](#why-two-stage-docstring-generation)
   - [Why NavMap Validation?](#why-navmap-validation)

8. **[Reference Materials](#reference-materials)**
   - [Complete Stage Execution Reference](#complete-stage-execution-reference)
   - [Environment Variables Reference](#environment-variables-reference)
   - [Files Generated by Each Stage](#files-generated-by-each-stage)

#### Configuration & Tools
9. **[Key Configuration Files](#key-configuration-files)**

10. **[Detailed Tool Descriptions](#detailed-tool-descriptions)**
    - [Master Orchestration: `tools/update_docs.sh`](#master-orchestration-toolsupdatedocssh)
    - [Sphinx Configuration: `docs/conf.py`](#sphinx-configuration-docsconfpy)
    - [Docstring Generation: `tools/generate_docstrings.py`](#docstring-generation-toolsgenerate_docstringspy)
    - [NavMap System: `tools/navmap/`](#navmap-system-toolsnavmap)
    - [README Generation: `tools/gen_readmes.py`](#readme-generation-toolsgen_readmespy)
    - [Symbol Index: `docs/_scripts/build_symbol_index.py`](#symbol-index-docs_scriptsbuild_symbol_indexpy)
    - [Package Detection: `tools/detect_pkg.py`](#package-detection-toolsdetect_pkgpy)

#### Pre-Commit & Quality
11. **[Pre-Commit Hooks](#pre-commit-hooks) (Detailed)**

12. **[Formatting & Type Checking Pipeline](#formatting--type-checking-pipeline)**

#### Workflows & Quick Reference
13. **[Quick Commands](#quick-commands)**

---

## Master Orchestration Script: `tools/update_docs.sh`

The `tools/update_docs.sh` script is the single, authoritative entry point for regenerating all documentation artifacts in the repository. It is designed to be idempotent, deterministic, and self-checking.

### Script Overview

**Location:** `/tools/update_docs.sh`

**Purpose:** One-command refresh of entire documentation system. Acts as a single source of truth for the correct order and configuration of documentation generation stages.

**Exit Behavior:**
- Exits with code 0 on complete success
- Exits with code 1 immediately if critical prerequisites are missing or any stage fails
- Uses strict bash mode (`set -euo pipefail`) to fail fast on any error
- Prints clear error messages to stderr with actionable guidance

### Pre-Flight Checks

Before executing any documentation generation, the script performs critical validation:

#### 1. Virtual Environment Verification
```bash
if [[ ! -x "$BIN/python" ]]; then
  echo "error: missing virtual environment at .venv/; run 'make bootstrap' first." >&2
  exit 1
fi
```

**What it checks:**
- `.venv/bin/python` exists and is executable
- The virtual environment was properly created with `make bootstrap`

**Why it matters:**
- All subsequent Python commands run in this environment
- Ensures consistent tool versions and dependencies
- Prevents accidental system Python contamination

**Recovery:**
```bash
make bootstrap
```

#### 2. Required Tools Validation
```bash
ensure_tools() {
  local missing=0
  for tool in doq docformatter pydocstyle interrogate; do
    if [[ ! -x "$BIN/$tool" ]]; then
      echo "error: missing '$tool'; install docs extras..." >&2
      missing=1
    fi
  done
}
```

**Required tools checked:**
- `doq`: Docstring skeleton generator
- `docformatter`: Docstring formatting
- `pydocstyle`: Docstring linting
- `interrogate`: Coverage enforcement

**Why they're essential:**
- Each tool performs a non-redundant stage in docstring generation
- Missing any tool breaks the entire documentation pipeline
- Cannot be auto-installed (must come from `[docs]` extras)

**Recovery:**
```bash
pip install -e ".[docs]"
```

#### 3. Optional MkDocs Detection
```bash
if [[ ! -x "$BIN/mkdocs" ]]; then
  echo "warning: mkdocs not installed; skipping mkdocs build..." >&2
  BUILD_MKDOCS=0
else
  BUILD_MKDOCS=1
fi
```

**MkDocs behavior:**
- Optional but recommended
- Missing MkDocs issues a warning, not an error
- Pipeline continues without it
- Skips `mkdocs build` stage if unavailable

**Recovery (optional):**
```bash
pip install -e ".[docs-mkdocs]"
```

### Environment Setup

The script exports critical environment variables used throughout the documentation pipeline:

```bash
export PYTHONPATH="${PYTHONPATH:-src}"
export SPHINXOPTS="-W"
```

**`PYTHONPATH=src`**
- Ensures all Python imports resolve correctly
- Points to the primary source directory
- Preserves existing PYTHONPATH if already set

**`SPHINXOPTS="-W"`**
- Treats Sphinx warnings as errors
- Forces documentation build to fail if there are unresolved references, missing modules, or broken links
- Ensures high documentation quality

### Clean Slate Initialization

```bash
rm -rf docs/_build/html docs/_build/json site
```

**Artifacts removed:**
- `docs/_build/html/`: Previous Sphinx HTML output
- `docs/_build/json/`: Previous Sphinx JSON corpus
- `site/`: Previous MkDocs output

**Why full removal?**
- Prevents stale artifacts from being served
- Ensures reproducible builds (idempotent)
- Forces re-generation of all pages from scratch
- Catches broken documentation early

### Execution Pipeline

The script executes stages sequentially in a strict order. Each stage must complete successfully (exit code 0) before the next stage begins.

#### Stage 1: Docstring Generation (`make docstrings`)

**Purpose:** Generate, update, format, and validate all docstrings.

**Executes:**
1. `python tools/generate_docstrings.py` - Regenerate docstrings using NumPy templates (doq + fallback)
2. `python tools/update_navmaps.py` - Assert module docstrings contain no legacy `NavMap:` blocks
3. `docformatter --wrap-summaries=100 --wrap-descriptions=100 -r -i` - Format to PEP 257
4. `pydocstyle` - Lint docstrings for PEP 257 compliance
5. `interrogate -i src --fail-under 90` - Enforce 90% coverage

**Targets:** `src/`, `tools/`, `docs/_scripts/`

**NumPy compliance guarantees:**
- Custom doq templates in `tools/doq_templates/numpy/` now emit `Parameters`, `Returns`, `Raises`, and `Examples` skeletons using NumPy formatting (`name : type, optional`).
- The fallback generator (`tools/auto_docstrings.py`) normalises missing docstrings to include `Examples`, `See Also`, and `Notes` sections, detects `raise` statements to populate `Raises`, and rewrites summaries in the imperative mood.
- `.numpydoc` plus `numpydoc_validation_checks` (GL01/SS01/ES01/RT01/PR01) ensure every regenerated docstring passes strict numpydoc validation during Sphinx builds.

**Exit condition:**
- Succeeds only if all five sub-stages pass
- Coverage must be ≥ 90% to proceed
- All docstrings must be PEP 257 compliant

**Failure reasons:**
- Docstring coverage below 90%
- PEP 257 style violations detected
- Generation tool errors (malformed Python)

#### Stage 2: README Generation (`make readmes`)

**Purpose:** Generate package-level README.md files with API listings and deep links.

**Executes:**
1. `python tools/gen_readmes.py` - Generate/update all `README.md` files
2. `doctoc src/<pkg>` (if available) - Populate TOC sections

**Targets:** All detected packages in `src/`

**What gets generated:**
- Package-level `README.md` in each package directory
- Hierarchical API listings with summaries
- Deep links to source code (editor or GitHub mode)

**Exit condition:**
- Succeeds if gen_readmes.py completes without error
- Gracefully continues if doctoc unavailable

**Failure reasons:**
- Broken Griffe analysis
- Permission issues writing READMEs

#### Stage 3: NavMap Update (`python tools/update_navmaps.py`)

**Purpose:** Validate that module docstrings remain free of legacy `NavMap:` sections.

**Tool:** `tools/update_navmaps.py`

**What it does:**
- Scans all Python files in `src/`
- Checks for deprecated `NavMap:` sections in module docstrings
- Exits with error if any legacy sections are found
- Ensures clean migration to the new `__navmap__` dictionary approach

**Exit condition:**
- Success: No legacy `NavMap:` sections found, exit code 0
- Failure: Legacy sections detected, exit code 1 with file paths

**Failure reasons:**
- Module docstrings containing `NavMap:` section markers
- Incomplete migration from old format to new format

**Impact of failure:**
- Halts entire documentation build
- Prevents commit via pre-commit hook
- Forces removal of legacy sections before proceeding

#### Stage 4: Navigation Map Building (`python tools/navmap/build_navmap.py`)

**Purpose:** Extract and index module-level navigation metadata.

**What it does:**
- Walks all Python files in `src/`
- Parses `__all__` declarations
- Extracts `__navmap__` metadata dictionaries
- Finds `[nav:anchor]` and `[nav:section]` comments
- Builds comprehensive JSON index

**Generates:** `site/_build/navmap/navmap.json`

**Exit condition:**
- Succeeds if all files parse successfully
- Creates `site/_build/` directory structure

**Failure reasons:**
- Syntax errors in Python files
- Permission issues creating output directory

#### Stage 5: Navigation Map Validation (`python tools/navmap/check_navmap.py`)

**Purpose:** Validate navmap metadata consistency and correctness.

**What it validates:**
- Export declarations match `__all__`
- First section ID is `"public-api"` (required)
- Section IDs are kebab-case (e.g., `public-api`, `advanced-usage`)
- All section symbols have corresponding `[nav:anchor]` comments
- All symbol names are valid Python identifiers

**Exit condition:**
- Success: All validations pass, exit code 0, prints `navmap check: OK`
- Failure: Any validation fails, exit code 1, prints errors with file paths

**Failure reasons:**
- Export mismatches (symbol in section but not in `__all__`)
- Invalid section naming
- Missing anchor comments
- Invalid Python identifiers

**Impact of failure:**
- Halts entire documentation build
- Prevents commit via pre-commit hook
- Forces correction before proceeding

#### Stage 6: Example Tests (`pytest --xdoctest`)

**Purpose:** Validate doctest examples in example scripts.

**Command:** `pytest -q --xdoctest --xdoctest-options=ELLIPSIS,IGNORE_WHITESPACE,NORMALIZE_WHITESPACE --xdoctest-modules --xdoctest-glob='examples/*.py' examples`

**What it does:**
- Runs xdoctest on all Python files in `examples/`
- Validates docstring examples against actual execution
- Checks that examples produce expected output
- Allows whitespace normalization and ellipsis matching

**Exit condition:**
- Success: All doctest examples pass, exit code 0
- Failure: Any doctest fails, exit code 1 with traceback

**Failure reasons:**
- Doctest examples produce incorrect output
- Examples reference unavailable dependencies
- Outdated examples that no longer match current API
- Runtime errors in example code

**Impact of failure:**
- Halts entire documentation build
- Ensures examples remain accurate and executable

#### Stage 7: Test Map Build (`python tools/docs/build_test_map.py`)

**Purpose:** Generate test coverage map for documentation.

**Tool:** `tools/docs/build_test_map.py`

**What it does:**
- Analyzes test files and their coverage
- Maps test functions to source code
- Generates visual representation of test coverage
- Creates documentation artifacts showing which code is tested

**Generates:** Test coverage maps and reports (location TBD based on tool implementation)

**Exit condition:**
- Success: Test map generated successfully, exit code 0
- Failure: Analysis errors, exit code 1

**Failure reasons:**
- Unable to parse test files
- Coverage data unavailable
- Permission issues writing output

#### Stage 8: Observability Scan (`python tools/docs/scan_observability.py`)

**Purpose:** Scan and document observability instrumentation.

**Tool:** `tools/docs/scan_observability.py`

**What it does:**
- Scans codebase for logging, tracing, and metrics instrumentation
- Documents observability patterns and practices
- Identifies logging levels and structured logging usage
- Maps telemetry spans and metrics definitions

**Generates:** Observability documentation artifacts (location TBD based on tool implementation)

**Exit condition:**
- Success: Observability scan complete, exit code 0
- Failure: Scan errors, exit code 1

**Failure reasons:**
- Unable to parse source files
- Instrumentation pattern detection errors
- Permission issues writing output

#### Stage 9: Schema Export (`python tools/docs/export_schemas.py`)

**Purpose:** Export data contract schemas for documentation.

**Tool:** `tools/docs/export_schemas.py`

**What it does:**
- Extracts Pydantic models and data schemas from code
- Exports JSON Schema definitions
- Documents API contracts and data structures
- Generates schema validation documentation

**Generates:** Schema documentation files (location TBD based on tool implementation)

**Exit condition:**
- Success: Schemas exported successfully, exit code 0
- Failure: Export errors, exit code 1

**Failure reasons:**
- Unable to parse schema definitions
- Invalid Pydantic models
- Schema serialization errors
- Permission issues writing output

#### Stage 10: Graph Build (`python tools/docs/build_graphs.py`)

**Purpose:** Build dependency and architecture graphs.

**Tool:** `tools/docs/build_graphs.py`

**What it does:**
- Analyzes code dependencies and relationships
- Generates visual dependency graphs
- Creates architecture diagrams
- Maps module relationships and import hierarchies

**Generates:** Graph visualizations and diagrams (location TBD based on tool implementation)

**Exit condition:**
- Success: Graphs generated successfully, exit code 0
- Failure: Graph generation errors, exit code 1

**Failure reasons:**
- Unable to analyze dependencies
- Graph rendering errors
- GraphViz or visualization library unavailable
- Permission issues writing output

#### Stage 11: Sphinx HTML Build (`make html`)

**Purpose:** Generate complete HTML documentation website.

**Executes:** `python -m sphinx -b html docs docs/_build/html`

**Configuration:** `docs/conf.py`

**What it does:**
- Performs static code analysis (no imports)
- Auto-detects primary package
- Generates per-symbol documentation pages
- Adds deep links to source code
- Builds navigation tree and search index

**Generates:**
- `docs/_build/html/index.html` - Homepage
- `docs/_build/html/autoapi/` - API reference pages
- `docs/_build/html/search/` - Search functionality
- `docs/_build/html/_static/` - CSS, JavaScript, images

**Exit condition:**
- Succeeds if `SPHINXOPTS="-W"` (warnings as errors) passes
- Fails on unresolved cross-references or missing modules

**Failure reasons:**
- Broken internal links
- Missing docstrings for public symbols
- AutoAPI analysis errors
- MyST-Parser Markdown errors

#### Stage 12: Sphinx JSON Build (`make json`)

**Purpose:** Generate machine-readable JSON documentation corpus.

**Executes:**
1. `rm -rf docs/_build/json` - Clean previous build
2. `python -m sphinx -b json docs docs/_build/json`

**Configuration:** `docs/conf.py` (same as HTML build)

**What it does:**
- Same static analysis as HTML build
- Outputs structured JSON instead of HTML
- One `.fjson` file per documentation page
- Includes metadata and relationships

**Generates:** `docs/_build/json/*.fjson` files

**Exit condition:**
- Succeeds if same validations as HTML build pass

**Use cases:**
- AI agent consumption of documentation
- Automated documentation analysis
- Search indexing systems
- Documentation testing

#### Stage 13: Symbol Index Build (`make symbols`)

**Purpose:** Generate flat symbol index for fast agent lookup.

**Executes:** `python docs/_scripts/build_symbol_index.py`

**What it does:**
- Walks complete symbol tree (all packages, modules, classes, functions)
- Extracts fully qualified name, kind, file path, line range, docstring
- Writes flat JSON array (one entry per symbol)

**Generates:** `docs/_build/symbols.json`

**Format:**
```json
[
  {
    "path": "kgfoundry_common.config.load_config",
    "kind": "function",
    "file": "src/kgfoundry_common/config.py",
    "lineno": 15,
    "endlineno": 25,
    "doc": "Load configuration from YAML file."
  }
]
```

**Exit condition:**
- Succeeds if all packages analyze successfully

**Use cases:**
- Agent symbol lookup
- Jump to definition
- Documentation validation
- IDE integration

#### Stage 14: MkDocs Build (Optional, Conditional)

**Purpose:** Generate alternative Markdown-first documentation site.

**Execution:**
```bash
if [[ $BUILD_MKDOCS -eq 1 ]]; then
  run "$BIN/mkdocs" build --config-file mkdocs.yml
fi
```

**Conditional logic:**
- Skipped if `mkdocs` not in virtualenv
- Warns if unavailable but continues
- No failure if this stage is skipped

**What it does:**
- Reads `mkdocs.yml` configuration
- Generates alternative documentation site
- Uses Material for MkDocs theme
- Includes search, dynamic API pages, TOC

**Generates:** `site/` directory (complete static site)

**Exit condition:**
- Succeeds or skipped (not critical)

**Failure reasons:**
- MkDocs configuration errors
- Theme issues
- Plugin conflicts

### Post-Execution Status

After all stages complete successfully:

```bash
printf '\nDocumentation refresh complete.\n' >&2
```

This message indicates:
- All documentation artifacts regenerated
- All validations passed
- Safe to commit changes
- Ready for deployment

---

## The Complete Documentation Pipeline

The complete documentation generation workflow is orchestrated by `tools/update_docs.sh`, which executes the following stages in sequence:

### Stage 0: Clean Slate

```bash
rm -rf docs/_build/html docs/_build/json site
```

Removes all previously generated documentation artifacts to ensure a clean rebuild:
- `docs/_build/html`: Sphinx HTML output
- `docs/_build/json`: Sphinx JSON corpus (machine-readable API docs)
- `site`: MkDocs build output

### Stage 1: Docstring Generation (`make docstrings`)

**Purpose:** Generate, update, and validate docstrings across the codebase.

**Makefile target:** `docstrings`

**Execution sequence:**

1. **`python tools/generate_docstrings.py`**
   - Runs `doq` (docstring skeleton generator) with NumPy-style templates from `tools/doq_templates/numpy/`
   - Processes directories: `src/`, `tools/`, `docs/_scripts/`
   - Generates complete function signatures with Parameters/Returns sections
   - Then runs `tools/auto_docstrings.py` as a fallback for remaining items
   - The fallback uses AST parsing to create docstrings for modules, classes, and functions
   - Logs changes to `site/_build/docstrings/fallback.log`

2. **`python tools/update_navmaps.py`**
   - Uses Griffe to statically analyze each module
   - Collects public classes and functions (non-underscore-prefixed names)
   - Rewrites module docstrings to include a `NavMap:` section
   - Each NavMap entry shows: `- SymbolName: truncated summary…`
   - Summaries are truncated to ~60 chars to fit within 100-character line limits
   - Only updates modules that already have docstrings (leaves others untouched)
   - Idempotent: can be run repeatedly without adverse effects

3. **`docformatter --wrap-summaries=100 --wrap-descriptions=100 -r -i <dirs>`**
   - Formats docstrings to conform to PEP 257 standards
   - Wraps summary and description lines to 100 characters
   - Recursively processes `src/`, `tools/`, `docs/_scripts/`
   - In-place modification (`-i` flag)
   - Continues on errors (`|| true`)

4. **`pydocstyle <dirs>`**
   - Lints docstrings against PEP 257 conventions
   - Uses NumPy convention (configured in `pyproject.toml`)
   - Enforces consistency in docstring format
   - Fails if violations are found

5. **`interrogate -i src --fail-under 90`**
   - Enforces 90% docstring coverage on the `src/` directory
   - Interactive mode (`-i`) shows coverage details
   - Fails the build if coverage drops below 90%

**What gets generated:**
- Complete NumPy-style docstrings for functions, classes, and modules
- Module-level NavMap sections listing public API entry points
- Properly formatted and wrapped docstring text
- Validated compliance with PEP 257

### Stage 2: README Generation (`make readmes`)

**Purpose:** Generate package-level README.md files with API listings and deep links.

**Makefile target:** `readmes`

**Execution sequence:**

1. **`python tools/gen_readmes.py`**
   - Uses Griffe to walk each package and collect public symbols
   - Detects packages via `tools/detect_pkg.py` (prefers `kgfoundry` packages in `src/`)
   - Generates `README.md` in each package directory with:
     - Package title (e.g., `# kgfoundry_common`)
     - Doctoc TOC placeholder (for optional TOC generation)
     - `## API` section with nested bullets for modules/classes/functions
     - Each entry includes:
       - Full qualified name in bold monospace (e.g., `**kgfoundry_common.config.load_config**`)
       - First-sentence docstring summary
       - `[open]` link: relative path with line/column (e.g., `./config.py:15:1`)
       - `[view]` link: GitHub permalink with SHA and line range
   - Link mode is controlled by `DOCS_LINK_MODE` environment variable:
     - `DOCS_LINK_MODE=editor` (default): Creates editor deep links (vscode://, pycharm://)
     - `DOCS_LINK_MODE=github`: Creates GitHub permalinks using current commit SHA
   - GitHub links use `DOCS_GITHUB_ORG` and `DOCS_GITHUB_REPO` env vars or auto-detect from git remote

2. **`doctoc src/<pkg>` (optional)**
   - If `doctoc` CLI tool is installed, updates README TOCs
   - Populates the `<!-- START doctoc -->` ... `<!-- END doctoc -->` sections
   - Gracefully skips if `doctoc` is not available

**What gets generated:**
- `README.md` files in each package directory under `src/`
- Hierarchical API listings with summaries and links
- Editor-friendly local links and/or commit-stable GitHub permalinks

### Stage 3: NavMap Index Build (`python tools/navmap/build_navmap.py`)

**Purpose:** Build a machine-readable navigation map index for AI agents and tooling.

**Tool:** `tools/navmap/build_navmap.py`

**What it does:**
- Walks the `src/` directory tree, parsing every Python file with AST
- Extracts:
  - `__all__` declarations (public exports)
  - `__navmap__` metadata dictionaries (structured navigation hints)
  - Special comments: `# [nav:anchor SymbolName]` and `# [nav:section section-id]`
- Builds a comprehensive index mapping each module to:
  - Repository-relative file path
  - Exported symbols (from `__all__` or `__navmap__["exports"]`)
  - Section definitions and line numbers
  - Anchor definitions (named jump points in code)
  - VSCode deep links to source files
  - Metadata: synopsis, tags, see_also, deps (from `__navmap__`)
- Outputs `site/_build/navmap/navmap.json` with:
  - Current git commit SHA for provenance
  - Per-module structured metadata
  - Supports advanced navigation, documentation linking, and agent-friendly code exploration

**NavMap metadata format:**

Modules can define a `__navmap__` dictionary with structured navigation hints:

```python
__all__ = ["func1", "func2", "MyClass"]

__navmap__ = {
    "exports": __all__,  # Can override or reference __all__
    "synopsis": "Brief module description",
    "sections": [
        {"id": "public-api", "symbols": ["func1", "func2"]},
        {"id": "advanced", "symbols": ["MyClass"]},
    ],
    "symbols": {
        "func1": {"category": "core", "stability": "stable"},
        "MyClass": {"category": "advanced", "stability": "beta"},
    },
    "tags": ["core", "networking"],
    "see_also": ["other.module"],
    "deps": ["required.module"],
}
```

Anchors and sections can be marked inline:

```python
# [nav:section public-api]

# [nav:anchor func1]
def func1():
    ...
```

**What gets generated:**
- `site/_build/navmap/navmap.json`: Complete module index with metadata
- Commit SHA for version tracking
- Machine-readable navigation structure for agents and IDE plugins

### Stage 4: NavMap Validation (`python tools/navmap/check_navmap.py`)

**Purpose:** Validate navmap metadata and ensure consistency.

**Tool:** `tools/navmap/check_navmap.py`

**What it validates:**
- `__navmap__["exports"]` matches `__all__` declarations
- First navmap section has id `"public-api"` (required convention)
- Section IDs are valid kebab-case slugs (lowercase, hyphens, alphanumeric)
- Symbol names are valid Python identifiers
- All symbols referenced in sections have corresponding `[nav:anchor SymbolName]` comments
- Returns exit code 0 on success, 1 if validation errors are found

**What happens:**
- Scans all Python files in `src/`
- Collects and reports validation errors
- Prints `navmap check: OK` on success or lists errors with file paths
- Prevents broken navigation metadata from being committed (via pre-commit hook)

### Stage 5: Sphinx HTML Build (`make html`)

**Purpose:** Generate the full HTML documentation website.

**Makefile target:** `html`

**Command:** `python -m sphinx -b html docs docs/_build/html`

**What it does:**
- Reads configuration from `docs/conf.py`
- Auto-detects primary package using `tools/detect_pkg.py`
- Scans source code using AutoAPI (static analysis, no imports)
- Parses Markdown files with MyST-Parser
- Generates per-symbol documentation pages with:
  - API reference auto-generated from source code
  - Deep links to source code via `linkcode` extension
    - Editor mode: `vscode://file/<abs-path>:<line>:<col>`
    - GitHub mode: `https://github.com/<org>/<repo>/blob/<sha>/<rel-path>#Lstart-Lend`
  - Inheritance diagrams via `sphinx.ext.inheritance_diagram`
  - Source code listings with line numbers via `sphinx.ext.viewcode`
  - Mermaid diagram support via `sphinxcontrib.mermaid`
- Theme: `pydata_sphinx_theme` (overridable via `SPHINX_THEME` env var)
- Extensions enabled:
  - `myst_parser`: Markdown support
  - `sphinx.ext.napoleon`: NumPy docstring parsing
  - `sphinx.ext.autosummary`: Summary tables
  - `sphinx.ext.intersphinx`: Cross-project links (Python stdlib)
  - `sphinx.ext.viewcode`: Source code pages
  - `sphinx.ext.linkcode`: Deep links to source
  - `sphinx.ext.graphviz`: Graphviz diagrams
  - `sphinx.ext.inheritance_diagram`: Class inheritance trees
  - `autoapi.extension`: Static API extraction
  - `sphinxcontrib.mermaid`: Mermaid diagrams
- Uses Griffe loader for symbol lookup without importing code
- Produces navigable HTML site with search functionality

**Environment variables:**
- `SPHINXOPTS`: Sphinx options (set to `-W` in update_docs.sh to treat warnings as errors)
- `DOCS_LINK_MODE`: `editor` or `github` (controls linkcode behavior)
- `DOCS_EDITOR`: `vscode` or `pycharm` (for editor links)
- `DOCS_GITHUB_ORG` / `DOCS_GITHUB_REPO`: GitHub org/repo for permalinks
- `SPHINX_THEME`: Override default theme

**What gets generated:**
- Complete HTML documentation site in `docs/_build/html/`
- API reference pages for all packages, modules, classes, and functions
- Navigation tree and search index
- Source code pages with syntax highlighting
- Cross-referenced documentation with hyperlinks

### Stage 6: Sphinx JSON Build (`make json`)

**Purpose:** Generate machine-readable JSON corpus of API documentation.

**Makefile target:** `json`

**Command:** `python -m sphinx -b json docs docs/_build/json`

**What it does:**
- Cleans previous JSON build (`rm -rf docs/_build/json`)
- Runs Sphinx with JSON builder instead of HTML
- Produces structured JSON files mirroring the HTML structure
- Each .fjson file contains:
  - Page title, body text, and metadata
  - Rendered documentation content in structured format
  - Cross-reference links and relationships
- Special JSON serialization handling for:
  - LRU cache wrappers (serialized as repr strings)
  - Complex Sphinx objects
- Same extensions and configuration as HTML build

**Use cases:**
- AI agent consumption of API documentation
- Automated documentation analysis
- Search indexing and content extraction
- Documentation testing and validation

**What gets generated:**
- `docs/_build/json/`: Complete JSON corpus
- One .fjson file per documentation page
- `globalcontext.json`: Site-wide metadata and configuration
- Machine-readable API reference data

### Stage 7: Symbol Index Build (`make symbols`)

**Purpose:** Generate a flat symbol index for fast agent lookup.

**Makefile target:** `symbols`

**Command:** `python docs/_scripts/build_symbol_index.py`

**What it does:**
- Uses Griffe to statically load and analyze all packages
- Walks the complete symbol tree (packages, modules, classes, functions, etc.)
- Extracts for each symbol:
  - Fully qualified name (e.g., `kgfoundry_common.config.load_config`)
  - Kind: module, class, function, attribute, etc.
  - File path (relative to repo root)
  - Line number range (start, end)
  - First paragraph of docstring (short summary)
- Writes `docs/_build/symbols.json` as a flat JSON array
- Each entry is a dict with keys: `path`, `kind`, `file`, `lineno`, `endlineno`, `doc`
- Provides fast symbol lookup without parsing multiple nested JSON files

**What gets generated:**
- `docs/_build/symbols.json`: Flat array of all symbols
- One entry per symbol with location and summary
- Fast-access format optimized for agent queries

### Stage 8: MkDocs Build (Optional)

**Purpose:** Generate an alternative Markdown-first documentation site.

**Condition:** Only runs if `mkdocs` is installed in the virtual environment

**Command:** `mkdocs build --config-file mkdocs.yml`

**What it does:**
- Reads configuration from `mkdocs.yml`
- Uses Material for MkDocs theme
- Plugins enabled:
  - `search`: Full-text search
  - `gen-files`: Generates API pages from source via `docs/_scripts/mkdocs_gen_api.py`
  - `mkdocstrings[python]`: Python API documentation extraction
  - `literate-nav`: Markdown-based navigation
  - `section-index`: Index pages for sections
- Renders Markdown files from `docs/` directory
- Generates API reference pages dynamically
- Uses Griffe via mkdocstrings for symbol extraction
- Produces a standalone static site

**What gets generated:**
- `site/`: Complete MkDocs HTML site
- Alternative navigation and presentation of same content
- Search functionality
- Material Design-themed interface

**Why both Sphinx and MkDocs?**
- Sphinx: More powerful, extensive ecosystem, better for API docs
- MkDocs: Cleaner, simpler, better for prose documentation
- Having both provides flexibility for different audiences

---

## Key Configuration Files

| File | Purpose |
| ---- | ------- |
| [`docs/conf.py`](docs/conf.py) | Sphinx configuration. Performs static parsing with AutoAPI, adds editor/GitHub deep links, builds HTML/JSON outputs, configures extensions, and defines symbol lookup via Griffe. |
| [`tools/update_docs.sh`](tools/update_docs.sh) | **Master orchestration script.** One-touch wrapper that runs the complete documentation pipeline: docstring generation, nav-map build/check, README generation, and Sphinx/MkDocs builds. |
| [`tools/generate_docstrings.py`](tools/generate_docstrings.py) | Docstring skeleton generator. Runs `doq` with NumPy templates on `src/`, `tools/`, and `docs/_scripts/`, then runs `auto_docstrings.py` fallback for remaining items. |
| [`tools/auto_docstrings.py`](tools/auto_docstrings.py) | AST-based fallback docstring generator. Creates NumPy-style docstrings for modules, classes, and functions that don't already have them or have TODO placeholders. |
| [`tools/update_navmaps.py`](tools/update_navmaps.py) | Validates that module docstrings remain free of legacy `NavMap:` sections; exits non-zero if any violations are detected. |
| [`tools/gen_readmes.py`](tools/gen_readmes.py) | Generates package-level `README.md` files that list public modules/classes/functions with summaries, editor deep links (`[open]`), and GitHub permalinks (`[view]`). |
| [`tools/navmap/build_navmap.py`](tools/navmap/build_navmap.py) | Builds machine-readable navigation map index (`site/_build/navmap/navmap.json`). Extracts `__all__`, `__navmap__`, anchors, and sections from all Python modules. |
| [`tools/navmap/check_navmap.py`](tools/navmap/check_navmap.py) | Validates navmap metadata: checks exports consistency, section naming conventions, kebab-case IDs, and anchor presence. Returns exit code 1 on errors. |
| [`tools/docs/build_test_map.py`](tools/docs/build_test_map.py) | Builds test coverage map for documentation. Analyzes test files and maps them to source code. |
| [`tools/docs/scan_observability.py`](tools/docs/scan_observability.py) | Scans codebase for observability instrumentation (logging, tracing, metrics). Documents observability patterns and practices. |
| [`tools/docs/export_schemas.py`](tools/docs/export_schemas.py) | Exports Pydantic models and data schemas as JSON Schema definitions for API contract documentation. |
| [`tools/docs/build_graphs.py`](tools/docs/build_graphs.py) | Builds dependency and architecture graphs. Analyzes code relationships and generates visual diagrams. |
| [`tools/detect_pkg.py`](tools/detect_pkg.py) | Detects primary/all packages for doc generation (used by Sphinx/Makefile/tools). Prefers lowercase names and `kgfoundry`-prefixed packages in `src/`. |
| [`docs/_scripts/build_symbol_index.py`](docs/_scripts/build_symbol_index.py) | Emits `docs/_build/symbols.json` flat array for agent consumption. Each entry contains fully qualified name, kind, file path, line range, and docstring summary. |
| [`Makefile`](Makefile) | Defines developer tasks: `docstrings`, `readmes`, `html`, `json`, `symbols`, `navmap-build`, `navmap-check`, `watch`, `fmt`, `lint`, `bootstrap`. |
| [`mkdocs.yml`](mkdocs.yml) | MkDocs configuration for Material theme with plugins: search, gen-files (dynamic API pages), mkdocstrings (Python docs), literate-nav, section-index. |
| [`.pre-commit-config.yaml`](.pre-commit-config.yaml) | Pre-commit hooks: Ruff (imports/lint/format), Black, Mypy, docformatter, **pydoclint**, pydocstyle, interrogate, navmap-build, navmap-check. |
| [`.numpydoc`](.numpydoc) | Global numpydoc validation settings (`GL01`, `SS01`, `ES01`, `RT01`, `PR01`) used by Sphinx during HTML/JSON builds. |
| [`pyproject.toml`](pyproject.toml) | Configures Ruff (lint/format), Black, pytest, mypy, pydocstyle, and docs extras (`[project.optional-dependencies.docs]`). |
| [`mypy.ini`](mypy.ini) | Strict type-check configuration (Python 3.13, `mypy_path=src`, third-party ignores for packages lacking stubs). |
| [`tools/doq_templates/numpy/`](tools/doq_templates/numpy/) | NumPy-style docstring templates used by `doq` during docstring generation (def, class, module templates). |

---

## Detailed Tool Descriptions

### Master Orchestration: `tools/update_docs.sh`

The single entry point for complete documentation regeneration.

**Prerequisites check:**
- Verifies `.venv/` virtual environment exists
- Checks for required tools: `doq`, `docformatter`, `pydocstyle`, `pydoclint`, `interrogate`
- Warns if `mkdocs` is missing (optional dependency)

**Environment setup:**
- Sets `PYTHONPATH` to include `src/`
- Sets `SPHINXOPTS=-W` to treat Sphinx warnings as errors
- Uses `.venv/bin/python` for all Python commands

**Execution flow:**
1. Clean slate: `rm -rf docs/_build site`
2. `make docstrings` - Generate and validate docstrings
3. `make readmes` - Generate package READMEs
4. `python tools/update_navmaps.py` - Ensure docstrings remain free of legacy `NavMap:` sections
5. `python tools/navmap/build_navmap.py` - Build navmap index
6. `python tools/navmap/check_navmap.py` - Validate navmap
7. `pytest --xdoctest` - Run doctest examples in examples/
8. `python tools/docs/build_test_map.py` - Build test coverage map
9. `python tools/docs/scan_observability.py` - Scan observability instrumentation
10. `python tools/docs/export_schemas.py` - Export data contract schemas
11. `python tools/docs/build_graphs.py` - Build dependency and architecture graphs
12. `make html` - Build Sphinx HTML docs
13. `make json` - Build Sphinx JSON corpus
14. `make symbols` - Build symbol index
15. `mkdocs build` (optional) - Build MkDocs site if available

**Exit behavior:**
- Exits with error if virtual environment is missing
- Exits with error if required doc tools are missing
- Continues with warning if mkdocs is unavailable
- Each stage must complete successfully or the script fails

### Sphinx Configuration: `docs/conf.py`

Comprehensive Sphinx configuration with agent-friendly features.

**Package detection:**
- Auto-detects primary package via `tools/detect_pkg.py`
- Prefers `src/<pkg>` layout, falls back to root layout
- Supports `DOCS_PKG` environment variable to override

**AutoAPI configuration:**
- Static analysis only - never imports the code
- Scans `src/` or root directory
- Generates complete API reference tree
- Options: members, undoc-members, show-inheritance, special-members, imported-members

**Link generation (linkcode extension):**
- Uses Griffe to look up symbol locations without importing
- Caches module lookups for performance
- Two modes controlled by `DOCS_LINK_MODE`:
  - **editor** (default): `vscode://file/<path>:<line>:<col>` or `pycharm://open?file=<path>&line=<line>`
  - **github**: `https://github.com/<org>/<repo>/blob/<sha>/<path>#Lstart-Lend`
- Git SHA resolution for commit-stable permalinks
- Falls back gracefully when symbols can't be located

**Extensions enabled:**
- `myst_parser`: Markdown parsing with colon_fence, deflist, linkify
- `sphinx.ext.napoleon`: NumPy docstring parsing
- `sphinx.ext.autosummary`: Summary tables
- `sphinx.ext.intersphinx`: Cross-links to Python docs
- `sphinx.ext.viewcode`: Source code pages with line numbers
- `sphinx.ext.linkcode`: Deep links via Griffe
- `sphinx.ext.graphviz`: Diagram rendering
- `sphinx.ext.inheritance_diagram`: Class hierarchy diagrams
- `autoapi.extension`: Static API docs
- `sphinxcontrib.mermaid`: Mermaid diagram support

**JSON builder support:**
- Custom JSON encoder handles lru_cache wrappers
- Serializes complex Sphinx objects safely
- Produces machine-readable .fjson files

**Environment variables:**
- `DOCS_PKG`: Override package detection (comma-separated for multiple)
- `DOCS_LINK_MODE`: `editor` or `github`
- `DOCS_EDITOR`: `vscode` or `pycharm`
- `DOCS_GITHUB_ORG` / `DOCS_GITHUB_REPO`: GitHub coordinates
- `DOCS_GITHUB_SHA`: Override git SHA (for CI)
- `SPHINX_THEME`: Override default theme
- `PROJECT_NAME` / `PROJECT_AUTHOR`: Project metadata

### Docstring Generation: `tools/generate_docstrings.py`

Two-stage docstring generation for comprehensive coverage.

**Stage 1: doq (primary generator)**
- Command: `doq --formatter numpy -t tools/doq_templates/numpy/ -w -r -d <target>`
- Uses custom NumPy templates from `tools/doq_templates/numpy/`:
  - `def.txt`: Function/method template
  - `class.txt`: Class template
  - Other templates for different contexts
- Generates skeleton docstrings with:
  - Summary line
  - Parameters section with types from annotations
  - Returns section with return type
  - Placeholder descriptions
- Writes in-place (`-w` flag)
- Recursive (`-r` flag)
- Processes: `src/`, `tools/`, `docs/_scripts/`

**Stage 2: auto_docstrings.py (fallback)**
- AST-based parsing for remaining items
- Targets:
  - Modules without docstrings
  - Classes/functions with missing or TODO docstrings
- Uses introspection to generate:
  - Imperative-style summaries (e.g., "Return user configuration.")
  - Parameter lists with types from annotations
  - Optional parameter markers for defaults
  - Return type documentation
- Logs touched files to `site/_build/docstrings/fallback.log`

**Why two stages?**
- doq is faster and more comprehensive for standard functions
- auto_docstrings catches edge cases doq misses
- Together they ensure 100% initial coverage

### NavMap System: `tools/navmap/`

Machine-readable navigation metadata for agents and tooling.

**build_navmap.py - Index Builder:**

Scans all Python files and extracts structured metadata:

```python
# Example module with full navmap metadata
"""Module for authentication and authorization."""

__all__ = ["authenticate", "authorize", "User"]

__navmap__ = {
    "exports": __all__,
    "synopsis": "Authentication and authorization utilities",
    "sections": [
        {"id": "public-api", "symbols": ["authenticate", "authorize"]},
        {"id": "models", "symbols": ["User"]},
    ],
    "symbols": {
        "authenticate": {"category": "core", "stability": "stable"},
        "authorize": {"category": "core", "stability": "stable"},
        "User": {"category": "model", "stability": "beta"},
    },
    "tags": ["auth", "security"],
    "see_also": ["session.manager"],
    "deps": ["crypto.utils"],
}

# [nav:section public-api]

# [nav:anchor authenticate]
def authenticate(username: str, password: str) -> bool:
    """Authenticate user credentials."""
    ...

# [nav:anchor authorize]
def authorize(user: User, resource: str) -> bool:
    """Authorize user access to resource."""
    ...

# [nav:section models]

# [nav:anchor User]
class User:
    """Represent authenticated user."""
    ...
```

**Output format (`site/_build/navmap/navmap.json`):**

```json
{
  "commit": "abc123...",
  "modules": {
    "auth.core": {
      "path": "src/auth/core.py",
      "exports": ["authenticate", "authorize", "User"],
      "sections": [
        {"id": "public-api", "symbols": ["authenticate", "authorize"]},
        {"id": "models", "symbols": ["User"]}
      ],
      "section_lines": {
        "public-api": 25,
        "models": 45
      },
      "anchors": {
        "authenticate": 27,
        "authorize": 35,
        "User": 47
      },
      "links": {
        "source": "vscode://file/src/auth/core.py"
      },
      "meta": {
        "authenticate": {"category": "core", "stability": "stable"},
        "authorize": {"category": "core", "stability": "stable"},
        "User": {"category": "model", "stability": "beta"}
      },
      "tags": ["auth", "security"],
      "synopsis": "Authentication and authorization utilities",
      "see_also": ["session.manager"],
      "deps": ["crypto.utils"]
    }
  }
}
```

**check_navmap.py - Validator:**

Enforces consistency and correctness:

1. **Export consistency:**
   ```python
   # ERROR: Mismatch
   __all__ = ["foo", "bar"]
   __navmap__ = {"exports": ["foo", "baz"]}  # bar missing, baz not in __all__
   ```

2. **Section naming:**
   ```python
   # ERROR: First section must be 'public-api'
   __navmap__ = {
       "sections": [
           {"id": "advanced", ...},  # Wrong! Must be 'public-api'
       ]
   }
   
   # ERROR: Invalid section ID (not kebab-case)
   {"id": "publicAPI", ...}  # Must be 'public-api'
   ```

3. **Anchor validation:**
   ```python
   # ERROR: Missing anchor
   __navmap__ = {
       "sections": [
           {"id": "public-api", "symbols": ["foo"]}
       ]
   }
   # No '# [nav:anchor foo]' in file
   ```

4. **Symbol naming:**
   ```python
   # ERROR: Invalid Python identifier
   {"symbols": ["123invalid"]}  # Can't start with number
   ```

**Use cases:**
- Agent navigation: Jump to symbol definitions
- Documentation linking: Cross-reference resolution
- Code exploration: Structured module understanding
- IDE integration: Symbol search and navigation
- Dependency analysis: Track module relationships

### README Generation: `tools/gen_readmes.py`

Package-level documentation with hierarchical API listings.

**Detection phase:**
- Uses `tools/detect_pkg.py` to find packages
- Prefers packages in `src/` directory
- Loads each package with Griffe (no imports)

**Rendering phase:**

For each package and sub-package:

1. **Header:**
   ```markdown
   # `kgfoundry_common`
   
   <!-- START doctoc generated TOC please keep comment here to allow auto update -->
   <!-- END doctoc generated TOC please keep comment here to allow auto update -->
   
   ## API
   ```

2. **Symbol entries:**
   - Hierarchical bullets (0, 2, 4, 6... space indentation)
   - Format: `**`fully.qualified.name`**` — Summary → [open](link) | [view](link)
   - Includes modules, classes, and functions
   - Skips private symbols (underscore-prefixed)

3. **Link generation:**
   - `[open]`: Relative path with line/column (e.g., `./config.py:15:1`)
   - `[view]`: GitHub permalink or relative path depending on mode
   - Automatically resolves file paths via Griffe

**Example output:**

```markdown
# `kgfoundry_common`

## API

- **`kgfoundry_common.config`** — Configuration management utilities → [open](./config.py:1:1) | [view](https://github.com/org/repo/blob/abc123.../src/kgfoundry_common/config.py#L1-L48)
  - **`kgfoundry_common.config.load_config`** — Load configuration from YAML file → [open](./config.py:15:1) | [view](https://github.com/.../config.py#L15-L25)
  - **`kgfoundry_common.config.ConfigSchema`** — Represent application configuration → [open](./config.py:28:1) | [view](https://github.com/.../config.py#L28-L45)
```

**Post-processing:**
- Optional `doctoc` run to populate TOC
- Gracefully skips if doctoc not installed

### Symbol Index: `docs/_scripts/build_symbol_index.py`

Flat JSON array for fast agent lookup.

**Purpose:**
- Provide O(1) symbol lookup by name
- Avoid parsing nested JSON structures
- Enable fast autocomplete and symbol search

**Process:**
1. Load all packages with Griffe
2. Walk complete symbol tree recursively
3. Extract for each symbol:
   - `path`: Fully qualified name (e.g., `kgfoundry.search_api.app.create_app`)
   - `kind`: module | class | function | attribute | etc.
   - `file`: Relative path to source file (e.g., `src/search_api/app.py`)
   - `lineno`: Start line (1-based)
   - `endlineno`: End line (1-based)
   - `doc`: First paragraph of docstring

**Output format:**

```json
[
  {
    "path": "kgfoundry_common.config.load_config",
    "kind": "function",
    "file": "src/kgfoundry_common/config.py",
    "lineno": 15,
    "endlineno": 25,
    "doc": "Load configuration from YAML file."
  },
  {
    "path": "kgfoundry_common.config.ConfigSchema",
    "kind": "class",
    "file": "src/kgfoundry_common/config.py",
    "lineno": 28,
    "endlineno": 45,
    "doc": "Represent application configuration."
  }
]
```

**Use cases:**
- Agent symbol lookup: "Where is `load_config`?"
- Jump to definition: File path + line number
- Symbol search: Filter by kind, name, or docstring content
- Documentation validation: Check all symbols are documented

### Package Detection: `tools/detect_pkg.py`

Intelligent package discovery for multi-package repos.

**Detection strategy:**

1. Scan `src/` for packages (directories with `__init__.py`)
2. Scan repo root for packages (excluding `docs`, `tools`, `optional`)
3. Remove `src` itself from candidates
4. Prefer lowercase package names
5. Prefer packages containing "kgfoundry"
6. Return ordered list: preferred packages first

**Usage modes:**

```bash
# Primary package (first in preference order)
python tools/detect_pkg.py
# Output: kgfoundry_common

# All packages
python tools/detect_pkg.py --all
# Output:
# kgfoundry_common
# search_api
# kg_builder
```

**Integration:**
- Used by `docs/conf.py` to auto-detect package
- Used by `gen_readmes.py` to generate all READMEs
- Used by `build_symbol_index.py` to index all packages
- Can be overridden by `DOCS_PKG` environment variable

---

## Pre-Commit Hooks

The `.pre-commit-config.yaml` file wires in comprehensive quality checks that run automatically before each commit.

### Hook execution order:

1. **Ruff (imports)** - `ruff --select I --fix`
   - Normalizes import ordering before other checks
   - Sorts imports alphabetically within groups
   - Groups: standard library, third-party, first-party
   - Fixes automatically, so subsequent hooks see clean imports

2. **Ruff (lint+fix)** - `ruff --fix`
   - Runs full Ruff ruleset (configured in `pyproject.toml`)
   - Auto-fixes issues where possible
   - Checks: F (pyflakes), E4/E7/E9 (pycodestyle), I (isort), N (naming), UP (pyupgrade), SIM (simplify), C4 (comprehensions), B (bugbear), RUF (ruff-specific), ANN (annotations), D (docstrings), RET (returns), RSE (raise), TRY (try/except), EM (error messages), G (logging), LOG (logging), ISC (implicit str concat), TID (tidy imports), ICN (import conventions), TD (todos), ERA (eradicate), PGH (pygrep-hooks), C90 (complexity), PLR (pylint refactor)
   - Max complexity: 10
   - Max branches: 12
   - Max returns: 6

3. **Ruff (format)** - `ruff format`
   - Applies Ruff's code formatter
   - Line length: 100
   - Double quotes, space indentation
   - Formats docstring code blocks
   - Should be a no-op after lint+fix

4. **Black** - `black`
   - Safety net downstream of Ruff
   - Should produce no changes if Ruff format ran
   - Line length: 100
   - Target version: py312 (code runs on py313)

5. **Mypy** - `mypy src`
   - Static type checking with strict mode
   - Python 3.13 target
   - `mypy_path = src` for imports
   - Ignores third-party packages without stubs (duckdb, faiss, etc.)
   - Checks: disallow_untyped_defs, no_implicit_optional, warn_unused_ignores, warn_redundant_casts, strict_equality
   - Fails commit if type errors found

6. **docformatter** - Custom wrapper (`tools/hooks/docformatter.py`)
   - Formats docstrings to PEP 257
   - Wrap at 100 characters
   - Processes all modified Python files
   - Prints touched files for visibility
   - Always runs (`always_run: true`)

7. **navmap-check** - `python tools/navmap/check_navmap.py`
   - Validates navmap metadata consistency
   - Checks exports match, section naming, anchor presence
   - Prevents broken navigation metadata from being committed
   - Always runs on all files (`always_run: true`, `pass_filenames: false`)

8. **navmap-build** - `python tools/navmap/build_navmap.py`
   - Regenerates navmap index after changes
   - Updates `site/_build/navmap/navmap.json`
   - Ensures index stays in sync with code
   - Always runs on all files

9. **pydoclint** - `pydoclint --style numpy src`
   - Enforces parameter/return parity for NumPy docstrings
   - Fails commits when documented parameters diverge from signatures
   - Runs against the full source tree (`language: system`, `pass_filenames: false`)

10. **pydocstyle** - `pydocstyle src`
    - Lints docstrings against the NumPy convention
    - Ignores: D200, D202, D204, D205, D209, D400, D401
    - Runs after pydoclint/docformatter to catch residual formatting issues

11. **interrogate** - `interrogate -i src --fail-under 90`
    - Enforces 90% docstring coverage on `src/`
    - Interactive mode (`-i`) shows coverage details
    - Fails the build if coverage drops below 90%

### Running manually:

```bash
# Run all hooks on all files
pre-commit run --all-files

# Run specific hook
pre-commit run ruff --all-files
pre-commit run mypy --all-files

# Install/update hooks
pre-commit install
pre-commit autoupdate
```

### Why always_run?

Some hooks use `always_run: true` and `pass_filenames: false` because:
- **docformatter**: Needs to see all files to maintain consistent formatting
- **navmap checks**: Module relationships require whole-codebase analysis
- **pydocstyle/interrogate**: Coverage metrics need complete visibility

This ensures consistency even when only one file is changed.

---

## Environment Variables Reference

Complete list of environment variables that control documentation generation:

### Package Selection

- **`DOCS_PKG`**: Override package detection (comma-separated for multiple packages)
  - Default: Auto-detected via `tools/detect_pkg.py`
  - Example: `DOCS_PKG=kgfoundry_common,search_api`

### Link Generation

- **`DOCS_LINK_MODE`**: Controls deep link format
  - Values: `editor` (default), `github`
  - `editor`: Creates `vscode://file/...` or `pycharm://open?file=...` URLs
  - `github`: Creates GitHub permalinks with commit SHA

- **`DOCS_EDITOR`**: Editor scheme for deep links (when `DOCS_LINK_MODE=editor`)
  - Values: `vscode` (default), `pycharm`
  - VSCode format: `vscode://file/<abs-path>:<line>:<col>`
  - PyCharm format: `pycharm://open?file=<abs-path>&line=<line>`

- **`DOCS_GITHUB_ORG`**: GitHub organization/owner name
  - Default: Auto-detected from git remote or `your-org`
  - Example: `DOCS_GITHUB_ORG=mycompany`

- **`DOCS_GITHUB_REPO`**: GitHub repository name
  - Default: Auto-detected from git remote or `your-repo`
  - Example: `DOCS_GITHUB_REPO=kgfoundry`

- **`DOCS_GITHUB_SHA`**: Git commit SHA for permalinks
  - Default: Auto-detected via `git rev-parse HEAD`
  - Example: `DOCS_GITHUB_SHA=abc123...` (useful in CI)

### Sphinx Configuration

- **`SPHINXOPTS`**: Options passed to sphinx-build
  - Default: Empty
  - `update_docs.sh` sets: `-W` (treat warnings as errors)
  - Example: `SPHINXOPTS="-W --keep-going"`

- **`SPHINX_THEME`**: Override HTML theme
  - Default: `pydata_sphinx_theme`
  - Example: `SPHINX_THEME=sphinx_rtd_theme`

- **`SPHINX_AUTOBUILD_PORT`**: Port for live server (`make watch`)
  - Default: `8000`
  - Example: `SPHINX_AUTOBUILD_PORT=8080`

### Project Metadata

- **`PROJECT_NAME`**: Project name in docs
  - Default: `kgfoundry`
  - Example: `PROJECT_NAME="My Project"`

- **`PROJECT_AUTHOR`**: Author name in docs
  - Default: `kgfoundry Maintainers`
  - Example: `PROJECT_AUTHOR="Acme Corp"`

### CI/Build Variables

- **`PYTHONPATH`**: Python module search path
  - `update_docs.sh` sets: `src` (or preserves existing)
  - Example: `PYTHONPATH=src:lib`

---

## Generated Artifacts

Complete list of files and directories generated by the documentation system:

### Sphinx Outputs

- **`docs/_build/html/`**: Complete HTML documentation website
  - `index.html`: Documentation homepage
  - `autoapi/`: Auto-generated API reference pages
  - `_static/`: CSS, JS, images
  - `_sources/`: reST/Markdown source files
  - `search.html`: Search interface
  - `searchindex.js`: Search index

- **`docs/_build/json/`**: Machine-readable JSON corpus
  - `*.fjson`: One file per documentation page
  - `globalcontext.json`: Site-wide metadata
  - Same structure as HTML build, different format

- **`docs/_build/symbols.json`**: Flat symbol index
  - JSON array of all symbols
  - Fields: path, kind, file, lineno, endlineno, doc
  - Optimized for agent lookup

### NavMap Outputs

- **`site/_build/navmap/navmap.json`**: Navigation map index
  - Per-module metadata (exports, sections, anchors)
  - Commit SHA for provenance
  - VSCode deep links
  - Symbol metadata (tags, categories, stability)

- **`site/_build/docstrings/fallback.log`**: Docstring generation log
  - Lists files touched by `auto_docstrings.py`
  - One file path per line
  - Useful for tracking changes

### Package Documentation

- **`src/<package>/README.md`**: Package-level documentation
  - Generated for each package and sub-package
  - API listings with deep links
  - Doctoc TOC placeholders
  - Editor and GitHub links

### MkDocs Output (Optional)

- **`site/`**: MkDocs HTML site
  - Alternative presentation of same content
  - Material Design theme
  - `site/index.html`: Homepage
  - `site/api/`: Generated API pages
  - `site/search/`: Search index
  - Complete standalone static site

### Intermediate Files

- **`.ruff_cache/`**: Ruff cache (gitignored)
- **`.mypy_cache/`**: Mypy cache (gitignored)
- **`.pytest_cache/`**: Pytest cache (gitignored)
- **`__pycache__/`**: Python bytecode (gitignored)

---

## Makefile Targets Reference

Complete reference for all Make targets:

### Documentation Generation

- **`make docstrings`**: Generate and validate docstrings
  - Runs `generate_docstrings.py` (doq + auto_docstrings)
  - Runs `update_navmaps.py` (refresh NavMap sections)
  - Runs `docformatter` (format docstrings)
  - Runs `pydocstyle` (lint docstrings)
  - Runs `interrogate` (check coverage)
  - Processes: `src/`, `tools/`, `docs/_scripts/`

- **`make readmes`**: Generate package READMEs
  - Runs `gen_readmes.py` (Griffe-based README generator)
  - Optionally runs `doctoc` (if installed)
  - Generates READMEs for all detected packages

- **`make navmap-build`**: Build navmap index
  - Runs `tools/navmap/build_navmap.py`
  - Outputs `site/_build/navmap/navmap.json`
  - Extracts __all__, __navmap__, anchors, sections

- **`make navmap-check`**: Validate navmap metadata
  - Runs `tools/navmap/check_navmap.py`
  - Checks exports, sections, anchors, naming
  - Exits 1 if validation fails

- **`make html`**: Build Sphinx HTML docs
  - Command: `python -m sphinx -b html docs docs/_build/html`
  - Uses AutoAPI for static analysis
  - Generates complete website with search

- **`make json`**: Build Sphinx JSON corpus
  - Command: `rm -rf docs/_build/json && python -m sphinx -b json docs docs/_build/json`
  - Clean build from scratch
  - Machine-readable API docs

- **`make symbols`**: Build symbol index
  - Runs `docs/_scripts/build_symbol_index.py`
  - Outputs `docs/_build/symbols.json`
  - Flat JSON array for fast lookup

- **`make watch`**: Live documentation server
  - Command: `PYTHONPATH=src python -m sphinx_autobuild --port <PORT> docs docs/_build/html`
  - Auto-rebuilds on file changes
  - Default port: 8000 (override with `SPHINX_AUTOBUILD_PORT`)
  - Includes browser auto-reload

### Development Tasks

- **`make bootstrap`**: Initial setup
  - Creates `.venv/` virtual environment
  - Upgrades pip and wheel
  - Installs package with `[dev,docs]` extras
  - Installs and configures pre-commit hooks
  - Applies database migrations

- **`make fmt`**: Format code
  - Ruff import sorting: `ruff check --select I --fix`
  - Ruff linting: `ruff check --fix`
  - Ruff formatting: `ruff format`
  - Black formatting: `black` (safety net)
  - Processes: `src/`, `tests/`, `tools/`, `docs/_scripts/`

- **`make lint`**: Lint code
  - Ruff import check: `ruff check --select I`
  - Ruff lint check: `ruff check`
  - Ruff format check: `ruff format --check`
  - Mypy type check: `mypy src`
  - No auto-fixes, only checks

- **`make test`**: Run tests
  - Command: `pytest -q`
  - Quick mode (less verbose)

- **`make e2e`**: Run end-to-end tests
  - Tries `pytest -q -m e2e` first
  - Falls back to all tests if e2e marker not found

### Application Tasks

- **`make run`** / **`make api`**: Run API server
  - Command: `uvicorn kgfoundry.search_api.app:app --app-dir src --host 0.0.0.0 --port 8080 --reload`
  - Hot reload enabled
  - Listens on all interfaces

- **`make mock`**: Run mock servers
  - Command: `python -m tests.mock_servers.run_all`
  - Starts all test mock servers

- **`make fixture`**: Run fixture flow
  - Command: `python -m kgfoundry.orchestration.fixture_flow`
  - Generates test fixtures

### Cleanup

- **`make clean`**: Remove caches and virtual environment
  - Deletes: `.venv/`, `.mypy_cache/`, `.ruff_cache/`, `.pytest_cache/`, `dist/`, `build/`
  - Does NOT delete documentation builds (use `rm -rf docs/_build site` manually)

---

## Quick Commands
- Adds [linkcode](https://www.sphinx-doc.org/en/master/usage/extensions/linkcode.html) hooks with:
  - Editor deep links (`vscode://file/...`) when `DOCS_LINK_MODE=editor` (default).
  - GitHub permalinks (`.../blob/<SHA>/...#Lstart-Lend`) when `DOCS_LINK_MODE=github`.
- Builds HTML and machine-readable JSON (`make html`, `make json`).
- Enables extensions such as `myst_parser`, `sphinx.ext.viewcode`, `sphinx.ext.graphviz`, `sphinx.ext.inheritance_diagram`, and `sphinxcontrib.mermaid`.

### README Generator (`tools/gen_readmes.py`)

- Uses **Griffe** to walk each package and collect public modules/classes/functions.
- Writes `README.md` with:
  - A Doctoc-compatible TOC placeholder.
  - Per-symbol entries (summary + `[open]`/`[view]` links).
  - `DOCS_LINK_MODE` toggles between editor links and GitHub permalinks.
- Re-run manually (`python tools/gen_readmes.py`) or automatically via `make readmes`.

### NavMap Updater (`tools/update_navmaps.py`)

- Called during `make docstrings`.
- Rewrites module docstrings to append a concise `NavMap:` section summarizing public API entry points.
- Summaries are truncated (~60 chars) so each bullet stays within the 100-character line length enforced by Ruff/Black/docformatter.

### Docs Update Script (`tools/update_docs.sh`)

- Run from repo root to perform the full pipeline:
  1. `make docstrings` (doq → nav map → docformatter/pydocstyle/interrogate)
  2. `make readmes`
  3. `make html`, `make json`, `make symbols`
  4. Optional MkDocs build if `mkdocs` is installed
- Gracefully skips MkDocs if not present.

### Makefile Tasks

- `make docstrings`: seeds and formats docstrings, updates NavMaps, runs docformatter/pydocstyle/interrogate.
- `make readmes`: regenerates package READMEs.
- `make html/json/symbols`: Sphinx builders for HTML, JSON corpus, and `docs/_build/symbols.json`.
- `make watch`: runs `sphinx-autobuild` (auto rebuild+serve).
- `make bootstrap`: creates `.venv`, installs `pip install -e "[dev,docs]"`, sets up pre-commit.

---

## Library & Extension Overview

| Tool / Library | Role |
|----------------|------|
| [Sphinx](https://www.sphinx-doc.org/) | Core documentation builder. |
| [AutoAPI](https://github.com/readthedocs/sphinx-autoapi) | Static API extraction without importing modules. |
| [MyST-Parser](https://myst-parser.readthedocs.io/) | Markdown support in Sphinx. |
| [Griffe](https://mkdocstrings.github.io/griffe/) | Static analyzer powering nav maps, README links, symbol index, and mkdocstrings integration. |
| [docformatter](https://github.com/PyCQA/docformatter) | Docstring formatter invoked in `make docstrings` and pre-commit. |
| [pydocstyle](https://www.pydocstyle.org/en/stable/) | PEP 257 docstring linting. |
| [interrogate](https://interrogate.readthedocs.io/) | Docstring coverage enforcement (configured for 90%). |
| [doq](https://github.com/heavenshell/py-doq) | Docstring skeleton generator used in `make docstrings`. |
| [MkDocs + mkdocstrings](https://www.mkdocs.org/) | Optional Markdown-first site (configured in `mkdocs.yml`). |
| [Doctoc](https://github.com/thlorenz/doctoc) | Optional CLI that updates README TOCs (invoked by `make readmes` if available). |

### Sphinx Extensions Enabled

- `myst_parser`
- `sphinx.ext.autosummary`
- `sphinx.ext.intersphinx`
- `sphinx.ext.viewcode`
- `sphinx.ext.linkcode`
- `sphinx.ext.graphviz`
- `sphinx.ext.inheritance_diagram`
- `autoapi.extension`
- `sphinxcontrib.mermaid`

### Optional Extras

- [MkDocs Material](https://squidfunk.github.io/mkdocs-material/) + mkdocstrings + mkdocs-gen-files (see `mkdocs.yml`).
- Graphviz system binary required for graphviz/inheritance diagrams.

---

## Pre-Commit Hooks

`.pre-commit-config.yaml` wires in:

- **Ruff (imports)** – runs `ruff --select I --fix` to normalize import ordering before other checks.
- **Ruff (lint+fix)** – runs `ruff --fix` with the full ruleset enabled in `pyproject.toml`.
- **Ruff (format)** – applies Ruff's formatter (`ruff format`) so commits always match the project style.
- **Black** – downstream safety net; should be a no-op if Ruff formatting has already run.
- **Mypy** – static type checking with strict mode configured via `mypy.ini` (invoked as `mypy src`).
- **Docformatter** (custom wrapper) for docstring formatting; prints touched files.
- **pydocstyle** to enforce docstring conventions.
- **Interrogate** to enforce docstring coverage (90%).

Run all hooks manually with `pre-commit run --all-files`.

---

## Formatting & Type Checking Pipeline

- Ruff handles import sorting, linting (including automated fixes), and code formatting. The three Ruff hooks run sequentially so that formatting happens before Black and before mypy executes.
- Black runs after Ruff to catch any drift (for example if Ruff is upgraded and emits slightly different formatting).
- Mypy is run in the same pre-commit pass and stops a commit if type checking fails. The configuration in `mypy.ini` enables strict options and whitelists third-party modules that do not ship type stubs.

Because these run on every commit, local commands like `tools/update_docs.sh` maintain code style and type safety as part of their workflow (the script itself calls tooling that reruns Ruff/Black/Mypy when you later commit).

### Style configuration highlights

- Line length is 100 in both Ruff and Black; docformatter also wraps at 100.
- Ruff's formatter is authoritative; Black acts as a safety net and should be a no-op.
- Mypy targets Python 3.13 with strict options; `mypy_path = src` for imports.
- Ruff formatting uses double quotes and space indentation.

---

## Workflows & CI

- `tools/update_docs.sh` is the recommended local command for a full rebuild.
- If CI is configured, it should run Ruff, Black, pytest, the documentation pipeline (`tools/update_docs.sh`), and assert a clean working tree.
- `make docstrings` is idempotent; it will rewrite docstrings, nav maps, and docformatter output each run.

---

## Error Handling & Troubleshooting

### Understanding Exit Codes

The `update_docs.sh` script uses exit codes to communicate results:

| Exit Code | Meaning | Action |
|-----------|---------|--------|
| 0 | Success | All documentation regenerated, safe to proceed |
| 1 | Failure | A required prerequisite or stage failed, see error message |

**Non-zero exit codes**

When the script exits with code 1, check stderr for the error message:

```bash
tools/update_docs.sh 2>&1 | tail -20
```

### Common Failure Scenarios & Recovery

#### Scenario 1: Missing Virtual Environment

**Error message:**
```
error: missing virtual environment at .venv/; run 'make bootstrap' first.
```

**Cause:**
- `.venv/bin/python` does not exist or is not executable
- Virtual environment was never created or was deleted

**Recovery:**
```bash
make bootstrap
```

**Details:**
- Creates `.venv/` directory
- Installs pip and wheel
- Installs package with `[dev,docs]` extras
- Sets up pre-commit hooks
- Takes 2-5 minutes

#### Scenario 2: Missing Documentation Tools

**Error message:**
```
error: missing 'doq'; install docs extras via 'pip install -e ".[docs]"' (inside .venv).
```

**Cause:**
- Documentation tool not installed in virtualenv
- Dependencies incomplete or partial installation

**Recovery:**
```bash
source .venv/bin/activate
pip install -e ".[docs]"
```

**Details:**
- Installs all tools in one command
- Completes in 30-60 seconds
- Checks for doq, docformatter, pydocstyle, interrogate

#### Scenario 3: Docstring Coverage Below Threshold

**Error message:**
```
FAILED: Docstring coverage below threshold (90%)
Current coverage: 87.5%
```

**Cause:**
- New code added without docstrings
- Docstring removed from existing code
- Coverage enforcement failure

**Recovery:**
```bash
# Check which symbols are missing docstrings
interrogate -i src

# Add docstrings to flagged symbols, then retry
make docstrings
```

**Details:**
- Coverage must be ≥ 90% in `src/` directory
- Tools and test directories not checked
- Re-run `make docstrings` after adding docstrings

#### Scenario 4: PEP 257 Docstring Violations

**Error message:**
```
src/some_module.py:15:1: D100 Missing docstring in public module
src/some_module.py:20:1: D102 Missing docstring in public method
```

**Cause:**
- Docstrings don't conform to PEP 257 standard
- Missing docstrings in public symbols
- Docstring format issues

**Recovery:**
```bash
# Let docformatter attempt automatic fixes
make docformatter

# If still failing, add missing docstrings manually
make docstrings
```

**Details:**
- `pydocstyle` enforces NumPy convention
- Most issues auto-fixable by `docformatter`
- Configured in `pyproject.toml` with specific ignore list

#### Scenario 5: NavMap Validation Failures

**Error message:**
```
ERROR: src/module.py:10: Exports mismatch
  __all__ = ["foo", "bar"]
  __navmap__["exports"] = ["foo", "baz"]  # baz not in __all__
```

**Cause:**
- `__navmap__["exports"]` doesn't match `__all__`
- Section ID not `"public-api"` for first section
- Missing `[nav:anchor]` comments
- Section ID not kebab-case

**Recovery:**
```bash
# Fix the specific issue in source file
# Then validate again
python tools/navmap/check_navmap.py
```

**Common fixes:**
- Sync `__navmap__["exports"]` with `__all__`
- Rename first section ID to `"public-api"`
- Add missing `# [nav:anchor SymbolName]` comments
- Use kebab-case for section IDs (lowercase, hyphens only)

**Details:**
- Navmap validation is strict
- Prevents broken navigation metadata
- Enforces consistency across codebase

#### Scenario 6: Sphinx Build Failures

**Error message:**
```
WARNING: Sphinx warnings treated as errors by SPHINXOPTS="-W"
build stopped due to warnings...
```

**Common causes:**
- Broken reST/Markdown syntax in docstrings
- Unresolved cross-references
- Missing modules referenced in documentation
- Malformed code blocks

**Recovery:**
```bash
# Run Sphinx without warnings-as-errors to see full output
SPHINXOPTS="" make html

# Fix the reported issues in source docstrings
# Then retry with warnings-as-errors
make html
```

**Details:**
- Check `docs/_build/html/` for generated output
- Read full error messages from build output
- Most issues are docstring formatting problems

#### Scenario 7: Permission Issues

**Error message:**
```
Permission denied: /docs/_build/html/
```

**Cause:**
- Previous build created files with restricted permissions
- Directory ownership issues
- File system permissions problem

**Recovery:**
```bash
# Remove and retry
rm -rf docs/_build site
tools/update_docs.sh
```

**Details:**
- Full removal followed by rebuild usually fixes this
- Check file ownership if issue persists
- May require `chmod` if mixing user/root permissions

### Stage Dependency Chain

The stages in `update_docs.sh` have strict dependencies and must execute in order:

```
Stage 1: Docstrings (doq → auto_docstrings → format → lint → coverage)
    ↓
Stage 2: READMEs (gen_readmes + doctoc)
    ↓
Stage 3: NavMap Update (validate no legacy sections) ⚠️ BLOCKING
    ↓
Stage 4: NavMap Build (extract metadata)
    ↓
Stage 5: NavMap Check (validate metadata) ⚠️ BLOCKING
    ↓
Stage 6: Example Tests (pytest --xdoctest) ⚠️ BLOCKING
    ↓
Stage 7: Test Map Build (build_test_map.py)
    ↓
Stage 8: Observability Scan (scan_observability.py)
    ↓
Stage 9: Schema Export (export_schemas.py)
    ↓
Stage 10: Graph Build (build_graphs.py)
    ↓
Stage 11: Sphinx HTML (build HTML site)
    ↓
Stage 12: Sphinx JSON (build JSON corpus)
    ↓
Stage 13: Symbol Index (build flat symbol array)
    ↓
Stage 14: MkDocs (optional, non-blocking)
    ↓
✓ Success
```

**Key dependencies:**

- **Stages 1-6 are sequential and critical:**
  - If any fails, entire build stops
  - Docstrings → READMEs → NavMap validation → Example tests chain is strict
  - NavMap validation (Stage 5) and example tests (Stage 6) act as gate-keepers

- **Stages 7-10 are sequential but non-critical:**
  - Generate additional documentation artifacts
  - Build test maps, observability docs, schemas, and graphs
  - Failures may be logged but don't halt the pipeline

- **Stages 11-13 depend on Stages 1-10:**
  - Sphinx builds use docstrings and metadata
  - Symbol index uses complete symbol tree
  - Cannot proceed if earlier stages failed

- **Stage 14 is optional:**
  - MkDocs build can fail without stopping
  - Skipped if not installed
  - Non-blocking for overall pipeline success

### What Happens on Failure

When any stage fails:

1. Error message is printed to stderr with:
   - Command that failed
   - Error details
   - Suggested recovery steps (if applicable)

2. Script exits immediately with code 1 (due to `set -euo pipefail`)

3. Subsequent stages do not execute

4. Documentation artifacts are in an inconsistent state

5. You must fix the error and re-run from the beginning

### Running Individual Stages Manually

For debugging or targeted updates, you can run stages independently:

```bash
# Docstring generation only
make docstrings

# READMEs only
make readmes

# NavMap building
python tools/navmap/build_navmap.py

# NavMap validation
python tools/navmap/check_navmap.py

# Sphinx HTML
make html

# Sphinx JSON
make json

# Symbol index
make symbols

# MkDocs
mkdocs build --config-file mkdocs.yml
```

**Important:** Running stages out of order may produce incomplete or incorrect results. Always run `tools/update_docs.sh` for a complete, consistent rebuild.

---

## Common Workflows

### Workflow 1: Add New Python Module

When adding a new module to the codebase:

```bash
# 1. Create module with docstrings
cat > src/mypackage/newmodule.py << 'EOF'
"""Describe the new module here."""

def my_function():
    """Describe the function."""
    pass

__all__ = ["my_function"]
EOF

# 2. Regenerate all documentation
tools/update_docs.sh

# 3. Verify in generated docs
open docs/_build/html/autoapi/mypackage/newmodule/index.html
```

**What happens:**
- `make docstrings` validates coverage (will fail if module docstring missing)
- `make readmes` includes new module in `src/mypackage/README.md`
- `make html` generates new module page
- `make symbols` indexes all new symbols

### Workflow 2: Update Function Signature

When modifying a function's parameters or return type:

```bash
# 1. Update function code
# 2. Update docstring manually (or let doq regenerate)
# 3. Validate documentation
tools/update_docs.sh
```

**What happens:**
- Docstring is validated against new signature
- README links update to new line numbers
- Symbol index updates with new signature metadata
- NavMap sections refresh

### Workflow 3: Add Navigation Structure

When organizing a module with sections:

```bash
# 1. Add __navmap__ metadata to module
cat >> src/mypackage/core.py << 'EOF'

__navmap__ = {
    "exports": __all__,
    "synopsis": "Core functionality for mypackage",
    "sections": [
        {"id": "public-api", "symbols": ["func1", "func2"]},
        {"id": "advanced", "symbols": ["Class1"]},
    ],
}

# [nav:section public-api]

# [nav:anchor func1]
def func1():
    ...

# 2. Validate navigation
python tools/navmap/check_navmap.py

# 3. Full rebuild
tools/update_docs.sh
```

**What happens:**
- NavMap stores section metadata in `site/_build/navmap/navmap.json`
- HTML docs structured with section navigation
- Symbol index includes section information

### Workflow 4: Fix Docstring Style Issues

When docstrings violate PEP 257:

```bash
# 1. Identify issues
pydocstyle src/

# 2. Auto-fix what's possible
docformatter --wrap-summaries=100 --wrap-descriptions=100 -r -i src/

# 3. Manually fix remaining issues
# (editor, specific formatting problems)

# 4. Validate
tools/update_docs.sh
```

### Workflow 5: Regenerate Only READMEs

When only package README.md files need updating:

```bash
# Fast: just regenerate READMEs
make readmes

# Or with doctoc TOC updates (if installed)
make readmes && doctoc src/mypackage/
```

**Use case:**
- Docstrings already up to date
- Only need to refresh deep links
- Faster than full pipeline

### Workflow 6: Validate Documentation Quality

Before committing:

```bash
# Full validation
tools/update_docs.sh

# Then check what changed
git diff docs/ src/

# Stage changes
git add -A

# Commit
git commit -m "docs: regenerate documentation"
```

---

## Performance Characteristics

### Typical Execution Times

**Full rebuild** (`tools/update_docs.sh` from scratch):
- Small codebase (< 50 modules): 10-20 seconds
- Medium codebase (50-200 modules): 30-90 seconds
- Large codebase (> 200 modules): 2-5 minutes

**Individual stages:**
- `make docstrings`: 3-15 seconds (slowest part)
- `make readmes`: 1-3 seconds
- `navmap build`: 1-2 seconds
- `navmap check`: < 1 second
- `make html`: 5-20 seconds
- `make json`: 5-20 seconds
- `make symbols`: 2-5 seconds
- `mkdocs build`: 5-15 seconds

### Optimization Tips

**For large codebases:**
- Run `make readmes` independently if only links need updating
- Run individual Sphinx builders (`make html` or `make json`) if only one format needed
- Use `SPHINXOPTS=""` to skip warnings-as-errors check during development
- Cache pre-commit checks by not running on every commit

**For development workflow:**
- Use `make watch` for live editing during documentation updates
- Run `make lint` before `make html` to catch issues early
- Pre-generate docstrings early to avoid late-stage failures

---

## Integration Points

### Pre-Commit Hooks

The documentation system integrates tightly with pre-commit:

```bash
pre-commit run --all-files
```

**Hooks that run:**
1. Ruff (imports, lint, format)
2. Black
3. Mypy
4. docformatter (custom wrapper)
5. **navmap-build** (regenerates index)
6. **navmap-check** (validates metadata)
7. pydocstyle
8. interrogate

**Critical:** Stages 5-7 enforce documentation consistency on every commit.

### CI/CD Integration

For continuous integration:

```bash
# Full documentation rebuild
tools/update_docs.sh

# Check that nothing changed (docs up to date)
git diff --exit-code docs/ src/
```

**CI workflow:**
1. Run `tools/update_docs.sh`
2. Check for uncommitted changes
3. Fail if docs are out of sync
4. Forces developers to regenerate before merging

### Local Development

Recommended local workflow:

```bash
# After pulling/making changes
tools/update_docs.sh

# Review changes
git diff

# Commit all changes together
git add -A
git commit -m "docs: regenerate documentation"
```

---

## Architecture & Design Decisions

### Why Multiple Documentation Formats?

**Sphinx (HTML + JSON):**
- Powerful, extensible, industry-standard
- AutoAPI provides static analysis without imports
- Rich extension ecosystem
- Strong cross-reference support
- Machine-readable JSON output for agents

**MkDocs:**
- Simpler, Markdown-first
- Better for narrative documentation
- Material theme is modern and polished
- Good for user guides and how-tos
- Optional (not blocking if unavailable)

**Having both:**
- Accommodates different audiences (developers vs users)
- Provides flexibility (which docs to serve where)
- Different strengths (API reference vs narrative)

### Why NavMaps?

Traditional approach (auto-detection only):
```
Problems:
- No semantic structure beyond module hierarchy
- Hard to know what symbols are "important"
- No cross-module relationships
- IDE integration difficult
```

NavMap approach (structured metadata):
```
Advantages:
- Explicit semantic organization
- Clear public API surface
- Supports sections and anchors
- Enables IDE navigation
- Machine-readable for agents
- Extensible metadata system
```

### Why Two-Stage Docstring Generation?

**Stage 1: doq (template-based)**
- Fast, predictable output
- Works for standard function signatures
- Generates parameter/return sections
- NumPy-style consistency

**Stage 2: auto_docstrings (AST-based fallback)**
- Catches edge cases doq misses
- Module-level docstrings
- Custom logic for special cases
- Ensures 100% coverage

**Why both?**
- `doq` alone: ~85% coverage
- `doq` + `auto_docstrings`: 100% coverage
- Two-pass ensures comprehensive coverage
- Fallback handles special cases

### Why NavMap Validation?

Strict validation prevents:
- Broken navigation metadata (stale references)
- Inconsistent export declarations
- Invalid section structures
- Missing navigation anchors

By making validation strict and preventing commits with errors, we ensure:
- Navmap index always accurate
- Navigation features work reliably
- IDE integration doesn't break
- Documentation stays consistent

---

## Reference Materials

### Complete Stage Execution Reference

This table shows all stages, their dependencies, and what they consume/produce:

| # | Stage | Command | Depends On | Consumes | Produces | Critical? |
|---|-------|---------|-----------|----------|----------|-----------|
| 1 | Docstrings | `make docstrings` | .venv, tools | Source code | Updated docstrings | YES |
| 2 | READMEs | `make readmes` | Stage 1 | Docstrings | `README.md` files | NO |
| 3 | NavMap Update | `update_navmaps.py` | Stage 2 | Source code | Validation result | YES |
| 4 | NavMap Build | `build_navmap.py` | Stage 3 | Source code | `navmap.json` | YES |
| 5 | NavMap Check | `check_navmap.py` | Stage 4 | `navmap.json` | Validation result | YES |
| 6 | Example Tests | `pytest --xdoctest` | Stage 5 | Example scripts | Test results | YES |
| 7 | Test Map Build | `build_test_map.py` | Stage 6 | Test files | Test coverage map | NO |
| 8 | Observability Scan | `scan_observability.py` | Stage 7 | Source code | Observability docs | NO |
| 9 | Schema Export | `export_schemas.py` | Stage 8 | Source code | Schema docs | NO |
| 10 | Graph Build | `build_graphs.py` | Stage 9 | Source code | Dependency graphs | NO |
| 11 | Sphinx HTML | `make html` | Stage 10 | Docstrings, Markdown | `docs/_build/html/` | NO |
| 12 | Sphinx JSON | `make json` | Stage 10 | Docstrings, Markdown | `docs/_build/json/` | NO |
| 13 | Symbol Index | `make symbols` | Stage 10 | Docstrings | `symbols.json` | NO |
| 14 | MkDocs | `mkdocs build` | Stage 10 | Docstrings, Markdown | `site/` | NO |

**Legend:**
- **YES:** Failure halts pipeline
- **NO:** Failure continues (non-blocking)

### Environment Variables Reference

Complete list of all environment variables that affect documentation generation:

| Variable | Default | Set By | Purpose |
|----------|---------|--------|---------|
| `PYTHONPATH` | (preserved or `src`) | `update_docs.sh` | Python import resolution |
| `SPHINXOPTS` | (empty) | `update_docs.sh` | Sphinx builder options, set to `-W` for warnings-as-errors |
| `DOCS_LINK_MODE` | `editor` | User/CI | Link format: `editor` or `github` |
| `DOCS_EDITOR` | `vscode` | User/CI | Editor for deep links: `vscode` or `pycharm` |
| `DOCS_GITHUB_ORG` | (auto-detect) | User/CI | GitHub organization name |
| `DOCS_GITHUB_REPO` | (auto-detect) | User/CI | GitHub repository name |
| `DOCS_GITHUB_SHA` | (auto-detect) | User/CI | Git commit SHA for permalinks |
| `DOCS_PKG` | (auto-detect) | User/CI | Override package detection |
| `SPHINX_THEME` | `pydata_sphinx_theme` | User | Sphinx HTML theme name |
| `SPHINX_AUTOBUILD_PORT` | `8000` | User | Port for `make watch` live server |
| `PROJECT_NAME` | `kgfoundry` | User | Project name in docs |
| `PROJECT_AUTHOR` | `kgfoundry Maintainers` | User | Author name in docs |

### Files Generated by Each Stage

| Stage | Output Files | Location | Size | Gitignored? |
|-------|-------------|----------|------|------------|
| Docstrings | Updated .py files | `src/`, `tools/`, `docs/_scripts/` | Variable | No |
| READMEs | `README.md` | `src/*/` | 5-50 KB each | No |
| NavMap Build | `navmap.json` | `site/_build/navmap/` | 10-100 KB | No (generated) |
| NavMap Check | Validation report | stdout | N/A | N/A |
| Sphinx HTML | HTML pages + assets | `docs/_build/html/` | 5-50 MB | No (generated) |
| Sphinx JSON | `.fjson` files | `docs/_build/json/` | 1-10 MB | No (generated) |
| Symbol Index | `symbols.json` | `docs/_build/` | 100 KB - 1 MB | No (generated) |
| MkDocs | HTML site | `site/` | 5-50 MB | No (generated) |

---

## The Complete Documentation Pipeline

The complete documentation generation workflow is orchestrated by `tools/update_docs.sh`, which executes the following stages in sequence:

### Stage 0: Clean Slate

```bash
rm -rf docs/_build/html docs/_build/json site
```

Removes all previously generated documentation artifacts to ensure a clean rebuild:
- `docs/_build/html`: Sphinx HTML output
- `docs/_build/json`: Sphinx JSON corpus (machine-readable API docs)
- `site`: MkDocs build output

### Stage 1: Docstring Generation (`make docstrings`)

**Purpose:** Generate, update, and validate docstrings across the codebase.

**Makefile target:** `docstrings`

**Execution sequence:**

1. **`python tools/generate_docstrings.py`**
   - Runs `doq` (docstring skeleton generator) with NumPy-style templates from `tools/doq_templates/numpy/`
   - Processes directories: `src/`, `tools/`, `docs/_scripts/`
   - Generates complete function signatures with Parameters/Returns sections
   - Then runs `tools/auto_docstrings.py` as a fallback for remaining items
   - The fallback uses AST parsing to create docstrings for modules, classes, and functions
   - Logs changes to `site/_build/docstrings/fallback.log`

2. **`python tools/update_navmaps.py`**
   - Uses Griffe to statically analyze each module
   - Collects public classes and functions (non-underscore-prefixed names)
   - Rewrites module docstrings to include a `NavMap:` section
   - Each NavMap entry shows: `- SymbolName: truncated summary…`
   - Summaries are truncated to ~60 chars to fit within 100-character line limits
   - Only updates modules that already have docstrings (leaves others untouched)
   - Idempotent: can be run repeatedly without adverse effects

3. **`docformatter --wrap-summaries=100 --wrap-descriptions=100 -r -i <dirs>`**
   - Formats docstrings to conform to PEP 257 standards
   - Wraps summary and description lines to 100 characters
   - Recursively processes `src/`, `tools/`, `docs/_scripts/`
   - In-place modification (`-i` flag)
   - Continues on errors (`|| true`)

4. **`pydocstyle <dirs>`**
   - Lints docstrings against PEP 257 conventions
   - Uses NumPy convention (configured in `pyproject.toml`)
   - Enforces consistency in docstring format
   - Fails if violations are found

5. **`interrogate -i src --fail-under 90`**
   - Enforces 90% docstring coverage on the `src/` directory
   - Interactive mode (`-i`) shows coverage details
   - Fails the build if coverage drops below 90%

**What gets generated:**
- Complete NumPy-style docstrings for functions, classes, and modules
- Module-level NavMap sections listing public API entry points
- Properly formatted and wrapped docstring text
- Validated compliance with PEP 257

### Stage 2: README Generation (`make readmes`)

**Purpose:** Generate package-level README.md files with API listings and deep links.

**Makefile target:** `readmes`

**Execution sequence:**

1. **`python tools/gen_readmes.py`**
   - Uses Griffe to walk each package and collect public symbols
   - Detects packages via `tools/detect_pkg.py` (prefers `kgfoundry` packages in `src/`)
   - Generates `README.md` in each package directory with:
     - Package title (e.g., `# kgfoundry_common`)
     - Doctoc TOC placeholder (for optional TOC generation)
     - `## API` section with nested bullets for modules/classes/functions
     - Each entry includes:
       - Full qualified name in bold monospace (e.g., `**kgfoundry_common.config.load_config**`)
       - First-sentence docstring summary
       - `[open]` link: relative path with line/column (e.g., `./config.py:15:1`)
       - `[view]` link: GitHub permalink with SHA and line range
   - Link mode is controlled by `DOCS_LINK_MODE` environment variable:
     - `DOCS_LINK_MODE=editor` (default): Creates editor deep links (vscode://, pycharm://)
     - `DOCS_LINK_MODE=github`: Creates GitHub permalinks using current commit SHA
   - GitHub links use `DOCS_GITHUB_ORG` and `DOCS_GITHUB_REPO` env vars or auto-detect from git remote

2. **`doctoc src/<pkg>` (optional)**
   - If `doctoc` CLI tool is installed, updates README TOCs
   - Populates the `<!-- START doctoc -->` ... `<!-- END doctoc -->` sections
   - Gracefully skips if `doctoc` is not available

**What gets generated:**
- `README.md` files in each package directory under `src/`
- Hierarchical API listings with summaries and links
- Editor-friendly local links and/or commit-stable GitHub permalinks

### Stage 3: NavMap Index Build (`python tools/navmap/build_navmap.py`)

**Purpose:** Build a machine-readable navigation map index for AI agents and tooling.

**Tool:** `tools/navmap/build_navmap.py`

**What it does:**
- Walks the `src/` directory tree, parsing every Python file with AST
- Extracts:
  - `__all__` declarations (public exports)
  - `__navmap__` metadata dictionaries (structured navigation hints)
  - Special comments: `# [nav:anchor SymbolName]` and `# [nav:section section-id]`
- Builds a comprehensive index mapping each module to:
  - Repository-relative file path
  - Exported symbols (from `__all__` or `__navmap__["exports"]`)
  - Section definitions and line numbers
  - Anchor definitions (named jump points in code)
  - VSCode deep links to source files
  - Metadata: synopsis, tags, see_also, deps (from `__navmap__`)
- Outputs `site/_build/navmap/navmap.json` with:
  - Current git commit SHA for provenance
  - Per-module structured metadata
  - Supports advanced navigation, documentation linking, and agent-friendly code exploration

**NavMap metadata format:**

Modules can define a `__navmap__` dictionary with structured navigation hints:

```python
__all__ = ["func1", "func2", "MyClass"]

__navmap__ = {
    "exports": __all__,  # Can override or reference __all__
    "synopsis": "Brief module description",
    "sections": [
        {"id": "public-api", "symbols": ["func1", "func2"]},
        {"id": "advanced", "symbols": ["MyClass"]},
    ],
    "symbols": {
        "func1": {"category": "core", "stability": "stable"},
        "MyClass": {"category": "advanced", "stability": "beta"},
    },
    "tags": ["core", "networking"],
    "see_also": ["other.module"],
    "deps": ["required.module"],
}
```

Anchors and sections can be marked inline:

```python
# [nav:section public-api]

# [nav:anchor func1]
def func1():
    ...
```

**What gets generated:**
- `site/_build/navmap/navmap.json`: Complete module index with metadata
- Commit SHA for version tracking
- Machine-readable navigation structure for agents and IDE plugins

### Stage 4: NavMap Validation (`python tools/navmap/check_navmap.py`)

**Purpose:** Validate navmap metadata and ensure consistency.

**Tool:** `tools/navmap/check_navmap.py`

**What it validates:**
- `__navmap__["exports"]` matches `__all__` declarations
- First navmap section has id `"public-api"` (required convention)
- Section IDs are valid kebab-case slugs (lowercase, hyphens, alphanumeric)
- Symbol names are valid Python identifiers
- All symbols referenced in sections have corresponding `[nav:anchor SymbolName]` comments
- Returns exit code 0 on success, 1 if validation errors are found

**What happens:**
- Scans all Python files in `src/`
- Collects and reports validation errors
- Prints `navmap check: OK` on success or lists errors with file paths
- Prevents broken navigation metadata from being committed (via pre-commit hook)

### Stage 5: Sphinx HTML Build (`make html`)

**Purpose:** Generate the full HTML documentation website.

**Makefile target:** `html`

**Command:** `python -m sphinx -b html docs docs/_build/html`

**What it does:**
- Reads configuration from `docs/conf.py`
- Auto-detects primary package using `tools/detect_pkg.py`
- Scans source code using AutoAPI (static analysis, no imports)
- Parses Markdown files with MyST-Parser
- Generates per-symbol documentation pages with:
  - API reference auto-generated from source code
  - Deep links to source code via `linkcode` extension
    - Editor mode: `vscode://file/<abs-path>:<line>:<col>`
    - GitHub mode: `https://github.com/<org>/<repo>/blob/<sha>/<rel-path>#Lstart-Lend`
  - Inheritance diagrams via `sphinx.ext.inheritance_diagram`
  - Source code listings with line numbers via `sphinx.ext.viewcode`
  - Mermaid diagram support via `sphinxcontrib.mermaid`
- Theme: `pydata_sphinx_theme` (overridable via `SPHINX_THEME` env var)
- Extensions enabled:
  - `myst_parser`: Markdown support
  - `sphinx.ext.napoleon`: NumPy docstring parsing
  - `sphinx.ext.autosummary`: Summary tables
  - `sphinx.ext.intersphinx`: Cross-project links (Python stdlib)
  - `sphinx.ext.viewcode`: Source code pages
  - `sphinx.ext.linkcode`: Deep links to source
  - `sphinx.ext.graphviz`: Graphviz diagrams
  - `sphinx.ext.inheritance_diagram`: Class inheritance trees
  - `autoapi.extension`: Static API extraction
  - `sphinxcontrib.mermaid`: Mermaid diagrams
- Uses Griffe loader for symbol lookup without importing code
- Produces navigable HTML site with search functionality

**Environment variables:**
- `SPHINXOPTS`: Sphinx options (set to `-W` in update_docs.sh to treat warnings as errors)
- `DOCS_LINK_MODE`: `editor` or `github` (controls linkcode behavior)
- `DOCS_EDITOR`: `vscode` or `pycharm` (for editor links)
- `DOCS_GITHUB_ORG` / `DOCS_GITHUB_REPO`: GitHub org/repo for permalinks
- `SPHINX_THEME`: Override default theme

**What gets generated:**
- Complete HTML documentation site in `docs/_build/html/`
- API reference pages for all packages, modules, classes, and functions
- Navigation tree and search index
- Source code pages with syntax highlighting
- Cross-referenced documentation with hyperlinks

### Stage 6: Sphinx JSON Build (`make json`)

**Purpose:** Generate machine-readable JSON corpus of API documentation.

**Makefile target:** `json`

**Command:** `python -m sphinx -b json docs docs/_build/json`

**What it does:**
- Cleans previous JSON build (`rm -rf docs/_build/json`)
- Runs Sphinx with JSON builder instead of HTML
- Produces structured JSON files mirroring the HTML structure
- Each .fjson file contains:
  - Page title, body text, and metadata
  - Rendered documentation content in structured format
  - Cross-reference links and relationships
- Special JSON serialization handling for:
  - LRU cache wrappers (serialized as repr strings)
  - Complex Sphinx objects
- Same extensions and configuration as HTML build

**Use cases:**
- AI agent consumption of API documentation
- Automated documentation analysis
- Search indexing and content extraction
- Documentation testing and validation

**What gets generated:**
- `docs/_build/json/`: Complete JSON corpus
- One .fjson file per documentation page
- `globalcontext.json`: Site-wide metadata and configuration
- Machine-readable API reference data

### Stage 7: Symbol Index Build (`make symbols`)

**Purpose:** Generate a flat symbol index for fast agent lookup.

**Makefile target:** `symbols`

**Command:** `python docs/_scripts/build_symbol_index.py`

**What it does:**
- Uses Griffe to statically load and analyze all packages
- Walks the complete symbol tree (packages, modules, classes, functions, etc.)
- Extracts for each symbol:
  - Fully qualified name (e.g., `kgfoundry_common.config.load_config`)
  - Kind: module, class, function, attribute, etc.
  - File path (relative to repo root)
  - Line number range (start, end)
  - First paragraph of docstring (short summary)
- Writes `docs/_build/symbols.json` as a flat JSON array
- Each entry is a dict with keys: `path`, `kind`, `file`, `lineno`, `endlineno`, `doc`
- Provides fast symbol lookup without parsing multiple nested JSON files

**What gets generated:**
- `docs/_build/symbols.json`: Flat array of all symbols
- One entry per symbol with location and summary
- Fast-access format optimized for agent queries

### Stage 8: MkDocs Build (Optional)

**Purpose:** Generate an alternative Markdown-first documentation site.

**Condition:** Only runs if `mkdocs` is installed in the virtual environment

**Command:** `mkdocs build --config-file mkdocs.yml`

**What it does:**
- Reads configuration from `mkdocs.yml`
- Uses Material for MkDocs theme
- Plugins enabled:
  - `search`: Full-text search
  - `gen-files`: Generates API pages from source via `docs/_scripts/mkdocs_gen_api.py`
  - `mkdocstrings[python]`: Python API documentation extraction
  - `literate-nav`: Markdown-based navigation
  - `section-index`: Index pages for sections
- Renders Markdown files from `docs/` directory
- Generates API reference pages dynamically
- Uses Griffe via mkdocstrings for symbol extraction
- Produces a standalone static site

**What gets generated:**
- `site/`: Complete MkDocs HTML site
- Alternative navigation and presentation of same content
- Search functionality
- Material Design-themed interface

**Why both Sphinx and MkDocs?**
- Sphinx: More powerful, extensive ecosystem, better for API docs
- MkDocs: Cleaner, simpler, better for prose documentation
- Having both provides flexibility for different audiences

---

## Key Configuration Files

| File | Purpose |
| ---- | ------- |
| [`docs/conf.py`](docs/conf.py) | Sphinx configuration. Performs static parsing with AutoAPI, adds editor/GitHub deep links, builds HTML/JSON outputs, configures extensions, and defines symbol lookup via Griffe. |
| [`tools/update_docs.sh`](tools/update_docs.sh) | **Master orchestration script.** One-touch wrapper that runs the complete documentation pipeline: docstring generation, nav-map build/check, README generation, and Sphinx/MkDocs builds. |
| [`tools/generate_docstrings.py`](tools/generate_docstrings.py) | Docstring skeleton generator. Runs `doq` with NumPy templates on `src/`, `tools/`, and `docs/_scripts/`, then runs `auto_docstrings.py` fallback for remaining items. |
| [`tools/auto_docstrings.py`](tools/auto_docstrings.py) | AST-based fallback docstring generator. Creates NumPy-style docstrings for modules, classes, and functions that don't already have them or have TODO placeholders. |
| [`tools/update_navmaps.py`](tools/update_navmaps.py) | Refreshes module-level docstrings with a `NavMap:` section summarizing public API entry points (classes/functions with truncated summaries). |
| [`tools/gen_readmes.py`](tools/gen_readmes.py) | Generates package-level `README.md` files that list public modules/classes/functions with summaries, editor deep links (`[open]`), and GitHub permalinks (`[view]`). |
| [`tools/navmap/build_navmap.py`](tools/navmap/build_navmap.py) | Builds machine-readable navigation map index (`site/_build/navmap/navmap.json`). Extracts `__all__`, `__navmap__`, anchors, and sections from all Python modules. |
| [`tools/navmap/check_navmap.py`](tools/navmap/check_navmap.py) | Validates navmap metadata: checks exports consistency, section naming conventions, kebab-case IDs, and anchor presence. Returns exit code 1 on errors. |
| [`tools/detect_pkg.py`](tools/detect_pkg.py) | Detects primary/all packages for doc generation (used by Sphinx/Makefile/tools). Prefers lowercase names and `kgfoundry`-prefixed packages in `src/`. |
| [`docs/_scripts/build_symbol_index.py`](docs/_scripts/build_symbol_index.py) | Emits `docs/_build/symbols.json` flat array for agent consumption. Each entry contains fully qualified name, kind, file path, line range, and docstring summary. |
| [`Makefile`](Makefile) | Defines developer tasks: `docstrings`, `readmes`, `html`, `json`, `symbols`, `navmap-build`, `navmap-check`, `watch`, `fmt`, `lint`, `bootstrap`. |
| [`mkdocs.yml`](mkdocs.yml) | MkDocs configuration for Material theme with plugins: search, gen-files (dynamic API pages), mkdocstrings (Python docs), literate-nav, section-index. |
| [`.pre-commit-config.yaml`](.pre-commit-config.yaml) | Pre-commit hooks: Ruff (imports/lint/format), Black, Mypy, docformatter, pydocstyle, interrogate, navmap-build, navmap-check. |
| [`pyproject.toml`](pyproject.toml) | Configures Ruff (lint/format), Black, pytest, mypy, pydocstyle, and docs extras (`[project.optional-dependencies.docs]`). |
| [`mypy.ini`](mypy.ini) | Strict type-check configuration (Python 3.13, `mypy_path=src`, third-party ignores for packages lacking stubs). |
| [`tools/doq_templates/numpy/`](tools/doq_templates/numpy/) | NumPy-style docstring templates used by `doq` during docstring generation (def, class, module templates). |

---

## Detailed Tool Descriptions

### Master Orchestration: `tools/update_docs.sh`

The single entry point for complete documentation regeneration.

**Prerequisites check:**
- Verifies `.venv/` virtual environment exists
- Checks for required tools: `doq`, `docformatter`, `pydocstyle`, `interrogate`
- Warns if `mkdocs` is missing (optional dependency)

**Environment setup:**
- Sets `PYTHONPATH` to include `src/`
- Sets `SPHINXOPTS=-W` to treat Sphinx warnings as errors
- Uses `.venv/bin/python` for all Python commands

**Execution flow:**
1. Clean slate: `rm -rf docs/_build/html docs/_build/json site`
2. `make docstrings` - Generate and validate docstrings
3. `make readmes` - Generate package READMEs
4. `python tools/navmap/build_navmap.py` - Build navmap index
5. `python tools/navmap/check_navmap.py` - Validate navmap
6. `make html` - Build Sphinx HTML docs
7. `make json` - Build Sphinx JSON corpus
8. `make symbols` - Build symbol index
9. `mkdocs build` (optional) - Build MkDocs site if available

**Exit behavior:**
- Exits with error if virtual environment is missing
- Exits with error if required doc tools are missing
- Continues with warning if mkdocs is unavailable
- Each stage must complete successfully or the script fails

### Sphinx Configuration: `docs/conf.py`

Comprehensive Sphinx configuration with agent-friendly features.

**Package detection:**
- Auto-detects primary package via `tools/detect_pkg.py`
- Prefers `src/<pkg>` layout, falls back to root layout
- Supports `DOCS_PKG` environment variable to override

**AutoAPI configuration:**
- Static analysis only - never imports the code
- Scans `src/` or root directory
- Generates complete API reference tree
- Options: members, undoc-members, show-inheritance, special-members, imported-members

**Link generation (linkcode extension):**
- Uses Griffe to look up symbol locations without importing
- Caches module lookups for performance
- Two modes controlled by `DOCS_LINK_MODE`:
  - **editor** (default): `vscode://file/<path>:<line>:<col>` or `pycharm://open?file=<path>&line=<line>`
  - **github**: `https://github.com/<org>/<repo>/blob/<sha>/<path>#Lstart-Lend`
- Git SHA resolution for commit-stable permalinks
- Falls back gracefully when symbols can't be located

**Extensions enabled:**
- `myst_parser`: Markdown parsing with colon_fence, deflist, linkify
- `sphinx.ext.napoleon`: NumPy docstring parsing
- `sphinx.ext.autosummary`: Summary tables
- `sphinx.ext.intersphinx`: Cross-links to Python docs
- `sphinx.ext.viewcode`: Source code pages with line numbers
- `sphinx.ext.linkcode`: Deep links via Griffe
- `sphinx.ext.graphviz`: Diagram rendering
- `sphinx.ext.inheritance_diagram`: Class hierarchy diagrams
- `autoapi.extension`: Static API docs
- `sphinxcontrib.mermaid`: Mermaid diagram support

**JSON builder support:**
- Custom JSON encoder handles lru_cache wrappers
- Serializes complex Sphinx objects safely
- Produces machine-readable .fjson files

**Environment variables:**
- `DOCS_PKG`: Override package detection (comma-separated for multiple)
- `DOCS_LINK_MODE`: `editor` or `github`
- `DOCS_EDITOR`: `vscode` or `pycharm`
- `DOCS_GITHUB_ORG` / `DOCS_GITHUB_REPO`: GitHub coordinates
- `DOCS_GITHUB_SHA`: Override git SHA (for CI)
- `SPHINX_THEME`: Override default theme
- `PROJECT_NAME` / `PROJECT_AUTHOR`: Project metadata

### Docstring Generation: `tools/generate_docstrings.py`

Two-stage docstring generation for comprehensive coverage.

**Stage 1: doq (primary generator)**
- Command: `doq --formatter numpy -t tools/doq_templates/numpy/ -w -r -d <target>`
- Uses custom NumPy templates from `tools/doq_templates/numpy/`:
  - `def.txt`: Function/method template
  - `class.txt`: Class template
  - Other templates for different contexts
- Generates skeleton docstrings with:
  - Summary line
  - Parameters section with types from annotations
  - Returns section with return type
  - Placeholder descriptions
- Writes in-place (`-w` flag)
- Recursive (`-r` flag)
- Processes: `src/`, `tools/`, `docs/_scripts/`

**Stage 2: auto_docstrings.py (fallback)**
- AST-based parsing for remaining items
- Targets:
  - Modules without docstrings
  - Classes/functions with missing or TODO docstrings
- Uses introspection to generate:
  - Imperative-style summaries (e.g., "Return user configuration.")
  - Parameter lists with types from annotations
  - Optional parameter markers for defaults
  - Return type documentation
- Logs touched files to `site/_build/docstrings/fallback.log`

**Why two stages?**
- doq is faster and more comprehensive for standard functions
- auto_docstrings catches edge cases doq misses
- Together they ensure 100% initial coverage

### NavMap System: `tools/navmap/`

Machine-readable navigation metadata for agents and tooling.

**build_navmap.py - Index Builder:**

Scans all Python files and extracts structured metadata:

```python
# Example module with full navmap metadata
"""Module for authentication and authorization."""

__all__ = ["authenticate", "authorize", "User"]

__navmap__ = {
    "exports": __all__,
    "synopsis": "Authentication and authorization utilities",
    "sections": [
        {"id": "public-api", "symbols": ["authenticate", "authorize"]},
        {"id": "models", "symbols": ["User"]},
    ],
    "symbols": {
        "authenticate": {"category": "core", "stability": "stable"},
        "authorize": {"category": "core", "stability": "stable"},
        "User": {"category": "model", "stability": "beta"},
    },
    "tags": ["auth", "security"],
    "see_also": ["session.manager"],
    "deps": ["crypto.utils"],
}

# [nav:section public-api]

# [nav:anchor authenticate]
def authenticate(username: str, password: str) -> bool:
    """Authenticate user credentials."""
    ...

# [nav:anchor authorize]
def authorize(user: User, resource: str) -> bool:
    """Authorize user access to resource."""
    ...

# [nav:section models]

# [nav:anchor User]
class User:
    """Represent authenticated user."""
    ...
```

**Output format (`site/_build/navmap/navmap.json`):**

```json
{
  "commit": "abc123...",
  "modules": {
    "auth.core": {
      "path": "src/auth/core.py",
      "exports": ["authenticate", "authorize", "User"],
      "sections": [
        {"id": "public-api", "symbols": ["authenticate", "authorize"]},
        {"id": "models", "symbols": ["User"]}
      ],
      "section_lines": {
        "public-api": 25,
        "models": 45
      },
      "anchors": {
        "authenticate": 27,
        "authorize": 35,
        "User": 47
      },
      "links": {
        "source": "vscode://file/src/auth/core.py"
      },
      "meta": {
        "authenticate": {"category": "core", "stability": "stable"},
        "authorize": {"category": "core", "stability": "stable"},
        "User": {"category": "model", "stability": "beta"}
      },
      "tags": ["auth", "security"],
      "synopsis": "Authentication and authorization utilities",
      "see_also": ["session.manager"],
      "deps": ["crypto.utils"]
    }
  }
}
```

**check_navmap.py - Validator:**

Enforces consistency and correctness:

1. **Export consistency:**
   ```python
   # ERROR: Mismatch
   __all__ = ["foo", "bar"]
   __navmap__ = {"exports": ["foo", "baz"]}  # bar missing, baz not in __all__
   ```

2. **Section naming:**
   ```python
   # ERROR: First section must be 'public-api'
   __navmap__ = {
       "sections": [
           {"id": "advanced", ...},  # Wrong! Must be 'public-api'
       ]
   }
   
   # ERROR: Invalid section ID (not kebab-case)
   {"id": "publicAPI", ...}  # Must be 'public-api'
   ```

3. **Anchor validation:**
   ```python
   # ERROR: Missing anchor
   __navmap__ = {
       "sections": [
           {"id": "public-api", "symbols": ["foo"]}
       ]
   }
   # No '# [nav:anchor foo]' in file
   ```

4. **Symbol naming:**
   ```python
   # ERROR: Invalid Python identifier
   {"symbols": ["123invalid"]}  # Can't start with number
   ```

**Use cases:**
- Agent navigation: Jump to symbol definitions
- Documentation linking: Cross-reference resolution
- Code exploration: Structured module understanding
- IDE integration: Symbol search and navigation
- Dependency analysis: Track module relationships

### README Generation: `tools/gen_readmes.py`

Package-level documentation with hierarchical API listings.

**Detection phase:**
- Uses `tools/detect_pkg.py` to find packages
- Prefers packages in `src/` directory
- Loads each package with Griffe (no imports)

**Rendering phase:**

For each package and sub-package:

1. **Header:**
   ```markdown
   # `kgfoundry_common`
   
   <!-- START doctoc generated TOC please keep comment here to allow auto update -->
   <!-- END doctoc generated TOC please keep comment here to allow auto update -->
   
   ## API
   ```

2. **Symbol entries:**
   - Hierarchical bullets (0, 2, 4, 6... space indentation)
   - Format: `**`fully.qualified.name`**` — Summary → [open](link) | [view](link)
   - Includes modules, classes, and functions
   - Skips private symbols (underscore-prefixed)

3. **Link generation:**
   - `[open]`: Relative path with line/column (e.g., `./config.py:15:1`)
   - `[view]`: GitHub permalink or relative path depending on mode
   - Automatically resolves file paths via Griffe

**Example output:**

```markdown
# `kgfoundry_common`

## API

- **`kgfoundry_common.config`** — Configuration management utilities → [open](./config.py:1:1) | [view](https://github.com/org/repo/blob/abc123.../src/kgfoundry_common/config.py#L1-L48)
  - **`kgfoundry_common.config.load_config`** — Load configuration from YAML file → [open](./config.py:15:1) | [view](https://github.com/.../config.py#L15-L25)
  - **`kgfoundry_common.config.ConfigSchema`** — Represent application configuration → [open](./config.py:28:1) | [view](https://github.com/.../config.py#L28-L45)
```

**Post-processing:**
- Optional `doctoc` run to populate TOC
- Gracefully skips if doctoc not installed

### Symbol Index: `docs/_scripts/build_symbol_index.py`

Flat JSON array for fast agent lookup.

**Purpose:**
- Provide O(1) symbol lookup by name
- Avoid parsing nested JSON structures
- Enable fast autocomplete and symbol search

**Process:**
1. Load all packages with Griffe
2. Walk complete symbol tree recursively
3. Extract for each symbol:
   - `path`: Fully qualified name (e.g., `kgfoundry.search_api.app.create_app`)
   - `kind`: module | class | function | attribute | etc.
   - `file`: Relative path to source file (e.g., `src/search_api/app.py`)
   - `lineno`: Start line (1-based)
   - `endlineno`: End line (1-based)
   - `doc`: First paragraph of docstring

**Output format:**

```json
[
  {
    "path": "kgfoundry_common.config.load_config",
    "kind": "function",
    "file": "src/kgfoundry_common/config.py",
    "lineno": 15,
    "endlineno": 25,
    "doc": "Load configuration from YAML file."
  },
  {
    "path": "kgfoundry_common.config.ConfigSchema",
    "kind": "class",
    "file": "src/kgfoundry_common/config.py",
    "lineno": 28,
    "endlineno": 45,
    "doc": "Represent application configuration."
  }
]
```

**Use cases:**
- Agent symbol lookup: "Where is `load_config`?"
- Jump to definition: File path + line number
- Symbol search: Filter by kind, name, or docstring content
- Documentation validation: Check all symbols are documented

### Package Detection: `tools/detect_pkg.py`

Intelligent package discovery for multi-package repos.

**Detection strategy:**

1. Scan `src/` for packages (directories with `__init__.py`)
2. Scan repo root for packages (excluding `docs`, `tools`, `optional`)
3. Remove `src` itself from candidates
4. Prefer lowercase package names
5. Prefer packages containing "kgfoundry"
6. Return ordered list: preferred packages first

**Usage modes:**

```bash
# Primary package (first in preference order)
python tools/detect_pkg.py
# Output: kgfoundry_common

# All packages
python tools/detect_pkg.py --all
# Output:
# kgfoundry_common
# search_api
# kg_builder
```

**Integration:**
- Used by `docs/conf.py` to auto-detect package
- Used by `gen_readmes.py` to generate all READMEs
- Used by `build_symbol_index.py` to index all packages
- Can be overridden by `DOCS_PKG` environment variable

---

## Pre-Commit Hooks

The `.pre-commit-config.yaml` file wires in:

- **Ruff (imports)** – runs `ruff --select I --fix` to normalize import ordering before other checks.
- **Ruff (lint+fix)** – runs `ruff --fix` with the full ruleset enabled in `pyproject.toml`.
- **Ruff (format)** – applies Ruff's formatter (`ruff format`) so commits always match the project style.
- **Black** – downstream safety net; should be a no-op if Ruff formatting has already run.
- **Mypy** – static type checking with strict mode configured via `mypy.ini` (invoked as `mypy src`).
- **Docformatter** (custom wrapper) for docstring formatting; prints touched files.
- **pydocstyle** to enforce docstring conventions.
- **Interrogate** to enforce docstring coverage (90%).

Run all hooks manually with `pre-commit run --all-files`.

---

## Formatting & Type Checking Pipeline

- Ruff handles import sorting, linting (including automated fixes), and code formatting. The three Ruff hooks run sequentially so that formatting happens before Black and before mypy executes.
- Black runs after Ruff to catch any drift (for example if Ruff is upgraded and emits slightly different formatting).
- Mypy is run in the same pre-commit pass and stops a commit if type checking fails. The configuration in `mypy.ini` enables strict options and whitelists third-party modules that do not ship type stubs.

Because these run on every commit, local commands like `tools/update_docs.sh` maintain code style and type safety as part of their workflow (the script itself calls tooling that reruns Ruff/Black/Mypy when you later commit).

### Style configuration highlights

- Line length is 100 in both Ruff and Black; docformatter also wraps at 100.
- Ruff's formatter is authoritative; Black acts as a safety net and should be a no-op.
- Mypy targets Python 3.13 with strict options; `mypy_path = src` for imports.
- Ruff formatting uses double quotes and space indentation.

---

## Workflows & CI

- `tools/update_docs.sh` is the recommended local command for a full rebuild.
- If CI is configured, it should run Ruff, Black, pytest, the documentation pipeline (`tools/update_docs.sh`), and assert a clean working tree.
- `make docstrings` is idempotent; it will rewrite docstrings, nav maps, and docformatter output each run.

---

## Things to Know

1. **Link Modes**
   - `DOCS_LINK_MODE=editor` (default) creates `vscode://` or `pycharm://` URLs.
   - `DOCS_LINK_MODE=github` + `DOCS_GITHUB_ORG/REPO` produces commit-stable permalinks.
2. **Nav Maps**
   - Only modules with existing docstrings are rewritten; others are left untouched.
   - Summaries are truncated (~60 chars) in generator to fit the 100-character line limit.
3. **README Links**
   - Each entry includes both an editor link (`open`) and a relative Markdown link (`view`).
   - Run Doctoc after regeneration if you want actual TOC entries populated.
4. **Symbol Index**
   - `make symbols` (or `python docs/_scripts/build_symbol_index.py`) writes `docs/_build/symbols.json` for agent consumption.
5. **Type Checking**
   - `mypy.ini` is configured with `mypy_path = src` and ignores for third-party packages lacking stubs (duckdb, faiss, etc.).
6. **Docstring Templates**
   - Located under `tools/doq_templates/numpy/` and used by `doq` during `make docstrings` to emit NumPy-style docstrings.
7. **Environment Variables**
   - `DOCS_EDITOR` for editor scheme (`vscode`, `pycharm`).
   - `SPHINX_AUTOBUILD_PORT` to change the live server port.
   - `SPHINX_THEME` to override the HTML theme.

---

## Quick Commands

```bash
# regenerate everything (docstrings, nav maps, READMEs, Sphinx outputs)
tools/update_docs.sh

# individual tasks
make docstrings
make readmes
make html
make json
make symbols
make watch

# formatting & linting
make fmt
make lint

# direct CLI (optional)
ruff check --fix src tests
ruff format src tests
black src tests
mypy src
```

For questions or modifications, see the comments inside each tooling script.
