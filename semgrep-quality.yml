# semgrep-quality.yml — Python quality-only rules (no security)
# Designed to be *strict* but practical; tune paths/excludes as you like.

rules:
  # 1) Avoid top-level side effects: networking at import time
  - id: python.quality.no-top-level-requests
    languages: [python]
    severity: MEDIUM
    message: >-
      Avoid network I/O at import time. Move requests.* calls into functions
      (or under `if __name__ == "__main__":`) so imports are side-effect free.
      This keeps modules importable, testable, and faster to start.
    patterns:
      - pattern: requests.$FUNC($...ARGS)
      - pattern-not-inside: |
          def $FN(...):
            ...
      - pattern-not-inside: |
          if __name__ == "__main__":
            ...
      - metavariable-regex:
          metavariable: $FUNC
          regex: "^(get|post|put|delete|head|options|request)$"
    metadata:
      category: best-practice
      references:
        - https://peps.python.org/pep-0008/
        - https://requests.readthedocs.io/en/master/user/advanced/#timeouts
    paths:
      exclude: ["**/tests/**", "tests/**", "scripts/**"]

  # 2) Always set a timeout on requests
  - id: python.quality.requests-timeout-required
    languages: [python]
    severity: HIGH
    message: >-
      Always set an explicit timeout on HTTP calls (e.g., timeout=10).
      Requests has no default timeout; without one your code may hang indefinitely.
    patterns:
      - pattern: requests.$FUNC($...ARGS)
      - pattern-not: requests.$FUNC(..., timeout=$T, ...)
      - metavariable-regex:
          metavariable: $FUNC
          regex: "^(get|post|put|delete|head|options|request)$"
    metadata:
      category: correctness
      references:
        - https://requests.readthedocs.io/en/master/user/advanced/#timeouts

  # 3) Use a context manager for files
  - id: python.quality.with-open-required
    languages: [python]
    severity: MEDIUM
    message: >-
      Use a context manager when opening files: `with open(path, ...) as f: ...`
      to ensure the file is closed reliably.
    patterns:
      - pattern: open($FILE, $...ARGS)
      - pattern-not-inside: |
          with open($FILE, $...ARGS) as $F:
            ...
    metadata:
      category: best-practice
      references:
        - https://docs.python.org/3/library/contextlib.html
        - https://docs.python.org/3/tutorial/inputoutput.html#reading-and-writing-files

  # 4) Specify encoding when opening text files
  - id: python.quality.open-explicit-encoding
    languages: [python]
    severity: MEDIUM
    message: >-
      Specify an explicit text encoding when using open(...).
      Prefer `encoding="utf-8"` for portability.
    patterns:
      - pattern: open($FILE)
    metadata:
      category: correctness
      references:
        - https://peps.python.org/pep-0597/
        - https://docs.python.org/3/tutorial/inputoutput.html
    # Optional: a simple autofix for the bare `open(path)` case.
    fix: open($FILE, encoding="utf-8")

  # 5) Prefer pathlib over os.path for path work
  - id: python.quality.prefer-pathlib
    languages: [python]
    severity: LOW
    message: >-
      Prefer pathlib for path handling (e.g., Path(base) / name) over os.path.* for clarity and portability.
    patterns:
      - pattern-either:
          - pattern: os.path.join($A, $B, ...)
          - pattern: os.path.exists($X)
          - pattern: os.path.isdir($X)
          - pattern: os.path.isfile($X)
    metadata:
      category: maintainability
      references:
        - https://docs.python.org/3/library/pathlib.html
        - https://realpython.com/python-pathlib/

  # 6) No print() in library code (allow in __main__ and tests)
  - id: python.quality.no-print-in-lib
    languages: [python]
    severity: MEDIUM
    message: >-
      Avoid print() in library code; use logging (e.g., logger = logging.getLogger(__name__); logger.info(...)).
      `print()` is acceptable under `if __name__ == "__main__":` or in tests/scripts.
    patterns:
      - pattern: print($...ARGS)
      - pattern-not-inside: |
          if __name__ == "__main__":
            ...
    metadata:
      category: best-practice
      references:
        - https://docs.python.org/3/howto/logging.html
    paths:
      exclude: ["**/tests/**", "tests/**", "scripts/**"]

  # 7) Don’t terminate libraries with sys.exit()
  - id: python.quality.no-sys-exit-in-lib
    languages: [python]
    severity: HIGH
    message: >-
      Avoid sys.exit() in importable modules. Raise an exception instead.
      Reserve process termination for CLI entry points (under __main__).
    patterns:
      - pattern: sys.exit($X)
      - pattern-not-inside: |
          if __name__ == "__main__":
            ...
    metadata:
      category: maintainability
      references:
        - https://docs.python.org/3/library/sys.html#sys.exit
        - https://docs.python.org/3/library/exceptions.html#SystemExit
    paths:
      exclude: ["**/tests/**", "tests/**", "scripts/**"]

  # 8) Prefer enumerate over range(len(...)) when iterating a sequence
  - id: python.quality.prefer-enumerate
    languages: [python]
    severity: LOW
    message: >-
      Prefer `for i, x in enumerate(seq):` to `for i in range(len(seq)):` when iterating sequences.
      It’s clearer and avoids manual index management.
    patterns:
      - pattern: |
          for $I in range(len($SEQ)):
            $BODY
    metadata:
      category: maintainability
      references:
        - https://realpython.com/python-enumerate/

  # 9) Suggest dataclasses for simple data containers
  - id: python.quality.consider-dataclass
    languages: [python]
    severity: LOW
    message: >-
      This class looks like a simple data container; consider `@dataclass` for
      auto-generated init/eq/repr and less boilerplate.
    patterns:
      - pattern: |
          class $C:
            def __init__(self, $ARGS):
              self.$A = $A
              self.$B = $B
              ...
    metadata:
      category: maintainability
      references:
        - https://docs.python.org/3/library/dataclasses.html
