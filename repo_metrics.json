{
  "generated_at": "2025-11-11T08:21:59Z",
  "scan_root": "/home/paul/kgfoundry/codeintel_rev",
  "repo_root": "/home/paul/kgfoundry",
  "summary": {
    "files": 164,
    "parsed_ok": 164,
    "tests": 86
  },
  "modules": [
    {
      "module": "typing",
      "path": "/home/paul/kgfoundry/codeintel_rev/typing.py",
      "is_test": false,
      "imports": [
        "__future__.annotations",
        "typing.TYPE_CHECKING",
        "typing.Any",
        "kgfoundry_common.typing.gate_import",
        "numpy",
        "numpy.typing"
      ],
      "public_api": [
        "HEAVY_DEPS",
        "NDArrayAny",
        "NDArrayF32",
        "NDArrayI64",
        "gate_import"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 0,
        "class_with_doc": 0,
        "func_total": 1,
        "func_with_doc": 1
      },
      "typing": {
        "functions": 1,
        "annotated_returns": 1,
        "total_params": 3,
        "annotated_params": 3
      },
      "complexity": {
        "branch_points": 1,
        "max_nesting": 1
      },
      "loc": 63,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "kgfoundry_common.typing.gate_import",
          "typing.Any",
          "typing.TYPE_CHECKING"
        ],
        "type_checking_imports": [
          "np",
          "npt"
        ],
        "exports": [
          "HEAVY_DEPS",
          "NDArrayAny",
          "NDArrayF32",
          "NDArrayI64",
          "gate_import"
        ],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 86,
      "has_tests": true,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "gate_import",
          "kind": "function",
          "signature": "gate_import(module_name: str, purpose: str, *, min_version: str | None = None) -> object",
          "doc_one_liner": "Resolve ``module_name`` lazily using the heavy dependency policy.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/typing.py:48"
        }
      ],
      "raises": {}
    },
    {
      "module": "errors",
      "path": "/home/paul/kgfoundry/codeintel_rev/errors.py",
      "is_test": false,
      "imports": [
        "__future__.annotations",
        "kgfoundry_common.errors.ErrorCode",
        "kgfoundry_common.errors.KgFoundryError"
      ],
      "public_api": [
        "FileOperationError",
        "FileReadError",
        "GitOperationError",
        "InvalidLineRangeError",
        "PathNotDirectoryError",
        "PathNotFoundError",
        "RuntimeLifecycleError",
        "RuntimeUnavailableError"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 8,
        "class_with_doc": 8,
        "func_total": 7,
        "func_with_doc": 0
      },
      "typing": {
        "functions": 7,
        "annotated_returns": 7,
        "total_params": 30,
        "annotated_params": 23
      },
      "complexity": {
        "branch_points": 4,
        "max_nesting": 3
      },
      "loc": 398,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "kgfoundry_common.errors.ErrorCode",
          "kgfoundry_common.errors.KgFoundryError"
        ],
        "type_checking_imports": [],
        "exports": [
          "FileOperationError",
          "FileReadError",
          "GitOperationError",
          "InvalidLineRangeError",
          "PathNotDirectoryError",
          "PathNotFoundError",
          "RuntimeLifecycleError",
          "RuntimeUnavailableError"
        ],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [
        "FileOperationError",
        "FileReadError",
        "GitOperationError",
        "InvalidLineRangeError",
        "PathNotDirectoryError",
        "PathNotFoundError",
        "RuntimeLifecycleError",
        "RuntimeUnavailableError"
      ],
      "public_api_details": [
        {
          "name": "FileOperationError",
          "kind": "class",
          "signature": "class FileOperationError(KgFoundryError)",
          "doc_one_liner": "Base exception for file operation errors.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/errors.py:40"
        },
        {
          "name": "FileReadError",
          "kind": "class",
          "signature": "class FileReadError(FileOperationError)",
          "doc_one_liner": "Raised when file cannot be read due to encoding or binary content.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/errors.py:95"
        },
        {
          "name": "InvalidLineRangeError",
          "kind": "class",
          "signature": "class InvalidLineRangeError(FileOperationError)",
          "doc_one_liner": "Raised when line range parameters are invalid.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/errors.py:142"
        },
        {
          "name": "PathNotFoundError",
          "kind": "class",
          "signature": "class PathNotFoundError(KgFoundryError)",
          "doc_one_liner": "Raised when a requested repository path does not exist.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/errors.py:214"
        },
        {
          "name": "PathNotDirectoryError",
          "kind": "class",
          "signature": "class PathNotDirectoryError(KgFoundryError)",
          "doc_one_liner": "Raised when a repository path is expected to be a directory but is not.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/errors.py:233"
        },
        {
          "name": "GitOperationError",
          "kind": "class",
          "signature": "class GitOperationError(KgFoundryError)",
          "doc_one_liner": "Base exception for Git operation errors.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/errors.py:255"
        },
        {
          "name": "RuntimeLifecycleError",
          "kind": "class",
          "signature": "class RuntimeLifecycleError(KgFoundryError)",
          "doc_one_liner": "Raised when a runtime fails to initialize or shut down.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/errors.py:334"
        },
        {
          "name": "RuntimeUnavailableError",
          "kind": "class",
          "signature": "class RuntimeUnavailableError(KgFoundryError)",
          "doc_one_liner": "Raised when a runtime dependency is missing or disabled.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/errors.py:353"
        }
      ],
      "raises": {}
    },
    {
      "module": "",
      "path": "/home/paul/kgfoundry/codeintel_rev/__init__.py",
      "is_test": false,
      "imports": [],
      "public_api": [],
      "doc": {
        "module_doc": true,
        "class_total": 0,
        "class_with_doc": 0,
        "func_total": 0,
        "func_with_doc": 0
      },
      "typing": {
        "functions": 0,
        "annotated_returns": 0,
        "total_params": 0,
        "annotated_params": 0
      },
      "complexity": {
        "branch_points": 0,
        "max_nesting": 0
      },
      "loc": 1,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [],
        "type_checking_imports": [],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [],
      "raises": {}
    },
    {
      "module": "_lazy_imports",
      "path": "/home/paul/kgfoundry/codeintel_rev/_lazy_imports.py",
      "is_test": false,
      "imports": [
        "__future__.annotations",
        "types.ModuleType",
        "typing.cast",
        "codeintel_rev.typing.gate_import"
      ],
      "public_api": [
        "LazyModule"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 1,
        "class_with_doc": 1,
        "func_total": 4,
        "func_with_doc": 2
      },
      "typing": {
        "functions": 4,
        "annotated_returns": 4,
        "total_params": 9,
        "annotated_params": 5
      },
      "complexity": {
        "branch_points": 2,
        "max_nesting": 3
      },
      "loc": 42,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "codeintel_rev.typing.gate_import",
          "types.ModuleType",
          "typing.cast"
        ],
        "type_checking_imports": [],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [
        "LazyModule"
      ],
      "public_api_details": [
        {
          "name": "LazyModule",
          "kind": "class",
          "signature": "class LazyModule",
          "doc_one_liner": "Proxy object that imports a module only when accessed.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/_lazy_imports.py:11"
        }
      ],
      "raises": {}
    },
    {
      "module": "ops",
      "path": "/home/paul/kgfoundry/codeintel_rev/ops/__init__.py",
      "is_test": false,
      "imports": [
        "__future__.annotations"
      ],
      "public_api": [],
      "doc": {
        "module_doc": true,
        "class_total": 0,
        "class_with_doc": 0,
        "func_total": 0,
        "func_with_doc": 0
      },
      "typing": {
        "functions": 0,
        "annotated_returns": 0,
        "total_params": 0,
        "annotated_params": 0
      },
      "complexity": {
        "branch_points": 0,
        "max_nesting": 0
      },
      "loc": 3,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations"
        ],
        "type_checking_imports": [],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [],
      "raises": {}
    },
    {
      "module": "app.scope_registry",
      "path": "/home/paul/kgfoundry/codeintel_rev/app/scope_registry.py",
      "is_test": false,
      "imports": [
        "__future__.annotations",
        "time",
        "copy.deepcopy",
        "threading.RLock",
        "typing.TYPE_CHECKING",
        "typing.cast",
        "kgfoundry_common.logging.get_logger",
        "kgfoundry_common.prometheus.build_counter",
        "kgfoundry_common.prometheus.build_gauge",
        "codeintel_rev.mcp_server.schemas.ScopeIn"
      ],
      "public_api": [
        "ScopeRegistry"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 1,
        "class_with_doc": 1,
        "func_total": 6,
        "func_with_doc": 5
      },
      "typing": {
        "functions": 6,
        "annotated_returns": 6,
        "total_params": 11,
        "annotated_params": 5
      },
      "complexity": {
        "branch_points": 12,
        "max_nesting": 4
      },
      "loc": 401,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "copy.deepcopy",
          "kgfoundry_common.logging.get_logger",
          "kgfoundry_common.prometheus.build_counter",
          "kgfoundry_common.prometheus.build_gauge",
          "threading.RLock",
          "time",
          "typing.TYPE_CHECKING",
          "typing.cast"
        ],
        "type_checking_imports": [
          "codeintel_rev.mcp_server.schemas.ScopeIn"
        ],
        "exports": [
          "ScopeRegistry"
        ],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [
        "ScopeRegistry"
      ],
      "public_api_details": [
        {
          "name": "ScopeRegistry",
          "kind": "class",
          "signature": "class ScopeRegistry",
          "doc_one_liner": "Thread-safe registry for session-scoped query scopes.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/app/scope_registry.py:81"
        }
      ],
      "raises": {}
    },
    {
      "module": "app.middleware",
      "path": "/home/paul/kgfoundry/codeintel_rev/app/middleware.py",
      "is_test": false,
      "imports": [
        "__future__.annotations",
        "contextvars",
        "uuid",
        "typing.TYPE_CHECKING",
        "starlette.middleware.base.BaseHTTPMiddleware",
        "starlette.middleware.base.DispatchFunction",
        "starlette.types.ASGIApp",
        "kgfoundry_common.logging.get_logger",
        "collections.abc.Awaitable",
        "collections.abc.Callable",
        "starlette.requests.Request",
        "starlette.responses.Response"
      ],
      "public_api": [
        "SessionScopeMiddleware",
        "get_session_id",
        "session_id_var"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 1,
        "class_with_doc": 1,
        "func_total": 3,
        "func_with_doc": 2
      },
      "typing": {
        "functions": 3,
        "annotated_returns": 3,
        "total_params": 6,
        "annotated_params": 4
      },
      "complexity": {
        "branch_points": 4,
        "max_nesting": 3
      },
      "loc": 244,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "contextvars",
          "kgfoundry_common.logging.get_logger",
          "starlette.middleware.base.BaseHTTPMiddleware",
          "starlette.middleware.base.DispatchFunction",
          "starlette.types.ASGIApp",
          "typing.TYPE_CHECKING",
          "uuid"
        ],
        "type_checking_imports": [
          "collections.abc.Awaitable",
          "collections.abc.Callable",
          "starlette.requests.Request",
          "starlette.responses.Response"
        ],
        "exports": [
          "SessionScopeMiddleware",
          "get_session_id",
          "session_id_var"
        ],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [
        "SessionScopeMiddleware",
        "get_session_id",
        "session_id_var"
      ],
      "public_api_details": [
        {
          "name": "get_session_id",
          "kind": "function",
          "signature": "get_session_id() -> str",
          "doc_one_liner": "Retrieve session ID from thread-local context.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/app/middleware.py:80"
        },
        {
          "name": "SessionScopeMiddleware",
          "kind": "class",
          "signature": "class SessionScopeMiddleware(BaseHTTPMiddleware)",
          "doc_one_liner": "Middleware for session ID extraction and context storage.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/app/middleware.py:131"
        }
      ],
      "raises": {
        "get_session_id": [
          "RuntimeError"
        ]
      }
    },
    {
      "module": "app.gpu_warmup",
      "path": "/home/paul/kgfoundry/codeintel_rev/app/gpu_warmup.py",
      "is_test": false,
      "imports": [
        "__future__.annotations",
        "functools.lru_cache",
        "typing.TYPE_CHECKING",
        "typing.cast",
        "codeintel_rev.typing.gate_import",
        "kgfoundry_common.logging.get_logger",
        "faiss",
        "torch"
      ],
      "public_api": [
        "warmup_gpu"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 0,
        "class_with_doc": 0,
        "func_total": 5,
        "func_with_doc": 5
      },
      "typing": {
        "functions": 5,
        "annotated_returns": 5,
        "total_params": 0,
        "annotated_params": 0
      },
      "complexity": {
        "branch_points": 24,
        "max_nesting": 3
      },
      "loc": 237,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "codeintel_rev.typing.gate_import",
          "functools.lru_cache",
          "kgfoundry_common.logging.get_logger",
          "typing.TYPE_CHECKING",
          "typing.cast"
        ],
        "type_checking_imports": [
          "_faiss",
          "_torch"
        ],
        "exports": [
          "warmup_gpu"
        ],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [
        "warmup_gpu"
      ],
      "public_api_details": [
        {
          "name": "warmup_gpu",
          "kind": "function",
          "signature": "warmup_gpu() -> dict[str, bool | str]",
          "doc_one_liner": "Perform GPU warmup sequence to verify GPU availability and functionality.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/app/gpu_warmup.py:148"
        }
      ],
      "raises": {}
    },
    {
      "module": "app.config_context",
      "path": "/home/paul/kgfoundry/codeintel_rev/app/config_context.py",
      "is_test": false,
      "imports": [
        "__future__.annotations",
        "importlib",
        "contextlib.contextmanager",
        "contextlib.suppress",
        "dataclasses.dataclass",
        "dataclasses.field",
        "pathlib.Path",
        "threading.Lock",
        "typing.TYPE_CHECKING",
        "typing.Any",
        "typing.TypeVar",
        "typing.cast",
        "redis.asyncio",
        "codeintel_rev.app.scope_store.ScopeStore",
        "codeintel_rev.config.settings.Settings",
        "codeintel_rev.config.settings.load_settings",
        "codeintel_rev.errors.RuntimeUnavailableError",
        "codeintel_rev.io.duckdb_catalog.DuckDBCatalog",
        "codeintel_rev.io.duckdb_manager.DuckDBManager",
        "codeintel_rev.io.git_client.AsyncGitClient",
        "codeintel_rev.io.git_client.GitClient",
        "codeintel_rev.io.vllm_client.VLLMClient",
        "codeintel_rev.runtime.NullRuntimeCellObserver",
        "codeintel_rev.runtime.RuntimeCell",
        "codeintel_rev.runtime.RuntimeCellObserver",
        "codeintel_rev.typing.gate_import",
        "kgfoundry_common.errors.ConfigurationError",
        "kgfoundry_common.logging.get_logger",
        "collections.abc.Iterator",
        "codeintel_rev.app.scope_store.SupportsAsyncRedis",
        "codeintel_rev.io.faiss_manager.FAISSManager",
        "codeintel_rev.io.hybrid_search.HybridSearchEngine",
        "codeintel_rev.io.xtr_manager.XTRIndex"
      ],
      "public_api": [
        "ApplicationContext",
        "ResolvedPaths",
        "resolve_application_paths"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 4,
        "class_with_doc": 4,
        "func_total": 27,
        "func_with_doc": 22
      },
      "typing": {
        "functions": 27,
        "annotated_returns": 27,
        "total_params": 33,
        "annotated_params": 17
      },
      "complexity": {
        "branch_points": 52,
        "max_nesting": 5
      },
      "loc": 1146,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "codeintel_rev.app.scope_store.ScopeStore",
          "codeintel_rev.config.settings.Settings",
          "codeintel_rev.config.settings.load_settings",
          "codeintel_rev.errors.RuntimeUnavailableError",
          "codeintel_rev.io.duckdb_catalog.DuckDBCatalog",
          "codeintel_rev.io.duckdb_manager.DuckDBManager",
          "codeintel_rev.io.git_client.AsyncGitClient",
          "codeintel_rev.io.git_client.GitClient",
          "codeintel_rev.io.vllm_client.VLLMClient",
          "codeintel_rev.runtime.NullRuntimeCellObserver",
          "codeintel_rev.runtime.RuntimeCell",
          "codeintel_rev.runtime.RuntimeCellObserver",
          "codeintel_rev.typing.gate_import",
          "contextlib.contextmanager",
          "contextlib.suppress",
          "dataclasses.dataclass",
          "dataclasses.field",
          "importlib",
          "kgfoundry_common.errors.ConfigurationError",
          "kgfoundry_common.logging.get_logger",
          "pathlib.Path",
          "redis_asyncio",
          "threading.Lock",
          "typing.Any",
          "typing.TYPE_CHECKING",
          "typing.TypeVar",
          "typing.cast"
        ],
        "type_checking_imports": [
          "codeintel_rev.app.scope_store.SupportsAsyncRedis",
          "codeintel_rev.io.faiss_manager.FAISSManager",
          "codeintel_rev.io.hybrid_search.HybridSearchEngine",
          "codeintel_rev.io.xtr_manager.XTRIndex",
          "collections.abc.Iterator"
        ],
        "exports": [
          "ApplicationContext",
          "ResolvedPaths",
          "resolve_application_paths"
        ],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [
        "ApplicationContext",
        "ResolvedPaths",
        "resolve_application_paths"
      ],
      "public_api_details": [
        {
          "name": "ResolvedPaths",
          "kind": "class",
          "signature": "class ResolvedPaths",
          "doc_one_liner": "Canonicalized filesystem paths for runtime operations.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/app/config_context.py:260"
        },
        {
          "name": "resolve_application_paths",
          "kind": "function",
          "signature": "resolve_application_paths(settings: Settings) -> ResolvedPaths",
          "doc_one_liner": "Resolve all configured paths to absolute paths.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/app/config_context.py:316"
        },
        {
          "name": "ApplicationContext",
          "kind": "class",
          "signature": "class ApplicationContext",
          "doc_one_liner": "Application-wide context holding all configuration and long-lived clients.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/app/config_context.py:478"
        }
      ],
      "raises": {
        "_require_dependency": [
          "RuntimeUnavailableError"
        ],
        "_ensure_path_exists": [
          "RuntimeUnavailableError"
        ],
        "resolve_application_paths": [
          "ConfigurationError"
        ],
        "get_hybrid_engine": [
          "RuntimeError"
        ],
        "get_coderank_faiss_manager": [
          "ValueError"
        ],
        "_build_xtr_index": [
          "RuntimeUnavailableError"
        ],
        "with_overrides": [
          "ValueError"
        ]
      }
    },
    {
      "module": "app.main",
      "path": "/home/paul/kgfoundry/codeintel_rev/app/main.py",
      "is_test": false,
      "imports": [
        "__future__.annotations",
        "asyncio",
        "os",
        "collections.abc.AsyncIterator",
        "collections.abc.Awaitable",
        "collections.abc.Callable",
        "collections.abc.Mapping",
        "contextlib.asynccontextmanager",
        "contextlib.suppress",
        "fastapi.FastAPI",
        "fastapi.Request",
        "fastapi.middleware.cors.CORSMiddleware",
        "fastapi.responses.JSONResponse",
        "fastapi.responses.StreamingResponse",
        "starlette.responses.Response",
        "codeintel_rev.app.capabilities.Capabilities",
        "codeintel_rev.app.config_context.ApplicationContext",
        "codeintel_rev.app.gpu_warmup.warmup_gpu",
        "codeintel_rev.app.middleware.SessionScopeMiddleware",
        "codeintel_rev.app.readiness.ReadinessProbe",
        "codeintel_rev.errors.RuntimeUnavailableError",
        "codeintel_rev.mcp_server.server.app_context",
        "codeintel_rev.mcp_server.server.build_http_app",
        "kgfoundry_common.errors.ConfigurationError",
        "kgfoundry_common.logging.get_logger"
      ],
      "public_api": [
        "app"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 0,
        "class_with_doc": 0,
        "func_total": 16,
        "func_with_doc": 15
      },
      "typing": {
        "functions": 16,
        "annotated_returns": 16,
        "total_params": 17,
        "annotated_params": 17
      },
      "complexity": {
        "branch_points": 31,
        "max_nesting": 4
      },
      "loc": 449,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "asyncio",
          "codeintel_rev.app.capabilities.Capabilities",
          "codeintel_rev.app.config_context.ApplicationContext",
          "codeintel_rev.app.gpu_warmup.warmup_gpu",
          "codeintel_rev.app.middleware.SessionScopeMiddleware",
          "codeintel_rev.app.readiness.ReadinessProbe",
          "codeintel_rev.errors.RuntimeUnavailableError",
          "codeintel_rev.mcp_server.server.app_context",
          "codeintel_rev.mcp_server.server.build_http_app",
          "collections.abc.AsyncIterator",
          "collections.abc.Awaitable",
          "collections.abc.Callable",
          "collections.abc.Mapping",
          "contextlib.asynccontextmanager",
          "contextlib.suppress",
          "fastapi.FastAPI",
          "fastapi.Request",
          "fastapi.middleware.cors.CORSMiddleware",
          "fastapi.responses.JSONResponse",
          "fastapi.responses.StreamingResponse",
          "kgfoundry_common.errors.ConfigurationError",
          "kgfoundry_common.logging.get_logger",
          "os",
          "starlette.responses.Response"
        ],
        "type_checking_imports": [],
        "exports": [
          "app"
        ],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [
        "app"
      ],
      "public_api_details": [],
      "raises": {}
    },
    {
      "module": "app.scope_store",
      "path": "/home/paul/kgfoundry/codeintel_rev/app/scope_store.py",
      "is_test": false,
      "imports": [
        "__future__.annotations",
        "asyncio",
        "time",
        "collections.OrderedDict",
        "collections.abc.Awaitable",
        "collections.abc.Callable",
        "collections.abc.Hashable",
        "collections.abc.Iterator",
        "collections.abc.MutableMapping",
        "dataclasses.dataclass",
        "threading.RLock",
        "typing.TYPE_CHECKING",
        "typing.Any",
        "typing.Protocol",
        "typing.cast",
        "msgspec",
        "codeintel_rev.mcp_server.schemas.ScopeIn"
      ],
      "public_api": [
        "AsyncSingleFlight",
        "LRUCache",
        "ScopeStore",
        "ScopeStoreMetrics"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 6,
        "class_with_doc": 6,
        "func_total": 37,
        "func_with_doc": 27
      },
      "typing": {
        "functions": 37,
        "annotated_returns": 37,
        "total_params": 71,
        "annotated_params": 34
      },
      "complexity": {
        "branch_points": 40,
        "max_nesting": 5
      },
      "loc": 538,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "asyncio",
          "collections.OrderedDict",
          "collections.abc.Awaitable",
          "collections.abc.Callable",
          "collections.abc.Hashable",
          "collections.abc.Iterator",
          "collections.abc.MutableMapping",
          "dataclasses.dataclass",
          "msgspec",
          "threading.RLock",
          "time",
          "typing.Any",
          "typing.Protocol",
          "typing.TYPE_CHECKING",
          "typing.cast"
        ],
        "type_checking_imports": [
          "codeintel_rev.mcp_server.schemas.ScopeIn"
        ],
        "exports": [
          "AsyncSingleFlight",
          "LRUCache",
          "ScopeStore",
          "ScopeStoreMetrics"
        ],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [
        "AsyncSingleFlight",
        "LRUCache",
        "ScopeStore",
        "ScopeStoreMetrics"
      ],
      "public_api_details": [
        {
          "name": "LRUCache",
          "kind": "class",
          "signature": "class LRUCache",
          "doc_one_liner": "Thread-safe least-recently-used cache with TTL-based eviction.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/app/scope_store.py:50"
        },
        {
          "name": "AsyncSingleFlight",
          "kind": "class",
          "signature": "class AsyncSingleFlight",
          "doc_one_liner": "Deduplicate concurrent coroutine execution keyed by ``KeyT``.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/app/scope_store.py:235"
        },
        {
          "name": "ScopeStoreMetrics",
          "kind": "class",
          "signature": "class ScopeStoreMetrics",
          "doc_one_liner": "Runtime counters describing scope store cache performance.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/app/scope_store.py:275"
        },
        {
          "name": "ScopeStore",
          "kind": "class",
          "signature": "class ScopeStore",
          "doc_one_liner": "Redis-backed scope store with L1/L2 caching and single-flight coalescing.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/app/scope_store.py:378"
        }
      ],
      "raises": {
        "__init__": [
          "ValueError"
        ],
        "get": [
          "ValueError"
        ],
        "set": [
          "ValueError"
        ],
        "delete": [
          "ValueError"
        ],
        "evict_l1": [
          "ValueError"
        ]
      }
    },
    {
      "module": "app",
      "path": "/home/paul/kgfoundry/codeintel_rev/app/__init__.py",
      "is_test": false,
      "imports": [],
      "public_api": [],
      "doc": {
        "module_doc": true,
        "class_total": 0,
        "class_with_doc": 0,
        "func_total": 0,
        "func_with_doc": 0
      },
      "typing": {
        "functions": 0,
        "annotated_returns": 0,
        "total_params": 0,
        "annotated_params": 0
      },
      "complexity": {
        "branch_points": 0,
        "max_nesting": 0
      },
      "loc": 1,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [],
        "type_checking_imports": [],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [],
      "raises": {}
    },
    {
      "module": "app.capabilities",
      "path": "/home/paul/kgfoundry/codeintel_rev/app/capabilities.py",
      "is_test": false,
      "imports": [
        "__future__.annotations",
        "importlib",
        "importlib.util",
        "collections.abc.Callable",
        "dataclasses.dataclass",
        "pathlib.Path",
        "types.ModuleType",
        "typing.TYPE_CHECKING",
        "typing.Final",
        "typing.cast",
        "kgfoundry_common.logging.get_logger",
        "kgfoundry_common.prometheus.GaugeLike",
        "kgfoundry_common.prometheus.build_gauge",
        "codeintel_rev.app.config_context.ApplicationContext"
      ],
      "public_api": [
        "Capabilities"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 1,
        "class_with_doc": 1,
        "func_total": 9,
        "func_with_doc": 8
      },
      "typing": {
        "functions": 9,
        "annotated_returns": 9,
        "total_params": 11,
        "annotated_params": 7
      },
      "complexity": {
        "branch_points": 16,
        "max_nesting": 4
      },
      "loc": 234,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "collections.abc.Callable",
          "dataclasses.dataclass",
          "importlib",
          "importlib.util",
          "kgfoundry_common.logging.get_logger",
          "kgfoundry_common.prometheus.GaugeLike",
          "kgfoundry_common.prometheus.build_gauge",
          "pathlib.Path",
          "types.ModuleType",
          "typing.Final",
          "typing.TYPE_CHECKING",
          "typing.cast"
        ],
        "type_checking_imports": [
          "codeintel_rev.app.config_context.ApplicationContext"
        ],
        "exports": [
          "Capabilities"
        ],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [
        "Capabilities"
      ],
      "public_api_details": [
        {
          "name": "Capabilities",
          "kind": "class",
          "signature": "class Capabilities",
          "doc_one_liner": "Capability snapshot used for MCP tool gating and the /capz endpoint.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/app/capabilities.py:133"
        }
      ],
      "raises": {}
    },
    {
      "module": "app.readiness",
      "path": "/home/paul/kgfoundry/codeintel_rev/app/readiness.py",
      "is_test": false,
      "imports": [
        "__future__.annotations",
        "asyncio",
        "shutil",
        "collections.abc.Mapping",
        "dataclasses.dataclass",
        "pathlib.Path",
        "typing.TYPE_CHECKING",
        "typing.Any",
        "typing.cast",
        "urllib.parse.urlparse",
        "codeintel_rev._lazy_imports.LazyModule",
        "codeintel_rev.app.config_context.ApplicationContext",
        "kgfoundry_common.logging.get_logger",
        "duckdb",
        "httpx"
      ],
      "public_api": [
        "CheckResult",
        "ReadinessProbe"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 2,
        "class_with_doc": 2,
        "func_total": 17,
        "func_with_doc": 16
      },
      "typing": {
        "functions": 17,
        "annotated_returns": 17,
        "total_params": 21,
        "annotated_params": 10
      },
      "complexity": {
        "branch_points": 38,
        "max_nesting": 5
      },
      "loc": 604,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "asyncio",
          "codeintel_rev._lazy_imports.LazyModule",
          "codeintel_rev.app.config_context.ApplicationContext",
          "collections.abc.Mapping",
          "dataclasses.dataclass",
          "kgfoundry_common.logging.get_logger",
          "pathlib.Path",
          "shutil",
          "typing.Any",
          "typing.TYPE_CHECKING",
          "typing.cast",
          "urllib.parse.urlparse"
        ],
        "type_checking_imports": [
          "duckdb",
          "httpx"
        ],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [
        "CheckResult",
        "ReadinessProbe"
      ],
      "public_api_details": [
        {
          "name": "CheckResult",
          "kind": "class",
          "signature": "class CheckResult",
          "doc_one_liner": "Outcome of a single readiness check.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/app/readiness.py:71"
        },
        {
          "name": "ReadinessProbe",
          "kind": "class",
          "signature": "class ReadinessProbe",
          "doc_one_liner": "Manages readiness checks across core dependencies.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/app/readiness.py:109"
        }
      ],
      "raises": {
        "snapshot": [
          "RuntimeError"
        ]
      }
    },
    {
      "module": "bin.index_all",
      "path": "/home/paul/kgfoundry/codeintel_rev/bin/index_all.py",
      "is_test": false,
      "imports": [
        "__future__.annotations",
        "argparse",
        "logging",
        "collections.defaultdict",
        "collections.abc.Mapping",
        "collections.abc.Sequence",
        "dataclasses.dataclass",
        "pathlib.Path",
        "typing.TYPE_CHECKING",
        "typing.cast",
        "codeintel_rev._lazy_imports.LazyModule",
        "codeintel_rev.config.settings.IndexConfig",
        "codeintel_rev.config.settings.Settings",
        "codeintel_rev.config.settings.VLLMConfig",
        "codeintel_rev.config.settings.load_settings",
        "codeintel_rev.indexing.cast_chunker.Chunk",
        "codeintel_rev.indexing.cast_chunker.ChunkOptions",
        "codeintel_rev.indexing.cast_chunker.chunk_file",
        "codeintel_rev.indexing.scip_reader.SCIPIndex",
        "codeintel_rev.indexing.scip_reader.SymbolDef",
        "codeintel_rev.indexing.scip_reader.extract_definitions",
        "codeintel_rev.indexing.scip_reader.get_top_level_definitions",
        "codeintel_rev.indexing.scip_reader.parse_scip_json",
        "codeintel_rev.io.duckdb_catalog.DuckDBCatalog",
        "codeintel_rev.io.duckdb_manager.DuckDBManager",
        "codeintel_rev.io.faiss_manager.FAISSManager",
        "codeintel_rev.io.parquet_store.ParquetWriteOptions",
        "codeintel_rev.io.parquet_store.write_chunks_parquet",
        "codeintel_rev.io.symbol_catalog.SymbolCatalog",
        "codeintel_rev.io.symbol_catalog.SymbolDefRow",
        "codeintel_rev.io.symbol_catalog.SymbolOccurrenceRow",
        "codeintel_rev.io.vllm_client.VLLMClient",
        "codeintel_rev.typing.NDArrayF32",
        "numpy"
      ],
      "public_api": [
        "PipelinePaths",
        "main"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 1,
        "class_with_doc": 1,
        "func_total": 13,
        "func_with_doc": 11
      },
      "typing": {
        "functions": 13,
        "annotated_returns": 13,
        "total_params": 28,
        "annotated_params": 28
      },
      "complexity": {
        "branch_points": 33,
        "max_nesting": 4
      },
      "loc": 605,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "argparse",
          "codeintel_rev._lazy_imports.LazyModule",
          "codeintel_rev.config.settings.IndexConfig",
          "codeintel_rev.config.settings.Settings",
          "codeintel_rev.config.settings.VLLMConfig",
          "codeintel_rev.config.settings.load_settings",
          "codeintel_rev.indexing.cast_chunker.Chunk",
          "codeintel_rev.indexing.cast_chunker.ChunkOptions",
          "codeintel_rev.indexing.cast_chunker.chunk_file",
          "codeintel_rev.indexing.scip_reader.SCIPIndex",
          "codeintel_rev.indexing.scip_reader.SymbolDef",
          "codeintel_rev.indexing.scip_reader.extract_definitions",
          "codeintel_rev.indexing.scip_reader.get_top_level_definitions",
          "codeintel_rev.indexing.scip_reader.parse_scip_json",
          "codeintel_rev.io.duckdb_catalog.DuckDBCatalog",
          "codeintel_rev.io.duckdb_manager.DuckDBManager",
          "codeintel_rev.io.faiss_manager.FAISSManager",
          "codeintel_rev.io.parquet_store.ParquetWriteOptions",
          "codeintel_rev.io.parquet_store.write_chunks_parquet",
          "codeintel_rev.io.symbol_catalog.SymbolCatalog",
          "codeintel_rev.io.symbol_catalog.SymbolDefRow",
          "codeintel_rev.io.symbol_catalog.SymbolOccurrenceRow",
          "codeintel_rev.io.vllm_client.VLLMClient",
          "codeintel_rev.typing.NDArrayF32",
          "collections.abc.Mapping",
          "collections.abc.Sequence",
          "collections.defaultdict",
          "dataclasses.dataclass",
          "logging",
          "pathlib.Path",
          "typing.TYPE_CHECKING",
          "typing.cast"
        ],
        "type_checking_imports": [
          "np"
        ],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [
        "PipelinePaths",
        "main"
      ],
      "public_api_details": [
        {
          "name": "PipelinePaths",
          "kind": "class",
          "signature": "class PipelinePaths",
          "doc_one_liner": "Resolved filesystem paths for the indexing pipeline.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/bin/index_all.py:67"
        },
        {
          "name": "main",
          "kind": "function",
          "signature": "main() -> None",
          "doc_one_liner": "Run the end-to-end indexing pipeline.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/bin/index_all.py:77"
        }
      ],
      "raises": {
        "_load_scip_index": [
          "FileNotFoundError"
        ],
        "_build_faiss_index": [
          "RuntimeError"
        ],
        "_update_faiss_index_incremental": [
          "FileNotFoundError",
          "RuntimeError"
        ]
      }
    },
    {
      "module": "bin",
      "path": "/home/paul/kgfoundry/codeintel_rev/bin/__init__.py",
      "is_test": false,
      "imports": [],
      "public_api": [],
      "doc": {
        "module_doc": true,
        "class_total": 0,
        "class_with_doc": 0,
        "func_total": 0,
        "func_with_doc": 0
      },
      "typing": {
        "functions": 0,
        "annotated_returns": 0,
        "total_params": 0,
        "annotated_params": 0
      },
      "complexity": {
        "branch_points": 0,
        "max_nesting": 0
      },
      "loc": 1,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [],
        "type_checking_imports": [],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [],
      "raises": {}
    },
    {
      "module": "config.settings",
      "path": "/home/paul/kgfoundry/codeintel_rev/config/settings.py",
      "is_test": false,
      "imports": [
        "__future__.annotations",
        "json",
        "os",
        "pathlib.Path",
        "typing.Literal",
        "msgspec",
        "codeintel_rev.io.duckdb_manager.DuckDBConfig"
      ],
      "public_api": [
        "BM25Config",
        "CodeRankConfig",
        "CodeRankLLMConfig",
        "IndexConfig",
        "PathsConfig",
        "RedisConfig",
        "ServerLimits",
        "Settings",
        "SpladeConfig",
        "VLLMConfig",
        "VLLMRunMode",
        "WarpConfig",
        "XTRConfig",
        "load_settings"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 13,
        "class_with_doc": 13,
        "func_total": 4,
        "func_with_doc": 1
      },
      "typing": {
        "functions": 4,
        "annotated_returns": 4,
        "total_params": 2,
        "annotated_params": 2
      },
      "complexity": {
        "branch_points": 13,
        "max_nesting": 4
      },
      "loc": 973,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "codeintel_rev.io.duckdb_manager.DuckDBConfig",
          "json",
          "msgspec",
          "os",
          "pathlib.Path",
          "typing.Literal"
        ],
        "type_checking_imports": [],
        "exports": [
          "BM25Config",
          "CodeRankConfig",
          "CodeRankLLMConfig",
          "IndexConfig",
          "PathsConfig",
          "RedisConfig",
          "ServerLimits",
          "Settings",
          "SpladeConfig",
          "VLLMConfig",
          "VLLMRunMode",
          "WarpConfig",
          "XTRConfig",
          "load_settings"
        ],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [
        "BM25Config",
        "CodeRankConfig",
        "CodeRankLLMConfig",
        "IndexConfig",
        "PathsConfig",
        "RedisConfig",
        "ServerLimits",
        "Settings",
        "SpladeConfig",
        "VLLMConfig",
        "VLLMRunMode",
        "WarpConfig",
        "XTRConfig",
        "load_settings"
      ],
      "public_api_details": [
        {
          "name": "CodeRankConfig",
          "kind": "class",
          "signature": "class CodeRankConfig(msgspec.Struct)",
          "doc_one_liner": "Configuration for the CodeRank dense retriever.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/config/settings.py:82"
        },
        {
          "name": "WarpConfig",
          "kind": "class",
          "signature": "class WarpConfig(msgspec.Struct)",
          "doc_one_liner": "Configuration for the WARP/XTR late-interaction reranker.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/config/settings.py:121"
        },
        {
          "name": "XTRConfig",
          "kind": "class",
          "signature": "class XTRConfig(msgspec.Struct)",
          "doc_one_liner": "Configuration for XTR token storage and scoring.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/config/settings.py:148"
        },
        {
          "name": "CodeRankLLMConfig",
          "kind": "class",
          "signature": "class CodeRankLLMConfig(msgspec.Struct)",
          "doc_one_liner": "Configuration for the CodeRank listwise reranker.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/config/settings.py:161"
        },
        {
          "name": "VLLMRunMode",
          "kind": "class",
          "signature": "class VLLMRunMode(msgspec.Struct)",
          "doc_one_liner": "Execution mode for the vLLM embedder.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/config/settings.py:173"
        },
        {
          "name": "VLLMConfig",
          "kind": "class",
          "signature": "class VLLMConfig(msgspec.Struct)",
          "doc_one_liner": "vLLM embedding service configuration.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/config/settings.py:179"
        },
        {
          "name": "BM25Config",
          "kind": "class",
          "signature": "class BM25Config(msgspec.Struct)",
          "doc_one_liner": "BM25 indexing and search configuration.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/config/settings.py:246"
        },
        {
          "name": "SpladeConfig",
          "kind": "class",
          "signature": "class SpladeConfig(msgspec.Struct)",
          "doc_one_liner": "SPLADE v3 configuration covering model artifacts and index directories.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/config/settings.py:265"
        },
        {
          "name": "PathsConfig",
          "kind": "class",
          "signature": "class PathsConfig(msgspec.Struct)",
          "doc_one_liner": "File system paths configuration.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/config/settings.py:313"
        },
        {
          "name": "IndexConfig",
          "kind": "class",
          "signature": "class IndexConfig(msgspec.Struct)",
          "doc_one_liner": "Indexing and search configuration.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/config/settings.py:381"
        },
        {
          "name": "ServerLimits",
          "kind": "class",
          "signature": "class ServerLimits(msgspec.Struct)",
          "doc_one_liner": "Server resource limits and rate limiting configuration.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/config/settings.py:485"
        },
        {
          "name": "RedisConfig",
          "kind": "class",
          "signature": "class RedisConfig(msgspec.Struct)",
          "doc_one_liner": "Redis configuration for scope storage.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/config/settings.py:531"
        },
        {
          "name": "Settings",
          "kind": "class",
          "signature": "class Settings(msgspec.Struct)",
          "doc_one_liner": "Global settings container for the entire code intelligence system.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/config/settings.py:552"
        },
        {
          "name": "load_settings",
          "kind": "function",
          "signature": "load_settings() -> Settings",
          "doc_one_liner": "Load settings from environment variables with sensible defaults.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/config/settings.py:611"
        }
      ],
      "raises": {}
    },
    {
      "module": "config.utils",
      "path": "/home/paul/kgfoundry/codeintel_rev/config/utils.py",
      "is_test": false,
      "imports": [
        "__future__.annotations",
        "msgspec.Struct",
        "msgspec.structs",
        "codeintel_rev.config.settings.Settings"
      ],
      "public_api": [
        "replace_settings",
        "replace_struct"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 0,
        "class_with_doc": 0,
        "func_total": 2,
        "func_with_doc": 2
      },
      "typing": {
        "functions": 2,
        "annotated_returns": 2,
        "total_params": 4,
        "annotated_params": 4
      },
      "complexity": {
        "branch_points": 0,
        "max_nesting": 1
      },
      "loc": 83,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "codeintel_rev.config.settings.Settings",
          "msgspec.Struct",
          "msgspec.structs"
        ],
        "type_checking_imports": [],
        "exports": [
          "replace_settings",
          "replace_struct"
        ],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [
        "replace_settings",
        "replace_struct"
      ],
      "public_api_details": [
        {
          "name": "replace_settings",
          "kind": "function",
          "signature": "replace_settings(settings: Settings, **updates: object) -> Settings",
          "doc_one_liner": "Return a new Settings instance with updates applied.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/config/utils.py:10"
        },
        {
          "name": "replace_struct",
          "kind": "function",
          "signature": "replace_struct(instance: T, **updates: object) -> T",
          "doc_one_liner": "Clone a struct instance with the provided field overrides applied.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/config/utils.py:45"
        }
      ],
      "raises": {}
    },
    {
      "module": "config",
      "path": "/home/paul/kgfoundry/codeintel_rev/config/__init__.py",
      "is_test": false,
      "imports": [],
      "public_api": [],
      "doc": {
        "module_doc": true,
        "class_total": 0,
        "class_with_doc": 0,
        "func_total": 0,
        "func_with_doc": 0
      },
      "typing": {
        "functions": 0,
        "annotated_returns": 0,
        "total_params": 0,
        "annotated_params": 0
      },
      "complexity": {
        "branch_points": 0,
        "max_nesting": 0
      },
      "loc": 1,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [],
        "type_checking_imports": [],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [],
      "raises": {}
    },
    {
      "module": "indexing.scip_reader",
      "path": "/home/paul/kgfoundry/codeintel_rev/indexing/scip_reader.py",
      "is_test": false,
      "imports": [
        "__future__.annotations",
        "json",
        "dataclasses.dataclass",
        "pathlib.Path",
        "typing.TYPE_CHECKING",
        "msgspec",
        "collections.abc.Iterable"
      ],
      "public_api": [
        "Document",
        "Occurrence",
        "Range",
        "SCIPIndex",
        "SymbolDef",
        "extract_definitions",
        "get_top_level_definitions",
        "parse_scip_json"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 5,
        "class_with_doc": 5,
        "func_total": 4,
        "func_with_doc": 3
      },
      "typing": {
        "functions": 4,
        "annotated_returns": 4,
        "total_params": 5,
        "annotated_params": 5
      },
      "complexity": {
        "branch_points": 29,
        "max_nesting": 6
      },
      "loc": 368,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "dataclasses.dataclass",
          "json",
          "msgspec",
          "pathlib.Path",
          "typing.TYPE_CHECKING"
        ],
        "type_checking_imports": [
          "collections.abc.Iterable"
        ],
        "exports": [
          "Document",
          "Occurrence",
          "Range",
          "SCIPIndex",
          "SymbolDef",
          "extract_definitions",
          "get_top_level_definitions",
          "parse_scip_json"
        ],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [
        "Document",
        "Occurrence",
        "Range",
        "SCIPIndex",
        "SymbolDef",
        "extract_definitions",
        "get_top_level_definitions",
        "parse_scip_json"
      ],
      "public_api_details": [
        {
          "name": "Range",
          "kind": "class",
          "signature": "class Range",
          "doc_one_liner": "Source code range with line and character positions.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/indexing/scip_reader.py:24"
        },
        {
          "name": "Occurrence",
          "kind": "class",
          "signature": "class Occurrence(msgspec.Struct)",
          "doc_one_liner": "Symbol occurrence in source code.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/indexing/scip_reader.py:59"
        },
        {
          "name": "Document",
          "kind": "class",
          "signature": "class Document(msgspec.Struct)",
          "doc_one_liner": "SCIP document representing a source file.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/indexing/scip_reader.py:92"
        },
        {
          "name": "SCIPIndex",
          "kind": "class",
          "signature": "class SCIPIndex(msgspec.Struct)",
          "doc_one_liner": "SCIP index containing all indexed documents.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/indexing/scip_reader.py:124"
        },
        {
          "name": "SymbolDef",
          "kind": "class",
          "signature": "class SymbolDef",
          "doc_one_liner": "Extracted symbol definition with location information.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/indexing/scip_reader.py:147"
        },
        {
          "name": "parse_scip_json",
          "kind": "function",
          "signature": "parse_scip_json(json_path: Path) -> SCIPIndex",
          "doc_one_liner": "Parse SCIP index from JSON export.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/indexing/scip_reader.py:183"
        },
        {
          "name": "extract_definitions",
          "kind": "function",
          "signature": "extract_definitions(index: SCIPIndex) -> Iterable[SymbolDef]",
          "doc_one_liner": "Extract symbol definitions from SCIP index.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/indexing/scip_reader.py:272"
        },
        {
          "name": "get_top_level_definitions",
          "kind": "function",
          "signature": "get_top_level_definitions(definitions: list[SymbolDef]) -> list[SymbolDef]",
          "doc_one_liner": "Filter to top-level definitions (not nested inside others).",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/indexing/scip_reader.py:322"
        }
      ],
      "raises": {}
    },
    {
      "module": "indexing.xtr_build",
      "path": "/home/paul/kgfoundry/codeintel_rev/indexing/xtr_build.py",
      "is_test": false,
      "imports": [
        "__future__.annotations",
        "json",
        "collections.abc.Iterable",
        "collections.abc.Sequence",
        "dataclasses.dataclass",
        "pathlib.Path",
        "typing.TYPE_CHECKING",
        "typing.Any",
        "typing.cast",
        "codeintel_rev._lazy_imports.LazyModule",
        "codeintel_rev.app.config_context.resolve_application_paths",
        "codeintel_rev.config.settings.Settings",
        "codeintel_rev.config.settings.load_settings",
        "codeintel_rev.io.duckdb_catalog.DuckDBCatalog",
        "codeintel_rev.io.xtr_manager.XTRIndex",
        "codeintel_rev.typing.NDArrayAny",
        "kgfoundry_common.logging.get_logger",
        "numpy"
      ],
      "public_api": [
        "XTRBuildSummary",
        "build_xtr_index",
        "main"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 1,
        "class_with_doc": 1,
        "func_total": 5,
        "func_with_doc": 5
      },
      "typing": {
        "functions": 5,
        "annotated_returns": 5,
        "total_params": 11,
        "annotated_params": 11
      },
      "complexity": {
        "branch_points": 15,
        "max_nesting": 5
      },
      "loc": 345,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "codeintel_rev._lazy_imports.LazyModule",
          "codeintel_rev.app.config_context.resolve_application_paths",
          "codeintel_rev.config.settings.Settings",
          "codeintel_rev.config.settings.load_settings",
          "codeintel_rev.io.duckdb_catalog.DuckDBCatalog",
          "codeintel_rev.io.xtr_manager.XTRIndex",
          "codeintel_rev.typing.NDArrayAny",
          "collections.abc.Iterable",
          "collections.abc.Sequence",
          "dataclasses.dataclass",
          "json",
          "kgfoundry_common.logging.get_logger",
          "pathlib.Path",
          "typing.Any",
          "typing.TYPE_CHECKING",
          "typing.cast"
        ],
        "type_checking_imports": [
          "np"
        ],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [
        "XTRBuildSummary",
        "build_xtr_index",
        "main"
      ],
      "public_api_details": [
        {
          "name": "XTRBuildSummary",
          "kind": "class",
          "signature": "class XTRBuildSummary",
          "doc_one_liner": "Metadata describing a freshly built XTR token index.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/indexing/xtr_build.py:28"
        },
        {
          "name": "build_xtr_index",
          "kind": "function",
          "signature": "build_xtr_index(settings: Settings | None = None) -> XTRBuildSummary",
          "doc_one_liner": "Build XTR token artifacts from DuckDB chunks.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/indexing/xtr_build.py:227"
        },
        {
          "name": "main",
          "kind": "function",
          "signature": "main() -> None",
          "doc_one_liner": "Entry point allowing ``python -m codeintel_rev.indexing.xtr_build``.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/indexing/xtr_build.py:330"
        }
      ],
      "raises": {
        "build_xtr_index": [
          "RuntimeError"
        ]
      }
    },
    {
      "module": "indexing",
      "path": "/home/paul/kgfoundry/codeintel_rev/indexing/__init__.py",
      "is_test": false,
      "imports": [],
      "public_api": [],
      "doc": {
        "module_doc": true,
        "class_total": 0,
        "class_with_doc": 0,
        "func_total": 0,
        "func_with_doc": 0
      },
      "typing": {
        "functions": 0,
        "annotated_returns": 0,
        "total_params": 0,
        "annotated_params": 0
      },
      "complexity": {
        "branch_points": 0,
        "max_nesting": 0
      },
      "loc": 1,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [],
        "type_checking_imports": [],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [],
      "raises": {}
    },
    {
      "module": "indexing.cast_chunker",
      "path": "/home/paul/kgfoundry/codeintel_rev/indexing/cast_chunker.py",
      "is_test": false,
      "imports": [
        "__future__.annotations",
        "bisect.bisect_right",
        "collections.abc.Sequence",
        "dataclasses.dataclass",
        "dataclasses.replace",
        "pathlib.Path",
        "typing.TYPE_CHECKING",
        "codeintel_rev.indexing.scip_reader.Range",
        "codeintel_rev.indexing.scip_reader.SymbolDef"
      ],
      "public_api": [
        "Chunk",
        "chunk_file",
        "line_starts",
        "range_to_bytes"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 6,
        "class_with_doc": 6,
        "func_total": 18,
        "func_with_doc": 8
      },
      "typing": {
        "functions": 18,
        "annotated_returns": 18,
        "total_params": 45,
        "annotated_params": 35
      },
      "complexity": {
        "branch_points": 36,
        "max_nesting": 5
      },
      "loc": 532,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "bisect.bisect_right",
          "collections.abc.Sequence",
          "dataclasses.dataclass",
          "dataclasses.replace",
          "pathlib.Path",
          "typing.TYPE_CHECKING"
        ],
        "type_checking_imports": [
          "codeintel_rev.indexing.scip_reader.Range",
          "codeintel_rev.indexing.scip_reader.SymbolDef"
        ],
        "exports": [
          "Chunk",
          "chunk_file",
          "line_starts",
          "range_to_bytes"
        ],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [
        "Chunk",
        "chunk_file",
        "line_starts",
        "range_to_bytes"
      ],
      "public_api_details": [
        {
          "name": "Chunk",
          "kind": "class",
          "signature": "class Chunk",
          "doc_one_liner": "Code chunk with precise byte and line bounds.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/indexing/cast_chunker.py:21"
        },
        {
          "name": "line_starts",
          "kind": "function",
          "signature": "line_starts(text: str) -> LineIndex",
          "doc_one_liner": "Compute character and byte offsets for each line start.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/indexing/cast_chunker.py:122"
        },
        {
          "name": "range_to_bytes",
          "kind": "function",
          "signature": "range_to_bytes(text: str, line_index: LineIndex, rng: Range) -> tuple[int, int]",
          "doc_one_liner": "Convert line/character range to byte offsets.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/indexing/cast_chunker.py:198"
        },
        {
          "name": "chunk_file",
          "kind": "function",
          "signature": "chunk_file(path: Path, text: str, definitions: list[SymbolDef], *, options: ChunkOptions | None = None, budget: int | None = None) -> list[Chunk]",
          "doc_one_liner": "Chunk file using SCIP symbol boundaries.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/indexing/cast_chunker.py:358"
        }
      ],
      "raises": {}
    },
    {
      "module": "io.rrf",
      "path": "/home/paul/kgfoundry/codeintel_rev/io/rrf.py",
      "is_test": false,
      "imports": [
        "__future__.annotations",
        "collections.abc.Mapping",
        "collections.abc.Sequence",
        "typing.Literal",
        "codeintel_rev.retrieval.fusion.fuse_weighted_rrf",
        "codeintel_rev.retrieval.types.ChannelHit"
      ],
      "public_api": [
        "weighted_rrf"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 0,
        "class_with_doc": 0,
        "func_total": 3,
        "func_with_doc": 2
      },
      "typing": {
        "functions": 3,
        "annotated_returns": 3,
        "total_params": 8,
        "annotated_params": 8
      },
      "complexity": {
        "branch_points": 8,
        "max_nesting": 3
      },
      "loc": 162,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "codeintel_rev.retrieval.fusion.fuse_weighted_rrf",
          "codeintel_rev.retrieval.types.ChannelHit",
          "collections.abc.Mapping",
          "collections.abc.Sequence",
          "typing.Literal"
        ],
        "type_checking_imports": [],
        "exports": [
          "weighted_rrf"
        ],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 4,
      "has_tests": true,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "weighted_rrf",
          "kind": "function",
          "signature": "weighted_rrf(channels: Mapping[str, Sequence[tuple[int, float]]], *, weights: Mapping[str, float], k: int, top_k: int, normalize: Literal['none', 'minmax', 'z'] = 'none') -> tuple[list[int], dict[int, list[tuple[str, int, float]]], dict[int, float]]",
          "doc_one_liner": "Apply weighted Reciprocal Rank Fusion to channel hits.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/io/rrf.py:12"
        }
      ],
      "raises": {
        "weighted_rrf": [
          "ValueError"
        ],
        "_to_int": [
          "ValueError"
        ]
      }
    },
    {
      "module": "io.path_utils",
      "path": "/home/paul/kgfoundry/codeintel_rev/io/path_utils.py",
      "is_test": false,
      "imports": [
        "__future__.annotations",
        "pathlib.Path"
      ],
      "public_api": [
        "PathOutsideRepositoryError",
        "resolve_within_repo"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 1,
        "class_with_doc": 1,
        "func_total": 1,
        "func_with_doc": 1
      },
      "typing": {
        "functions": 1,
        "annotated_returns": 1,
        "total_params": 3,
        "annotated_params": 3
      },
      "complexity": {
        "branch_points": 4,
        "max_nesting": 2
      },
      "loc": 54,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "pathlib.Path"
        ],
        "type_checking_imports": [],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 4,
      "has_tests": true,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "PathOutsideRepositoryError",
          "kind": "class",
          "signature": "class PathOutsideRepositoryError(ValueError)",
          "doc_one_liner": "Raised when a path escapes the configured repository root.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/io/path_utils.py:8"
        },
        {
          "name": "resolve_within_repo",
          "kind": "function",
          "signature": "resolve_within_repo(repo_root: Path, target: str | Path, *, allow_nonexistent: bool = True) -> Path",
          "doc_one_liner": "Resolve ``target`` against ``repo_root`` and ensure it stays within bounds.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/io/path_utils.py:12"
        }
      ],
      "raises": {
        "resolve_within_repo": [
          "FileNotFoundError",
          "PathOutsideRepositoryError"
        ]
      }
    },
    {
      "module": "io.coderank_embedder",
      "path": "/home/paul/kgfoundry/codeintel_rev/io/coderank_embedder.py",
      "is_test": false,
      "imports": [
        "__future__.annotations",
        "threading",
        "collections.abc.Iterable",
        "typing.TYPE_CHECKING",
        "typing.ClassVar",
        "typing.Protocol",
        "typing.cast",
        "codeintel_rev._lazy_imports.LazyModule",
        "codeintel_rev.typing.NDArrayF32",
        "codeintel_rev.typing.gate_import",
        "kgfoundry_common.logging.get_logger",
        "numpy",
        "sentence_transformers.SentenceTransformer"
      ],
      "public_api": [
        "SupportsCodeRankSettings",
        "CodeRankEmbedder"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 2,
        "class_with_doc": 2,
        "func_total": 10,
        "func_with_doc": 9
      },
      "typing": {
        "functions": 10,
        "annotated_returns": 10,
        "total_params": 13,
        "annotated_params": 3
      },
      "complexity": {
        "branch_points": 8,
        "max_nesting": 4
      },
      "loc": 174,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "codeintel_rev._lazy_imports.LazyModule",
          "codeintel_rev.typing.NDArrayF32",
          "codeintel_rev.typing.gate_import",
          "collections.abc.Iterable",
          "kgfoundry_common.logging.get_logger",
          "threading",
          "typing.ClassVar",
          "typing.Protocol",
          "typing.TYPE_CHECKING",
          "typing.cast"
        ],
        "type_checking_imports": [
          "np",
          "sentence_transformers.SentenceTransformer"
        ],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 4,
      "has_tests": true,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "SupportsCodeRankSettings",
          "kind": "class",
          "signature": "class SupportsCodeRankSettings(Protocol)",
          "doc_one_liner": "Protocol describing the minimal settings required by the embedder.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/io/coderank_embedder.py:20"
        },
        {
          "name": "CodeRankEmbedder",
          "kind": "class",
          "signature": "class CodeRankEmbedder",
          "doc_one_liner": "Encode queries or code snippets with the CodeRank bi-encoder.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/io/coderank_embedder.py:57"
        }
      ],
      "raises": {
        "encode_queries": [
          "ValueError"
        ],
        "encode_codes": [
          "ValueError"
        ],
        "_ensure_model": [
          "RuntimeError"
        ]
      }
    },
    {
      "module": "io.vllm_engine",
      "path": "/home/paul/kgfoundry/codeintel_rev/io/vllm_engine.py",
      "is_test": false,
      "imports": [
        "__future__.annotations",
        "os",
        "collections.abc.Sequence",
        "dataclasses.dataclass",
        "dataclasses.field",
        "typing.TYPE_CHECKING",
        "typing.Any",
        "typing.cast",
        "codeintel_rev._lazy_imports.LazyModule",
        "codeintel_rev.runtime.RuntimeCell",
        "codeintel_rev.typing.NDArrayF32",
        "kgfoundry_common.logging.get_logger",
        "numpy",
        "transformers",
        "vllm",
        "vllm.config",
        "vllm.inputs",
        "transformers.PreTrainedTokenizerBase",
        "vllm.LLM",
        "vllm.config.PoolerConfig",
        "vllm.inputs.TokensPrompt",
        "codeintel_rev.config.settings.VLLMConfig"
      ],
      "public_api": [
        "InprocessVLLMEmbedder"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 2,
        "class_with_doc": 2,
        "func_total": 9,
        "func_with_doc": 4
      },
      "typing": {
        "functions": 9,
        "annotated_returns": 9,
        "total_params": 10,
        "annotated_params": 1
      },
      "complexity": {
        "branch_points": 12,
        "max_nesting": 5
      },
      "loc": 213,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "codeintel_rev._lazy_imports.LazyModule",
          "codeintel_rev.runtime.RuntimeCell",
          "codeintel_rev.typing.NDArrayF32",
          "collections.abc.Sequence",
          "dataclasses.dataclass",
          "dataclasses.field",
          "kgfoundry_common.logging.get_logger",
          "os",
          "typing.Any",
          "typing.TYPE_CHECKING",
          "typing.cast"
        ],
        "type_checking_imports": [
          "codeintel_rev.config.settings.VLLMConfig",
          "np",
          "transformers",
          "transformers.PreTrainedTokenizerBase",
          "vllm",
          "vllm.LLM",
          "vllm.config.PoolerConfig",
          "vllm.inputs.TokensPrompt",
          "vllm_config",
          "vllm_inputs"
        ],
        "exports": [
          "InprocessVLLMEmbedder"
        ],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 4,
      "has_tests": true,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "InprocessVLLMEmbedder",
          "kind": "class",
          "signature": "class InprocessVLLMEmbedder",
          "doc_one_liner": "Embed text batches locally using vLLM.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/io/vllm_engine.py:60"
        }
      ],
      "raises": {
        "embed_batch": [
          "RuntimeError"
        ],
        "_runtime": [
          "RuntimeError"
        ]
      }
    },
    {
      "module": "io.symbol_catalog",
      "path": "/home/paul/kgfoundry/codeintel_rev/io/symbol_catalog.py",
      "is_test": false,
      "imports": [
        "__future__.annotations",
        "collections.abc.Iterable",
        "collections.abc.Sequence",
        "dataclasses.dataclass",
        "codeintel_rev.io.duckdb_manager.DuckDBManager"
      ],
      "public_api": [
        "SymbolDefRow",
        "SymbolOccurrenceRow",
        "SymbolCatalog"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 3,
        "class_with_doc": 3,
        "func_total": 5,
        "func_with_doc": 4
      },
      "typing": {
        "functions": 5,
        "annotated_returns": 5,
        "total_params": 9,
        "annotated_params": 4
      },
      "complexity": {
        "branch_points": 9,
        "max_nesting": 4
      },
      "loc": 162,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "codeintel_rev.io.duckdb_manager.DuckDBManager",
          "collections.abc.Iterable",
          "collections.abc.Sequence",
          "dataclasses.dataclass"
        ],
        "type_checking_imports": [],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 4,
      "has_tests": true,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "SymbolDefRow",
          "kind": "class",
          "signature": "class SymbolDefRow",
          "doc_one_liner": "Immutable row describing a symbol definition.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/io/symbol_catalog.py:12"
        },
        {
          "name": "SymbolOccurrenceRow",
          "kind": "class",
          "signature": "class SymbolOccurrenceRow",
          "doc_one_liner": "Service row for individual symbol occurrences.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/io/symbol_catalog.py:30"
        },
        {
          "name": "SymbolCatalog",
          "kind": "class",
          "signature": "class SymbolCatalog",
          "doc_one_liner": "Writer for symbol metadata tables alongside `chunks`.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/io/symbol_catalog.py:45"
        }
      ],
      "raises": {}
    },
    {
      "module": "io.splade_manager",
      "path": "/home/paul/kgfoundry/codeintel_rev/io/splade_manager.py",
      "is_test": false,
      "imports": [
        "__future__.annotations",
        "importlib",
        "json",
        "logging",
        "math",
        "os",
        "shutil",
        "statistics",
        "sys",
        "collections.abc.Iterable",
        "collections.abc.Sequence",
        "dataclasses.dataclass",
        "datetime.UTC",
        "datetime.datetime",
        "pathlib.Path",
        "time.perf_counter",
        "typing.TYPE_CHECKING",
        "typing.TextIO",
        "typing.cast",
        "msgspec",
        "codeintel_rev.io.path_utils.resolve_within_repo",
        "kgfoundry_common.subprocess_utils.run_subprocess",
        "typing.Protocol",
        "codeintel_rev.config.settings.Settings",
        "sentence_transformers.SparseEncoder",
        "sentence_transformers.export_dynamic_quantized_onnx_model",
        "sentence_transformers.export_optimized_onnx_model"
      ],
      "public_api": [
        "SpladeArtifactMetadata",
        "SpladeArtifactsManager",
        "SpladeBuildOptions",
        "SpladeEncodeOptions",
        "SpladeEncodingMetadata",
        "SpladeEncodingSummary",
        "SpladeExportOptions",
        "SpladeExportSummary",
        "SpladeIndexManager",
        "SpladeIndexMetadata"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 18,
        "class_with_doc": 15,
        "func_total": 36,
        "func_with_doc": 20
      },
      "typing": {
        "functions": 36,
        "annotated_returns": 36,
        "total_params": 83,
        "annotated_params": 63
      },
      "complexity": {
        "branch_points": 75,
        "max_nesting": 4
      },
      "loc": 1282,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "codeintel_rev.io.path_utils.resolve_within_repo",
          "collections.abc.Iterable",
          "collections.abc.Sequence",
          "dataclasses.dataclass",
          "datetime.UTC",
          "datetime.datetime",
          "importlib",
          "json",
          "kgfoundry_common.subprocess_utils.run_subprocess",
          "logging",
          "math",
          "msgspec",
          "os",
          "pathlib.Path",
          "sentence_transformers.SparseEncoder",
          "sentence_transformers.export_dynamic_quantized_onnx_model",
          "sentence_transformers.export_optimized_onnx_model",
          "shutil",
          "statistics",
          "sys",
          "time.perf_counter",
          "typing.TYPE_CHECKING",
          "typing.TextIO",
          "typing.cast"
        ],
        "type_checking_imports": [
          "codeintel_rev.config.settings.Settings",
          "typing.Protocol"
        ],
        "exports": [
          "SpladeArtifactMetadata",
          "SpladeArtifactsManager",
          "SpladeBuildOptions",
          "SpladeEncodeOptions",
          "SpladeEncodingMetadata",
          "SpladeEncodingSummary",
          "SpladeExportOptions",
          "SpladeExportSummary",
          "SpladeIndexManager",
          "SpladeIndexMetadata"
        ],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 4,
      "has_tests": true,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "SpladeArtifactMetadata",
          "kind": "class",
          "signature": "class SpladeArtifactMetadata(msgspec.Struct)",
          "doc_one_liner": "Metadata describing exported SPLADE ONNX artifacts.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/io/splade_manager.py:90"
        },
        {
          "name": "SpladeExportSummary",
          "kind": "class",
          "signature": "class SpladeExportSummary(msgspec.Struct)",
          "doc_one_liner": "Summary returned after exporting SPLADE artifacts.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/io/splade_manager.py:105"
        },
        {
          "name": "SpladeEncodingMetadata",
          "kind": "class",
          "signature": "class SpladeEncodingMetadata(msgspec.Struct)",
          "doc_one_liner": "Metadata describing SPLADE vector encoding runs.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/io/splade_manager.py:112"
        },
        {
          "name": "SpladeEncodingSummary",
          "kind": "class",
          "signature": "class SpladeEncodingSummary(msgspec.Struct)",
          "doc_one_liner": "Summary describing SPLADE encoding output.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/io/splade_manager.py:126"
        },
        {
          "name": "SpladeExportOptions",
          "kind": "class",
          "signature": "class SpladeExportOptions(msgspec.Struct)",
          "doc_one_liner": "Options controlling SPLADE ONNX export behaviour.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/io/splade_manager.py:160"
        },
        {
          "name": "SpladeEncodeOptions",
          "kind": "class",
          "signature": "class SpladeEncodeOptions(msgspec.Struct)",
          "doc_one_liner": "Options controlling SPLADE corpus encoding.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/io/splade_manager.py:171"
        },
        {
          "name": "SpladeBuildOptions",
          "kind": "class",
          "signature": "class SpladeBuildOptions(msgspec.Struct)",
          "doc_one_liner": "Options controlling SPLADE Lucene impact index builds.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/io/splade_manager.py:182"
        },
        {
          "name": "SpladeIndexMetadata",
          "kind": "class",
          "signature": "class SpladeIndexMetadata(msgspec.Struct)",
          "doc_one_liner": "Metadata describing a SPLADE Lucene impact index.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/io/splade_manager.py:192"
        },
        {
          "name": "SpladeArtifactsManager",
          "kind": "class",
          "signature": "class SpladeArtifactsManager",
          "doc_one_liner": "Manage SPLADE model exports and ONNX artifacts.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/io/splade_manager.py:770"
        },
        {
          "name": "SpladeIndexManager",
          "kind": "class",
          "signature": "class SpladeIndexManager",
          "doc_one_liner": "Build SPLADE Lucene impact indexes from vector collections.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/io/splade_manager.py:1133"
        }
      ],
      "raises": {
        "_require_sparse_encoder": [
          "RuntimeError"
        ],
        "_require_export_helpers": [
          "RuntimeError"
        ],
        "_percentile_value": [
          "ValueError"
        ],
        "_flush_batch": [
          "RuntimeError"
        ],
        "_encode_records": [
          "TypeError"
        ],
        "encode_corpus": [
          "TypeError"
        ],
        "benchmark_queries": [
          "ValueError"
        ],
        "build_index": [
          "FileExistsError"
        ]
      }
    },
    {
      "module": "io.vllm_client",
      "path": "/home/paul/kgfoundry/codeintel_rev/io/vllm_client.py",
      "is_test": false,
      "imports": [
        "__future__.annotations",
        "asyncio",
        "functools.lru_cache",
        "importlib.import_module",
        "types.ModuleType",
        "typing.TYPE_CHECKING",
        "typing.cast",
        "msgspec",
        "codeintel_rev._lazy_imports.LazyModule",
        "codeintel_rev.typing.NDArrayF32",
        "codeintel_rev.typing.gate_import",
        "kgfoundry_common.logging.get_logger",
        "collections.abc.Sequence",
        "httpx",
        "numpy",
        "codeintel_rev.config.settings.VLLMConfig",
        "codeintel_rev.io.vllm_engine.InprocessVLLMEmbedder"
      ],
      "public_api": [
        "EmbeddingData",
        "EmbeddingRequest",
        "EmbeddingResponse",
        "VLLMClient"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 4,
        "class_with_doc": 4,
        "func_total": 14,
        "func_with_doc": 7
      },
      "typing": {
        "functions": 14,
        "annotated_returns": 14,
        "total_params": 21,
        "annotated_params": 8
      },
      "complexity": {
        "branch_points": 25,
        "max_nesting": 5
      },
      "loc": 568,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "asyncio",
          "codeintel_rev._lazy_imports.LazyModule",
          "codeintel_rev.typing.NDArrayF32",
          "codeintel_rev.typing.gate_import",
          "functools.lru_cache",
          "importlib.import_module",
          "kgfoundry_common.logging.get_logger",
          "msgspec",
          "types.ModuleType",
          "typing.TYPE_CHECKING",
          "typing.cast"
        ],
        "type_checking_imports": [
          "codeintel_rev.config.settings.VLLMConfig",
          "codeintel_rev.io.vllm_engine.InprocessVLLMEmbedder",
          "collections.abc.Sequence",
          "httpx",
          "np"
        ],
        "exports": [
          "EmbeddingData",
          "EmbeddingRequest",
          "EmbeddingResponse",
          "VLLMClient"
        ],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 4,
      "has_tests": true,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "EmbeddingRequest",
          "kind": "class",
          "signature": "class EmbeddingRequest(msgspec.Struct)",
          "doc_one_liner": "OpenAI-compatible embedding request payload.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/io/vllm_client.py:71"
        },
        {
          "name": "EmbeddingData",
          "kind": "class",
          "signature": "class EmbeddingData(msgspec.Struct)",
          "doc_one_liner": "Single embedding result from a batch request.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/io/vllm_client.py:99"
        },
        {
          "name": "EmbeddingResponse",
          "kind": "class",
          "signature": "class EmbeddingResponse(msgspec.Struct)",
          "doc_one_liner": "OpenAI-compatible embedding response payload.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/io/vllm_client.py:124"
        },
        {
          "name": "VLLMClient",
          "kind": "class",
          "signature": "class VLLMClient",
          "doc_one_liner": "vLLM embedding client supporting HTTP or in-process execution.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/io/vllm_client.py:155"
        }
      ],
      "raises": {
        "embed_single": [
          "RuntimeError"
        ],
        "_embed_batch_async_local": [
          "RuntimeError"
        ],
        "_require_http_client": [
          "RuntimeError"
        ]
      }
    },
    {
      "module": "io.parquet_store",
      "path": "/home/paul/kgfoundry/codeintel_rev/io/parquet_store.py",
      "is_test": false,
      "imports": [
        "__future__.annotations",
        "dataclasses.dataclass",
        "pathlib.Path",
        "typing.TYPE_CHECKING",
        "typing.cast",
        "pyarrow",
        "pyarrow.parquet",
        "codeintel_rev._lazy_imports.LazyModule",
        "codeintel_rev.typing.NDArrayF32",
        "collections.abc.Sequence",
        "numpy",
        "codeintel_rev.indexing.cast_chunker.Chunk"
      ],
      "public_api": [
        "ParquetWriteOptions",
        "extract_embeddings",
        "get_chunks_schema",
        "read_chunks_parquet",
        "write_chunks_parquet"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 1,
        "class_with_doc": 1,
        "func_total": 4,
        "func_with_doc": 4
      },
      "typing": {
        "functions": 4,
        "annotated_returns": 4,
        "total_params": 7,
        "annotated_params": 7
      },
      "complexity": {
        "branch_points": 4,
        "max_nesting": 2
      },
      "loc": 198,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "codeintel_rev._lazy_imports.LazyModule",
          "codeintel_rev.typing.NDArrayF32",
          "dataclasses.dataclass",
          "pa",
          "pathlib.Path",
          "pq",
          "typing.TYPE_CHECKING",
          "typing.cast"
        ],
        "type_checking_imports": [
          "codeintel_rev.indexing.cast_chunker.Chunk",
          "collections.abc.Sequence",
          "np"
        ],
        "exports": [
          "ParquetWriteOptions",
          "extract_embeddings",
          "get_chunks_schema",
          "read_chunks_parquet",
          "write_chunks_parquet"
        ],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 4,
      "has_tests": true,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "get_chunks_schema",
          "kind": "function",
          "signature": "get_chunks_schema(vec_dim: int) -> pa.Schema",
          "doc_one_liner": "Get Arrow schema for chunks table.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/io/parquet_store.py:29"
        },
        {
          "name": "ParquetWriteOptions",
          "kind": "class",
          "signature": "class ParquetWriteOptions",
          "doc_one_liner": "Configuration for Parquet persistence.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/io/parquet_store.py:59"
        },
        {
          "name": "write_chunks_parquet",
          "kind": "function",
          "signature": "write_chunks_parquet(output_path: Path, chunks: Sequence[Chunk], embeddings: NDArrayF32, *, options: ParquetWriteOptions | None = None) -> None",
          "doc_one_liner": "Write chunks and embeddings to Parquet.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/io/parquet_store.py:67"
        },
        {
          "name": "read_chunks_parquet",
          "kind": "function",
          "signature": "read_chunks_parquet(parquet_path: Path) -> pa.Table",
          "doc_one_liner": "Read chunks from Parquet file.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/io/parquet_store.py:145"
        },
        {
          "name": "extract_embeddings",
          "kind": "function",
          "signature": "extract_embeddings(table: pa.Table) -> NDArrayF32",
          "doc_one_liner": "Extract embeddings from chunks table.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/io/parquet_store.py:161"
        }
      ],
      "raises": {
        "write_chunks_parquet": [
          "ValueError"
        ],
        "extract_embeddings": [
          "TypeError"
        ]
      }
    },
    {
      "module": "io.duckdb_manager",
      "path": "/home/paul/kgfoundry/codeintel_rev/io/duckdb_manager.py",
      "is_test": false,
      "imports": [
        "__future__.annotations",
        "collections.abc.Iterator",
        "collections.abc.Sequence",
        "contextlib.contextmanager",
        "contextlib.suppress",
        "dataclasses.dataclass",
        "pathlib.Path",
        "queue.Empty",
        "queue.Full",
        "queue.LifoQueue",
        "threading.Lock",
        "typing.TYPE_CHECKING",
        "typing.cast",
        "codeintel_rev._lazy_imports.LazyModule",
        "duckdb"
      ],
      "public_api": [
        "DuckDBConfig",
        "DuckDBManager",
        "DuckDBQueryBuilder",
        "DuckDBQueryOptions"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 4,
        "class_with_doc": 4,
        "func_total": 13,
        "func_with_doc": 7
      },
      "typing": {
        "functions": 13,
        "annotated_returns": 13,
        "total_params": 23,
        "annotated_params": 11
      },
      "complexity": {
        "branch_points": 42,
        "max_nesting": 5
      },
      "loc": 346,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "codeintel_rev._lazy_imports.LazyModule",
          "collections.abc.Iterator",
          "collections.abc.Sequence",
          "contextlib.contextmanager",
          "contextlib.suppress",
          "dataclasses.dataclass",
          "pathlib.Path",
          "queue.Empty",
          "queue.Full",
          "queue.LifoQueue",
          "threading.Lock",
          "typing.TYPE_CHECKING",
          "typing.cast"
        ],
        "type_checking_imports": [
          "duckdb"
        ],
        "exports": [
          "DuckDBConfig",
          "DuckDBManager",
          "DuckDBQueryBuilder",
          "DuckDBQueryOptions"
        ],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 4,
      "has_tests": true,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "DuckDBConfig",
          "kind": "class",
          "signature": "class DuckDBConfig",
          "doc_one_liner": "Configuration parameters controlling DuckDB connections.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/io/duckdb_manager.py:24"
        },
        {
          "name": "DuckDBManager",
          "kind": "class",
          "signature": "class DuckDBManager",
          "doc_one_liner": "Factory for DuckDB connections with consistent pragmas.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/io/duckdb_manager.py:52"
        },
        {
          "name": "DuckDBQueryOptions",
          "kind": "class",
          "signature": "class DuckDBQueryOptions",
          "doc_one_liner": "Options controlling DuckDB query generation.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/io/duckdb_manager.py:172"
        },
        {
          "name": "DuckDBQueryBuilder",
          "kind": "class",
          "signature": "class DuckDBQueryBuilder",
          "doc_one_liner": "Helper for building parameterized DuckDB queries with scope filters.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/io/duckdb_manager.py:182"
        }
      ],
      "raises": {
        "build_filter_query": [
          "ValueError"
        ]
      }
    },
    {
      "module": "io.xtr_manager",
      "path": "/home/paul/kgfoundry/codeintel_rev/io/xtr_manager.py",
      "is_test": false,
      "imports": [
        "__future__.annotations",
        "json",
        "collections.abc.Iterable",
        "dataclasses.dataclass",
        "dataclasses.field",
        "pathlib.Path",
        "typing.TYPE_CHECKING",
        "typing.Any",
        "typing.Literal",
        "typing.Protocol",
        "typing.TypedDict",
        "typing.cast",
        "codeintel_rev._lazy_imports.LazyModule",
        "codeintel_rev.config.settings.XTRConfig",
        "codeintel_rev.runtime.RuntimeCell",
        "codeintel_rev.typing.NDArrayF32",
        "codeintel_rev.typing.gate_import",
        "kgfoundry_common.logging.get_logger",
        "numpy"
      ],
      "public_api": [
        "XTRMetadata",
        "XTRIndex",
        "TorchDeviceModule"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 5,
        "class_with_doc": 4,
        "func_total": 20,
        "func_with_doc": 15
      },
      "typing": {
        "functions": 20,
        "annotated_returns": 20,
        "total_params": 37,
        "annotated_params": 19
      },
      "complexity": {
        "branch_points": 48,
        "max_nesting": 5
      },
      "loc": 630,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "codeintel_rev._lazy_imports.LazyModule",
          "codeintel_rev.config.settings.XTRConfig",
          "codeintel_rev.runtime.RuntimeCell",
          "codeintel_rev.typing.NDArrayF32",
          "codeintel_rev.typing.gate_import",
          "collections.abc.Iterable",
          "dataclasses.dataclass",
          "dataclasses.field",
          "json",
          "kgfoundry_common.logging.get_logger",
          "pathlib.Path",
          "typing.Any",
          "typing.Literal",
          "typing.Protocol",
          "typing.TYPE_CHECKING",
          "typing.TypedDict",
          "typing.cast"
        ],
        "type_checking_imports": [
          "np"
        ],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 4,
      "has_tests": true,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "XTRMetadata",
          "kind": "class",
          "signature": "class XTRMetadata(TypedDict)",
          "doc_one_liner": "Metadata persisted alongside the token memmap.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/io/xtr_manager.py:25"
        },
        {
          "name": "XTRIndex",
          "kind": "class",
          "signature": "class XTRIndex",
          "doc_one_liner": "Memory-mapped XTR token index with query encoding + scoring helpers.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/io/xtr_manager.py:61"
        },
        {
          "name": "TorchDeviceModule",
          "kind": "class",
          "signature": "class TorchDeviceModule(Protocol)",
          "doc_one_liner": "Subset of torch API required for device resolution.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/io/xtr_manager.py:619"
        }
      ],
      "raises": {
        "_slice_chunk": [
          "KeyError",
          "RuntimeError"
        ]
      }
    },
    {
      "module": "io.hybrid_search",
      "path": "/home/paul/kgfoundry/codeintel_rev/io/hybrid_search.py",
      "is_test": false,
      "imports": [
        "__future__.annotations",
        "collections.abc.Mapping",
        "collections.abc.Sequence",
        "importlib.import_module",
        "pathlib.Path",
        "threading.Lock",
        "typing.TYPE_CHECKING",
        "codeintel_rev.retrieval.fusion.fuse_weighted_rrf",
        "codeintel_rev.retrieval.types.ChannelHit",
        "codeintel_rev.retrieval.types.HybridResultDoc",
        "codeintel_rev.retrieval.types.HybridSearchResult",
        "kgfoundry_common.logging.get_logger",
        "codeintel_rev.app.config_context.ResolvedPaths",
        "codeintel_rev.config.settings.Settings",
        "codeintel_rev.config.settings.SpladeConfig"
      ],
      "public_api": [
        "BM25SearchProvider",
        "ChannelHit",
        "HybridResultDoc",
        "HybridSearchEngine",
        "HybridSearchResult",
        "SpladeSearchProvider"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 3,
        "class_with_doc": 3,
        "func_total": 17,
        "func_with_doc": 7
      },
      "typing": {
        "functions": 17,
        "annotated_returns": 17,
        "total_params": 48,
        "annotated_params": 32
      },
      "complexity": {
        "branch_points": 48,
        "max_nesting": 5
      },
      "loc": 538,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "codeintel_rev.retrieval.fusion.fuse_weighted_rrf",
          "codeintel_rev.retrieval.types.ChannelHit",
          "codeintel_rev.retrieval.types.HybridResultDoc",
          "codeintel_rev.retrieval.types.HybridSearchResult",
          "collections.abc.Mapping",
          "collections.abc.Sequence",
          "importlib.import_module",
          "kgfoundry_common.logging.get_logger",
          "pathlib.Path",
          "threading.Lock",
          "typing.TYPE_CHECKING"
        ],
        "type_checking_imports": [
          "codeintel_rev.app.config_context.ResolvedPaths",
          "codeintel_rev.config.settings.Settings",
          "codeintel_rev.config.settings.SpladeConfig"
        ],
        "exports": [
          "BM25SearchProvider",
          "ChannelHit",
          "HybridResultDoc",
          "HybridSearchEngine",
          "HybridSearchResult",
          "SpladeSearchProvider"
        ],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 4,
      "has_tests": true,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "BM25SearchProvider",
          "kind": "class",
          "signature": "class BM25SearchProvider",
          "doc_one_liner": "Thin wrapper around Pyserini's LuceneSearcher for BM25 retrieval.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/io/hybrid_search.py:26"
        },
        {
          "name": "SpladeSearchProvider",
          "kind": "class",
          "signature": "class SpladeSearchProvider",
          "doc_one_liner": "SPLADE query encoder and Lucene impact searcher for learned sparse retrieval.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/io/hybrid_search.py:100"
        },
        {
          "name": "HybridSearchEngine",
          "kind": "class",
          "signature": "class HybridSearchEngine",
          "doc_one_liner": "Combine dense (FAISS) and sparse channels (BM25, SPLADE) via RRF.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/io/hybrid_search.py:227"
        }
      ],
      "raises": {
        "__init__": [
          "FileNotFoundError"
        ]
      }
    },
    {
      "module": "io.warp_engine",
      "path": "/home/paul/kgfoundry/codeintel_rev/io/warp_engine.py",
      "is_test": false,
      "imports": [
        "__future__.annotations",
        "collections.abc.Callable",
        "collections.abc.Sequence",
        "pathlib.Path",
        "typing.TYPE_CHECKING",
        "typing.cast",
        "codeintel_rev.typing.gate_import",
        "kgfoundry_common.logging.get_logger",
        "types.ModuleType"
      ],
      "public_api": [
        "WarpUnavailableError",
        "WarpEngine"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 2,
        "class_with_doc": 2,
        "func_total": 7,
        "func_with_doc": 5
      },
      "typing": {
        "functions": 7,
        "annotated_returns": 7,
        "total_params": 13,
        "annotated_params": 9
      },
      "complexity": {
        "branch_points": 18,
        "max_nesting": 4
      },
      "loc": 194,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "codeintel_rev.typing.gate_import",
          "collections.abc.Callable",
          "collections.abc.Sequence",
          "kgfoundry_common.logging.get_logger",
          "pathlib.Path",
          "typing.TYPE_CHECKING",
          "typing.cast"
        ],
        "type_checking_imports": [
          "types.ModuleType"
        ],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 4,
      "has_tests": true,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "WarpUnavailableError",
          "kind": "class",
          "signature": "class WarpUnavailableError(RuntimeError)",
          "doc_one_liner": "Raised when the WARP executor or index artifacts are missing.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/io/warp_engine.py:20"
        },
        {
          "name": "WarpEngine",
          "kind": "class",
          "signature": "class WarpEngine",
          "doc_one_liner": "Encapsulates interactions with the optional ``xtr-warp`` executor.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/io/warp_engine.py:24"
        }
      ],
      "raises": {
        "__init__": [
          "WarpUnavailableError"
        ],
        "rerank": [
          "WarpUnavailableError"
        ],
        "_load_executor_cls": [
          "WarpUnavailableError"
        ],
        "_ensure_executor": [
          "WarpUnavailableError"
        ]
      }
    },
    {
      "module": "io.faiss_manager",
      "path": "/home/paul/kgfoundry/codeintel_rev/io/faiss_manager.py",
      "is_test": false,
      "imports": [
        "__future__.annotations",
        "importlib",
        "collections.abc.Callable",
        "pathlib.Path",
        "types.ModuleType",
        "typing.TYPE_CHECKING",
        "typing.Any",
        "typing.cast",
        "codeintel_rev._lazy_imports.LazyModule",
        "codeintel_rev.typing.NDArrayF32",
        "codeintel_rev.typing.NDArrayI64",
        "codeintel_rev.typing.gate_import",
        "kgfoundry_common.logging.get_logger",
        "faiss",
        "numpy"
      ],
      "public_api": [
        "FAISSManager"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 2,
        "class_with_doc": 2,
        "func_total": 39,
        "func_with_doc": 27
      },
      "typing": {
        "functions": 39,
        "annotated_returns": 39,
        "total_params": 67,
        "annotated_params": 43
      },
      "complexity": {
        "branch_points": 91,
        "max_nesting": 5
      },
      "loc": 1297,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "codeintel_rev._lazy_imports.LazyModule",
          "codeintel_rev.typing.NDArrayF32",
          "codeintel_rev.typing.NDArrayI64",
          "codeintel_rev.typing.gate_import",
          "collections.abc.Callable",
          "importlib",
          "kgfoundry_common.logging.get_logger",
          "pathlib.Path",
          "types.ModuleType",
          "typing.Any",
          "typing.TYPE_CHECKING",
          "typing.cast"
        ],
        "type_checking_imports": [
          "_faiss",
          "np"
        ],
        "exports": [
          "FAISSManager"
        ],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 4,
      "has_tests": true,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "FAISSManager",
          "kind": "class",
          "signature": "class FAISSManager",
          "doc_one_liner": "FAISS index manager with adaptive indexing, GPU support, and incremental updates.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/io/faiss_manager.py:117"
        }
      ],
      "raises": {
        "add_vectors": [
          "RuntimeError"
        ],
        "update_index": [
          "RuntimeError"
        ],
        "save_cpu_index": [
          "RuntimeError"
        ],
        "load_cpu_index": [
          "FileNotFoundError"
        ],
        "save_secondary_index": [
          "RuntimeError"
        ],
        "load_secondary_index": [
          "FileNotFoundError"
        ],
        "clone_to_gpu": [
          "RuntimeError"
        ],
        "search_primary": [
          "RuntimeError"
        ],
        "search_secondary": [
          "RuntimeError"
        ],
        "merge_indexes": [
          "RuntimeError"
        ],
        "_extract_all_vectors": [
          "RuntimeError",
          "TypeError"
        ],
        "_try_load_cuvs": [
          "ImportError",
          "RuntimeError"
        ],
        "_require_cpu_index": [
          "RuntimeError"
        ],
        "_active_index": [
          "RuntimeError"
        ]
      }
    },
    {
      "module": "io.faiss_dual_index",
      "path": "/home/paul/kgfoundry/codeintel_rev/io/faiss_dual_index.py",
      "is_test": false,
      "imports": [
        "__future__.annotations",
        "asyncio",
        "importlib",
        "json",
        "contextlib.suppress",
        "dataclasses.asdict",
        "dataclasses.dataclass",
        "pathlib.Path",
        "types.ModuleType",
        "typing.TYPE_CHECKING",
        "typing.cast",
        "codeintel_rev._lazy_imports.LazyModule",
        "codeintel_rev.typing.NDArrayF32",
        "codeintel_rev.typing.NDArrayI64",
        "kgfoundry_common.logging.get_logger",
        "faiss",
        "numpy",
        "codeintel_rev.config.settings.IndexConfig"
      ],
      "public_api": [
        "FAISSDualIndexManager",
        "IndexManifest"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 2,
        "class_with_doc": 2,
        "func_total": 26,
        "func_with_doc": 14
      },
      "typing": {
        "functions": 26,
        "annotated_returns": 26,
        "total_params": 49,
        "annotated_params": 24
      },
      "complexity": {
        "branch_points": 83,
        "max_nesting": 5
      },
      "loc": 644,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "asyncio",
          "codeintel_rev._lazy_imports.LazyModule",
          "codeintel_rev.typing.NDArrayF32",
          "codeintel_rev.typing.NDArrayI64",
          "contextlib.suppress",
          "dataclasses.asdict",
          "dataclasses.dataclass",
          "importlib",
          "json",
          "kgfoundry_common.logging.get_logger",
          "pathlib.Path",
          "types.ModuleType",
          "typing.TYPE_CHECKING",
          "typing.cast"
        ],
        "type_checking_imports": [
          "codeintel_rev.config.settings.IndexConfig",
          "faiss",
          "np"
        ],
        "exports": [
          "FAISSDualIndexManager",
          "IndexManifest"
        ],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 4,
      "has_tests": true,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "IndexManifest",
          "kind": "class",
          "signature": "class IndexManifest",
          "doc_one_liner": "Persisted metadata for FAISS dual-index deployments.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/io/faiss_dual_index.py:32"
        },
        {
          "name": "FAISSDualIndexManager",
          "kind": "class",
          "signature": "class FAISSDualIndexManager",
          "doc_one_liner": "Manage dual FAISS indexes with CPU/GPU coordination.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/io/faiss_dual_index.py:89"
        }
      ],
      "raises": {
        "from_file": [
          "TypeError",
          "ValueError"
        ],
        "search": [
          "RuntimeError",
          "ValueError"
        ],
        "add_incremental": [
          "RuntimeError",
          "ValueError"
        ],
        "_select_primary_index": [
          "RuntimeError"
        ]
      }
    },
    {
      "module": "io.duckdb_catalog",
      "path": "/home/paul/kgfoundry/codeintel_rev/io/duckdb_catalog.py",
      "is_test": false,
      "imports": [
        "__future__.annotations",
        "collections.abc.Iterator",
        "collections.abc.Sequence",
        "contextlib.contextmanager",
        "contextlib.suppress",
        "dataclasses.dataclass",
        "pathlib.Path",
        "threading.Lock",
        "time.perf_counter",
        "typing.TYPE_CHECKING",
        "typing.Self",
        "typing.cast",
        "codeintel_rev._lazy_imports.LazyModule",
        "codeintel_rev.io.duckdb_manager.DuckDBManager",
        "codeintel_rev.io.duckdb_manager.DuckDBQueryBuilder",
        "codeintel_rev.io.duckdb_manager.DuckDBQueryOptions",
        "codeintel_rev.mcp_server.scope_utils.LANGUAGE_EXTENSIONS",
        "codeintel_rev.mcp_server.scope_utils.path_matches_glob",
        "codeintel_rev.typing.NDArrayF32",
        "kgfoundry_common.logging.get_logger",
        "kgfoundry_common.prometheus.build_histogram",
        "duckdb",
        "numpy"
      ],
      "public_api": [
        "DuckDBCatalog"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 2,
        "class_with_doc": 2,
        "func_total": 27,
        "func_with_doc": 26
      },
      "typing": {
        "functions": 27,
        "annotated_returns": 27,
        "total_params": 61,
        "annotated_params": 40
      },
      "complexity": {
        "branch_points": 65,
        "max_nesting": 5
      },
      "loc": 895,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "codeintel_rev._lazy_imports.LazyModule",
          "codeintel_rev.io.duckdb_manager.DuckDBManager",
          "codeintel_rev.io.duckdb_manager.DuckDBQueryBuilder",
          "codeintel_rev.io.duckdb_manager.DuckDBQueryOptions",
          "codeintel_rev.mcp_server.scope_utils.LANGUAGE_EXTENSIONS",
          "codeintel_rev.mcp_server.scope_utils.path_matches_glob",
          "codeintel_rev.typing.NDArrayF32",
          "collections.abc.Iterator",
          "collections.abc.Sequence",
          "contextlib.contextmanager",
          "contextlib.suppress",
          "dataclasses.dataclass",
          "kgfoundry_common.logging.get_logger",
          "kgfoundry_common.prometheus.build_histogram",
          "pathlib.Path",
          "threading.Lock",
          "time.perf_counter",
          "typing.Self",
          "typing.TYPE_CHECKING",
          "typing.cast"
        ],
        "type_checking_imports": [
          "duckdb",
          "np"
        ],
        "exports": [
          "DuckDBCatalog"
        ],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 4,
      "has_tests": true,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "DuckDBCatalog",
          "kind": "class",
          "signature": "class DuckDBCatalog",
          "doc_one_liner": "DuckDB catalog for querying chunks.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/io/duckdb_catalog.py:80"
        }
      ],
      "raises": {}
    },
    {
      "module": "io.bm25_manager",
      "path": "/home/paul/kgfoundry/codeintel_rev/io/bm25_manager.py",
      "is_test": false,
      "imports": [
        "__future__.annotations",
        "importlib",
        "json",
        "logging",
        "shutil",
        "sys",
        "datetime.UTC",
        "datetime.datetime",
        "hashlib.sha256",
        "pathlib.Path",
        "typing.TYPE_CHECKING",
        "msgspec",
        "codeintel_rev.io.path_utils.resolve_within_repo",
        "kgfoundry_common.subprocess_utils.run_subprocess",
        "codeintel_rev.config.settings.Settings"
      ],
      "public_api": [
        "BM25BuildOptions",
        "BM25CorpusMetadata",
        "BM25CorpusSummary",
        "BM25IndexManager",
        "BM25IndexMetadata"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 5,
        "class_with_doc": 5,
        "func_total": 11,
        "func_with_doc": 10
      },
      "typing": {
        "functions": 11,
        "annotated_returns": 11,
        "total_params": 20,
        "annotated_params": 15
      },
      "complexity": {
        "branch_points": 34,
        "max_nesting": 5
      },
      "loc": 478,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "codeintel_rev.io.path_utils.resolve_within_repo",
          "datetime.UTC",
          "datetime.datetime",
          "hashlib.sha256",
          "importlib",
          "json",
          "kgfoundry_common.subprocess_utils.run_subprocess",
          "logging",
          "msgspec",
          "pathlib.Path",
          "shutil",
          "sys",
          "typing.TYPE_CHECKING"
        ],
        "type_checking_imports": [
          "codeintel_rev.config.settings.Settings"
        ],
        "exports": [
          "BM25BuildOptions",
          "BM25CorpusMetadata",
          "BM25CorpusSummary",
          "BM25IndexManager",
          "BM25IndexMetadata"
        ],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 4,
      "has_tests": true,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "BM25CorpusMetadata",
          "kind": "class",
          "signature": "class BM25CorpusMetadata(msgspec.Struct)",
          "doc_one_liner": "Metadata describing a prepared BM25 corpus.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/io/bm25_manager.py:30"
        },
        {
          "name": "BM25CorpusSummary",
          "kind": "class",
          "signature": "class BM25CorpusSummary(msgspec.Struct)",
          "doc_one_liner": "Summary information returned after preparing a corpus.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/io/bm25_manager.py:40"
        },
        {
          "name": "BM25IndexMetadata",
          "kind": "class",
          "signature": "class BM25IndexMetadata(msgspec.Struct)",
          "doc_one_liner": "Metadata describing a built BM25 index.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/io/bm25_manager.py:49"
        },
        {
          "name": "BM25BuildOptions",
          "kind": "class",
          "signature": "class BM25BuildOptions(msgspec.Struct)",
          "doc_one_liner": "Options controlling BM25 index builds.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/io/bm25_manager.py:63"
        },
        {
          "name": "BM25IndexManager",
          "kind": "class",
          "signature": "class BM25IndexManager",
          "doc_one_liner": "Manage BM25 corpus preparation and Lucene index builds.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/io/bm25_manager.py:75"
        }
      ],
      "raises": {
        "_parse_corpus_line": [
          "ValueError"
        ],
        "prepare_corpus": [
          "FileExistsError",
          "FileNotFoundError",
          "ValueError"
        ],
        "build_index": [
          "FileExistsError",
          "FileNotFoundError"
        ]
      }
    },
    {
      "module": "io",
      "path": "/home/paul/kgfoundry/codeintel_rev/io/__init__.py",
      "is_test": false,
      "imports": [
        "__future__.annotations",
        "importlib.import_module",
        "typing.TYPE_CHECKING",
        "codeintel_rev.io.bm25_manager.BM25CorpusMetadata",
        "codeintel_rev.io.bm25_manager.BM25CorpusSummary",
        "codeintel_rev.io.bm25_manager.BM25IndexManager",
        "codeintel_rev.io.bm25_manager.BM25IndexMetadata",
        "codeintel_rev.io.hybrid_search.HybridResultDoc",
        "codeintel_rev.io.hybrid_search.HybridSearchEngine",
        "codeintel_rev.io.hybrid_search.HybridSearchResult",
        "codeintel_rev.io.splade_manager.SpladeArtifactMetadata",
        "codeintel_rev.io.splade_manager.SpladeArtifactsManager",
        "codeintel_rev.io.splade_manager.SpladeBenchmarkOptions",
        "codeintel_rev.io.splade_manager.SpladeBenchmarkSummary",
        "codeintel_rev.io.splade_manager.SpladeBuildOptions",
        "codeintel_rev.io.splade_manager.SpladeEncodeOptions",
        "codeintel_rev.io.splade_manager.SpladeEncodingMetadata",
        "codeintel_rev.io.splade_manager.SpladeEncodingSummary",
        "codeintel_rev.io.splade_manager.SpladeExportOptions",
        "codeintel_rev.io.splade_manager.SpladeExportSummary",
        "codeintel_rev.io.splade_manager.SpladeIndexManager",
        "codeintel_rev.io.splade_manager.SpladeIndexMetadata"
      ],
      "public_api": [
        "BM25CorpusMetadata",
        "BM25CorpusSummary",
        "BM25IndexManager",
        "BM25IndexMetadata",
        "HybridResultDoc",
        "HybridSearchEngine",
        "HybridSearchResult",
        "SpladeArtifactMetadata",
        "SpladeArtifactsManager",
        "SpladeBenchmarkOptions",
        "SpladeBenchmarkSummary",
        "SpladeBuildOptions",
        "SpladeEncodeOptions",
        "SpladeEncodingMetadata",
        "SpladeEncodingSummary",
        "SpladeExportOptions",
        "SpladeExportSummary",
        "SpladeIndexManager",
        "SpladeIndexMetadata"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 0,
        "class_with_doc": 0,
        "func_total": 2,
        "func_with_doc": 1
      },
      "typing": {
        "functions": 2,
        "annotated_returns": 2,
        "total_params": 1,
        "annotated_params": 1
      },
      "complexity": {
        "branch_points": 3,
        "max_nesting": 2
      },
      "loc": 110,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "importlib.import_module",
          "typing.TYPE_CHECKING"
        ],
        "type_checking_imports": [
          "codeintel_rev.io.bm25_manager.BM25CorpusMetadata",
          "codeintel_rev.io.bm25_manager.BM25CorpusSummary",
          "codeintel_rev.io.bm25_manager.BM25IndexManager",
          "codeintel_rev.io.bm25_manager.BM25IndexMetadata",
          "codeintel_rev.io.hybrid_search.HybridResultDoc",
          "codeintel_rev.io.hybrid_search.HybridSearchEngine",
          "codeintel_rev.io.hybrid_search.HybridSearchResult",
          "codeintel_rev.io.splade_manager.SpladeArtifactMetadata",
          "codeintel_rev.io.splade_manager.SpladeArtifactsManager",
          "codeintel_rev.io.splade_manager.SpladeBenchmarkOptions",
          "codeintel_rev.io.splade_manager.SpladeBenchmarkSummary",
          "codeintel_rev.io.splade_manager.SpladeBuildOptions",
          "codeintel_rev.io.splade_manager.SpladeEncodeOptions",
          "codeintel_rev.io.splade_manager.SpladeEncodingMetadata",
          "codeintel_rev.io.splade_manager.SpladeEncodingSummary",
          "codeintel_rev.io.splade_manager.SpladeExportOptions",
          "codeintel_rev.io.splade_manager.SpladeExportSummary",
          "codeintel_rev.io.splade_manager.SpladeIndexManager",
          "codeintel_rev.io.splade_manager.SpladeIndexMetadata"
        ],
        "exports": [
          "BM25CorpusMetadata",
          "BM25CorpusSummary",
          "BM25IndexManager",
          "BM25IndexMetadata",
          "HybridResultDoc",
          "HybridSearchEngine",
          "HybridSearchResult",
          "SpladeArtifactMetadata",
          "SpladeArtifactsManager",
          "SpladeBenchmarkOptions",
          "SpladeBenchmarkSummary",
          "SpladeBuildOptions",
          "SpladeEncodeOptions",
          "SpladeEncodingMetadata",
          "SpladeEncodingSummary",
          "SpladeExportOptions",
          "SpladeExportSummary",
          "SpladeIndexManager",
          "SpladeIndexMetadata"
        ],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 6,
      "has_tests": true,
      "public_api_without_tests": [],
      "public_api_details": [],
      "raises": {
        "__getattr__": [
          "AttributeError"
        ]
      }
    },
    {
      "module": "io.git_client",
      "path": "/home/paul/kgfoundry/codeintel_rev/io/git_client.py",
      "is_test": false,
      "imports": [
        "__future__.annotations",
        "asyncio",
        "dataclasses.dataclass",
        "dataclasses.field",
        "dataclasses.replace",
        "pathlib.Path",
        "typing.TYPE_CHECKING",
        "typing.cast",
        "git",
        "git.exc",
        "kgfoundry_common.logging.get_logger",
        "codeintel_rev.mcp_server.schemas.GitBlameEntry"
      ],
      "public_api": [
        "AsyncGitClient",
        "GitClient"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 2,
        "class_with_doc": 2,
        "func_total": 7,
        "func_with_doc": 6
      },
      "typing": {
        "functions": 7,
        "annotated_returns": 7,
        "total_params": 19,
        "annotated_params": 12
      },
      "complexity": {
        "branch_points": 17,
        "max_nesting": 5
      },
      "loc": 549,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "asyncio",
          "dataclasses.dataclass",
          "dataclasses.field",
          "dataclasses.replace",
          "git",
          "git.exc",
          "kgfoundry_common.logging.get_logger",
          "pathlib.Path",
          "typing.TYPE_CHECKING",
          "typing.cast"
        ],
        "type_checking_imports": [
          "codeintel_rev.mcp_server.schemas.GitBlameEntry"
        ],
        "exports": [
          "AsyncGitClient",
          "GitClient"
        ],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 4,
      "has_tests": true,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "GitClient",
          "kind": "class",
          "signature": "class GitClient",
          "doc_one_liner": "Typed wrapper around GitPython for blame and history operations.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/io/git_client.py:63"
        },
        {
          "name": "AsyncGitClient",
          "kind": "class",
          "signature": "class AsyncGitClient",
          "doc_one_liner": "Async wrapper around GitClient using asyncio.to_thread.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/io/git_client.py:424"
        }
      ],
      "raises": {
        "blame_range": [
          "FileNotFoundError"
        ],
        "file_history": [
          "FileNotFoundError"
        ]
      }
    },
    {
      "module": "io.rerank_coderankllm",
      "path": "/home/paul/kgfoundry/codeintel_rev/io/rerank_coderankllm.py",
      "is_test": false,
      "imports": [
        "__future__.annotations",
        "json",
        "threading",
        "collections.abc.Sequence",
        "typing.TYPE_CHECKING",
        "typing.ClassVar",
        "typing.cast",
        "codeintel_rev.typing.gate_import",
        "kgfoundry_common.logging.get_logger",
        "transformers.AutoModelForCausalLM",
        "transformers.PreTrainedTokenizerBase"
      ],
      "public_api": [
        "CodeRankListwiseReranker"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 1,
        "class_with_doc": 1,
        "func_total": 5,
        "func_with_doc": 1
      },
      "typing": {
        "functions": 5,
        "annotated_returns": 5,
        "total_params": 14,
        "annotated_params": 11
      },
      "complexity": {
        "branch_points": 21,
        "max_nesting": 4
      },
      "loc": 166,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "codeintel_rev.typing.gate_import",
          "collections.abc.Sequence",
          "json",
          "kgfoundry_common.logging.get_logger",
          "threading",
          "typing.ClassVar",
          "typing.TYPE_CHECKING",
          "typing.cast"
        ],
        "type_checking_imports": [
          "transformers.AutoModelForCausalLM",
          "transformers.PreTrainedTokenizerBase"
        ],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 4,
      "has_tests": true,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "CodeRankListwiseReranker",
          "kind": "class",
          "signature": "class CodeRankListwiseReranker",
          "doc_one_liner": "Listwise reranking helper built on CodeRankLLM.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/io/rerank_coderankllm.py:33"
        }
      ],
      "raises": {
        "rerank": [
          "RuntimeError"
        ],
        "_ensure_model": [
          "RuntimeError"
        ]
      }
    },
    {
      "module": "retrieval.types",
      "path": "/home/paul/kgfoundry/codeintel_rev/retrieval/types.py",
      "is_test": false,
      "imports": [
        "__future__.annotations",
        "collections.abc.Mapping",
        "collections.abc.Sequence",
        "dataclasses.dataclass"
      ],
      "public_api": [
        "ChannelHit",
        "HybridResultDoc",
        "HybridSearchResult",
        "StageDecision",
        "StageSignals"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 5,
        "class_with_doc": 5,
        "func_total": 1,
        "func_with_doc": 1
      },
      "typing": {
        "functions": 1,
        "annotated_returns": 1,
        "total_params": 1,
        "annotated_params": 0
      },
      "complexity": {
        "branch_points": 2,
        "max_nesting": 3
      },
      "loc": 72,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "collections.abc.Mapping",
          "collections.abc.Sequence",
          "dataclasses.dataclass"
        ],
        "type_checking_imports": [],
        "exports": [
          "ChannelHit",
          "HybridResultDoc",
          "HybridSearchResult",
          "StageDecision",
          "StageSignals"
        ],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [
        "ChannelHit",
        "HybridResultDoc",
        "HybridSearchResult",
        "StageDecision",
        "StageSignals"
      ],
      "public_api_details": [
        {
          "name": "ChannelHit",
          "kind": "class",
          "signature": "class ChannelHit",
          "doc_one_liner": "Score emitted by a retrieval channel prior to fusion.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/retrieval/types.py:10"
        },
        {
          "name": "HybridResultDoc",
          "kind": "class",
          "signature": "class HybridResultDoc",
          "doc_one_liner": "Final fused result produced by weighted RRF.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/retrieval/types.py:18"
        },
        {
          "name": "HybridSearchResult",
          "kind": "class",
          "signature": "class HybridSearchResult",
          "doc_one_liner": "Container for fused docs alongside explainability metadata.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/retrieval/types.py:26"
        },
        {
          "name": "StageSignals",
          "kind": "class",
          "signature": "class StageSignals",
          "doc_one_liner": "Signals gathered from a stage for downstream gating decisions.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/retrieval/types.py:36"
        },
        {
          "name": "StageDecision",
          "kind": "class",
          "signature": "class StageDecision",
          "doc_one_liner": "Decision emitted by gating logic describing whether to run the stage.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/retrieval/types.py:58"
        }
      ],
      "raises": {}
    },
    {
      "module": "retrieval.telemetry",
      "path": "/home/paul/kgfoundry/codeintel_rev/retrieval/telemetry.py",
      "is_test": false,
      "imports": [
        "__future__.annotations",
        "collections.abc.Iterator",
        "contextlib.contextmanager",
        "dataclasses.dataclass",
        "dataclasses.field",
        "time.perf_counter",
        "typing.cast",
        "prometheus_client.CollectorRegistry",
        "codeintel_rev.retrieval.types.StageDecision",
        "kgfoundry_common.logging.get_logger",
        "kgfoundry_common.observability.MetricsProvider",
        "kgfoundry_common.prometheus.build_counter",
        "kgfoundry_common.prometheus.get_default_registry"
      ],
      "public_api": [
        "StageTiming",
        "record_stage_decision",
        "record_stage_metric",
        "track_stage"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 3,
        "class_with_doc": 2,
        "func_total": 8,
        "func_with_doc": 4
      },
      "typing": {
        "functions": 8,
        "annotated_returns": 8,
        "total_params": 13,
        "annotated_params": 8
      },
      "complexity": {
        "branch_points": 6,
        "max_nesting": 3
      },
      "loc": 183,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "codeintel_rev.retrieval.types.StageDecision",
          "collections.abc.Iterator",
          "contextlib.contextmanager",
          "dataclasses.dataclass",
          "dataclasses.field",
          "kgfoundry_common.logging.get_logger",
          "kgfoundry_common.observability.MetricsProvider",
          "kgfoundry_common.prometheus.build_counter",
          "kgfoundry_common.prometheus.get_default_registry",
          "prometheus_client.CollectorRegistry",
          "time.perf_counter",
          "typing.cast"
        ],
        "type_checking_imports": [],
        "exports": [
          "StageTiming",
          "record_stage_decision",
          "record_stage_metric",
          "track_stage"
        ],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [
        "StageTiming",
        "record_stage_decision",
        "record_stage_metric",
        "track_stage"
      ],
      "public_api_details": [
        {
          "name": "StageTiming",
          "kind": "class",
          "signature": "class StageTiming",
          "doc_one_liner": "Snapshot describing how long a stage took relative to its budget.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/retrieval/telemetry.py:20"
        },
        {
          "name": "track_stage",
          "kind": "function",
          "signature": "track_stage(name: str, *, budget_ms: int | None = None) -> Iterator[_StageTimer]",
          "doc_one_liner": "Context manager yielding a timer that can be converted into StageTiming.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/retrieval/telemetry.py:83"
        },
        {
          "name": "record_stage_metric",
          "kind": "function",
          "signature": "record_stage_metric(component: str, timing: StageTiming, *, metrics: MetricsProvider | None = None) -> None",
          "doc_one_liner": "Record the provided ``timing`` in Prometheus metrics.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/retrieval/telemetry.py:138"
        },
        {
          "name": "record_stage_decision",
          "kind": "function",
          "signature": "record_stage_decision(component: str, stage: str, *, decision: StageDecision) -> None",
          "doc_one_liner": "Increment the stage decision counter for the given outcome.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/retrieval/telemetry.py:163"
        }
      ],
      "raises": {}
    },
    {
      "module": "retrieval.gating",
      "path": "/home/paul/kgfoundry/codeintel_rev/retrieval/gating.py",
      "is_test": false,
      "imports": [
        "__future__.annotations",
        "dataclasses.dataclass",
        "codeintel_rev.retrieval.types.StageDecision",
        "codeintel_rev.retrieval.types.StageSignals"
      ],
      "public_api": [
        "StageGateConfig",
        "should_run_secondary_stage"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 1,
        "class_with_doc": 1,
        "func_total": 1,
        "func_with_doc": 1
      },
      "typing": {
        "functions": 1,
        "annotated_returns": 1,
        "total_params": 2,
        "annotated_params": 2
      },
      "complexity": {
        "branch_points": 5,
        "max_nesting": 2
      },
      "loc": 81,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "codeintel_rev.retrieval.types.StageDecision",
          "codeintel_rev.retrieval.types.StageSignals",
          "dataclasses.dataclass"
        ],
        "type_checking_imports": [],
        "exports": [
          "StageGateConfig",
          "should_run_secondary_stage"
        ],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [
        "StageGateConfig",
        "should_run_secondary_stage"
      ],
      "public_api_details": [
        {
          "name": "StageGateConfig",
          "kind": "class",
          "signature": "class StageGateConfig",
          "doc_one_liner": "Configuration inputs for deciding whether to invoke a follow-up stage.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/retrieval/gating.py:11"
        },
        {
          "name": "should_run_secondary_stage",
          "kind": "function",
          "signature": "should_run_secondary_stage(signals: StageSignals, config: StageGateConfig) -> StageDecision",
          "doc_one_liner": "Return a gating decision for a downstream stage based on upstream signals.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/retrieval/gating.py:19"
        }
      ],
      "raises": {}
    },
    {
      "module": "retrieval.hybrid",
      "path": "/home/paul/kgfoundry/codeintel_rev/retrieval/hybrid.py",
      "is_test": false,
      "imports": [
        "__future__.annotations",
        "dataclasses.dataclass",
        "typing.TYPE_CHECKING",
        "collections.abc.Sequence"
      ],
      "public_api": [
        "SearchHit",
        "create_hit_list",
        "reciprocal_rank_fusion"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 1,
        "class_with_doc": 1,
        "func_total": 2,
        "func_with_doc": 2
      },
      "typing": {
        "functions": 2,
        "annotated_returns": 2,
        "total_params": 6,
        "annotated_params": 6
      },
      "complexity": {
        "branch_points": 4,
        "max_nesting": 4
      },
      "loc": 133,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "dataclasses.dataclass",
          "typing.TYPE_CHECKING"
        ],
        "type_checking_imports": [
          "collections.abc.Sequence"
        ],
        "exports": [
          "SearchHit",
          "create_hit_list",
          "reciprocal_rank_fusion"
        ],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [
        "SearchHit",
        "create_hit_list",
        "reciprocal_rank_fusion"
      ],
      "public_api_details": [
        {
          "name": "SearchHit",
          "kind": "class",
          "signature": "class SearchHit",
          "doc_one_liner": "Search result hit from a single retrieval system.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/retrieval/hybrid.py:16"
        },
        {
          "name": "reciprocal_rank_fusion",
          "kind": "function",
          "signature": "reciprocal_rank_fusion(result_lists: Sequence[Sequence[SearchHit]], k: int = 60, top_k: int = 50) -> list[tuple[str, float]]",
          "doc_one_liner": "Fuse multiple ranked lists using RRF.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/retrieval/hybrid.py:54"
        },
        {
          "name": "create_hit_list",
          "kind": "function",
          "signature": "create_hit_list(doc_ids: Sequence[str], scores: Sequence[float], source: str) -> list[SearchHit]",
          "doc_one_liner": "Create SearchHit list from retrieval results.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/retrieval/hybrid.py:102"
        }
      ],
      "raises": {}
    },
    {
      "module": "retrieval",
      "path": "/home/paul/kgfoundry/codeintel_rev/retrieval/__init__.py",
      "is_test": false,
      "imports": [],
      "public_api": [],
      "doc": {
        "module_doc": true,
        "class_total": 0,
        "class_with_doc": 0,
        "func_total": 0,
        "func_with_doc": 0
      },
      "typing": {
        "functions": 0,
        "annotated_returns": 0,
        "total_params": 0,
        "annotated_params": 0
      },
      "complexity": {
        "branch_points": 0,
        "max_nesting": 0
      },
      "loc": 1,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [],
        "type_checking_imports": [],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [],
      "raises": {}
    },
    {
      "module": "runtime.cells",
      "path": "/home/paul/kgfoundry/codeintel_rev/runtime/cells.py",
      "is_test": false,
      "imports": [
        "__future__.annotations",
        "os",
        "time",
        "collections.abc.Callable",
        "dataclasses.dataclass",
        "threading.RLock",
        "typing.Literal",
        "typing.Protocol",
        "typing.TypeVar",
        "typing.final",
        "typing.runtime_checkable",
        "kgfoundry_common.logging.get_logger"
      ],
      "public_api": [
        "NullRuntimeCellObserver",
        "RuntimeCell",
        "RuntimeCellCloseResult",
        "RuntimeCellInitResult",
        "RuntimeCellObserver"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 5,
        "class_with_doc": 5,
        "func_total": 18,
        "func_with_doc": 13
      },
      "typing": {
        "functions": 18,
        "annotated_returns": 18,
        "total_params": 27,
        "annotated_params": 13
      },
      "complexity": {
        "branch_points": 23,
        "max_nesting": 4
      },
      "loc": 495,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "collections.abc.Callable",
          "dataclasses.dataclass",
          "kgfoundry_common.logging.get_logger",
          "os",
          "threading.RLock",
          "time",
          "typing.Literal",
          "typing.Protocol",
          "typing.TypeVar",
          "typing.final",
          "typing.runtime_checkable"
        ],
        "type_checking_imports": [],
        "exports": [
          "NullRuntimeCellObserver",
          "RuntimeCell",
          "RuntimeCellCloseResult",
          "RuntimeCellInitResult",
          "RuntimeCellObserver"
        ],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [
        "NullRuntimeCellObserver",
        "RuntimeCell",
        "RuntimeCellCloseResult",
        "RuntimeCellInitResult",
        "RuntimeCellObserver"
      ],
      "public_api_details": [
        {
          "name": "RuntimeCellInitResult",
          "kind": "class",
          "signature": "class RuntimeCellInitResult",
          "doc_one_liner": "Immutable payload describing initialization outcome.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/runtime/cells.py:27"
        },
        {
          "name": "RuntimeCellCloseResult",
          "kind": "class",
          "signature": "class RuntimeCellCloseResult",
          "doc_one_liner": "Immutable payload describing close outcome.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/runtime/cells.py:38"
        },
        {
          "name": "RuntimeCellObserver",
          "kind": "class",
          "signature": "class RuntimeCellObserver(Protocol)",
          "doc_one_liner": "Protocol for observing RuntimeCell lifecycle events.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/runtime/cells.py:56"
        },
        {
          "name": "NullRuntimeCellObserver",
          "kind": "class",
          "signature": "class NullRuntimeCellObserver",
          "doc_one_liner": "No-op observer used when instrumentation is disabled.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/runtime/cells.py:69"
        },
        {
          "name": "RuntimeCell",
          "kind": "class",
          "signature": "class RuntimeCell",
          "doc_one_liner": "Thread-safe lazy holder for mutable runtime state.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/runtime/cells.py:91"
        }
      ],
      "raises": {
        "seed": [
          "RuntimeError"
        ]
      }
    },
    {
      "module": "runtime",
      "path": "/home/paul/kgfoundry/codeintel_rev/runtime/__init__.py",
      "is_test": false,
      "imports": [
        "__future__.annotations",
        "codeintel_rev.runtime.cells.NullRuntimeCellObserver",
        "codeintel_rev.runtime.cells.RuntimeCell",
        "codeintel_rev.runtime.cells.RuntimeCellCloseResult",
        "codeintel_rev.runtime.cells.RuntimeCellInitResult",
        "codeintel_rev.runtime.cells.RuntimeCellObserver"
      ],
      "public_api": [
        "NullRuntimeCellObserver",
        "RuntimeCell",
        "RuntimeCellCloseResult",
        "RuntimeCellInitResult",
        "RuntimeCellObserver"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 0,
        "class_with_doc": 0,
        "func_total": 0,
        "func_with_doc": 0
      },
      "typing": {
        "functions": 0,
        "annotated_returns": 0,
        "total_params": 0,
        "annotated_params": 0
      },
      "complexity": {
        "branch_points": 0,
        "max_nesting": 0
      },
      "loc": 19,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "codeintel_rev.runtime.cells.NullRuntimeCellObserver",
          "codeintel_rev.runtime.cells.RuntimeCell",
          "codeintel_rev.runtime.cells.RuntimeCellCloseResult",
          "codeintel_rev.runtime.cells.RuntimeCellInitResult",
          "codeintel_rev.runtime.cells.RuntimeCellObserver"
        ],
        "type_checking_imports": [],
        "exports": [
          "NullRuntimeCellObserver",
          "RuntimeCell",
          "RuntimeCellCloseResult",
          "RuntimeCellInitResult",
          "RuntimeCellObserver"
        ],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [
        "NullRuntimeCellObserver",
        "RuntimeCell",
        "RuntimeCellCloseResult",
        "RuntimeCellInitResult",
        "RuntimeCellObserver"
      ],
      "public_api_details": [],
      "raises": {}
    },
    {
      "module": "mcp_server.service_context",
      "path": "/home/paul/kgfoundry/codeintel_rev/mcp_server/service_context.py",
      "is_test": false,
      "imports": [
        "__future__.annotations",
        "threading.Lock",
        "codeintel_rev.app.config_context.ApplicationContext"
      ],
      "public_api": [
        "get_service_context",
        "reset_service_context"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 0,
        "class_with_doc": 0,
        "func_total": 4,
        "func_with_doc": 4
      },
      "typing": {
        "functions": 4,
        "annotated_returns": 4,
        "total_params": 1,
        "annotated_params": 1
      },
      "complexity": {
        "branch_points": 4,
        "max_nesting": 4
      },
      "loc": 79,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "codeintel_rev.app.config_context.ApplicationContext",
          "threading.Lock"
        ],
        "type_checking_imports": [],
        "exports": [
          "get_service_context",
          "reset_service_context"
        ],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [
        "get_service_context",
        "reset_service_context"
      ],
      "public_api_details": [
        {
          "name": "get_service_context",
          "kind": "function",
          "signature": "get_service_context() -> ApplicationContext",
          "doc_one_liner": "Return the cached :class:`ApplicationContext` instance.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/mcp_server/service_context.py:47"
        },
        {
          "name": "reset_service_context",
          "kind": "function",
          "signature": "reset_service_context() -> None",
          "doc_one_liner": "Clear the cached :class:`ApplicationContext`.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/mcp_server/service_context.py:71"
        }
      ],
      "raises": {}
    },
    {
      "module": "mcp_server.schemas",
      "path": "/home/paul/kgfoundry/codeintel_rev/mcp_server/schemas.py",
      "is_test": false,
      "imports": [
        "__future__.annotations",
        "typing.Literal",
        "typing.NotRequired",
        "typing.TypedDict",
        "kgfoundry_common.problem_details.ProblemDetailsDict"
      ],
      "public_api": [
        "AnswerEnvelope",
        "BaseErrorFields",
        "BlameRangeResponse",
        "FileHistoryResponse",
        "Finding",
        "GitBlameEntry",
        "ListPathsResponse",
        "Location",
        "Match",
        "MethodInfo",
        "OpenFileResponse",
        "ScopeIn",
        "SearchTextResponse",
        "SymbolInfo"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 15,
        "class_with_doc": 15,
        "func_total": 0,
        "func_with_doc": 0
      },
      "typing": {
        "functions": 0,
        "annotated_returns": 0,
        "total_params": 0,
        "annotated_params": 0
      },
      "complexity": {
        "branch_points": 0,
        "max_nesting": 1
      },
      "loc": 519,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "kgfoundry_common.problem_details.ProblemDetailsDict",
          "typing.Literal",
          "typing.NotRequired",
          "typing.TypedDict"
        ],
        "type_checking_imports": [],
        "exports": [
          "AnswerEnvelope",
          "BaseErrorFields",
          "BlameRangeResponse",
          "FileHistoryResponse",
          "Finding",
          "GitBlameEntry",
          "ListPathsResponse",
          "Location",
          "Match",
          "MethodInfo",
          "OpenFileResponse",
          "ScopeIn",
          "SearchTextResponse",
          "SymbolInfo"
        ],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [
        "AnswerEnvelope",
        "BaseErrorFields",
        "BlameRangeResponse",
        "FileHistoryResponse",
        "Finding",
        "GitBlameEntry",
        "ListPathsResponse",
        "Location",
        "Match",
        "MethodInfo",
        "OpenFileResponse",
        "ScopeIn",
        "SearchTextResponse",
        "SymbolInfo"
      ],
      "public_api_details": [
        {
          "name": "BaseErrorFields",
          "kind": "class",
          "signature": "class BaseErrorFields(TypedDict)",
          "doc_one_liner": "Base fields present in ALL error responses.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/mcp_server/schemas.py:13"
        },
        {
          "name": "ScopeIn",
          "kind": "class",
          "signature": "class ScopeIn(TypedDict)",
          "doc_one_liner": "Query scope parameters for filtering search results.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/mcp_server/schemas.py:35"
        },
        {
          "name": "Match",
          "kind": "class",
          "signature": "class Match(TypedDict)",
          "doc_one_liner": "Search match result from text or semantic search.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/mcp_server/schemas.py:87"
        },
        {
          "name": "Location",
          "kind": "class",
          "signature": "class Location(TypedDict)",
          "doc_one_liner": "Source code location with precise line and column positions.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/mcp_server/schemas.py:125"
        },
        {
          "name": "Finding",
          "kind": "class",
          "signature": "class Finding(TypedDict)",
          "doc_one_liner": "Generic finding result from code intelligence queries.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/mcp_server/schemas.py:163"
        },
        {
          "name": "MethodInfo",
          "kind": "class",
          "signature": "class MethodInfo(TypedDict)",
          "doc_one_liner": "Retrieval method metadata for search operations.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/mcp_server/schemas.py:213"
        },
        {
          "name": "AnswerEnvelope",
          "kind": "class",
          "signature": "class AnswerEnvelope(TypedDict)",
          "doc_one_liner": "Standard response envelope for MCP code intelligence tools.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/mcp_server/schemas.py:257"
        },
        {
          "name": "SymbolInfo",
          "kind": "class",
          "signature": "class SymbolInfo(TypedDict)",
          "doc_one_liner": "Symbol information with location and documentation.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/mcp_server/schemas.py:344"
        },
        {
          "name": "GitBlameEntry",
          "kind": "class",
          "signature": "class GitBlameEntry(TypedDict)",
          "doc_one_liner": "Git blame entry for a single line of code.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/mcp_server/schemas.py:375"
        },
        {
          "name": "OpenFileResponse",
          "kind": "class",
          "signature": "class OpenFileResponse(BaseErrorFields)",
          "doc_one_liner": "Response from open_file tool.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/mcp_server/schemas.py:408"
        },
        {
          "name": "ListPathsResponse",
          "kind": "class",
          "signature": "class ListPathsResponse(BaseErrorFields)",
          "doc_one_liner": "Response from list_paths tool.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/mcp_server/schemas.py:432"
        },
        {
          "name": "BlameRangeResponse",
          "kind": "class",
          "signature": "class BlameRangeResponse(BaseErrorFields)",
          "doc_one_liner": "Response from blame_range tool.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/mcp_server/schemas.py:453"
        },
        {
          "name": "FileHistoryResponse",
          "kind": "class",
          "signature": "class FileHistoryResponse(BaseErrorFields)",
          "doc_one_liner": "Response from file_history tool.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/mcp_server/schemas.py:468"
        },
        {
          "name": "SearchTextResponse",
          "kind": "class",
          "signature": "class SearchTextResponse(BaseErrorFields)",
          "doc_one_liner": "Response from search_text tool.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/mcp_server/schemas.py:483"
        }
      ],
      "raises": {}
    },
    {
      "module": "mcp_server.server_semantic",
      "path": "/home/paul/kgfoundry/codeintel_rev/mcp_server/server_semantic.py",
      "is_test": false,
      "imports": [
        "__future__.annotations",
        "codeintel_rev.mcp_server.adapters.semantic",
        "codeintel_rev.mcp_server.adapters.semantic_pro",
        "codeintel_rev.mcp_server.error_handling.handle_adapter_errors",
        "codeintel_rev.mcp_server.schemas.AnswerEnvelope",
        "codeintel_rev.mcp_server.server.get_context",
        "codeintel_rev.mcp_server.server.mcp"
      ],
      "public_api": [
        "semantic_search",
        "semantic_search_pro"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 0,
        "class_with_doc": 0,
        "func_total": 2,
        "func_with_doc": 2
      },
      "typing": {
        "functions": 2,
        "annotated_returns": 2,
        "total_params": 5,
        "annotated_params": 5
      },
      "complexity": {
        "branch_points": 0,
        "max_nesting": 1
      },
      "loc": 56,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "codeintel_rev.mcp_server.adapters.semantic",
          "codeintel_rev.mcp_server.adapters.semantic_pro",
          "codeintel_rev.mcp_server.error_handling.handle_adapter_errors",
          "codeintel_rev.mcp_server.schemas.AnswerEnvelope",
          "codeintel_rev.mcp_server.server.get_context",
          "codeintel_rev.mcp_server.server.mcp"
        ],
        "type_checking_imports": [],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [
        "semantic_search",
        "semantic_search_pro"
      ],
      "public_api_details": [
        {
          "name": "semantic_search",
          "kind": "function",
          "signature": "semantic_search(query: str, limit: int = 20) -> AnswerEnvelope",
          "doc_one_liner": "Semantic code search using embeddings.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/mcp_server/server_semantic.py:17"
        },
        {
          "name": "semantic_search_pro",
          "kind": "function",
          "signature": "semantic_search_pro(query: str, limit: int = 20, *, options: semantic_pro_adapter.SemanticProOptions | None = None) -> AnswerEnvelope",
          "doc_one_liner": "Two-stage semantic retrieval with optional late interaction and reranker.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/mcp_server/server_semantic.py:37"
        }
      ],
      "raises": {}
    },
    {
      "module": "mcp_server.server_symbols",
      "path": "/home/paul/kgfoundry/codeintel_rev/mcp_server/server_symbols.py",
      "is_test": false,
      "imports": [
        "__future__.annotations",
        "codeintel_rev.mcp_server.error_handling.handle_adapter_errors",
        "codeintel_rev.mcp_server.schemas.Location",
        "codeintel_rev.mcp_server.schemas.SymbolInfo",
        "codeintel_rev.mcp_server.server.get_context",
        "codeintel_rev.mcp_server.server.mcp"
      ],
      "public_api": [
        "symbol_search",
        "definition_at",
        "references_at"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 0,
        "class_with_doc": 0,
        "func_total": 3,
        "func_with_doc": 3
      },
      "typing": {
        "functions": 3,
        "annotated_returns": 3,
        "total_params": 9,
        "annotated_params": 9
      },
      "complexity": {
        "branch_points": 13,
        "max_nesting": 3
      },
      "loc": 176,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "codeintel_rev.mcp_server.error_handling.handle_adapter_errors",
          "codeintel_rev.mcp_server.schemas.Location",
          "codeintel_rev.mcp_server.schemas.SymbolInfo",
          "codeintel_rev.mcp_server.server.get_context",
          "codeintel_rev.mcp_server.server.mcp"
        ],
        "type_checking_imports": [],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [
        "symbol_search",
        "definition_at",
        "references_at"
      ],
      "public_api_details": [
        {
          "name": "symbol_search",
          "kind": "function",
          "signature": "symbol_search(query: str, kind: str | None = None, language: str | None = None) -> dict",
          "doc_one_liner": "Search for symbols (functions, classes, etc).",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/mcp_server/server_symbols.py:15"
        },
        {
          "name": "definition_at",
          "kind": "function",
          "signature": "definition_at(path: str, line: int, character: int) -> dict",
          "doc_one_liner": "Find definition at position.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/mcp_server/server_symbols.py:72"
        },
        {
          "name": "references_at",
          "kind": "function",
          "signature": "references_at(path: str, line: int, character: int) -> dict",
          "doc_one_liner": "Find references at position.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/mcp_server/server_symbols.py:128"
        }
      ],
      "raises": {}
    },
    {
      "module": "mcp_server.error_handling",
      "path": "/home/paul/kgfoundry/codeintel_rev/mcp_server/error_handling.py",
      "is_test": false,
      "imports": [
        "__future__.annotations",
        "inspect",
        "collections.abc.Callable",
        "collections.abc.Mapping",
        "dataclasses.dataclass",
        "functools.wraps",
        "http.HTTPStatus",
        "typing.TYPE_CHECKING",
        "typing.TypeVar",
        "typing.cast",
        "codeintel_rev.errors.PathNotDirectoryError",
        "codeintel_rev.errors.PathNotFoundError",
        "codeintel_rev.io.path_utils.PathOutsideRepositoryError",
        "kgfoundry_common.errors.KgFoundryError",
        "kgfoundry_common.logging.get_logger",
        "kgfoundry_common.logging.with_fields",
        "kgfoundry_common.problem_details.build_problem_details",
        "kgfoundry_common.problem_details.ProblemDetails"
      ],
      "public_api": [
        "EXCEPTION_TO_ERROR_CODE",
        "convert_exception_to_envelope",
        "format_error_response",
        "handle_adapter_errors"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 1,
        "class_with_doc": 0,
        "func_total": 6,
        "func_with_doc": 3
      },
      "typing": {
        "functions": 6,
        "annotated_returns": 6,
        "total_params": 12,
        "annotated_params": 12
      },
      "complexity": {
        "branch_points": 21,
        "max_nesting": 9
      },
      "loc": 542,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "codeintel_rev.errors.PathNotDirectoryError",
          "codeintel_rev.errors.PathNotFoundError",
          "codeintel_rev.io.path_utils.PathOutsideRepositoryError",
          "collections.abc.Callable",
          "collections.abc.Mapping",
          "dataclasses.dataclass",
          "functools.wraps",
          "http.HTTPStatus",
          "inspect",
          "kgfoundry_common.errors.KgFoundryError",
          "kgfoundry_common.logging.get_logger",
          "kgfoundry_common.logging.with_fields",
          "kgfoundry_common.problem_details.build_problem_details",
          "typing.TYPE_CHECKING",
          "typing.TypeVar",
          "typing.cast"
        ],
        "type_checking_imports": [
          "kgfoundry_common.problem_details.ProblemDetails"
        ],
        "exports": [
          "EXCEPTION_TO_ERROR_CODE",
          "convert_exception_to_envelope",
          "format_error_response",
          "handle_adapter_errors"
        ],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [
        "EXCEPTION_TO_ERROR_CODE",
        "convert_exception_to_envelope",
        "format_error_response",
        "handle_adapter_errors"
      ],
      "public_api_details": [
        {
          "name": "format_error_response",
          "kind": "function",
          "signature": "format_error_response(exc: BaseException, *, instance: str) -> dict[str, object]",
          "doc_one_liner": "Return Problem Details payload for the provided exception.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/mcp_server/error_handling.py:133"
        },
        {
          "name": "convert_exception_to_envelope",
          "kind": "function",
          "signature": "convert_exception_to_envelope(exc: BaseException, operation: str, empty_result: Mapping[str, object]) -> dict",
          "doc_one_liner": "Convert exception to unified error envelope with Problem Details.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/mcp_server/error_handling.py:191"
        },
        {
          "name": "handle_adapter_errors",
          "kind": "function",
          "signature": "handle_adapter_errors(*, operation: str, empty_result: Mapping[str, object]) -> Callable[[F], F]",
          "doc_one_liner": "Convert adapter exceptions to unified error envelopes.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/mcp_server/error_handling.py:376"
        }
      ],
      "raises": {}
    },
    {
      "module": "mcp_server.scope_utils",
      "path": "/home/paul/kgfoundry/codeintel_rev/mcp_server/scope_utils.py",
      "is_test": false,
      "imports": [
        "__future__.annotations",
        "fnmatch",
        "time.perf_counter",
        "typing.TYPE_CHECKING",
        "kgfoundry_common.logging.get_logger",
        "kgfoundry_common.prometheus.build_histogram",
        "codeintel_rev.app.config_context.ApplicationContext",
        "codeintel_rev.mcp_server.schemas.ScopeIn"
      ],
      "public_api": [
        "LANGUAGE_EXTENSIONS",
        "apply_language_filter",
        "apply_path_filters",
        "get_effective_scope",
        "merge_scope_filters",
        "path_matches_glob"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 0,
        "class_with_doc": 0,
        "func_total": 5,
        "func_with_doc": 5
      },
      "typing": {
        "functions": 5,
        "annotated_returns": 5,
        "total_params": 11,
        "annotated_params": 11
      },
      "complexity": {
        "branch_points": 16,
        "max_nesting": 4
      },
      "loc": 486,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "fnmatch",
          "kgfoundry_common.logging.get_logger",
          "kgfoundry_common.prometheus.build_histogram",
          "time.perf_counter",
          "typing.TYPE_CHECKING"
        ],
        "type_checking_imports": [
          "codeintel_rev.app.config_context.ApplicationContext",
          "codeintel_rev.mcp_server.schemas.ScopeIn"
        ],
        "exports": [
          "LANGUAGE_EXTENSIONS",
          "apply_language_filter",
          "apply_path_filters",
          "get_effective_scope",
          "merge_scope_filters",
          "path_matches_glob"
        ],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [
        "LANGUAGE_EXTENSIONS",
        "apply_language_filter",
        "apply_path_filters",
        "get_effective_scope",
        "merge_scope_filters",
        "path_matches_glob"
      ],
      "public_api_details": [
        {
          "name": "get_effective_scope",
          "kind": "function",
          "signature": "get_effective_scope(context: ApplicationContext, session_id: str | None) -> ScopeIn | None",
          "doc_one_liner": "Retrieve session scope from the scope store.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/mcp_server/scope_utils.py:116"
        },
        {
          "name": "merge_scope_filters",
          "kind": "function",
          "signature": "merge_scope_filters(scope: ScopeIn | None, explicit_params: dict) -> dict",
          "doc_one_liner": "Merge session scope with explicit adapter parameters.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/mcp_server/scope_utils.py:160"
        },
        {
          "name": "apply_path_filters",
          "kind": "function",
          "signature": "apply_path_filters(paths: list[str], include_globs: list[str], exclude_globs: list[str]) -> list[str]",
          "doc_one_liner": "Filter paths using glob patterns.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/mcp_server/scope_utils.py:235"
        },
        {
          "name": "apply_language_filter",
          "kind": "function",
          "signature": "apply_language_filter(paths: list[str], languages: list[str]) -> list[str]",
          "doc_one_liner": "Filter paths by programming language.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/mcp_server/scope_utils.py:324"
        },
        {
          "name": "path_matches_glob",
          "kind": "function",
          "signature": "path_matches_glob(path: str, pattern: str) -> bool",
          "doc_one_liner": "Test if path matches glob pattern.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/mcp_server/scope_utils.py:418"
        }
      ],
      "raises": {}
    },
    {
      "module": "mcp_server.server",
      "path": "/home/paul/kgfoundry/codeintel_rev/mcp_server/server.py",
      "is_test": false,
      "imports": [
        "__future__.annotations",
        "contextvars",
        "importlib",
        "fastmcp.FastMCP",
        "starlette.types.ASGIApp",
        "codeintel_rev.app.capabilities.Capabilities",
        "codeintel_rev.app.config_context.ApplicationContext",
        "codeintel_rev.mcp_server.adapters.files",
        "codeintel_rev.mcp_server.adapters.history",
        "codeintel_rev.mcp_server.adapters.text_search",
        "codeintel_rev.mcp_server.error_handling.handle_adapter_errors",
        "codeintel_rev.mcp_server.schemas.ScopeIn"
      ],
      "public_api": [
        "app_context",
        "build_http_app",
        "get_context",
        "mcp"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 0,
        "class_with_doc": 0,
        "func_total": 10,
        "func_with_doc": 10
      },
      "typing": {
        "functions": 10,
        "annotated_returns": 10,
        "total_params": 22,
        "annotated_params": 22
      },
      "complexity": {
        "branch_points": 4,
        "max_nesting": 2
      },
      "loc": 337,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "codeintel_rev.app.capabilities.Capabilities",
          "codeintel_rev.app.config_context.ApplicationContext",
          "codeintel_rev.mcp_server.adapters.files",
          "codeintel_rev.mcp_server.adapters.history",
          "codeintel_rev.mcp_server.adapters.text_search",
          "codeintel_rev.mcp_server.error_handling.handle_adapter_errors",
          "codeintel_rev.mcp_server.schemas.ScopeIn",
          "contextvars",
          "fastmcp.FastMCP",
          "importlib",
          "starlette.types.ASGIApp"
        ],
        "type_checking_imports": [],
        "exports": [
          "app_context",
          "build_http_app",
          "get_context",
          "mcp"
        ],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [
        "app_context",
        "build_http_app",
        "get_context",
        "mcp"
      ],
      "public_api_details": [
        {
          "name": "get_context",
          "kind": "function",
          "signature": "get_context() -> ApplicationContext",
          "doc_one_liner": "Extract ApplicationContext from context variable.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/mcp_server/server.py:33"
        },
        {
          "name": "build_http_app",
          "kind": "function",
          "signature": "build_http_app(capabilities: Capabilities) -> ASGIApp",
          "doc_one_liner": "Return the FastMCP ASGI app with capability-gated tool registration.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/mcp_server/server.py:322"
        }
      ],
      "raises": {
        "get_context": [
          "RuntimeError"
        ]
      }
    },
    {
      "module": "mcp_server",
      "path": "/home/paul/kgfoundry/codeintel_rev/mcp_server/__init__.py",
      "is_test": false,
      "imports": [],
      "public_api": [],
      "doc": {
        "module_doc": true,
        "class_total": 0,
        "class_with_doc": 0,
        "func_total": 0,
        "func_with_doc": 0
      },
      "typing": {
        "functions": 0,
        "annotated_returns": 0,
        "total_params": 0,
        "annotated_params": 0
      },
      "complexity": {
        "branch_points": 0,
        "max_nesting": 0
      },
      "loc": 1,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [],
        "type_checking_imports": [],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [],
      "raises": {}
    },
    {
      "module": "cache",
      "path": "/home/paul/kgfoundry/codeintel_rev/cache/__init__.py",
      "is_test": false,
      "imports": [],
      "public_api": [],
      "doc": {
        "module_doc": true,
        "class_total": 0,
        "class_with_doc": 0,
        "func_total": 0,
        "func_with_doc": 0
      },
      "typing": {
        "functions": 0,
        "annotated_returns": 0,
        "total_params": 0,
        "annotated_params": 0
      },
      "complexity": {
        "branch_points": 0,
        "max_nesting": 0
      },
      "loc": 1,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [],
        "type_checking_imports": [],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [],
      "raises": {}
    },
    {
      "module": "cli.xtr",
      "path": "/home/paul/kgfoundry/codeintel_rev/cli/xtr.py",
      "is_test": false,
      "imports": [
        "__future__.annotations",
        "codeintel_rev.mcp_server.retrieval.xtr_cli.app",
        "codeintel_rev.mcp_server.retrieval.xtr_cli.main"
      ],
      "public_api": [
        "app",
        "main"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 0,
        "class_with_doc": 0,
        "func_total": 0,
        "func_with_doc": 0
      },
      "typing": {
        "functions": 0,
        "annotated_returns": 0,
        "total_params": 0,
        "annotated_params": 0
      },
      "complexity": {
        "branch_points": 0,
        "max_nesting": 0
      },
      "loc": 7,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "codeintel_rev.mcp_server.retrieval.xtr_cli.app",
          "codeintel_rev.mcp_server.retrieval.xtr_cli.main"
        ],
        "type_checking_imports": [],
        "exports": [
          "app",
          "main"
        ],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [
        "app",
        "main"
      ],
      "public_api_details": [],
      "raises": {}
    },
    {
      "module": "cli.splade",
      "path": "/home/paul/kgfoundry/codeintel_rev/cli/splade.py",
      "is_test": false,
      "imports": [
        "__future__.annotations",
        "pathlib.Path",
        "typing.Annotated",
        "msgspec",
        "typer",
        "tools.CliContext",
        "tools.EnvelopeBuilder",
        "tools.cli_operation",
        "tools.sha256_file",
        "codeintel_rev.config.settings.load_settings",
        "codeintel_rev.io.splade_manager.SpladeArtifactsManager",
        "codeintel_rev.io.splade_manager.SpladeBenchmarkOptions",
        "codeintel_rev.io.splade_manager.SpladeBuildOptions",
        "codeintel_rev.io.splade_manager.SpladeEncodeOptions",
        "codeintel_rev.io.splade_manager.SpladeEncoderService",
        "codeintel_rev.io.splade_manager.SpladeExportOptions",
        "codeintel_rev.io.splade_manager.SpladeIndexManager"
      ],
      "public_api": [
        "export_onnx",
        "encode",
        "build_index",
        "bench",
        "main"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 0,
        "class_with_doc": 0,
        "func_total": 13,
        "func_with_doc": 9
      },
      "typing": {
        "functions": 13,
        "annotated_returns": 13,
        "total_params": 34,
        "annotated_params": 34
      },
      "complexity": {
        "branch_points": 6,
        "max_nesting": 3
      },
      "loc": 486,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "codeintel_rev.config.settings.load_settings",
          "codeintel_rev.io.splade_manager.SpladeArtifactsManager",
          "codeintel_rev.io.splade_manager.SpladeBenchmarkOptions",
          "codeintel_rev.io.splade_manager.SpladeBuildOptions",
          "codeintel_rev.io.splade_manager.SpladeEncodeOptions",
          "codeintel_rev.io.splade_manager.SpladeEncoderService",
          "codeintel_rev.io.splade_manager.SpladeExportOptions",
          "codeintel_rev.io.splade_manager.SpladeIndexManager",
          "msgspec",
          "pathlib.Path",
          "tools.CliContext",
          "tools.EnvelopeBuilder",
          "tools.cli_operation",
          "tools.sha256_file",
          "typer",
          "typing.Annotated"
        ],
        "type_checking_imports": [],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [
        "export_onnx",
        "encode",
        "build_index",
        "bench",
        "main"
      ],
      "public_api_details": [
        {
          "name": "export_onnx",
          "kind": "function",
          "signature": "export_onnx(*, model_id: str | None = MODEL_ID_OPTION, optimize: OptimizeFlag = True, quantize: QuantizeFlag = True, quantization_config: str = QUANTIZATION_OPTION) -> None",
          "doc_one_liner": "Export SPLADE ONNX artifacts (optimized and quantized).",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/cli/splade.py:107"
        },
        {
          "name": "encode",
          "kind": "function",
          "signature": "encode(*, source: Path = SOURCE_ARGUMENT, output_dir: Path | None = OUTPUT_DIR_OPTION, batch_size: int | None = BATCH_SIZE_OPTION, quantization: int | None = QUANTIZATION_OPTION_ENCODE, shard_size: int = SHARD_SIZE_OPTION) -> None",
          "doc_one_liner": "Encode a corpus into SPLADE JsonVectorCollection shards.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/cli/splade.py:196"
        },
        {
          "name": "build_index",
          "kind": "function",
          "signature": "build_index(*, vectors_dir: Path | None = VECTORS_DIR_OPTION, index_dir: Path | None = INDEX_DIR_OPTION, threads: int | None = THREADS_OPTION, max_clause_count: int | None = MAX_CLAUSE_OPTION, overwrite: OverwriteFlag = True) -> None",
          "doc_one_liner": "Build a SPLADE Lucene impact index from JsonVectorCollection shards.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/cli/splade.py:308"
        },
        {
          "name": "bench",
          "kind": "function",
          "signature": "bench(*, query: str | None = QUERY_OPTION, queries_file: Path | None = QUERIES_FILE_OPTION, warmup: int = WARMUP_OPTION, runs: int = RUNS_OPTION) -> None",
          "doc_one_liner": "Benchmark SPLADE query encoding latency.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/cli/splade.py:369"
        },
        {
          "name": "main",
          "kind": "function",
          "signature": "main() -> None",
          "doc_one_liner": "Run the SPLADE CLI directly.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/cli/splade.py:480"
        }
      ],
      "raises": {
        "bench": [
          "BadParameter"
        ]
      }
    },
    {
      "module": "cli.bm25",
      "path": "/home/paul/kgfoundry/codeintel_rev/cli/bm25.py",
      "is_test": false,
      "imports": [
        "__future__.annotations",
        "pathlib.Path",
        "typer",
        "tools.CliContext",
        "tools.EnvelopeBuilder",
        "tools.cli_operation",
        "tools.sha256_file",
        "codeintel_rev.config.settings.load_settings",
        "codeintel_rev.io.bm25_manager.BM25BuildOptions",
        "codeintel_rev.io.bm25_manager.BM25IndexManager"
      ],
      "public_api": [
        "prepare_corpus",
        "build_index",
        "main"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 0,
        "class_with_doc": 0,
        "func_total": 7,
        "func_with_doc": 5
      },
      "typing": {
        "functions": 7,
        "annotated_returns": 7,
        "total_params": 18,
        "annotated_params": 18
      },
      "complexity": {
        "branch_points": 2,
        "max_nesting": 2
      },
      "loc": 189,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "codeintel_rev.config.settings.load_settings",
          "codeintel_rev.io.bm25_manager.BM25BuildOptions",
          "codeintel_rev.io.bm25_manager.BM25IndexManager",
          "pathlib.Path",
          "tools.CliContext",
          "tools.EnvelopeBuilder",
          "tools.cli_operation",
          "tools.sha256_file",
          "typer"
        ],
        "type_checking_imports": [],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [
        "prepare_corpus",
        "build_index",
        "main"
      ],
      "public_api_details": [
        {
          "name": "prepare_corpus",
          "kind": "function",
          "signature": "prepare_corpus(*, source: Path = SOURCE_ARGUMENT, output_dir: Path | None = OUTPUT_DIR_OPTION, overwrite: bool = OVERWRITE_OPTION) -> None",
          "doc_one_liner": "Prepare a BM25 JsonCollection from a JSONL source.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/cli/bm25.py:57"
        },
        {
          "name": "build_index",
          "kind": "function",
          "signature": "build_index(*, json_dir: Path | None = JSON_DIR_OPTION, index_dir: Path | None = INDEX_DIR_OPTION, threads: int | None = THREADS_OPTION) -> None",
          "doc_one_liner": "Build a Lucene BM25 index using Pyserini.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/cli/bm25.py:127"
        },
        {
          "name": "main",
          "kind": "function",
          "signature": "main() -> None",
          "doc_one_liner": "Run the BM25 CLI directly.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/cli/bm25.py:183"
        }
      ],
      "raises": {}
    },
    {
      "module": "cli",
      "path": "/home/paul/kgfoundry/codeintel_rev/cli/__init__.py",
      "is_test": false,
      "imports": [
        "__future__.annotations",
        "typer",
        "codeintel_rev.cli.bm25",
        "codeintel_rev.cli.splade",
        "codeintel_rev.cli.xtr"
      ],
      "public_api": [
        "main"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 0,
        "class_with_doc": 0,
        "func_total": 1,
        "func_with_doc": 1
      },
      "typing": {
        "functions": 1,
        "annotated_returns": 1,
        "total_params": 0,
        "annotated_params": 0
      },
      "complexity": {
        "branch_points": 1,
        "max_nesting": 1
      },
      "loc": 25,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "codeintel_rev.cli.bm25",
          "codeintel_rev.cli.splade",
          "codeintel_rev.cli.xtr",
          "typer"
        ],
        "type_checking_imports": [],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [
        "main"
      ],
      "public_api_details": [
        {
          "name": "main",
          "kind": "function",
          "signature": "main() -> None",
          "doc_one_liner": "Run the aggregated CodeIntel CLI.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/cli/__init__.py:19"
        }
      ],
      "raises": {}
    },
    {
      "module": "mcp_server.common.observability",
      "path": "/home/paul/kgfoundry/codeintel_rev/mcp_server/common/observability.py",
      "is_test": false,
      "imports": [
        "__future__.annotations",
        "collections.abc.Iterator",
        "contextlib.contextmanager",
        "typing.Protocol",
        "kgfoundry_common.logging.get_logger",
        "kgfoundry_common.observability.MetricsProvider",
        "kgfoundry_common.observability.observe_duration"
      ],
      "public_api": [
        "Observation",
        "observe_duration"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 2,
        "class_with_doc": 2,
        "func_total": 6,
        "func_with_doc": 6
      },
      "typing": {
        "functions": 6,
        "annotated_returns": 6,
        "total_params": 8,
        "annotated_params": 4
      },
      "complexity": {
        "branch_points": 8,
        "max_nesting": 3
      },
      "loc": 141,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "collections.abc.Iterator",
          "contextlib.contextmanager",
          "kgfoundry_common.logging.get_logger",
          "kgfoundry_common.observability.MetricsProvider",
          "kgfoundry_common.observability.observe_duration",
          "typing.Protocol"
        ],
        "type_checking_imports": [],
        "exports": [
          "Observation",
          "observe_duration"
        ],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [
        "Observation",
        "observe_duration"
      ],
      "public_api_details": [
        {
          "name": "Observation",
          "kind": "class",
          "signature": "class Observation(Protocol)",
          "doc_one_liner": "Protocol describing the helpers provided by metrics observations.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/mcp_server/common/observability.py:79"
        },
        {
          "name": "observe_duration",
          "kind": "function",
          "signature": "observe_duration(operation: str, component: str, *, metrics: MetricsProvider | None = None) -> Iterator[Observation]",
          "doc_one_liner": "Yield a metrics observation with graceful degradation.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/mcp_server/common/observability.py:90"
        }
      ],
      "raises": {}
    },
    {
      "module": "mcp_server.common",
      "path": "/home/paul/kgfoundry/codeintel_rev/mcp_server/common/__init__.py",
      "is_test": false,
      "imports": [],
      "public_api": [],
      "doc": {
        "module_doc": true,
        "class_total": 0,
        "class_with_doc": 0,
        "func_total": 0,
        "func_with_doc": 0
      },
      "typing": {
        "functions": 0,
        "annotated_returns": 0,
        "total_params": 0,
        "annotated_params": 0
      },
      "complexity": {
        "branch_points": 0,
        "max_nesting": 0
      },
      "loc": 1,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [],
        "type_checking_imports": [],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [],
      "raises": {}
    },
    {
      "module": "mcp_server.tools",
      "path": "/home/paul/kgfoundry/codeintel_rev/mcp_server/tools/__init__.py",
      "is_test": false,
      "imports": [],
      "public_api": [],
      "doc": {
        "module_doc": true,
        "class_total": 0,
        "class_with_doc": 0,
        "func_total": 0,
        "func_with_doc": 0
      },
      "typing": {
        "functions": 0,
        "annotated_returns": 0,
        "total_params": 0,
        "annotated_params": 0
      },
      "complexity": {
        "branch_points": 0,
        "max_nesting": 0
      },
      "loc": 1,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [],
        "type_checking_imports": [],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [],
      "raises": {}
    },
    {
      "module": "mcp_server.tools.gpu_doctor",
      "path": "/home/paul/kgfoundry/codeintel_rev/mcp_server/tools/gpu_doctor.py",
      "is_test": false,
      "imports": [
        "__future__.annotations",
        "argparse",
        "sys",
        "traceback",
        "typing.TYPE_CHECKING",
        "typing.cast",
        "codeintel_rev._lazy_imports.LazyModule",
        "codeintel_rev.typing.gate_import",
        "faiss",
        "numpy",
        "torch"
      ],
      "public_api": [
        "check_torch",
        "check_faiss",
        "main"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 0,
        "class_with_doc": 0,
        "func_total": 3,
        "func_with_doc": 3
      },
      "typing": {
        "functions": 3,
        "annotated_returns": 3,
        "total_params": 1,
        "annotated_params": 1
      },
      "complexity": {
        "branch_points": 19,
        "max_nesting": 3
      },
      "loc": 201,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "argparse",
          "codeintel_rev._lazy_imports.LazyModule",
          "codeintel_rev.typing.gate_import",
          "sys",
          "traceback",
          "typing.TYPE_CHECKING",
          "typing.cast"
        ],
        "type_checking_imports": [
          "_faiss",
          "_torch",
          "np"
        ],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [
        "check_torch",
        "check_faiss",
        "main"
      ],
      "public_api_details": [
        {
          "name": "check_torch",
          "kind": "function",
          "signature": "check_torch(device_index: int = 0) -> tuple[bool, dict[str, object]]",
          "doc_one_liner": "Check PyTorch CUDA availability and perform smoke test.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/mcp_server/tools/gpu_doctor.py:36"
        },
        {
          "name": "check_faiss",
          "kind": "function",
          "signature": "check_faiss() -> tuple[bool, dict[str, object]]",
          "doc_one_liner": "Check FAISS GPU availability and perform smoke test.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/mcp_server/tools/gpu_doctor.py:96"
        },
        {
          "name": "main",
          "kind": "function",
          "signature": "main() -> None",
          "doc_one_liner": "Run GPU diagnostics and print results.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/mcp_server/tools/gpu_doctor.py:149"
        }
      ],
      "raises": {}
    },
    {
      "module": "mcp_server.retrieval.xtr_cli",
      "path": "/home/paul/kgfoundry/codeintel_rev/mcp_server/retrieval/xtr_cli.py",
      "is_test": false,
      "imports": [
        "__future__.annotations",
        "typing.Annotated",
        "typer",
        "codeintel_rev.app.config_context.resolve_application_paths",
        "codeintel_rev.config.settings.load_settings",
        "codeintel_rev.indexing.xtr_build.build_xtr_index",
        "codeintel_rev.io.xtr_manager.XTRIndex"
      ],
      "public_api": [
        "build",
        "verify",
        "search",
        "main"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 0,
        "class_with_doc": 0,
        "func_total": 4,
        "func_with_doc": 4
      },
      "typing": {
        "functions": 4,
        "annotated_returns": 4,
        "total_params": 4,
        "annotated_params": 4
      },
      "complexity": {
        "branch_points": 11,
        "max_nesting": 4
      },
      "loc": 164,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "codeintel_rev.app.config_context.resolve_application_paths",
          "codeintel_rev.config.settings.load_settings",
          "codeintel_rev.indexing.xtr_build.build_xtr_index",
          "codeintel_rev.io.xtr_manager.XTRIndex",
          "typer",
          "typing.Annotated"
        ],
        "type_checking_imports": [],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [
        "build",
        "verify",
        "search",
        "main"
      ],
      "public_api_details": [
        {
          "name": "build",
          "kind": "function",
          "signature": "build() -> None",
          "doc_one_liner": "Build token-level XTR artifacts from the DuckDB catalog.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/mcp_server/retrieval/xtr_cli.py:31"
        },
        {
          "name": "verify",
          "kind": "function",
          "signature": "verify() -> None",
          "doc_one_liner": "Verify that XTR artifacts can be opened.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/mcp_server/retrieval/xtr_cli.py:44"
        },
        {
          "name": "search",
          "kind": "function",
          "signature": "search(query: _QueryArg, k: _KOption = 5, candidate_ids: _CandidateIdsOption = None, explain: _ExplainOption = None) -> None",
          "doc_one_liner": "Run a quick XTR search (wide or narrow depending on candidate ids).",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/mcp_server/retrieval/xtr_cli.py:70"
        },
        {
          "name": "main",
          "kind": "function",
          "signature": "main() -> None",
          "doc_one_liner": "Execute the Typer app.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/mcp_server/retrieval/xtr_cli.py:158"
        }
      ],
      "raises": {
        "verify": [
          "Exit"
        ],
        "search": [
          "Exit"
        ]
      }
    },
    {
      "module": "mcp_server.retrieval",
      "path": "/home/paul/kgfoundry/codeintel_rev/mcp_server/retrieval/__init__.py",
      "is_test": false,
      "imports": [
        "codeintel_rev.mcp_server.retrieval.xtr_cli"
      ],
      "public_api": [
        "xtr_cli"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 0,
        "class_with_doc": 0,
        "func_total": 0,
        "func_with_doc": 0
      },
      "typing": {
        "functions": 0,
        "annotated_returns": 0,
        "total_params": 0,
        "annotated_params": 0
      },
      "complexity": {
        "branch_points": 0,
        "max_nesting": 0
      },
      "loc": 5,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "codeintel_rev.mcp_server.retrieval.xtr_cli"
        ],
        "type_checking_imports": [],
        "exports": [
          "xtr_cli"
        ],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [
        "xtr_cli"
      ],
      "public_api_details": [],
      "raises": {}
    },
    {
      "module": "mcp_server.adapters.semantic",
      "path": "/home/paul/kgfoundry/codeintel_rev/mcp_server/adapters/semantic.py",
      "is_test": false,
      "imports": [
        "__future__.annotations",
        "asyncio",
        "collections.abc.Sequence",
        "dataclasses.dataclass",
        "pathlib.Path",
        "time.perf_counter",
        "typing.TYPE_CHECKING",
        "typing.cast",
        "codeintel_rev._lazy_imports.LazyModule",
        "codeintel_rev.app.middleware.get_session_id",
        "codeintel_rev.io.faiss_manager.FAISSManager",
        "codeintel_rev.io.vllm_client.VLLMClient",
        "codeintel_rev.mcp_server.common.observability.Observation",
        "codeintel_rev.mcp_server.common.observability.observe_duration",
        "codeintel_rev.mcp_server.schemas.AnswerEnvelope",
        "codeintel_rev.mcp_server.schemas.Finding",
        "codeintel_rev.mcp_server.schemas.MethodInfo",
        "codeintel_rev.mcp_server.schemas.ScopeIn",
        "codeintel_rev.mcp_server.scope_utils.get_effective_scope",
        "codeintel_rev.typing.NDArrayF32",
        "kgfoundry_common.errors.EmbeddingError",
        "kgfoundry_common.errors.VectorSearchError",
        "kgfoundry_common.logging.get_logger",
        "httpx",
        "numpy",
        "codeintel_rev.app.config_context.ApplicationContext"
      ],
      "public_api": [
        "semantic_search"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 6,
        "class_with_doc": 6,
        "func_total": 22,
        "func_with_doc": 21
      },
      "typing": {
        "functions": 22,
        "annotated_returns": 22,
        "total_params": 75,
        "annotated_params": 73
      },
      "complexity": {
        "branch_points": 56,
        "max_nesting": 5
      },
      "loc": 1101,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "asyncio",
          "codeintel_rev._lazy_imports.LazyModule",
          "codeintel_rev.app.middleware.get_session_id",
          "codeintel_rev.io.faiss_manager.FAISSManager",
          "codeintel_rev.io.vllm_client.VLLMClient",
          "codeintel_rev.mcp_server.common.observability.Observation",
          "codeintel_rev.mcp_server.common.observability.observe_duration",
          "codeintel_rev.mcp_server.schemas.AnswerEnvelope",
          "codeintel_rev.mcp_server.schemas.Finding",
          "codeintel_rev.mcp_server.schemas.MethodInfo",
          "codeintel_rev.mcp_server.schemas.ScopeIn",
          "codeintel_rev.mcp_server.scope_utils.get_effective_scope",
          "codeintel_rev.typing.NDArrayF32",
          "collections.abc.Sequence",
          "dataclasses.dataclass",
          "kgfoundry_common.errors.EmbeddingError",
          "kgfoundry_common.errors.VectorSearchError",
          "kgfoundry_common.logging.get_logger",
          "pathlib.Path",
          "time.perf_counter",
          "typing.TYPE_CHECKING",
          "typing.cast"
        ],
        "type_checking_imports": [
          "codeintel_rev.app.config_context.ApplicationContext",
          "httpx",
          "np"
        ],
        "exports": [
          "semantic_search"
        ],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [
        "semantic_search"
      ],
      "public_api_details": [
        {
          "name": "semantic_search",
          "kind": "function",
          "signature": "semantic_search(context: ApplicationContext, query: str, limit: int = 20) -> AnswerEnvelope",
          "doc_one_liner": "Perform semantic search using embeddings.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/mcp_server/adapters/semantic.py:129"
        }
      ],
      "raises": {
        "_build_search_budget": [
          "VectorSearchError"
        ],
        "_embed_query_or_raise": [
          "EmbeddingError"
        ],
        "_run_faiss_search_or_raise": [
          "VectorSearchError"
        ],
        "_ensure_hydration_success": [
          "VectorSearchError"
        ]
      }
    },
    {
      "module": "mcp_server.adapters.files",
      "path": "/home/paul/kgfoundry/codeintel_rev/mcp_server/adapters/files.py",
      "is_test": false,
      "imports": [
        "__future__.annotations",
        "asyncio",
        "fnmatch",
        "os",
        "collections.abc.Sequence",
        "dataclasses.dataclass",
        "pathlib.Path",
        "typing.TYPE_CHECKING",
        "typing.SupportsIndex",
        "typing.cast",
        "codeintel_rev.app.middleware.get_session_id",
        "codeintel_rev.errors.FileReadError",
        "codeintel_rev.errors.InvalidLineRangeError",
        "codeintel_rev.errors.PathNotDirectoryError",
        "codeintel_rev.errors.PathNotFoundError",
        "codeintel_rev.io.path_utils.PathOutsideRepositoryError",
        "codeintel_rev.io.path_utils.resolve_within_repo",
        "codeintel_rev.mcp_server.schemas.ScopeIn",
        "codeintel_rev.mcp_server.scope_utils.LANGUAGE_EXTENSIONS",
        "codeintel_rev.mcp_server.scope_utils.get_effective_scope",
        "codeintel_rev.mcp_server.scope_utils.merge_scope_filters",
        "kgfoundry_common.logging.get_logger",
        "codeintel_rev.app.config_context.ApplicationContext"
      ],
      "public_api": [
        "list_paths",
        "open_file",
        "set_scope"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 2,
        "class_with_doc": 2,
        "func_total": 14,
        "func_with_doc": 9
      },
      "typing": {
        "functions": 14,
        "annotated_returns": 14,
        "total_params": 38,
        "annotated_params": 38
      },
      "complexity": {
        "branch_points": 54,
        "max_nesting": 4
      },
      "loc": 714,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "asyncio",
          "codeintel_rev.app.middleware.get_session_id",
          "codeintel_rev.errors.FileReadError",
          "codeintel_rev.errors.InvalidLineRangeError",
          "codeintel_rev.errors.PathNotDirectoryError",
          "codeintel_rev.errors.PathNotFoundError",
          "codeintel_rev.io.path_utils.PathOutsideRepositoryError",
          "codeintel_rev.io.path_utils.resolve_within_repo",
          "codeintel_rev.mcp_server.schemas.ScopeIn",
          "codeintel_rev.mcp_server.scope_utils.LANGUAGE_EXTENSIONS",
          "codeintel_rev.mcp_server.scope_utils.get_effective_scope",
          "codeintel_rev.mcp_server.scope_utils.merge_scope_filters",
          "collections.abc.Sequence",
          "dataclasses.dataclass",
          "fnmatch",
          "kgfoundry_common.logging.get_logger",
          "os",
          "pathlib.Path",
          "typing.SupportsIndex",
          "typing.TYPE_CHECKING",
          "typing.cast"
        ],
        "type_checking_imports": [
          "codeintel_rev.app.config_context.ApplicationContext"
        ],
        "exports": [
          "list_paths",
          "open_file",
          "set_scope"
        ],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [
        "list_paths",
        "open_file",
        "set_scope"
      ],
      "public_api_details": [
        {
          "name": "set_scope",
          "kind": "function",
          "signature": "set_scope(context: ApplicationContext, scope: ScopeIn) -> dict",
          "doc_one_liner": "Set query scope for subsequent operations.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/mcp_server/adapters/files.py:58"
        },
        {
          "name": "list_paths",
          "kind": "function",
          "signature": "list_paths(context: ApplicationContext, *args: object, **kwargs: object) -> dict",
          "doc_one_liner": "List files in repository (async with threadpool offload).",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/mcp_server/adapters/files.py:102"
        },
        {
          "name": "open_file",
          "kind": "function",
          "signature": "open_file(context: ApplicationContext, path: str, start_line: int | None = None, end_line: int | None = None) -> dict",
          "doc_one_liner": "Read file content with optional line slicing.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/mcp_server/adapters/files.py:498"
        }
      ],
      "raises": {
        "_normalize_list_paths_arguments": [
          "TypeError"
        ],
        "open_file": [
          "FileReadError",
          "InvalidLineRangeError",
          "PathNotFoundError"
        ],
        "_resolve_search_root": [
          "PathNotDirectoryError",
          "PathNotFoundError"
        ]
      }
    },
    {
      "module": "mcp_server.adapters.semantic_pro",
      "path": "/home/paul/kgfoundry/codeintel_rev/mcp_server/adapters/semantic_pro.py",
      "is_test": false,
      "imports": [
        "__future__.annotations",
        "asyncio",
        "collections.abc.Mapping",
        "collections.abc.Sequence",
        "concurrent.futures.Future",
        "concurrent.futures.ThreadPoolExecutor",
        "dataclasses.dataclass",
        "dataclasses.field",
        "pathlib.Path",
        "time.perf_counter",
        "typing.TYPE_CHECKING",
        "typing.Any",
        "typing.TypedDict",
        "typing.cast",
        "codeintel_rev.app.middleware.get_session_id",
        "codeintel_rev.errors.RuntimeUnavailableError",
        "codeintel_rev.io.hybrid_search.ChannelHit",
        "codeintel_rev.io.rerank_coderankllm.CodeRankListwiseReranker",
        "codeintel_rev.io.warp_engine.WarpEngine",
        "codeintel_rev.io.warp_engine.WarpUnavailableError",
        "codeintel_rev.mcp_server.common.observability.Observation",
        "codeintel_rev.mcp_server.common.observability.observe_duration",
        "codeintel_rev.mcp_server.schemas.AnswerEnvelope",
        "codeintel_rev.mcp_server.schemas.Finding",
        "codeintel_rev.mcp_server.schemas.MethodInfo",
        "codeintel_rev.mcp_server.schemas.ScopeIn",
        "codeintel_rev.mcp_server.schemas.StageInfo",
        "codeintel_rev.mcp_server.scope_utils.get_effective_scope",
        "codeintel_rev.retrieval.gating.StageGateConfig",
        "codeintel_rev.retrieval.gating.should_run_secondary_stage",
        "codeintel_rev.retrieval.telemetry.StageTiming",
        "codeintel_rev.retrieval.telemetry.record_stage_decision",
        "codeintel_rev.retrieval.telemetry.record_stage_metric",
        "codeintel_rev.retrieval.telemetry.track_stage",
        "codeintel_rev.retrieval.types.HybridResultDoc",
        "codeintel_rev.retrieval.types.HybridSearchResult",
        "codeintel_rev.retrieval.types.StageDecision",
        "codeintel_rev.retrieval.types.StageSignals",
        "kgfoundry_common.errors.EmbeddingError",
        "kgfoundry_common.errors.VectorSearchError",
        "kgfoundry_common.logging.get_logger",
        "codeintel_rev.app.config_context.ApplicationContext",
        "codeintel_rev.config.settings.XTRConfig",
        "codeintel_rev.io.xtr_manager.XTRIndex"
      ],
      "public_api": [
        "SemanticProOptions",
        "SemanticProRuntimeOptions",
        "StageOnePlan",
        "HydrationPlan",
        "build_runtime_options",
        "semantic_search_pro",
        "merge_explainability_into_findings",
        "WarpOutcome",
        "FusionRequest",
        "MethodContext"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 7,
        "class_with_doc": 7,
        "func_total": 31,
        "func_with_doc": 7
      },
      "typing": {
        "functions": 31,
        "annotated_returns": 31,
        "total_params": 94,
        "annotated_params": 94
      },
      "complexity": {
        "branch_points": 114,
        "max_nesting": 5
      },
      "loc": 1418,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "asyncio",
          "codeintel_rev.app.middleware.get_session_id",
          "codeintel_rev.errors.RuntimeUnavailableError",
          "codeintel_rev.io.hybrid_search.ChannelHit",
          "codeintel_rev.io.rerank_coderankllm.CodeRankListwiseReranker",
          "codeintel_rev.io.warp_engine.WarpEngine",
          "codeintel_rev.io.warp_engine.WarpUnavailableError",
          "codeintel_rev.mcp_server.common.observability.Observation",
          "codeintel_rev.mcp_server.common.observability.observe_duration",
          "codeintel_rev.mcp_server.schemas.AnswerEnvelope",
          "codeintel_rev.mcp_server.schemas.Finding",
          "codeintel_rev.mcp_server.schemas.MethodInfo",
          "codeintel_rev.mcp_server.schemas.ScopeIn",
          "codeintel_rev.mcp_server.schemas.StageInfo",
          "codeintel_rev.mcp_server.scope_utils.get_effective_scope",
          "codeintel_rev.retrieval.gating.StageGateConfig",
          "codeintel_rev.retrieval.gating.should_run_secondary_stage",
          "codeintel_rev.retrieval.telemetry.StageTiming",
          "codeintel_rev.retrieval.telemetry.record_stage_decision",
          "codeintel_rev.retrieval.telemetry.record_stage_metric",
          "codeintel_rev.retrieval.telemetry.track_stage",
          "codeintel_rev.retrieval.types.HybridResultDoc",
          "codeintel_rev.retrieval.types.HybridSearchResult",
          "codeintel_rev.retrieval.types.StageDecision",
          "codeintel_rev.retrieval.types.StageSignals",
          "collections.abc.Mapping",
          "collections.abc.Sequence",
          "concurrent.futures.Future",
          "concurrent.futures.ThreadPoolExecutor",
          "dataclasses.dataclass",
          "dataclasses.field",
          "kgfoundry_common.errors.EmbeddingError",
          "kgfoundry_common.errors.VectorSearchError",
          "kgfoundry_common.logging.get_logger",
          "pathlib.Path",
          "time.perf_counter",
          "typing.Any",
          "typing.TYPE_CHECKING",
          "typing.TypedDict",
          "typing.cast"
        ],
        "type_checking_imports": [
          "codeintel_rev.app.config_context.ApplicationContext",
          "codeintel_rev.config.settings.XTRConfig",
          "codeintel_rev.io.xtr_manager.XTRIndex"
        ],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [
        "SemanticProOptions",
        "SemanticProRuntimeOptions",
        "StageOnePlan",
        "HydrationPlan",
        "build_runtime_options",
        "semantic_search_pro",
        "merge_explainability_into_findings",
        "WarpOutcome",
        "FusionRequest",
        "MethodContext"
      ],
      "public_api_details": [
        {
          "name": "SemanticProOptions",
          "kind": "class",
          "signature": "class SemanticProOptions(TypedDict)",
          "doc_one_liner": "User-facing options for semantic_pro retrieval.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/mcp_server/adapters/semantic_pro.py:53"
        },
        {
          "name": "SemanticProRuntimeOptions",
          "kind": "class",
          "signature": "class SemanticProRuntimeOptions",
          "doc_one_liner": "Internal immutable representation of semantic_pro options.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/mcp_server/adapters/semantic_pro.py:65"
        },
        {
          "name": "StageOnePlan",
          "kind": "class",
          "signature": "class StageOnePlan",
          "doc_one_liner": "Container for Stage-1 orchestration inputs to reduce argument lists.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/mcp_server/adapters/semantic_pro.py:80"
        },
        {
          "name": "HydrationPlan",
          "kind": "class",
          "signature": "class HydrationPlan",
          "doc_one_liner": "Hydration plus rerank inputs passed as a cohesive plan.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/mcp_server/adapters/semantic_pro.py:92"
        },
        {
          "name": "build_runtime_options",
          "kind": "function",
          "signature": "build_runtime_options(options: SemanticProOptions | None) -> SemanticProRuntimeOptions",
          "doc_one_liner": "Normalize user-supplied options into an immutable dataclass.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/mcp_server/adapters/semantic_pro.py:104"
        },
        {
          "name": "semantic_search_pro",
          "kind": "function",
          "signature": "semantic_search_pro(context: ApplicationContext, *, query: str, limit: int, options: SemanticProOptions | None = None) -> AnswerEnvelope",
          "doc_one_liner": "Execute the two-stage semantic search pipeline (CodeRank \u2192 optional WARP \u2192 optional reranker).",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/mcp_server/adapters/semantic_pro.py:176"
        },
        {
          "name": "merge_explainability_into_findings",
          "kind": "function",
          "signature": "merge_explainability_into_findings(findings: list[Finding], explainability: Sequence[tuple[int, dict[str, Any]]]) -> None",
          "doc_one_liner": "Append token-level explainability snippets to existing findings.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/mcp_server/adapters/semantic_pro.py:1132"
        },
        {
          "name": "WarpOutcome",
          "kind": "class",
          "signature": "class WarpOutcome",
          "doc_one_liner": "Container describing the results of the optional WARP stage.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/mcp_server/adapters/semantic_pro.py:1385"
        },
        {
          "name": "FusionRequest",
          "kind": "class",
          "signature": "class FusionRequest",
          "doc_one_liner": "Inputs required to execute the fusion stage.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/mcp_server/adapters/semantic_pro.py:1396"
        },
        {
          "name": "MethodContext",
          "kind": "class",
          "signature": "class MethodContext",
          "doc_one_liner": "Inputs required to build the MethodInfo payload.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/mcp_server/adapters/semantic_pro.py:1408"
        }
      ],
      "raises": {
        "semantic_search_pro": [
          "VectorSearchError"
        ],
        "_semantic_search_pro_sync": [
          "VectorSearchError"
        ],
        "_run_coderank_stage": [
          "EmbeddingError",
          "VectorSearchError"
        ],
        "_safe_int": [
          "VectorSearchError"
        ],
        "_hydrate_and_rerank_records": [
          "VectorSearchError"
        ]
      }
    },
    {
      "module": "mcp_server.adapters.text_search",
      "path": "/home/paul/kgfoundry/codeintel_rev/mcp_server/adapters/text_search.py",
      "is_test": false,
      "imports": [
        "__future__.annotations",
        "asyncio",
        "json",
        "collections.abc.Mapping",
        "collections.abc.Sequence",
        "dataclasses.dataclass",
        "pathlib.Path",
        "typing.TYPE_CHECKING",
        "typing.cast",
        "codeintel_rev.app.middleware.get_session_id",
        "codeintel_rev.mcp_server.common.observability.Observation",
        "codeintel_rev.mcp_server.common.observability.observe_duration",
        "codeintel_rev.mcp_server.schemas.Match",
        "codeintel_rev.mcp_server.schemas.ScopeIn",
        "codeintel_rev.mcp_server.scope_utils.get_effective_scope",
        "codeintel_rev.mcp_server.scope_utils.merge_scope_filters",
        "kgfoundry_common.errors.VectorSearchError",
        "kgfoundry_common.logging.get_logger",
        "kgfoundry_common.subprocess_utils.SubprocessError",
        "kgfoundry_common.subprocess_utils.SubprocessTimeoutError",
        "kgfoundry_common.subprocess_utils.run_subprocess",
        "codeintel_rev.app.config_context.ApplicationContext"
      ],
      "public_api": [
        "search_text"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 2,
        "class_with_doc": 2,
        "func_total": 9,
        "func_with_doc": 8
      },
      "typing": {
        "functions": 9,
        "annotated_returns": 9,
        "total_params": 26,
        "annotated_params": 25
      },
      "complexity": {
        "branch_points": 50,
        "max_nesting": 5
      },
      "loc": 595,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "asyncio",
          "codeintel_rev.app.middleware.get_session_id",
          "codeintel_rev.mcp_server.common.observability.Observation",
          "codeintel_rev.mcp_server.common.observability.observe_duration",
          "codeintel_rev.mcp_server.schemas.Match",
          "codeintel_rev.mcp_server.schemas.ScopeIn",
          "codeintel_rev.mcp_server.scope_utils.get_effective_scope",
          "codeintel_rev.mcp_server.scope_utils.merge_scope_filters",
          "collections.abc.Mapping",
          "collections.abc.Sequence",
          "dataclasses.dataclass",
          "json",
          "kgfoundry_common.errors.VectorSearchError",
          "kgfoundry_common.logging.get_logger",
          "kgfoundry_common.subprocess_utils.SubprocessError",
          "kgfoundry_common.subprocess_utils.SubprocessTimeoutError",
          "kgfoundry_common.subprocess_utils.run_subprocess",
          "pathlib.Path",
          "typing.TYPE_CHECKING",
          "typing.cast"
        ],
        "type_checking_imports": [
          "codeintel_rev.app.config_context.ApplicationContext"
        ],
        "exports": [
          "search_text"
        ],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [
        "search_text"
      ],
      "public_api_details": [
        {
          "name": "search_text",
          "kind": "function",
          "signature": "search_text(context: ApplicationContext, query: str, *, options: TextSearchOptions | None = None, **overrides: object) -> dict",
          "doc_one_liner": "Fast text search using ripgrep (async wrapper).",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/mcp_server/adapters/text_search.py:204"
        }
      ],
      "raises": {
        "_bool_override": [
          "TypeError"
        ],
        "_sequence_override": [
          "TypeError"
        ],
        "_int_override": [
          "TypeError"
        ],
        "search_text": [
          "TypeError"
        ],
        "_search_text_sync": [
          "VectorSearchError"
        ],
        "_fallback_grep": [
          "VectorSearchError"
        ],
        "from_overrides": [
          "TypeError"
        ]
      }
    },
    {
      "module": "mcp_server.adapters",
      "path": "/home/paul/kgfoundry/codeintel_rev/mcp_server/adapters/__init__.py",
      "is_test": false,
      "imports": [
        "__future__.annotations"
      ],
      "public_api": [],
      "doc": {
        "module_doc": true,
        "class_total": 0,
        "class_with_doc": 0,
        "func_total": 0,
        "func_with_doc": 0
      },
      "typing": {
        "functions": 0,
        "annotated_returns": 0,
        "total_params": 0,
        "annotated_params": 0
      },
      "complexity": {
        "branch_points": 0,
        "max_nesting": 0
      },
      "loc": 9,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations"
        ],
        "type_checking_imports": [],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [],
      "raises": {}
    },
    {
      "module": "mcp_server.adapters.history",
      "path": "/home/paul/kgfoundry/codeintel_rev/mcp_server/adapters/history.py",
      "is_test": false,
      "imports": [
        "__future__.annotations",
        "typing.TYPE_CHECKING",
        "git.exc",
        "codeintel_rev.errors.GitOperationError",
        "codeintel_rev.errors.PathNotFoundError",
        "codeintel_rev.io.path_utils.resolve_within_repo",
        "kgfoundry_common.logging.get_logger",
        "codeintel_rev.app.config_context.ApplicationContext"
      ],
      "public_api": [
        "blame_range",
        "file_history"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 0,
        "class_with_doc": 0,
        "func_total": 2,
        "func_with_doc": 2
      },
      "typing": {
        "functions": 2,
        "annotated_returns": 2,
        "total_params": 7,
        "annotated_params": 7
      },
      "complexity": {
        "branch_points": 9,
        "max_nesting": 2
      },
      "loc": 203,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "codeintel_rev.errors.GitOperationError",
          "codeintel_rev.errors.PathNotFoundError",
          "codeintel_rev.io.path_utils.resolve_within_repo",
          "git.exc",
          "kgfoundry_common.logging.get_logger",
          "typing.TYPE_CHECKING"
        ],
        "type_checking_imports": [
          "codeintel_rev.app.config_context.ApplicationContext"
        ],
        "exports": [
          "blame_range",
          "file_history"
        ],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [
        "blame_range",
        "file_history"
      ],
      "public_api_details": [
        {
          "name": "blame_range",
          "kind": "function",
          "signature": "blame_range(context: ApplicationContext, path: str, start_line: int, end_line: int) -> dict",
          "doc_one_liner": "Get git blame for line range using GitPython (async).",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/mcp_server/adapters/history.py:24"
        },
        {
          "name": "file_history",
          "kind": "function",
          "signature": "file_history(context: ApplicationContext, path: str, limit: int = 50) -> dict",
          "doc_one_liner": "Get commit history for file using GitPython (async).",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/mcp_server/adapters/history.py:119"
        }
      ],
      "raises": {
        "blame_range": [
          "GitOperationError",
          "PathNotFoundError"
        ],
        "file_history": [
          "GitOperationError",
          "PathNotFoundError"
        ]
      }
    },
    {
      "module": "retrieval.fusion.weighted_rrf",
      "path": "/home/paul/kgfoundry/codeintel_rev/retrieval/fusion/weighted_rrf.py",
      "is_test": false,
      "imports": [
        "__future__.annotations",
        "collections.abc.Mapping",
        "collections.abc.Sequence",
        "codeintel_rev.retrieval.types.ChannelHit",
        "codeintel_rev.retrieval.types.HybridResultDoc"
      ],
      "public_api": [
        "fuse_weighted_rrf"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 0,
        "class_with_doc": 0,
        "func_total": 1,
        "func_with_doc": 1
      },
      "typing": {
        "functions": 1,
        "annotated_returns": 1,
        "total_params": 4,
        "annotated_params": 4
      },
      "complexity": {
        "branch_points": 5,
        "max_nesting": 3
      },
      "loc": 90,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "codeintel_rev.retrieval.types.ChannelHit",
          "codeintel_rev.retrieval.types.HybridResultDoc",
          "collections.abc.Mapping",
          "collections.abc.Sequence"
        ],
        "type_checking_imports": [],
        "exports": [
          "fuse_weighted_rrf"
        ],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [
        "fuse_weighted_rrf"
      ],
      "public_api_details": [
        {
          "name": "fuse_weighted_rrf",
          "kind": "function",
          "signature": "fuse_weighted_rrf(runs: Mapping[str, Sequence[ChannelHit]], *, weights: Mapping[str, float], k: int, limit: int) -> tuple[list[HybridResultDoc], dict[str, list[tuple[str, int, float]]]]",
          "doc_one_liner": "Apply weighted RRF across runs and return fused docs plus contributions.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/retrieval/fusion/weighted_rrf.py:10"
        }
      ],
      "raises": {
        "fuse_weighted_rrf": [
          "ValueError"
        ]
      }
    },
    {
      "module": "retrieval.fusion",
      "path": "/home/paul/kgfoundry/codeintel_rev/retrieval/fusion/__init__.py",
      "is_test": false,
      "imports": [
        "__future__.annotations",
        "codeintel_rev.retrieval.fusion.weighted_rrf.fuse_weighted_rrf"
      ],
      "public_api": [
        "fuse_weighted_rrf"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 0,
        "class_with_doc": 0,
        "func_total": 0,
        "func_with_doc": 0
      },
      "typing": {
        "functions": 0,
        "annotated_returns": 0,
        "total_params": 0,
        "annotated_params": 0
      },
      "complexity": {
        "branch_points": 0,
        "max_nesting": 0
      },
      "loc": 7,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "codeintel_rev.retrieval.fusion.weighted_rrf.fuse_weighted_rrf"
        ],
        "type_checking_imports": [],
        "exports": [
          "fuse_weighted_rrf"
        ],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [
        "fuse_weighted_rrf"
      ],
      "public_api_details": [],
      "raises": {}
    },
    {
      "module": "ops.runtime",
      "path": "/home/paul/kgfoundry/codeintel_rev/ops/runtime/__init__.py",
      "is_test": false,
      "imports": [
        "__future__.annotations"
      ],
      "public_api": [],
      "doc": {
        "module_doc": true,
        "class_total": 0,
        "class_with_doc": 0,
        "func_total": 0,
        "func_with_doc": 0
      },
      "typing": {
        "functions": 0,
        "annotated_returns": 0,
        "total_params": 0,
        "annotated_params": 0
      },
      "complexity": {
        "branch_points": 0,
        "max_nesting": 0
      },
      "loc": 3,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations"
        ],
        "type_checking_imports": [],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [],
      "raises": {}
    },
    {
      "module": "ops.runtime.xtr_open",
      "path": "/home/paul/kgfoundry/codeintel_rev/ops/runtime/xtr_open.py",
      "is_test": false,
      "imports": [
        "__future__.annotations",
        "json",
        "pathlib.Path",
        "typing.Annotated",
        "typer",
        "codeintel_rev.app.config_context.resolve_application_paths",
        "codeintel_rev.config.settings.load_settings",
        "codeintel_rev.errors.RuntimeUnavailableError",
        "codeintel_rev.io.xtr_manager.XTRIndex",
        "kgfoundry_common.logging.get_logger"
      ],
      "public_api": [
        "xtr_open",
        "main"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 0,
        "class_with_doc": 0,
        "func_total": 3,
        "func_with_doc": 2
      },
      "typing": {
        "functions": 3,
        "annotated_returns": 3,
        "total_params": 5,
        "annotated_params": 5
      },
      "complexity": {
        "branch_points": 10,
        "max_nesting": 2
      },
      "loc": 188,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "codeintel_rev.app.config_context.resolve_application_paths",
          "codeintel_rev.config.settings.load_settings",
          "codeintel_rev.errors.RuntimeUnavailableError",
          "codeintel_rev.io.xtr_manager.XTRIndex",
          "json",
          "kgfoundry_common.logging.get_logger",
          "pathlib.Path",
          "typer",
          "typing.Annotated"
        ],
        "type_checking_imports": [],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [
        "xtr_open",
        "main"
      ],
      "public_api_details": [
        {
          "name": "xtr_open",
          "kind": "function",
          "signature": "xtr_open(root: _RootOption = None, *, verbose: _VerboseOption = _VERBOSE_DEFAULT) -> None",
          "doc_one_liner": "Validate that XTR artifacts are present and readable.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/ops/runtime/xtr_open.py:53"
        },
        {
          "name": "main",
          "kind": "function",
          "signature": "main() -> None",
          "doc_one_liner": "Execute the Typer CLI.",
          "defined_at": "/home/paul/kgfoundry/codeintel_rev/ops/runtime/xtr_open.py:182"
        }
      ],
      "raises": {
        "xtr_open": [
          "Exit"
        ],
        "_exit_with_problem": [
          "Exit"
        ]
      }
    },
    {
      "module": "tests.test_namespace_proxy",
      "path": "/home/paul/kgfoundry/tests/test_namespace_proxy.py",
      "is_test": true,
      "imports": [
        "__future__.annotations",
        "types.ModuleType",
        "typing.TYPE_CHECKING",
        "typing.NoReturn",
        "typing.cast",
        "pytest",
        "tests.helpers.load_attribute",
        "collections.abc.Callable",
        "collections.abc.Iterable",
        "collections.abc.MutableMapping",
        "kgfoundry._namespace_proxy.NamespaceRegistry"
      ],
      "public_api": [
        "TestNamespaceRegistry",
        "TestNamespaceHelpers"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 2,
        "class_with_doc": 2,
        "func_total": 21,
        "func_with_doc": 19
      },
      "typing": {
        "functions": 21,
        "annotated_returns": 21,
        "total_params": 19,
        "annotated_params": 4
      },
      "complexity": {
        "branch_points": 7,
        "max_nesting": 4
      },
      "loc": 271,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "pytest",
          "tests.helpers.load_attribute",
          "types.ModuleType",
          "typing.NoReturn",
          "typing.TYPE_CHECKING",
          "typing.cast"
        ],
        "type_checking_imports": [
          "collections.abc.Callable",
          "collections.abc.Iterable",
          "collections.abc.MutableMapping",
          "kgfoundry._namespace_proxy.NamespaceRegistry"
        ],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "TestNamespaceRegistry",
          "kind": "class",
          "signature": "class TestNamespaceRegistry",
          "doc_one_liner": "Tests for the NamespaceRegistry class.",
          "defined_at": "/home/paul/kgfoundry/tests/test_namespace_proxy.py:53"
        },
        {
          "name": "TestNamespaceHelpers",
          "kind": "class",
          "signature": "class TestNamespaceHelpers",
          "doc_one_liner": "Tests for namespace helper functions.",
          "defined_at": "/home/paul/kgfoundry/tests/test_namespace_proxy.py:212"
        }
      ],
      "raises": {
        "test_resolve_with_exception_in_loader": [
          "RuntimeError"
        ],
        "failing_loader": [
          "RuntimeError"
        ]
      }
    },
    {
      "module": "tests.test_runtime_determinism",
      "path": "/home/paul/kgfoundry/tests/test_runtime_determinism.py",
      "is_test": true,
      "imports": [
        "__future__.annotations",
        "pathlib.Path",
        "typing.TYPE_CHECKING",
        "typing.TypeGuard",
        "pytest",
        "tests.helpers.load_attribute",
        "tests.helpers.load_module",
        "collections.abc.Callable"
      ],
      "public_api": [
        "TestPostponedAnnotations",
        "TestTypingFacadeModules",
        "TestTypeOnlyImportGuarding",
        "TestRuntimeImportSafety",
        "TestCLIEntryPointImportClean"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 5,
        "class_with_doc": 5,
        "func_total": 14,
        "func_with_doc": 12
      },
      "typing": {
        "functions": 14,
        "annotated_returns": 14,
        "total_params": 17,
        "annotated_params": 5
      },
      "complexity": {
        "branch_points": 22,
        "max_nesting": 4
      },
      "loc": 211,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "pathlib.Path",
          "pytest",
          "tests.helpers.load_attribute",
          "tests.helpers.load_module",
          "typing.TYPE_CHECKING",
          "typing.TypeGuard"
        ],
        "type_checking_imports": [
          "collections.abc.Callable"
        ],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "TestPostponedAnnotations",
          "kind": "class",
          "signature": "class TestPostponedAnnotations",
          "doc_one_liner": "Verify postponed annotations are present in core modules.",
          "defined_at": "/home/paul/kgfoundry/tests/test_runtime_determinism.py:33"
        },
        {
          "name": "TestTypingFacadeModules",
          "kind": "class",
          "signature": "class TestTypingFacadeModules",
          "doc_one_liner": "Verify fa\u00e7ade modules export expected helpers.",
          "defined_at": "/home/paul/kgfoundry/tests/test_runtime_determinism.py:63"
        },
        {
          "name": "TestTypeOnlyImportGuarding",
          "kind": "class",
          "signature": "class TestTypeOnlyImportGuarding",
          "doc_one_liner": "Verify TYPE_CHECKING guards in fa\u00e7ade modules.",
          "defined_at": "/home/paul/kgfoundry/tests/test_runtime_determinism.py:121"
        },
        {
          "name": "TestRuntimeImportSafety",
          "kind": "class",
          "signature": "class TestRuntimeImportSafety",
          "doc_one_liner": "Verify that fa\u00e7ade modules work without optional deps.",
          "defined_at": "/home/paul/kgfoundry/tests/test_runtime_determinism.py:158"
        },
        {
          "name": "TestCLIEntryPointImportClean",
          "kind": "class",
          "signature": "class TestCLIEntryPointImportClean",
          "doc_one_liner": "Verify CLI entry points initialize without heavy deps.",
          "defined_at": "/home/paul/kgfoundry/tests/test_runtime_determinism.py:193"
        }
      ],
      "raises": {}
    },
    {
      "module": "tests.test_regression_public_api_hardening",
      "path": "/home/paul/kgfoundry/tests/test_regression_public_api_hardening.py",
      "is_test": true,
      "imports": [
        "__future__.annotations",
        "inspect",
        "tempfile",
        "typing.cast",
        "tools.docstring_builder.cache.DocstringBuilderCache",
        "kgfoundry_common.errors.ConfigurationError",
        "kgfoundry_common.errors.KgFoundryError",
        "kgfoundry_common.logging.LoggingCache",
        "kgfoundry_common.logging.get_logging_cache",
        "kgfoundry_common.problem_details.build_configuration_problem",
        "orchestration.config.IndexCliConfig",
        "tests.helpers.assert_frozen_attribute"
      ],
      "public_api": [
        "TestCacheProtocolAccess",
        "TestConfigurationErrorProbleDetails",
        "TestConfigurationModelValidation",
        "TestNewPublicAPI",
        "TestConfigurationErrorIntegration",
        "TestAPIConsistency"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 6,
        "class_with_doc": 6,
        "func_total": 15,
        "func_with_doc": 15
      },
      "typing": {
        "functions": 15,
        "annotated_returns": 15,
        "total_params": 15,
        "annotated_params": 0
      },
      "complexity": {
        "branch_points": 5,
        "max_nesting": 3
      },
      "loc": 247,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "inspect",
          "kgfoundry_common.errors.ConfigurationError",
          "kgfoundry_common.errors.KgFoundryError",
          "kgfoundry_common.logging.LoggingCache",
          "kgfoundry_common.logging.get_logging_cache",
          "kgfoundry_common.problem_details.build_configuration_problem",
          "orchestration.config.IndexCliConfig",
          "tempfile",
          "tests.helpers.assert_frozen_attribute",
          "tools.docstring_builder.cache.DocstringBuilderCache",
          "typing.cast"
        ],
        "type_checking_imports": [],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "TestCacheProtocolAccess",
          "kind": "class",
          "signature": "class TestCacheProtocolAccess",
          "doc_one_liner": "Regression tests for cache Protocol access patterns.",
          "defined_at": "/home/paul/kgfoundry/tests/test_regression_public_api_hardening.py:18"
        },
        {
          "name": "TestConfigurationErrorProbleDetails",
          "kind": "class",
          "signature": "class TestConfigurationErrorProbleDetails",
          "doc_one_liner": "Regression tests for ConfigurationError Problem Details generation.",
          "defined_at": "/home/paul/kgfoundry/tests/test_regression_public_api_hardening.py:51"
        },
        {
          "name": "TestConfigurationModelValidation",
          "kind": "class",
          "signature": "class TestConfigurationModelValidation",
          "doc_one_liner": "Regression tests for configuration model validation.",
          "defined_at": "/home/paul/kgfoundry/tests/test_regression_public_api_hardening.py:108"
        },
        {
          "name": "TestNewPublicAPI",
          "kind": "class",
          "signature": "class TestNewPublicAPI",
          "doc_one_liner": "Regression tests for new public API patterns.",
          "defined_at": "/home/paul/kgfoundry/tests/test_regression_public_api_hardening.py:152"
        },
        {
          "name": "TestConfigurationErrorIntegration",
          "kind": "class",
          "signature": "class TestConfigurationErrorIntegration",
          "doc_one_liner": "Integration tests for configuration error handling.",
          "defined_at": "/home/paul/kgfoundry/tests/test_regression_public_api_hardening.py:183"
        },
        {
          "name": "TestAPIConsistency",
          "kind": "class",
          "signature": "class TestAPIConsistency",
          "doc_one_liner": "Tests ensuring API consistency across refactored modules.",
          "defined_at": "/home/paul/kgfoundry/tests/test_regression_public_api_hardening.py:207"
        }
      ],
      "raises": {}
    },
    {
      "module": "tests.bootstrap",
      "path": "/home/paul/kgfoundry/tests/bootstrap.py",
      "is_test": true,
      "imports": [
        "__future__.annotations",
        "importlib",
        "importlib.util",
        "inspect",
        "sys",
        "importlib.import_module",
        "pathlib.Path",
        "typing.TYPE_CHECKING",
        "typing.Final",
        "typing.Protocol",
        "typing.cast",
        "typing.no_type_check",
        "collections.abc.Callable",
        "types.ModuleType",
        "click.testing.Result"
      ],
      "public_api": [
        "ensure_src_path",
        "load_optional_module",
        "load_optional_attr"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 2,
        "class_with_doc": 0,
        "func_total": 7,
        "func_with_doc": 6
      },
      "typing": {
        "functions": 7,
        "annotated_returns": 7,
        "total_params": 9,
        "annotated_params": 8
      },
      "complexity": {
        "branch_points": 13,
        "max_nesting": 2
      },
      "loc": 154,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "importlib",
          "importlib.import_module",
          "importlib.util",
          "inspect",
          "pathlib.Path",
          "sys",
          "typing.Final",
          "typing.Protocol",
          "typing.TYPE_CHECKING",
          "typing.cast",
          "typing.no_type_check"
        ],
        "type_checking_imports": [
          "click.testing.Result",
          "collections.abc.Callable",
          "types.ModuleType"
        ],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "ensure_src_path",
          "kind": "function",
          "signature": "ensure_src_path() -> None",
          "doc_one_liner": "Add the ``src`` directory to ``sys.path`` exactly once.",
          "defined_at": "/home/paul/kgfoundry/tests/bootstrap.py:50"
        },
        {
          "name": "load_optional_module",
          "kind": "function",
          "signature": "load_optional_module(module_name: str) -> ModuleType | None",
          "doc_one_liner": "Return ``module_name`` when importable, otherwise ``None``.",
          "defined_at": "/home/paul/kgfoundry/tests/bootstrap.py:60"
        },
        {
          "name": "load_optional_attr",
          "kind": "function",
          "signature": "load_optional_attr(module_name: str, attr_name: str) -> object | None",
          "doc_one_liner": "Return ``getattr`` from ``module_name`` when available.",
          "defined_at": "/home/paul/kgfoundry/tests/bootstrap.py:79"
        }
      ],
      "raises": {}
    },
    {
      "module": "tests.test_logging",
      "path": "/home/paul/kgfoundry/tests/test_logging.py",
      "is_test": true,
      "imports": [
        "__future__.annotations",
        "json",
        "logging",
        "io.StringIO",
        "typing.TYPE_CHECKING",
        "typing.Final",
        "typing.cast",
        "kgfoundry_common.logging.CorrelationContext",
        "kgfoundry_common.logging.JsonFormatter",
        "kgfoundry_common.logging.get_correlation_id",
        "kgfoundry_common.logging.get_logger",
        "kgfoundry_common.logging.set_correlation_id",
        "kgfoundry_common.logging.with_fields",
        "collections.abc.Mapping",
        "_pytest.logging.LogCaptureFixture",
        "kgfoundry_common.logging.LoggerAdapter"
      ],
      "public_api": [
        "parse_log_record",
        "expect_str",
        "test_format_with_structured_fields",
        "test_correlation_id_from_context",
        "test_get_logger_attaches_null_handler",
        "test_log_success_method",
        "test_log_failure_method",
        "test_log_io_method",
        "test_status_inferred_from_level",
        "test_correlation_context_sets_and_clears_id",
        "test_correlation_context_nesting",
        "test_with_fields_context_manager",
        "test_correlation_id_propagates_through_logger",
        "test_adapter_merges_extra_fields"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 0,
        "class_with_doc": 0,
        "func_total": 14,
        "func_with_doc": 14
      },
      "typing": {
        "functions": 14,
        "annotated_returns": 14,
        "total_params": 10,
        "annotated_params": 10
      },
      "complexity": {
        "branch_points": 10,
        "max_nesting": 3
      },
      "loc": 283,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "io.StringIO",
          "json",
          "kgfoundry_common.logging.CorrelationContext",
          "kgfoundry_common.logging.JsonFormatter",
          "kgfoundry_common.logging.get_correlation_id",
          "kgfoundry_common.logging.get_logger",
          "kgfoundry_common.logging.set_correlation_id",
          "kgfoundry_common.logging.with_fields",
          "logging",
          "typing.Final",
          "typing.TYPE_CHECKING",
          "typing.cast"
        ],
        "type_checking_imports": [
          "_pytest.logging.LogCaptureFixture",
          "collections.abc.Mapping",
          "kgfoundry_common.logging.LoggerAdapter"
        ],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "parse_log_record",
          "kind": "function",
          "signature": "parse_log_record(raw: str) -> dict[str, object]",
          "doc_one_liner": "Parse JSON log record string.",
          "defined_at": "/home/paul/kgfoundry/tests/test_logging.py:29"
        },
        {
          "name": "expect_str",
          "kind": "function",
          "signature": "expect_str(mapping: Mapping[str, object], key: str) -> str",
          "doc_one_liner": "Expect mapping value to be a string.",
          "defined_at": "/home/paul/kgfoundry/tests/test_logging.py:55"
        },
        {
          "name": "test_format_with_structured_fields",
          "kind": "function",
          "signature": "test_format_with_structured_fields() -> None",
          "doc_one_liner": "Test JSON formatter includes structured fields.",
          "defined_at": "/home/paul/kgfoundry/tests/test_logging.py:82"
        },
        {
          "name": "test_correlation_id_from_context",
          "kind": "function",
          "signature": "test_correlation_id_from_context() -> None",
          "doc_one_liner": "Test correlation ID is injected from context.",
          "defined_at": "/home/paul/kgfoundry/tests/test_logging.py:116"
        },
        {
          "name": "test_get_logger_attaches_null_handler",
          "kind": "function",
          "signature": "test_get_logger_attaches_null_handler() -> None",
          "doc_one_liner": "Test that get_logger attaches a NullHandler.",
          "defined_at": "/home/paul/kgfoundry/tests/test_logging.py:141"
        },
        {
          "name": "test_log_success_method",
          "kind": "function",
          "signature": "test_log_success_method(caplog: LogCaptureFixture) -> None",
          "doc_one_liner": "Test log_success helper method.",
          "defined_at": "/home/paul/kgfoundry/tests/test_logging.py:149"
        },
        {
          "name": "test_log_failure_method",
          "kind": "function",
          "signature": "test_log_failure_method(caplog: LogCaptureFixture) -> None",
          "doc_one_liner": "Test log_failure helper method.",
          "defined_at": "/home/paul/kgfoundry/tests/test_logging.py:166"
        },
        {
          "name": "test_log_io_method",
          "kind": "function",
          "signature": "test_log_io_method(caplog: LogCaptureFixture) -> None",
          "doc_one_liner": "Test log_io helper method.",
          "defined_at": "/home/paul/kgfoundry/tests/test_logging.py:184"
        },
        {
          "name": "test_status_inferred_from_level",
          "kind": "function",
          "signature": "test_status_inferred_from_level(caplog: LogCaptureFixture) -> None",
          "doc_one_liner": "Test that status is inferred from log level.",
          "defined_at": "/home/paul/kgfoundry/tests/test_logging.py:209"
        },
        {
          "name": "test_correlation_context_sets_and_clears_id",
          "kind": "function",
          "signature": "test_correlation_context_sets_and_clears_id() -> None",
          "doc_one_liner": "Test that CorrelationContext sets and clears correlation ID.",
          "defined_at": "/home/paul/kgfoundry/tests/test_logging.py:221"
        },
        {
          "name": "test_correlation_context_nesting",
          "kind": "function",
          "signature": "test_correlation_context_nesting() -> None",
          "doc_one_liner": "Test that CorrelationContext nesting works correctly.",
          "defined_at": "/home/paul/kgfoundry/tests/test_logging.py:231"
        },
        {
          "name": "test_with_fields_context_manager",
          "kind": "function",
          "signature": "test_with_fields_context_manager(caplog: LogCaptureFixture) -> None",
          "doc_one_liner": "Test with_fields context manager for temporary field injection.",
          "defined_at": "/home/paul/kgfoundry/tests/test_logging.py:244"
        },
        {
          "name": "test_correlation_id_propagates_through_logger",
          "kind": "function",
          "signature": "test_correlation_id_propagates_through_logger(caplog: LogCaptureFixture) -> None",
          "doc_one_liner": "Test that correlation ID from context is automatically injected.",
          "defined_at": "/home/paul/kgfoundry/tests/test_logging.py:258"
        },
        {
          "name": "test_adapter_merges_extra_fields",
          "kind": "function",
          "signature": "test_adapter_merges_extra_fields(caplog: LogCaptureFixture) -> None",
          "doc_one_liner": "Test that adapter merges bound fields with runtime extra.",
          "defined_at": "/home/paul/kgfoundry/tests/test_logging.py:274"
        }
      ],
      "raises": {
        "parse_log_record": [
          "TypeError"
        ],
        "expect_str": [
          "TypeError"
        ]
      }
    },
    {
      "module": "tests.conftest",
      "path": "/home/paul/kgfoundry/tests/conftest.py",
      "is_test": true,
      "imports": [
        "__future__.annotations",
        "importlib.util",
        "json",
        "logging",
        "os",
        "sys",
        "collections.abc.Callable",
        "importlib.import_module",
        "importlib.metadata",
        "pathlib.Path",
        "tempfile.TemporaryDirectory",
        "types.ModuleType",
        "typing.TYPE_CHECKING",
        "typing.Any",
        "typing.ParamSpec",
        "typing.Protocol",
        "typing.TypeVar",
        "typing.cast",
        "pytest",
        "prometheus_client.registry.CollectorRegistry",
        "tests.bootstrap.ensure_src_path",
        "collections.abc.Iterable",
        "collections.abc.Iterator",
        "collections.abc.Sequence",
        "_pytest.logging.LogCaptureFixture",
        "kgfoundry_common.opentelemetry_types.SpanExporterProtocol",
        "kgfoundry_common.opentelemetry_types.SpanProtocol",
        "kgfoundry_common.opentelemetry_types.TracerProviderProtocol",
        "kgfoundry_common.problem_details.JsonValue",
        "warnings",
        "numpy"
      ],
      "public_api": [
        "HAS_GPU_STACK",
        "caplog_records",
        "gpu_warmup_session",
        "load_problem_details_example",
        "metrics_asserter",
        "otel_span_exporter",
        "otel_tracer_provider",
        "problem_details_loader",
        "prometheus_registry",
        "pytest_plugins",
        "structured_log_asserter",
        "temp_index_dir"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 4,
        "class_with_doc": 4,
        "func_total": 27,
        "func_with_doc": 23
      },
      "typing": {
        "functions": 27,
        "annotated_returns": 27,
        "total_params": 23,
        "annotated_params": 18
      },
      "complexity": {
        "branch_points": 48,
        "max_nesting": 6
      },
      "loc": 725,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "collections.abc.Callable",
          "importlib.import_module",
          "importlib.metadata",
          "importlib.util",
          "json",
          "logging",
          "np",
          "os",
          "pathlib.Path",
          "prometheus_client.registry.CollectorRegistry",
          "pytest",
          "sys",
          "tempfile.TemporaryDirectory",
          "tests.bootstrap.ensure_src_path",
          "types.ModuleType",
          "typing.Any",
          "typing.ParamSpec",
          "typing.Protocol",
          "typing.TYPE_CHECKING",
          "typing.TypeVar",
          "typing.cast",
          "warnings"
        ],
        "type_checking_imports": [
          "_pytest.logging.LogCaptureFixture",
          "collections.abc.Callable",
          "collections.abc.Iterable",
          "collections.abc.Iterator",
          "collections.abc.Sequence",
          "kgfoundry_common.opentelemetry_types.SpanExporterProtocol",
          "kgfoundry_common.opentelemetry_types.SpanProtocol",
          "kgfoundry_common.opentelemetry_types.TracerProviderProtocol",
          "kgfoundry_common.problem_details.JsonValue"
        ],
        "exports": [
          "HAS_GPU_STACK",
          "caplog_records",
          "gpu_warmup_session",
          "load_problem_details_example",
          "metrics_asserter",
          "otel_span_exporter",
          "otel_tracer_provider",
          "problem_details_loader",
          "prometheus_registry",
          "pytest_plugins",
          "structured_log_asserter",
          "temp_index_dir"
        ],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "temp_index_dir",
          "kind": "function",
          "signature": "temp_index_dir() -> Iterator[Path]",
          "doc_one_liner": "Provide a temporary directory for index operations.",
          "defined_at": "/home/paul/kgfoundry/tests/conftest.py:240"
        },
        {
          "name": "caplog_records",
          "kind": "function",
          "signature": "caplog_records(caplog: LogCaptureFixture) -> dict[str, list[logging.LogRecord]]",
          "doc_one_liner": "Capture logs by operation name for structured assertions.",
          "defined_at": "/home/paul/kgfoundry/tests/conftest.py:253"
        },
        {
          "name": "prometheus_registry",
          "kind": "function",
          "signature": "prometheus_registry() -> CollectorRegistry",
          "doc_one_liner": "Provide an isolated Prometheus registry for metrics capture.",
          "defined_at": "/home/paul/kgfoundry/tests/conftest.py:292"
        },
        {
          "name": "otel_span_exporter",
          "kind": "function",
          "signature": "otel_span_exporter() -> SpanExporterProtocol",
          "doc_one_liner": "Provide an in-memory OpenTelemetry span exporter for testing.",
          "defined_at": "/home/paul/kgfoundry/tests/conftest.py:307"
        },
        {
          "name": "otel_tracer_provider",
          "kind": "function",
          "signature": "otel_tracer_provider(otel_span_exporter: SpanExporterProtocol) -> Iterator[TracerProviderProtocol]",
          "doc_one_liner": "Provide an OpenTelemetry tracer provider configured with in-memory exporter.",
          "defined_at": "/home/paul/kgfoundry/tests/conftest.py:335"
        },
        {
          "name": "load_problem_details_example",
          "kind": "function",
          "signature": "load_problem_details_example(example_name: str) -> ProblemDetailsDict",
          "doc_one_liner": "Load a Problem Details example from schema/examples.",
          "defined_at": "/home/paul/kgfoundry/tests/conftest.py:392"
        },
        {
          "name": "problem_details_loader",
          "kind": "function",
          "signature": "problem_details_loader() -> Callable[[str], ProblemDetailsDict]",
          "doc_one_liner": "Fixture providing access to Problem Details examples.",
          "defined_at": "/home/paul/kgfoundry/tests/conftest.py:423"
        },
        {
          "name": "structured_log_asserter",
          "kind": "function",
          "signature": "structured_log_asserter() -> Callable[[logging.LogRecord, set[str]], None]",
          "doc_one_liner": "Provide helpers for asserting structured log fields.",
          "defined_at": "/home/paul/kgfoundry/tests/conftest.py:435"
        },
        {
          "name": "metrics_asserter",
          "kind": "function",
          "signature": "metrics_asserter(prometheus_registry: CollectorRegistry) -> Callable[[str, int | float | None], None]",
          "doc_one_liner": "Provide helpers for asserting Prometheus metrics.",
          "defined_at": "/home/paul/kgfoundry/tests/conftest.py:476"
        },
        {
          "name": "gpu_warmup_session",
          "kind": "function",
          "signature": "gpu_warmup_session() -> None",
          "doc_one_liner": "Tiny GPU warm-up & early-fail. Set REQUIRE_GPU=1 to make missing GPU a hard error.",
          "defined_at": "/home/paul/kgfoundry/tests/conftest.py:671"
        }
      ],
      "raises": {
        "otel_span_exporter": [
          "SkipReturnedUnexpectedlyError"
        ],
        "otel_tracer_provider": [
          "SkipReturnedUnexpectedlyError"
        ],
        "load_problem_details_example": [
          "FileNotFoundError"
        ],
        "structured_log_asserter": [
          "AssertionError"
        ],
        "metrics_asserter": [
          "AssertionError"
        ],
        "assert_log_has_fields": [
          "AssertionError"
        ],
        "assert_metric": [
          "AssertionError"
        ]
      }
    },
    {
      "module": "tests.test_logging_contexts",
      "path": "/home/paul/kgfoundry/tests/test_logging_contexts.py",
      "is_test": true,
      "imports": [
        "__future__.annotations",
        "json",
        "logging",
        "io.StringIO",
        "typing.TYPE_CHECKING",
        "typing.cast",
        "tools.docstring_builder.models.CLI_SCHEMA_ID",
        "tools.docstring_builder.models.CLI_SCHEMA_VERSION",
        "tools.docstring_builder.models.make_cli_result",
        "tools.docstring_builder.models.make_error_report",
        "kgfoundry_common.logging.CorrelationContext",
        "kgfoundry_common.logging.JsonFormatter",
        "kgfoundry_common.logging.LogContextExtra",
        "kgfoundry_common.logging.LoggerAdapter",
        "kgfoundry_common.logging.get_correlation_id",
        "kgfoundry_common.logging.with_fields",
        "tests.helpers.assert_frozen_attribute",
        "tools.docstring_builder.models.CliResultOptionalFields",
        "kgfoundry_common.problem_details.ProblemDetails"
      ],
      "public_api": [
        "TestLogContextExtraImmutability",
        "TestLogContextExtraConversion",
        "TestLoggerAdapterWithLogContextExtra",
        "TestLogContextExtraDoctest",
        "TestSafeAccessorPatterns",
        "TestErrorReportConstructor",
        "TestCliResultConstructor",
        "TestObservabilityIntegration"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 8,
        "class_with_doc": 8,
        "func_total": 19,
        "func_with_doc": 19
      },
      "typing": {
        "functions": 19,
        "annotated_returns": 19,
        "total_params": 19,
        "annotated_params": 0
      },
      "complexity": {
        "branch_points": 2,
        "max_nesting": 3
      },
      "loc": 281,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "io.StringIO",
          "json",
          "kgfoundry_common.logging.CorrelationContext",
          "kgfoundry_common.logging.JsonFormatter",
          "kgfoundry_common.logging.LogContextExtra",
          "kgfoundry_common.logging.LoggerAdapter",
          "kgfoundry_common.logging.get_correlation_id",
          "kgfoundry_common.logging.with_fields",
          "logging",
          "tests.helpers.assert_frozen_attribute",
          "tools.docstring_builder.models.CLI_SCHEMA_ID",
          "tools.docstring_builder.models.CLI_SCHEMA_VERSION",
          "tools.docstring_builder.models.make_cli_result",
          "tools.docstring_builder.models.make_error_report",
          "typing.TYPE_CHECKING",
          "typing.cast"
        ],
        "type_checking_imports": [
          "kgfoundry_common.problem_details.ProblemDetails",
          "tools.docstring_builder.models.CliResultOptionalFields"
        ],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "TestLogContextExtraImmutability",
          "kind": "class",
          "signature": "class TestLogContextExtraImmutability",
          "doc_one_liner": "Test that LogContextExtra is truly immutable (frozen).",
          "defined_at": "/home/paul/kgfoundry/tests/test_logging_contexts.py:40"
        },
        {
          "name": "TestLogContextExtraConversion",
          "kind": "class",
          "signature": "class TestLogContextExtraConversion",
          "doc_one_liner": "Test conversion of LogContextExtra to dict for logging.",
          "defined_at": "/home/paul/kgfoundry/tests/test_logging_contexts.py:77"
        },
        {
          "name": "TestLoggerAdapterWithLogContextExtra",
          "kind": "class",
          "signature": "class TestLoggerAdapterWithLogContextExtra",
          "doc_one_liner": "Test LoggerAdapter handles LogContextExtra dataclass correctly.",
          "defined_at": "/home/paul/kgfoundry/tests/test_logging_contexts.py:111"
        },
        {
          "name": "TestLogContextExtraDoctest",
          "kind": "class",
          "signature": "class TestLogContextExtraDoctest",
          "doc_one_liner": "Verify doctest examples in LogContextExtra docstring work correctly.",
          "defined_at": "/home/paul/kgfoundry/tests/test_logging_contexts.py:146"
        },
        {
          "name": "TestSafeAccessorPatterns",
          "kind": "class",
          "signature": "class TestSafeAccessorPatterns",
          "doc_one_liner": "Test safe patterns for accessing optional fields.",
          "defined_at": "/home/paul/kgfoundry/tests/test_logging_contexts.py:170"
        },
        {
          "name": "TestErrorReportConstructor",
          "kind": "class",
          "signature": "class TestErrorReportConstructor",
          "doc_one_liner": "Test safe construction of ErrorReport with Required/NotRequired fields.",
          "defined_at": "/home/paul/kgfoundry/tests/test_logging_contexts.py:197"
        },
        {
          "name": "TestCliResultConstructor",
          "kind": "class",
          "signature": "class TestCliResultConstructor",
          "doc_one_liner": "Test safe construction of CliResult with explicit required/optional fields.",
          "defined_at": "/home/paul/kgfoundry/tests/test_logging_contexts.py:230"
        },
        {
          "name": "TestObservabilityIntegration",
          "kind": "class",
          "signature": "class TestObservabilityIntegration",
          "doc_one_liner": "Test integration with Problem Details and correlation IDs.",
          "defined_at": "/home/paul/kgfoundry/tests/test_logging_contexts.py:268"
        }
      ],
      "raises": {}
    },
    {
      "module": "tests.docstring_builder.test_plugin_registry",
      "path": "/home/paul/kgfoundry/tests/docstring_builder/test_plugin_registry.py",
      "is_test": true,
      "imports": [
        "__future__.annotations",
        "typing.TYPE_CHECKING",
        "typing.Any",
        "typing.Protocol",
        "typing.cast",
        "pytest",
        "tools.docstring_builder.config.BuilderConfig",
        "tools.docstring_builder.plugins.load_plugins",
        "tools.docstring_builder.plugins.base.PluginFactory",
        "tools.docstring_builder.plugins.base.PluginRegistryError",
        "tools.docstring_builder.plugins.base.TransformerPlugin",
        "tools.docstring_builder.plugins.dataclass_fields.DataclassFieldDocPlugin",
        "kgfoundry_common.errors.KgFoundryError",
        "collections.abc.Mapping",
        "collections.abc.Sequence",
        "pathlib.Path"
      ],
      "public_api": [
        "expect_context",
        "TestPluginRegistryError",
        "TestPluginFactory",
        "TestBuiltInPlugins",
        "TestPluginValidation",
        "TestPluginStageDetection"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 6,
        "class_with_doc": 6,
        "func_total": 14,
        "func_with_doc": 13
      },
      "typing": {
        "functions": 14,
        "annotated_returns": 14,
        "total_params": 21,
        "annotated_params": 8
      },
      "complexity": {
        "branch_points": 5,
        "max_nesting": 3
      },
      "loc": 191,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "kgfoundry_common.errors.KgFoundryError",
          "pytest",
          "tools.docstring_builder.config.BuilderConfig",
          "tools.docstring_builder.plugins.base.PluginFactory",
          "tools.docstring_builder.plugins.base.PluginRegistryError",
          "tools.docstring_builder.plugins.base.TransformerPlugin",
          "tools.docstring_builder.plugins.dataclass_fields.DataclassFieldDocPlugin",
          "tools.docstring_builder.plugins.load_plugins",
          "typing.Any",
          "typing.Protocol",
          "typing.TYPE_CHECKING",
          "typing.cast"
        ],
        "type_checking_imports": [
          "collections.abc.Mapping",
          "collections.abc.Sequence",
          "pathlib.Path"
        ],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "expect_context",
          "kind": "function",
          "signature": "expect_context(value: Mapping[str, Any] | None) -> Mapping[str, Any]",
          "doc_one_liner": "",
          "defined_at": "/home/paul/kgfoundry/tests/docstring_builder/test_plugin_registry.py:26"
        },
        {
          "name": "TestPluginRegistryError",
          "kind": "class",
          "signature": "class TestPluginRegistryError",
          "doc_one_liner": "Test PluginRegistryError behavior.",
          "defined_at": "/home/paul/kgfoundry/tests/docstring_builder/test_plugin_registry.py:33"
        },
        {
          "name": "TestPluginFactory",
          "kind": "class",
          "signature": "class TestPluginFactory",
          "doc_one_liner": "Test PluginFactory Protocol behavior.",
          "defined_at": "/home/paul/kgfoundry/tests/docstring_builder/test_plugin_registry.py:70"
        },
        {
          "name": "TestBuiltInPlugins",
          "kind": "class",
          "signature": "class TestBuiltInPlugins",
          "doc_one_liner": "Test built-in plugins work as factories.",
          "defined_at": "/home/paul/kgfoundry/tests/docstring_builder/test_plugin_registry.py:85"
        },
        {
          "name": "TestPluginValidation",
          "kind": "class",
          "signature": "class TestPluginValidation",
          "doc_one_liner": "Test plugin registry validation.",
          "defined_at": "/home/paul/kgfoundry/tests/docstring_builder/test_plugin_registry.py:133"
        },
        {
          "name": "TestPluginStageDetection",
          "kind": "class",
          "signature": "class TestPluginStageDetection",
          "doc_one_liner": "Test plugin stage detection and routing.",
          "defined_at": "/home/paul/kgfoundry/tests/docstring_builder/test_plugin_registry.py:169"
        }
      ],
      "raises": {
        "expect_context": [
          "AssertionError"
        ]
      }
    },
    {
      "module": "tests.docstring_builder.test_pipeline_runner",
      "path": "/home/paul/kgfoundry/tests/docstring_builder/test_pipeline_runner.py",
      "is_test": true,
      "imports": [
        "__future__.annotations",
        "logging",
        "dataclasses.dataclass",
        "dataclasses.field",
        "types.SimpleNamespace",
        "typing.TYPE_CHECKING",
        "typing.Literal",
        "typing.cast",
        "tools.docstring_builder.builder_types.STATUS_LABELS",
        "tools.docstring_builder.builder_types.DocstringBuildRequest",
        "tools.docstring_builder.builder_types.ExitStatus",
        "tools.docstring_builder.builder_types.status_from_exit",
        "tools.docstring_builder.metrics.MetricsRecorder",
        "tools.docstring_builder.orchestrator.load_builder_config",
        "tools.docstring_builder.pipeline.PipelineConfig",
        "tools.docstring_builder.pipeline.PipelineRunner",
        "tools.docstring_builder.pipeline_types.DocfactsResult",
        "tools.docstring_builder.pipeline_types.FileOutcome",
        "tools.docstring_builder.pipeline_types.ProcessingOptions",
        "tools.docstring_builder.policy.PolicyReport",
        "collections.abc.Iterable",
        "collections.abc.Sequence",
        "pathlib.Path",
        "pytest",
        "tools.docstring_builder.cache.BuilderCache",
        "tools.docstring_builder.diff_manager.DiffManager",
        "tools.docstring_builder.docfacts.DocFact",
        "tools.docstring_builder.docfacts_coordinator.DocfactsCoordinator",
        "tools.docstring_builder.file_processor.FileProcessor",
        "tools.docstring_builder.models.ErrorReport",
        "tools.docstring_builder.models.ProblemDetails",
        "tools.docstring_builder.policy.PolicyEngine",
        "tools.docstring_builder.semantics.SemanticResult"
      ],
      "public_api": [
        "PipelineConfigOverrides",
        "make_pipeline_config",
        "test_pipeline_runner_collects_diff_previews",
        "test_pipeline_runner_records_docfacts_violation",
        "test_pipeline_runner_records_docfacts_baseline_payload",
        "test_pipeline_runner_includes_baseline_in_file_report"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 7,
        "class_with_doc": 2,
        "func_total": 25,
        "func_with_doc": 3
      },
      "typing": {
        "functions": 25,
        "annotated_returns": 25,
        "total_params": 45,
        "annotated_params": 31
      },
      "complexity": {
        "branch_points": 7,
        "max_nesting": 3
      },
      "loc": 436,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "dataclasses.dataclass",
          "dataclasses.field",
          "logging",
          "tools.docstring_builder.builder_types.DocstringBuildRequest",
          "tools.docstring_builder.builder_types.ExitStatus",
          "tools.docstring_builder.builder_types.STATUS_LABELS",
          "tools.docstring_builder.builder_types.status_from_exit",
          "tools.docstring_builder.metrics.MetricsRecorder",
          "tools.docstring_builder.orchestrator.load_builder_config",
          "tools.docstring_builder.pipeline.PipelineConfig",
          "tools.docstring_builder.pipeline.PipelineRunner",
          "tools.docstring_builder.pipeline_types.DocfactsResult",
          "tools.docstring_builder.pipeline_types.FileOutcome",
          "tools.docstring_builder.pipeline_types.ProcessingOptions",
          "tools.docstring_builder.policy.PolicyReport",
          "types.SimpleNamespace",
          "typing.Literal",
          "typing.TYPE_CHECKING",
          "typing.cast"
        ],
        "type_checking_imports": [
          "collections.abc.Iterable",
          "collections.abc.Sequence",
          "pathlib.Path",
          "pytest",
          "tools.docstring_builder.cache.BuilderCache",
          "tools.docstring_builder.diff_manager.DiffManager",
          "tools.docstring_builder.docfacts.DocFact",
          "tools.docstring_builder.docfacts_coordinator.DocfactsCoordinator",
          "tools.docstring_builder.file_processor.FileProcessor",
          "tools.docstring_builder.models.ErrorReport",
          "tools.docstring_builder.models.ProblemDetails",
          "tools.docstring_builder.policy.PolicyEngine",
          "tools.docstring_builder.semantics.SemanticResult"
        ],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "PipelineConfigOverrides",
          "kind": "class",
          "signature": "class PipelineConfigOverrides",
          "doc_one_liner": "Customization knobs for building pipeline configurations in tests.",
          "defined_at": "/home/paul/kgfoundry/tests/docstring_builder/test_pipeline_runner.py:115"
        },
        {
          "name": "make_pipeline_config",
          "kind": "function",
          "signature": "make_pipeline_config(request: DocstringBuildRequest, file_outcomes: Sequence[FileOutcome], overrides: PipelineConfigOverrides | None = None) -> PipelineConfig",
          "doc_one_liner": "Construct a pipeline configuration tailored for orchestrator tests.",
          "defined_at": "/home/paul/kgfoundry/tests/docstring_builder/test_pipeline_runner.py:156"
        },
        {
          "name": "test_pipeline_runner_collects_diff_previews",
          "kind": "function",
          "signature": "test_pipeline_runner_collects_diff_previews(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -> None",
          "doc_one_liner": "",
          "defined_at": "/home/paul/kgfoundry/tests/docstring_builder/test_pipeline_runner.py:257"
        },
        {
          "name": "test_pipeline_runner_records_docfacts_violation",
          "kind": "function",
          "signature": "test_pipeline_runner_records_docfacts_violation(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -> None",
          "doc_one_liner": "",
          "defined_at": "/home/paul/kgfoundry/tests/docstring_builder/test_pipeline_runner.py:289"
        },
        {
          "name": "test_pipeline_runner_records_docfacts_baseline_payload",
          "kind": "function",
          "signature": "test_pipeline_runner_records_docfacts_baseline_payload(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -> None",
          "doc_one_liner": "",
          "defined_at": "/home/paul/kgfoundry/tests/docstring_builder/test_pipeline_runner.py:329"
        },
        {
          "name": "test_pipeline_runner_includes_baseline_in_file_report",
          "kind": "function",
          "signature": "test_pipeline_runner_includes_baseline_in_file_report(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -> None",
          "doc_one_liner": "",
          "defined_at": "/home/paul/kgfoundry/tests/docstring_builder/test_pipeline_runner.py:386"
        }
      ],
      "raises": {}
    },
    {
      "module": "tests.docstring_builder.test_pipeline_helpers",
      "path": "/home/paul/kgfoundry/tests/docstring_builder/test_pipeline_helpers.py",
      "is_test": true,
      "imports": [
        "__future__.annotations",
        "logging",
        "dataclasses.dataclass",
        "dataclasses.field",
        "typing.TYPE_CHECKING",
        "pytest",
        "tools.docstring_builder.builder_types.ExitStatus",
        "tools.docstring_builder.failure_summary.FailureSummaryRenderer",
        "tools.docstring_builder.failure_summary.RunSummarySnapshot",
        "tools.docstring_builder.metrics.MetricsRecorder",
        "tools.docstring_builder.models.RunStatus",
        "tools.docstring_builder.paths.OBSERVABILITY_PATH",
        "tools.docstring_builder.pipeline_types.ErrorEnvelope",
        "tools.docstring_builder.pipeline_types.FileOutcome",
        "_pytest.logging.LogCaptureFixture",
        "tools.docstring_builder.docfacts.DocFact"
      ],
      "public_api": [
        "TestFailureSummaryRenderer",
        "TestMetricsRecorder",
        "TestErrorEnvelope",
        "TestFileOutcomeTracking",
        "TestStatusMapping"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 7,
        "class_with_doc": 5,
        "func_total": 13,
        "func_with_doc": 8
      },
      "typing": {
        "functions": 13,
        "annotated_returns": 13,
        "total_params": 21,
        "annotated_params": 10
      },
      "complexity": {
        "branch_points": 1,
        "max_nesting": 2
      },
      "loc": 197,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "dataclasses.dataclass",
          "dataclasses.field",
          "logging",
          "pytest",
          "tools.docstring_builder.builder_types.ExitStatus",
          "tools.docstring_builder.failure_summary.FailureSummaryRenderer",
          "tools.docstring_builder.failure_summary.RunSummarySnapshot",
          "tools.docstring_builder.metrics.MetricsRecorder",
          "tools.docstring_builder.models.RunStatus",
          "tools.docstring_builder.paths.OBSERVABILITY_PATH",
          "tools.docstring_builder.pipeline_types.ErrorEnvelope",
          "tools.docstring_builder.pipeline_types.FileOutcome",
          "typing.TYPE_CHECKING"
        ],
        "type_checking_imports": [
          "_pytest.logging.LogCaptureFixture",
          "tools.docstring_builder.docfacts.DocFact"
        ],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "TestFailureSummaryRenderer",
          "kind": "class",
          "signature": "class TestFailureSummaryRenderer",
          "doc_one_liner": "Tests for FailureSummaryRenderer.",
          "defined_at": "/home/paul/kgfoundry/tests/docstring_builder/test_pipeline_helpers.py:71"
        },
        {
          "name": "TestMetricsRecorder",
          "kind": "class",
          "signature": "class TestMetricsRecorder",
          "doc_one_liner": "Tests for MetricsRecorder.",
          "defined_at": "/home/paul/kgfoundry/tests/docstring_builder/test_pipeline_helpers.py:125"
        },
        {
          "name": "TestErrorEnvelope",
          "kind": "class",
          "signature": "class TestErrorEnvelope",
          "doc_one_liner": "Tests for ErrorEnvelope.",
          "defined_at": "/home/paul/kgfoundry/tests/docstring_builder/test_pipeline_helpers.py:147"
        },
        {
          "name": "TestFileOutcomeTracking",
          "kind": "class",
          "signature": "class TestFileOutcomeTracking",
          "doc_one_liner": "Tests for FileOutcome data structure.",
          "defined_at": "/home/paul/kgfoundry/tests/docstring_builder/test_pipeline_helpers.py:163"
        },
        {
          "name": "TestStatusMapping",
          "kind": "class",
          "signature": "class TestStatusMapping",
          "doc_one_liner": "Tests for status value mappings.",
          "defined_at": "/home/paul/kgfoundry/tests/docstring_builder/test_pipeline_helpers.py:190"
        }
      ],
      "raises": {}
    },
    {
      "module": "tests.app._context_factory",
      "path": "/home/paul/kgfoundry/tests/app/_context_factory.py",
      "is_test": true,
      "imports": [
        "__future__.annotations",
        "pathlib.Path",
        "types.SimpleNamespace",
        "typing.TYPE_CHECKING",
        "typing.cast",
        "unittest.mock.MagicMock",
        "codeintel_rev.app.config_context.ApplicationContext",
        "codeintel_rev.app.config_context.ResolvedPaths",
        "codeintel_rev.config.settings.Settings"
      ],
      "public_api": [
        "build_application_context"
      ],
      "doc": {
        "module_doc": false,
        "class_total": 0,
        "class_with_doc": 0,
        "func_total": 1,
        "func_with_doc": 1
      },
      "typing": {
        "functions": 1,
        "annotated_returns": 1,
        "total_params": 4,
        "annotated_params": 4
      },
      "complexity": {
        "branch_points": 2,
        "max_nesting": 2
      },
      "loc": 119,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "codeintel_rev.app.config_context.ApplicationContext",
          "codeintel_rev.app.config_context.ResolvedPaths",
          "pathlib.Path",
          "types.SimpleNamespace",
          "typing.TYPE_CHECKING",
          "typing.cast",
          "unittest.mock.MagicMock"
        ],
        "type_checking_imports": [
          "codeintel_rev.config.settings.Settings"
        ],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "build_application_context",
          "kind": "function",
          "signature": "build_application_context(tmp_path: Path, *, xtr_enabled: bool = False, enable_bm25: bool = False, enable_splade: bool = False) -> ApplicationContext",
          "doc_one_liner": "Create a lightweight ApplicationContext for unit tests.",
          "defined_at": "/home/paul/kgfoundry/tests/app/_context_factory.py:14"
        }
      ],
      "raises": {}
    },
    {
      "module": "tests.app.test_lifespan_runtime_cleanup",
      "path": "/home/paul/kgfoundry/tests/app/test_lifespan_runtime_cleanup.py",
      "is_test": true,
      "imports": [
        "__future__.annotations",
        "pathlib.Path",
        "types.SimpleNamespace",
        "typing.Any",
        "typing.cast",
        "pytest",
        "codeintel_rev.app.config_context.ApplicationContext",
        "codeintel_rev.app.main.lifespan",
        "fastapi.FastAPI",
        "tests.app._context_factory.build_application_context"
      ],
      "public_api": [
        "test_lifespan_preload_and_cleanup",
        "test_close_all_runtimes_idempotent",
        "application_context"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 4,
        "class_with_doc": 0,
        "func_total": 21,
        "func_with_doc": 4
      },
      "typing": {
        "functions": 21,
        "annotated_returns": 21,
        "total_params": 23,
        "annotated_params": 10
      },
      "complexity": {
        "branch_points": 0,
        "max_nesting": 3
      },
      "loc": 179,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "codeintel_rev.app.config_context.ApplicationContext",
          "codeintel_rev.app.main.lifespan",
          "fastapi.FastAPI",
          "pathlib.Path",
          "pytest",
          "tests.app._context_factory.build_application_context",
          "types.SimpleNamespace",
          "typing.Any",
          "typing.cast"
        ],
        "type_checking_imports": [],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "test_lifespan_preload_and_cleanup",
          "kind": "function",
          "signature": "test_lifespan_preload_and_cleanup(monkeypatch: pytest.MonkeyPatch) -> None",
          "doc_one_liner": "",
          "defined_at": "/home/paul/kgfoundry/tests/app/test_lifespan_runtime_cleanup.py:71"
        },
        {
          "name": "test_close_all_runtimes_idempotent",
          "kind": "function",
          "signature": "test_close_all_runtimes_idempotent(application_context: ApplicationContext, monkeypatch: pytest.MonkeyPatch) -> None",
          "doc_one_liner": "",
          "defined_at": "/home/paul/kgfoundry/tests/app/test_lifespan_runtime_cleanup.py:108"
        },
        {
          "name": "application_context",
          "kind": "function",
          "signature": "application_context(_base_application_context: ApplicationContext) -> ApplicationContext",
          "doc_one_liner": "Expose the shared application_context fixture to this module.",
          "defined_at": "/home/paul/kgfoundry/tests/app/test_lifespan_runtime_cleanup.py:166"
        }
      ],
      "raises": {}
    },
    {
      "module": "tests.app.test_capz",
      "path": "/home/paul/kgfoundry/tests/app/test_capz.py",
      "is_test": true,
      "imports": [
        "__future__.annotations",
        "types.SimpleNamespace",
        "typing.Any",
        "codeintel_rev.app.capabilities",
        "codeintel_rev.app.capabilities.Capabilities",
        "codeintel_rev.app.main.capz",
        "fastapi.FastAPI",
        "fastapi.testclient.TestClient",
        "tests.app._context_factory.build_application_context"
      ],
      "public_api": [
        "test_capabilities_snapshot_reports_paths",
        "test_capz_endpoint_refresh"
      ],
      "doc": {
        "module_doc": false,
        "class_total": 0,
        "class_with_doc": 0,
        "func_total": 6,
        "func_with_doc": 1
      },
      "typing": {
        "functions": 6,
        "annotated_returns": 6,
        "total_params": 10,
        "annotated_params": 6
      },
      "complexity": {
        "branch_points": 2,
        "max_nesting": 2
      },
      "loc": 84,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "codeintel_rev.app.capabilities",
          "codeintel_rev.app.capabilities.Capabilities",
          "codeintel_rev.app.main.capz",
          "fastapi.FastAPI",
          "fastapi.testclient.TestClient",
          "tests.app._context_factory.build_application_context",
          "types.SimpleNamespace",
          "typing.Any"
        ],
        "type_checking_imports": [],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "test_capabilities_snapshot_reports_paths",
          "kind": "function",
          "signature": "test_capabilities_snapshot_reports_paths(tmp_path, monkeypatch) -> None",
          "doc_one_liner": "",
          "defined_at": "/home/paul/kgfoundry/tests/app/test_capz.py:26"
        },
        {
          "name": "test_capz_endpoint_refresh",
          "kind": "function",
          "signature": "test_capz_endpoint_refresh(tmp_path, monkeypatch) -> None",
          "doc_one_liner": "",
          "defined_at": "/home/paul/kgfoundry/tests/app/test_capz.py:58"
        }
      ],
      "raises": {}
    },
    {
      "module": "tests.docs.test_griffe_facade",
      "path": "/home/paul/kgfoundry/tests/docs/test_griffe_facade.py",
      "is_test": true,
      "imports": [
        "__future__.annotations",
        "importlib.util",
        "inspect",
        "sys",
        "typing.TYPE_CHECKING",
        "typing.cast",
        "unittest.mock",
        "pytest",
        "docs._scripts.shared.detect_environment",
        "docs._types.griffe.GriffeFacade",
        "docs._types.griffe.build_facade",
        "docs._types.griffe.get_autoapi_loader",
        "docs._types.griffe.get_sphinx_loader",
        "kgfoundry_common.errors.ArtifactDependencyError",
        "docs._types.griffe.GriffeNode"
      ],
      "public_api": [
        "TestGriffeStubExports",
        "TestGriffeLoaderSignatures",
        "TestGriffeFacade",
        "TestOptionalDependencyHandling",
        "TestGriffeNodeProtocol",
        "TestDoctest"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 6,
        "class_with_doc": 6,
        "func_total": 20,
        "func_with_doc": 20
      },
      "typing": {
        "functions": 20,
        "annotated_returns": 20,
        "total_params": 27,
        "annotated_params": 7
      },
      "complexity": {
        "branch_points": 16,
        "max_nesting": 5
      },
      "loc": 286,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "docs._scripts.shared.detect_environment",
          "docs._types.griffe.GriffeFacade",
          "docs._types.griffe.build_facade",
          "docs._types.griffe.get_autoapi_loader",
          "docs._types.griffe.get_sphinx_loader",
          "importlib.util",
          "inspect",
          "kgfoundry_common.errors.ArtifactDependencyError",
          "pytest",
          "sys",
          "typing.TYPE_CHECKING",
          "typing.cast",
          "unittest.mock"
        ],
        "type_checking_imports": [
          "docs._types.griffe.GriffeNode"
        ],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "TestGriffeStubExports",
          "kind": "class",
          "signature": "class TestGriffeStubExports",
          "doc_one_liner": "Verify stub exports match runtime Griffe 1.14.0.",
          "defined_at": "/home/paul/kgfoundry/tests/docs/test_griffe_facade.py:38"
        },
        {
          "name": "TestGriffeLoaderSignatures",
          "kind": "class",
          "signature": "class TestGriffeLoaderSignatures",
          "doc_one_liner": "Verify loader and load() function signatures match stubs.",
          "defined_at": "/home/paul/kgfoundry/tests/docs/test_griffe_facade.py:101"
        },
        {
          "name": "TestGriffeFacade",
          "kind": "class",
          "signature": "class TestGriffeFacade",
          "doc_one_liner": "Test the typed Griffe facade.",
          "defined_at": "/home/paul/kgfoundry/tests/docs/test_griffe_facade.py:156"
        },
        {
          "name": "TestOptionalDependencyHandling",
          "kind": "class",
          "signature": "class TestOptionalDependencyHandling",
          "doc_one_liner": "Test graceful degradation when optional plugins are missing.",
          "defined_at": "/home/paul/kgfoundry/tests/docs/test_griffe_facade.py:192"
        },
        {
          "name": "TestGriffeNodeProtocol",
          "kind": "class",
          "signature": "class TestGriffeNodeProtocol",
          "doc_one_liner": "Test the GriffeNode protocol implementation.",
          "defined_at": "/home/paul/kgfoundry/tests/docs/test_griffe_facade.py:226"
        },
        {
          "name": "TestDoctest",
          "kind": "class",
          "signature": "class TestDoctest",
          "doc_one_liner": "Doctest examples in griffe module.",
          "defined_at": "/home/paul/kgfoundry/tests/docs/test_griffe_facade.py:277"
        }
      ],
      "raises": {}
    },
    {
      "module": "tests.docs.test_doc_artifacts",
      "path": "/home/paul/kgfoundry/tests/docs/test_doc_artifacts.py",
      "is_test": true,
      "imports": [
        "__future__.annotations",
        "json",
        "pathlib.Path",
        "typing.TYPE_CHECKING",
        "typing.cast",
        "pytest",
        "docs.scripts.validate_artifacts",
        "docs.scripts.validation.validate_against_schema",
        "docs.types.artifacts.JsonValue",
        "docs.types.artifacts.symbol_delta_from_json",
        "docs.types.artifacts.symbol_delta_to_payload",
        "docs.types.artifacts.symbol_index_from_json",
        "docs.types.artifacts.symbol_index_to_payload",
        "tools.ToolExecutionError",
        "collections.abc.Callable",
        "collections.abc.Mapping",
        "docs.types.artifacts.JsonPayload"
      ],
      "public_api": [
        "TestSymbolIndexValidation",
        "TestSymbolDeltaValidation",
        "TestReverseLookupValidation",
        "PayloadFactory",
        "TestMalformedPayloads",
        "TestValidateArtifactsHelpers",
        "TestByteIdenticalRoundTrip"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 7,
        "class_with_doc": 7,
        "func_total": 31,
        "func_with_doc": 30
      },
      "typing": {
        "functions": 31,
        "annotated_returns": 31,
        "total_params": 37,
        "annotated_params": 9
      },
      "complexity": {
        "branch_points": 30,
        "max_nesting": 7
      },
      "loc": 451,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "docs.scripts.validate_artifacts",
          "docs.scripts.validation.validate_against_schema",
          "docs.types.artifacts.JsonValue",
          "docs.types.artifacts.symbol_delta_from_json",
          "docs.types.artifacts.symbol_delta_to_payload",
          "docs.types.artifacts.symbol_index_from_json",
          "docs.types.artifacts.symbol_index_to_payload",
          "json",
          "pathlib.Path",
          "pytest",
          "tools.ToolExecutionError",
          "typing.TYPE_CHECKING",
          "typing.cast"
        ],
        "type_checking_imports": [
          "collections.abc.Callable",
          "collections.abc.Mapping",
          "docs.types.artifacts.JsonPayload"
        ],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "TestSymbolIndexValidation",
          "kind": "class",
          "signature": "class TestSymbolIndexValidation",
          "doc_one_liner": "Tests for symbol index artifact validation.",
          "defined_at": "/home/paul/kgfoundry/tests/docs/test_doc_artifacts.py:70"
        },
        {
          "name": "TestSymbolDeltaValidation",
          "kind": "class",
          "signature": "class TestSymbolDeltaValidation",
          "doc_one_liner": "Tests for symbol delta artifact validation.",
          "defined_at": "/home/paul/kgfoundry/tests/docs/test_doc_artifacts.py:109"
        },
        {
          "name": "TestReverseLookupValidation",
          "kind": "class",
          "signature": "class TestReverseLookupValidation",
          "doc_one_liner": "Tests for reverse lookup artifact validation.",
          "defined_at": "/home/paul/kgfoundry/tests/docs/test_doc_artifacts.py:135"
        },
        {
          "name": "PayloadFactory",
          "kind": "class",
          "signature": "class PayloadFactory",
          "doc_one_liner": "Factory for constructing test payloads with controlled mutations.",
          "defined_at": "/home/paul/kgfoundry/tests/docs/test_doc_artifacts.py:170"
        },
        {
          "name": "TestMalformedPayloads",
          "kind": "class",
          "signature": "class TestMalformedPayloads",
          "doc_one_liner": "Test malformed payload detection for scenario 3.2.b.",
          "defined_at": "/home/paul/kgfoundry/tests/docs/test_doc_artifacts.py:248"
        },
        {
          "name": "TestValidateArtifactsHelpers",
          "kind": "class",
          "signature": "class TestValidateArtifactsHelpers",
          "doc_one_liner": "Tests for helper functions in docs.scripts.validate_artifacts.",
          "defined_at": "/home/paul/kgfoundry/tests/docs/test_doc_artifacts.py:260"
        },
        {
          "name": "TestByteIdenticalRoundTrip",
          "kind": "class",
          "signature": "class TestByteIdenticalRoundTrip",
          "doc_one_liner": "Test byte-identical round-trip serialization for scenario 3.2.c.",
          "defined_at": "/home/paul/kgfoundry/tests/docs/test_doc_artifacts.py:384"
        }
      ],
      "raises": {}
    },
    {
      "module": "tests.docs.conftest",
      "path": "/home/paul/kgfoundry/tests/docs/conftest.py",
      "is_test": true,
      "imports": [
        "__future__.annotations",
        "typing.TYPE_CHECKING",
        "pytest",
        "docs.scripts.testing.clear_lazy_import_caches",
        "collections.abc.Iterator"
      ],
      "public_api": [
        "reset_docs_scripts_caches"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 0,
        "class_with_doc": 0,
        "func_total": 1,
        "func_with_doc": 1
      },
      "typing": {
        "functions": 1,
        "annotated_returns": 1,
        "total_params": 0,
        "annotated_params": 0
      },
      "complexity": {
        "branch_points": 2,
        "max_nesting": 2
      },
      "loc": 21,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "docs.scripts.testing.clear_lazy_import_caches",
          "pytest",
          "typing.TYPE_CHECKING"
        ],
        "type_checking_imports": [
          "collections.abc.Iterator"
        ],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "reset_docs_scripts_caches",
          "kind": "function",
          "signature": "reset_docs_scripts_caches() -> Iterator[None]",
          "doc_one_liner": "Ensure docs script caches are clean around each test.",
          "defined_at": "/home/paul/kgfoundry/tests/docs/conftest.py:15"
        }
      ],
      "raises": {}
    },
    {
      "module": "tests.docs.test_validate_artifacts_script",
      "path": "/home/paul/kgfoundry/tests/docs/test_validate_artifacts_script.py",
      "is_test": true,
      "imports": [
        "__future__.annotations",
        "json",
        "importlib.import_module",
        "pathlib.Path",
        "typing.TYPE_CHECKING",
        "typing.cast",
        "pytest",
        "collections.abc.Callable",
        "docs._scripts.validate_artifacts.ArtifactValidationError",
        "docs.types.artifacts.SymbolDeltaPayload",
        "docs.types.artifacts.SymbolIndexArtifacts"
      ],
      "public_api": [
        "test_validate_symbol_index_resolves_schema_from_repo",
        "test_validate_symbol_delta_resolves_schema_from_repo"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 0,
        "class_with_doc": 0,
        "func_total": 2,
        "func_with_doc": 2
      },
      "typing": {
        "functions": 2,
        "annotated_returns": 2,
        "total_params": 2,
        "annotated_params": 2
      },
      "complexity": {
        "branch_points": 4,
        "max_nesting": 2
      },
      "loc": 98,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "importlib.import_module",
          "json",
          "pathlib.Path",
          "pytest",
          "typing.TYPE_CHECKING",
          "typing.cast"
        ],
        "type_checking_imports": [
          "collections.abc.Callable",
          "docs._scripts.validate_artifacts.ArtifactValidationError",
          "docs.types.artifacts.SymbolDeltaPayload",
          "docs.types.artifacts.SymbolIndexArtifacts"
        ],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "test_validate_symbol_index_resolves_schema_from_repo",
          "kind": "function",
          "signature": "test_validate_symbol_index_resolves_schema_from_repo(tmp_path: Path) -> None",
          "doc_one_liner": "The validator should locate schemas relative to the repository root.",
          "defined_at": "/home/paul/kgfoundry/tests/docs/test_validate_artifacts_script.py:43"
        },
        {
          "name": "test_validate_symbol_delta_resolves_schema_from_repo",
          "kind": "function",
          "signature": "test_validate_symbol_delta_resolves_schema_from_repo(tmp_path: Path) -> None",
          "doc_one_liner": "The delta validator should locate schemas relative to the repository root.",
          "defined_at": "/home/paul/kgfoundry/tests/docs/test_validate_artifacts_script.py:73"
        }
      ],
      "raises": {}
    },
    {
      "module": "tests.docs.test_artifact_models",
      "path": "/home/paul/kgfoundry/tests/docs/test_artifact_models.py",
      "is_test": true,
      "imports": [
        "__future__.annotations",
        "json",
        "collections.abc.Mapping",
        "typing.TYPE_CHECKING",
        "typing.cast",
        "pytest",
        "docs.types.artifacts.SYMBOL_INDEX_ROW_FIELDS",
        "docs.types.artifacts.ArtifactValidationError",
        "docs.types.artifacts.JsonValue",
        "docs.types.artifacts.LineSpan",
        "docs.types.artifacts.SymbolDeltaChange",
        "docs.types.artifacts.SymbolDeltaPayload",
        "docs.types.artifacts.SymbolIndexArtifacts",
        "docs.types.artifacts.SymbolIndexRow",
        "docs.types.artifacts.align_schema_fields",
        "docs.types.artifacts.symbol_delta_from_json",
        "docs.types.artifacts.symbol_delta_to_payload",
        "docs.types.artifacts.symbol_index_from_json",
        "docs.types.artifacts.symbol_index_to_payload",
        "kgfoundry_common.errors.ArtifactDeserializationError",
        "docs.types.artifacts.JsonPayload"
      ],
      "public_api": [
        "expect_json_string",
        "expect_json_int",
        "expect_json_mapping",
        "expect_json_sequence",
        "to_json_payload",
        "TestLineSpan",
        "TestSymbolIndexRow",
        "TestSymbolIndexRoundTrip",
        "TestSymbolDeltaPayload",
        "TestSymbolDeltaRoundTrip",
        "TestArtifactValidation",
        "TestArtifactCoercion",
        "TestArtifactJSONFormatting",
        "TestCanonicalConstructors"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 9,
        "class_with_doc": 9,
        "func_total": 44,
        "func_with_doc": 44
      },
      "typing": {
        "functions": 44,
        "annotated_returns": 44,
        "total_params": 45,
        "annotated_params": 13
      },
      "complexity": {
        "branch_points": 21,
        "max_nesting": 4
      },
      "loc": 961,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "collections.abc.Mapping",
          "docs.types.artifacts.ArtifactValidationError",
          "docs.types.artifacts.JsonValue",
          "docs.types.artifacts.LineSpan",
          "docs.types.artifacts.SYMBOL_INDEX_ROW_FIELDS",
          "docs.types.artifacts.SymbolDeltaChange",
          "docs.types.artifacts.SymbolDeltaPayload",
          "docs.types.artifacts.SymbolIndexArtifacts",
          "docs.types.artifacts.SymbolIndexRow",
          "docs.types.artifacts.align_schema_fields",
          "docs.types.artifacts.symbol_delta_from_json",
          "docs.types.artifacts.symbol_delta_to_payload",
          "docs.types.artifacts.symbol_index_from_json",
          "docs.types.artifacts.symbol_index_to_payload",
          "json",
          "kgfoundry_common.errors.ArtifactDeserializationError",
          "pytest",
          "typing.TYPE_CHECKING",
          "typing.cast"
        ],
        "type_checking_imports": [
          "docs.types.artifacts.JsonPayload"
        ],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "expect_json_string",
          "kind": "function",
          "signature": "expect_json_string(value: JsonValue) -> str",
          "doc_one_liner": "Expect JSON value to be a string.",
          "defined_at": "/home/paul/kgfoundry/tests/docs/test_artifact_models.py:245"
        },
        {
          "name": "expect_json_int",
          "kind": "function",
          "signature": "expect_json_int(value: JsonValue) -> int",
          "doc_one_liner": "Expect JSON value to be an integer.",
          "defined_at": "/home/paul/kgfoundry/tests/docs/test_artifact_models.py:269"
        },
        {
          "name": "expect_json_mapping",
          "kind": "function",
          "signature": "expect_json_mapping(value: JsonValue) -> dict[str, JsonValue]",
          "doc_one_liner": "Expect JSON value to be a mapping (dict).",
          "defined_at": "/home/paul/kgfoundry/tests/docs/test_artifact_models.py:293"
        },
        {
          "name": "expect_json_sequence",
          "kind": "function",
          "signature": "expect_json_sequence(value: JsonValue) -> list[JsonValue]",
          "doc_one_liner": "Expect JSON value to be a sequence (list).",
          "defined_at": "/home/paul/kgfoundry/tests/docs/test_artifact_models.py:317"
        },
        {
          "name": "to_json_payload",
          "kind": "function",
          "signature": "to_json_payload(rows: JsonObjectArray) -> JsonPayload",
          "doc_one_liner": "Convert rows array to JSON payload.",
          "defined_at": "/home/paul/kgfoundry/tests/docs/test_artifact_models.py:341"
        },
        {
          "name": "TestLineSpan",
          "kind": "class",
          "signature": "class TestLineSpan",
          "doc_one_liner": "Tests for LineSpan data class.",
          "defined_at": "/home/paul/kgfoundry/tests/docs/test_artifact_models.py:357"
        },
        {
          "name": "TestSymbolIndexRow",
          "kind": "class",
          "signature": "class TestSymbolIndexRow",
          "doc_one_liner": "Tests for SymbolIndexRow model.",
          "defined_at": "/home/paul/kgfoundry/tests/docs/test_artifact_models.py:373"
        },
        {
          "name": "TestSymbolIndexRoundTrip",
          "kind": "class",
          "signature": "class TestSymbolIndexRoundTrip",
          "doc_one_liner": "Tests for SymbolIndexArtifacts round-trip serialization.",
          "defined_at": "/home/paul/kgfoundry/tests/docs/test_artifact_models.py:418"
        },
        {
          "name": "TestSymbolDeltaPayload",
          "kind": "class",
          "signature": "class TestSymbolDeltaPayload",
          "doc_one_liner": "Tests for SymbolDeltaPayload model.",
          "defined_at": "/home/paul/kgfoundry/tests/docs/test_artifact_models.py:537"
        },
        {
          "name": "TestSymbolDeltaRoundTrip",
          "kind": "class",
          "signature": "class TestSymbolDeltaRoundTrip",
          "doc_one_liner": "Tests for SymbolDeltaPayload round-trip serialization.",
          "defined_at": "/home/paul/kgfoundry/tests/docs/test_artifact_models.py:633"
        },
        {
          "name": "TestArtifactValidation",
          "kind": "class",
          "signature": "class TestArtifactValidation",
          "doc_one_liner": "Tests for artifact validation error handling.",
          "defined_at": "/home/paul/kgfoundry/tests/docs/test_artifact_models.py:679"
        },
        {
          "name": "TestArtifactCoercion",
          "kind": "class",
          "signature": "class TestArtifactCoercion",
          "doc_one_liner": "Tests for field coercion during deserialization.",
          "defined_at": "/home/paul/kgfoundry/tests/docs/test_artifact_models.py:715"
        },
        {
          "name": "TestArtifactJSONFormatting",
          "kind": "class",
          "signature": "class TestArtifactJSONFormatting",
          "doc_one_liner": "Tests for JSON serialization formatting.",
          "defined_at": "/home/paul/kgfoundry/tests/docs/test_artifact_models.py:755"
        },
        {
          "name": "TestCanonicalConstructors",
          "kind": "class",
          "signature": "class TestCanonicalConstructors",
          "doc_one_liner": "Tests for canonical keyword-based constructor usage with alignment.",
          "defined_at": "/home/paul/kgfoundry/tests/docs/test_artifact_models.py:796"
        }
      ],
      "raises": {
        "_normalize_tested_by": [
          "TypeError"
        ],
        "_normalize_source_link": [
          "TypeError"
        ],
        "expect_json_string": [
          "TypeError"
        ],
        "expect_json_int": [
          "TypeError"
        ],
        "expect_json_mapping": [
          "TypeError"
        ],
        "expect_json_sequence": [
          "TypeError"
        ]
      }
    },
    {
      "module": "tests.docs.test_scripts_testing_helpers",
      "path": "/home/paul/kgfoundry/tests/docs/test_scripts_testing_helpers.py",
      "is_test": true,
      "imports": [
        "__future__.annotations",
        "typing.TYPE_CHECKING",
        "unittest.mock.MagicMock",
        "docs.scripts.build_symbol_index",
        "docs.scripts.mkdocs_gen_api",
        "docs.scripts.shared",
        "docs.scripts.symbol_delta",
        "docs.scripts.validate_artifacts",
        "docs.scripts.testing.clear_lazy_import_caches",
        "pytest"
      ],
      "public_api": [
        "test_clear_lazy_import_caches_invokes_all_facade_clearers"
      ],
      "doc": {
        "module_doc": false,
        "class_total": 0,
        "class_with_doc": 0,
        "func_total": 1,
        "func_with_doc": 1
      },
      "typing": {
        "functions": 1,
        "annotated_returns": 1,
        "total_params": 1,
        "annotated_params": 1
      },
      "complexity": {
        "branch_points": 3,
        "max_nesting": 2
      },
      "loc": 45,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "docs.scripts.build_symbol_index",
          "docs.scripts.mkdocs_gen_api",
          "docs.scripts.shared",
          "docs.scripts.symbol_delta",
          "docs.scripts.testing.clear_lazy_import_caches",
          "docs.scripts.validate_artifacts",
          "typing.TYPE_CHECKING",
          "unittest.mock.MagicMock"
        ],
        "type_checking_imports": [
          "pytest"
        ],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "test_clear_lazy_import_caches_invokes_all_facade_clearers",
          "kind": "function",
          "signature": "test_clear_lazy_import_caches_invokes_all_facade_clearers(monkeypatch: pytest.MonkeyPatch) -> None",
          "doc_one_liner": "Test that clear_lazy_import_caches invokes all facade clear_cache methods.",
          "defined_at": "/home/paul/kgfoundry/tests/docs/test_scripts_testing_helpers.py:19"
        }
      ],
      "raises": {}
    },
    {
      "module": "tests.orchestration.test_cli_configuration_error",
      "path": "/home/paul/kgfoundry/tests/orchestration/test_cli_configuration_error.py",
      "is_test": true,
      "imports": [
        "__future__.annotations",
        "typing.TYPE_CHECKING",
        "typing.cast",
        "kgfoundry_common.errors.ConfigurationError",
        "kgfoundry_common.problem_details.build_configuration_problem",
        "kgfoundry_common.problem_details.render_problem",
        "orchestration.config.IndexCliConfig",
        "pathlib.Path"
      ],
      "public_api": [
        "TestConfigurationErrorHandling",
        "TestConfigurationErrorIntegration"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 2,
        "class_with_doc": 2,
        "func_total": 5,
        "func_with_doc": 5
      },
      "typing": {
        "functions": 5,
        "annotated_returns": 5,
        "total_params": 6,
        "annotated_params": 1
      },
      "complexity": {
        "branch_points": 2,
        "max_nesting": 3
      },
      "loc": 106,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "kgfoundry_common.errors.ConfigurationError",
          "kgfoundry_common.problem_details.build_configuration_problem",
          "kgfoundry_common.problem_details.render_problem",
          "orchestration.config.IndexCliConfig",
          "typing.TYPE_CHECKING",
          "typing.cast"
        ],
        "type_checking_imports": [
          "pathlib.Path"
        ],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "TestConfigurationErrorHandling",
          "kind": "class",
          "signature": "class TestConfigurationErrorHandling",
          "doc_one_liner": "Test that ConfigurationError is properly rendered in CLI context.",
          "defined_at": "/home/paul/kgfoundry/tests/orchestration/test_cli_configuration_error.py:18"
        },
        {
          "name": "TestConfigurationErrorIntegration",
          "kind": "class",
          "signature": "class TestConfigurationErrorIntegration",
          "doc_one_liner": "Integration tests for CLI configuration error handling.",
          "defined_at": "/home/paul/kgfoundry/tests/orchestration/test_cli_configuration_error.py:66"
        }
      ],
      "raises": {}
    },
    {
      "module": "tests.orchestration.test_cli_refactor",
      "path": "/home/paul/kgfoundry/tests/orchestration/test_cli_refactor.py",
      "is_test": true,
      "imports": [
        "__future__.annotations",
        "tempfile",
        "pathlib.Path",
        "typing.cast",
        "unittest.mock.patch",
        "orchestration.cli",
        "orchestration.cli.index_faiss",
        "orchestration.cli.run_index_faiss",
        "orchestration.config.IndexCliConfig"
      ],
      "public_api": [
        "TestRunIndexFaissSignature",
        "TestIndexFaissCliBuildsConfig",
        "TestRunIndexFaissDocstring",
        "TestIndexFaissDocstring",
        "TestConfigExportedInAll",
        "TestIndexCliConfigIntegration",
        "TestAPIConsistency"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 7,
        "class_with_doc": 7,
        "func_total": 16,
        "func_with_doc": 16
      },
      "typing": {
        "functions": 16,
        "annotated_returns": 16,
        "total_params": 16,
        "annotated_params": 0
      },
      "complexity": {
        "branch_points": 13,
        "max_nesting": 4
      },
      "loc": 209,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "orchestration.cli",
          "orchestration.cli.index_faiss",
          "orchestration.cli.run_index_faiss",
          "orchestration.config.IndexCliConfig",
          "pathlib.Path",
          "tempfile",
          "typing.cast",
          "unittest.mock.patch"
        ],
        "type_checking_imports": [],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "TestRunIndexFaissSignature",
          "kind": "class",
          "signature": "class TestRunIndexFaissSignature",
          "doc_one_liner": "Tests for run_index_faiss function signature and type safety.",
          "defined_at": "/home/paul/kgfoundry/tests/orchestration/test_cli_refactor.py:19"
        },
        {
          "name": "TestIndexFaissCliBuildsConfig",
          "kind": "class",
          "signature": "class TestIndexFaissCliBuildsConfig",
          "doc_one_liner": "Tests for index_faiss CLI function config construction.",
          "defined_at": "/home/paul/kgfoundry/tests/orchestration/test_cli_refactor.py:50"
        },
        {
          "name": "TestRunIndexFaissDocstring",
          "kind": "class",
          "signature": "class TestRunIndexFaissDocstring",
          "doc_one_liner": "Tests for run_index_faiss docstring completeness.",
          "defined_at": "/home/paul/kgfoundry/tests/orchestration/test_cli_refactor.py:98"
        },
        {
          "name": "TestIndexFaissDocstring",
          "kind": "class",
          "signature": "class TestIndexFaissDocstring",
          "doc_one_liner": "Tests for index_faiss docstring completeness.",
          "defined_at": "/home/paul/kgfoundry/tests/orchestration/test_cli_refactor.py:126"
        },
        {
          "name": "TestConfigExportedInAll",
          "kind": "class",
          "signature": "class TestConfigExportedInAll",
          "doc_one_liner": "Tests for public API exports.",
          "defined_at": "/home/paul/kgfoundry/tests/orchestration/test_cli_refactor.py:148"
        },
        {
          "name": "TestIndexCliConfigIntegration",
          "kind": "class",
          "signature": "class TestIndexCliConfigIntegration",
          "doc_one_liner": "Tests for integration between IndexCliConfig and CLI functions.",
          "defined_at": "/home/paul/kgfoundry/tests/orchestration/test_cli_refactor.py:160"
        },
        {
          "name": "TestAPIConsistency",
          "kind": "class",
          "signature": "class TestAPIConsistency",
          "doc_one_liner": "Tests for API consistency between old and new functions.",
          "defined_at": "/home/paul/kgfoundry/tests/orchestration/test_cli_refactor.py:188"
        }
      ],
      "raises": {}
    },
    {
      "module": "tests.orchestration.test_cli_envelopes",
      "path": "/home/paul/kgfoundry/tests/orchestration/test_cli_envelopes.py",
      "is_test": true,
      "imports": [
        "__future__.annotations",
        "json",
        "pathlib.Path",
        "typing.cast",
        "pytest",
        "typer.testing.CliRunner",
        "kgfoundry_common.vector_types.VectorValidationError",
        "orchestration.cli"
      ],
      "public_api": [
        "test_index_bm25_emits_success_envelope",
        "test_index_faiss_records_validation_failure"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 0,
        "class_with_doc": 0,
        "func_total": 6,
        "func_with_doc": 0
      },
      "typing": {
        "functions": 6,
        "annotated_returns": 6,
        "total_params": 10,
        "annotated_params": 10
      },
      "complexity": {
        "branch_points": 0,
        "max_nesting": 2
      },
      "loc": 98,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "json",
          "kgfoundry_common.vector_types.VectorValidationError",
          "orchestration.cli",
          "pathlib.Path",
          "pytest",
          "typer.testing.CliRunner",
          "typing.cast"
        ],
        "type_checking_imports": [],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "test_index_bm25_emits_success_envelope",
          "kind": "function",
          "signature": "test_index_bm25_emits_success_envelope(tmp_path: Path, monkeypatch: pytest.MonkeyPatch, runner: CliRunner) -> None",
          "doc_one_liner": "",
          "defined_at": "/home/paul/kgfoundry/tests/orchestration/test_cli_envelopes.py:26"
        },
        {
          "name": "test_index_faiss_records_validation_failure",
          "kind": "function",
          "signature": "test_index_faiss_records_validation_failure(tmp_path: Path, monkeypatch: pytest.MonkeyPatch, runner: CliRunner) -> None",
          "doc_one_liner": "",
          "defined_at": "/home/paul/kgfoundry/tests/orchestration/test_cli_envelopes.py:65"
        }
      ],
      "raises": {
        "test_index_faiss_records_validation_failure": [
          "error"
        ],
        "fake_run": [
          "error"
        ]
      }
    },
    {
      "module": "tests.orchestration.test_index_cli_idempotency",
      "path": "/home/paul/kgfoundry/tests/orchestration/test_index_cli_idempotency.py",
      "is_test": true,
      "imports": [
        "__future__.annotations",
        "json",
        "logging",
        "typing.TYPE_CHECKING",
        "typing.Any",
        "typing.cast",
        "pytest",
        "typer",
        "orchestration.cli.index_bm25",
        "orchestration.cli.index_faiss",
        "collections.abc.Iterable",
        "pathlib.Path",
        "_pytest.logging.LogCaptureFixture"
      ],
      "public_api": [
        "TestIndexBM25Idempotency",
        "TestIndexFAISSIdempotency",
        "TestIndexingErrorHandling"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 3,
        "class_with_doc": 3,
        "func_total": 5,
        "func_with_doc": 4
      },
      "typing": {
        "functions": 5,
        "annotated_returns": 5,
        "total_params": 16,
        "annotated_params": 12
      },
      "complexity": {
        "branch_points": 5,
        "max_nesting": 3
      },
      "loc": 249,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "json",
          "logging",
          "orchestration.cli.index_bm25",
          "orchestration.cli.index_faiss",
          "pytest",
          "typer",
          "typing.Any",
          "typing.TYPE_CHECKING",
          "typing.cast"
        ],
        "type_checking_imports": [
          "_pytest.logging.LogCaptureFixture",
          "collections.abc.Iterable",
          "pathlib.Path"
        ],
        "exports": [
          "TestIndexBM25Idempotency",
          "TestIndexFAISSIdempotency",
          "TestIndexingErrorHandling"
        ],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "TestIndexBM25Idempotency",
          "kind": "class",
          "signature": "class TestIndexBM25Idempotency",
          "doc_one_liner": "Verify BM25 indexing is idempotent.",
          "defined_at": "/home/paul/kgfoundry/tests/orchestration/test_index_cli_idempotency.py:31"
        },
        {
          "name": "TestIndexFAISSIdempotency",
          "kind": "class",
          "signature": "class TestIndexFAISSIdempotency",
          "doc_one_liner": "Verify FAISS indexing is idempotent.",
          "defined_at": "/home/paul/kgfoundry/tests/orchestration/test_index_cli_idempotency.py:95"
        },
        {
          "name": "TestIndexingErrorHandling",
          "kind": "class",
          "signature": "class TestIndexingErrorHandling",
          "doc_one_liner": "Verify error handling in index operations.",
          "defined_at": "/home/paul/kgfoundry/tests/orchestration/test_index_cli_idempotency.py:151"
        }
      ],
      "raises": {}
    },
    {
      "module": "tests.search_api.test_client_idempotency",
      "path": "/home/paul/kgfoundry/tests/search_api/test_client_idempotency.py",
      "is_test": true,
      "imports": [
        "__future__.annotations",
        "dataclasses.dataclass",
        "typing.TYPE_CHECKING",
        "_pytest.logging.LogCaptureFixture",
        "kgfoundry_common.types.JsonValue"
      ],
      "public_api": [
        "TestCorrelationIdPropagation",
        "TestHttpGetIdempotency",
        "TestHttpPostIdempotency",
        "TestTransientErrorRetries"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 6,
        "class_with_doc": 6,
        "func_total": 15,
        "func_with_doc": 13
      },
      "typing": {
        "functions": 15,
        "annotated_returns": 15,
        "total_params": 24,
        "annotated_params": 9
      },
      "complexity": {
        "branch_points": 11,
        "max_nesting": 4
      },
      "loc": 357,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "dataclasses.dataclass",
          "typing.TYPE_CHECKING"
        ],
        "type_checking_imports": [
          "_pytest.logging.LogCaptureFixture",
          "kgfoundry_common.types.JsonValue"
        ],
        "exports": [
          "TestCorrelationIdPropagation",
          "TestHttpGetIdempotency",
          "TestHttpPostIdempotency",
          "TestTransientErrorRetries"
        ],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "TestHttpGetIdempotency",
          "kind": "class",
          "signature": "class TestHttpGetIdempotency",
          "doc_one_liner": "Verify GET requests are idempotent (safe, repeatable).",
          "defined_at": "/home/paul/kgfoundry/tests/search_api/test_client_idempotency.py:125"
        },
        {
          "name": "TestHttpPostIdempotency",
          "kind": "class",
          "signature": "class TestHttpPostIdempotency",
          "doc_one_liner": "Verify POST requests with idempotency keys prevent duplicate side effects.",
          "defined_at": "/home/paul/kgfoundry/tests/search_api/test_client_idempotency.py:178"
        },
        {
          "name": "TestTransientErrorRetries",
          "kind": "class",
          "signature": "class TestTransientErrorRetries",
          "doc_one_liner": "Verify transient errors (5xx) trigger automatic retries.",
          "defined_at": "/home/paul/kgfoundry/tests/search_api/test_client_idempotency.py:251"
        },
        {
          "name": "TestCorrelationIdPropagation",
          "kind": "class",
          "signature": "class TestCorrelationIdPropagation",
          "doc_one_liner": "Verify correlation IDs are preserved and propagated across retries.",
          "defined_at": "/home/paul/kgfoundry/tests/search_api/test_client_idempotency.py:307"
        }
      ],
      "raises": {
        "_response_for": [
          "AssertionError"
        ]
      }
    },
    {
      "module": "tests.search_api.test_faiss_adapter",
      "path": "/home/paul/kgfoundry/tests/search_api/test_faiss_adapter.py",
      "is_test": true,
      "imports": [
        "__future__.annotations",
        "typing.TYPE_CHECKING",
        "numpy",
        "pytest",
        "search_api.types.wrap_faiss_module",
        "collections.abc.Callable",
        "pathlib.Path",
        "numpy.typing",
        "search_api.types.FaissIndexProtocol",
        "search_api.types.IndexArray",
        "search_api.types.VectorArray"
      ],
      "public_api": [
        "test_wrap_faiss_module_adapts_legacy_surface",
        "test_wrap_faiss_module_returns_pep8_module_directly"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 3,
        "class_with_doc": 3,
        "func_total": 21,
        "func_with_doc": 18
      },
      "typing": {
        "functions": 21,
        "annotated_returns": 21,
        "total_params": 43,
        "annotated_params": 27
      },
      "complexity": {
        "branch_points": 1,
        "max_nesting": 3
      },
      "loc": 384,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "np",
          "pytest",
          "search_api.types.wrap_faiss_module",
          "typing.TYPE_CHECKING"
        ],
        "type_checking_imports": [
          "collections.abc.Callable",
          "npt",
          "pathlib.Path",
          "search_api.types.FaissIndexProtocol",
          "search_api.types.IndexArray",
          "search_api.types.VectorArray"
        ],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "test_wrap_faiss_module_adapts_legacy_surface",
          "kind": "function",
          "signature": "test_wrap_faiss_module_adapts_legacy_surface(dimension: int, tmp_path: Path) -> None",
          "doc_one_liner": "Test that legacy FAISS module is adapted to modern interface.",
          "defined_at": "/home/paul/kgfoundry/tests/search_api/test_faiss_adapter.py:333"
        },
        {
          "name": "test_wrap_faiss_module_returns_pep8_module_directly",
          "kind": "function",
          "signature": "test_wrap_faiss_module_returns_pep8_module_directly() -> None",
          "doc_one_liner": "Test that modern PEP-8 module is returned unchanged.",
          "defined_at": "/home/paul/kgfoundry/tests/search_api/test_faiss_adapter.py:373"
        }
      ],
      "raises": {}
    },
    {
      "module": "tests.io.test_hybrid_search_paths",
      "path": "/home/paul/kgfoundry/tests/io/test_hybrid_search_paths.py",
      "is_test": true,
      "imports": [
        "__future__.annotations",
        "pathlib.Path",
        "types.SimpleNamespace",
        "typing.cast",
        "pytest",
        "codeintel_rev.app.config_context.ResolvedPaths",
        "codeintel_rev.config.settings.Settings",
        "codeintel_rev.io.hybrid_search.HybridSearchEngine"
      ],
      "public_api": [
        "test_resolve_path_absolute",
        "test_resolve_path_relative",
        "test_resolve_path_expands_user_home"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 0,
        "class_with_doc": 0,
        "func_total": 4,
        "func_with_doc": 1
      },
      "typing": {
        "functions": 4,
        "annotated_returns": 4,
        "total_params": 3,
        "annotated_params": 3
      },
      "complexity": {
        "branch_points": 0,
        "max_nesting": 1
      },
      "loc": 63,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "codeintel_rev.app.config_context.ResolvedPaths",
          "codeintel_rev.config.settings.Settings",
          "codeintel_rev.io.hybrid_search.HybridSearchEngine",
          "pathlib.Path",
          "pytest",
          "types.SimpleNamespace",
          "typing.cast"
        ],
        "type_checking_imports": [],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "test_resolve_path_absolute",
          "kind": "function",
          "signature": "test_resolve_path_absolute() -> None",
          "doc_one_liner": "",
          "defined_at": "/home/paul/kgfoundry/tests/io/test_hybrid_search_paths.py:33"
        },
        {
          "name": "test_resolve_path_relative",
          "kind": "function",
          "signature": "test_resolve_path_relative() -> None",
          "doc_one_liner": "",
          "defined_at": "/home/paul/kgfoundry/tests/io/test_hybrid_search_paths.py:44"
        },
        {
          "name": "test_resolve_path_expands_user_home",
          "kind": "function",
          "signature": "test_resolve_path_expands_user_home(monkeypatch: pytest.MonkeyPatch, tmp_path: Path) -> None",
          "doc_one_liner": "",
          "defined_at": "/home/paul/kgfoundry/tests/io/test_hybrid_search_paths.py:55"
        }
      ],
      "raises": {}
    },
    {
      "module": "tests.tools.test_check_typing_gates",
      "path": "/home/paul/kgfoundry/tests/tools/test_check_typing_gates.py",
      "is_test": true,
      "imports": [
        "__future__.annotations",
        "json",
        "typing.TYPE_CHECKING",
        "typing.Any",
        "typing.cast",
        "tools.lint.check_typing_gates.HEAVY_MODULES",
        "tools.lint.check_typing_gates.check_file",
        "tools.lint.check_typing_gates.format_violations",
        "tools.lint.check_typing_gates.main",
        "pathlib.Path"
      ],
      "public_api": [
        "TestTypeGateViolationTypes",
        "TestAutoFixSuggestions",
        "TestOutputFormats",
        "TestMainCommand",
        "TestEdgeCases"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 5,
        "class_with_doc": 5,
        "func_total": 25,
        "func_with_doc": 25
      },
      "typing": {
        "functions": 25,
        "annotated_returns": 25,
        "total_params": 50,
        "annotated_params": 25
      },
      "complexity": {
        "branch_points": 1,
        "max_nesting": 2
      },
      "loc": 382,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "json",
          "tools.lint.check_typing_gates.HEAVY_MODULES",
          "tools.lint.check_typing_gates.check_file",
          "tools.lint.check_typing_gates.format_violations",
          "tools.lint.check_typing_gates.main",
          "typing.Any",
          "typing.TYPE_CHECKING",
          "typing.cast"
        ],
        "type_checking_imports": [
          "pathlib.Path"
        ],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "TestTypeGateViolationTypes",
          "kind": "class",
          "signature": "class TestTypeGateViolationTypes",
          "doc_one_liner": "Test detection of different violation types.",
          "defined_at": "/home/paul/kgfoundry/tests/tools/test_check_typing_gates.py:28"
        },
        {
          "name": "TestAutoFixSuggestions",
          "kind": "class",
          "signature": "class TestAutoFixSuggestions",
          "doc_one_liner": "Test that suggestions are actionable and specific.",
          "defined_at": "/home/paul/kgfoundry/tests/tools/test_check_typing_gates.py:182"
        },
        {
          "name": "TestOutputFormats",
          "kind": "class",
          "signature": "class TestOutputFormats",
          "doc_one_liner": "Test different output formats.",
          "defined_at": "/home/paul/kgfoundry/tests/tools/test_check_typing_gates.py:225"
        },
        {
          "name": "TestMainCommand",
          "kind": "class",
          "signature": "class TestMainCommand",
          "doc_one_liner": "Test command-line interface.",
          "defined_at": "/home/paul/kgfoundry/tests/tools/test_check_typing_gates.py:283"
        },
        {
          "name": "TestEdgeCases",
          "kind": "class",
          "signature": "class TestEdgeCases",
          "doc_one_liner": "Test edge cases and special scenarios.",
          "defined_at": "/home/paul/kgfoundry/tests/tools/test_check_typing_gates.py:311"
        }
      ],
      "raises": {}
    },
    {
      "module": "tests.tools.test_cli_context_registry",
      "path": "/home/paul/kgfoundry/tests/tools/test_cli_context_registry.py",
      "is_test": true,
      "imports": [
        "__future__.annotations",
        "sys",
        "collections.abc.Sequence",
        "pathlib.Path",
        "typing.cast",
        "uuid.uuid4",
        "pytest",
        "tools.CLIToolingContext",
        "tools.cli_context_registry",
        "tools._shared.augment_registry.AugmentMetadataModel",
        "tools.cli_context_registry.CLIContextDefinition",
        "tools.cli_context_registry.context_for",
        "tools.cli_context_registry.default_version_resolver",
        "tools.cli_context_registry.register_cli",
        "tools.cli_context_registry.settings_for"
      ],
      "public_api": [
        "test_settings_for_returns_expected_fields",
        "test_context_for_is_cached",
        "test_duplicate_registration_raises",
        "test_unknown_key_raises_key_error",
        "test_version_resolver_fallback",
        "test_operation_override_dispatch"
      ],
      "doc": {
        "module_doc": false,
        "class_total": 1,
        "class_with_doc": 0,
        "func_total": 13,
        "func_with_doc": 0
      },
      "typing": {
        "functions": 13,
        "annotated_returns": 13,
        "total_params": 14,
        "annotated_params": 12
      },
      "complexity": {
        "branch_points": 5,
        "max_nesting": 3
      },
      "loc": 158,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "collections.abc.Sequence",
          "pathlib.Path",
          "pytest",
          "sys",
          "tools.CLIToolingContext",
          "tools._shared.augment_registry.AugmentMetadataModel",
          "tools.cli_context_registry",
          "tools.cli_context_registry.CLIContextDefinition",
          "tools.cli_context_registry.context_for",
          "tools.cli_context_registry.default_version_resolver",
          "tools.cli_context_registry.register_cli",
          "tools.cli_context_registry.settings_for",
          "typing.cast",
          "uuid.uuid4"
        ],
        "type_checking_imports": [],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "test_settings_for_returns_expected_fields",
          "kind": "function",
          "signature": "test_settings_for_returns_expected_fields() -> None",
          "doc_one_liner": "",
          "defined_at": "/home/paul/kgfoundry/tests/tools/test_cli_context_registry.py:57"
        },
        {
          "name": "test_context_for_is_cached",
          "kind": "function",
          "signature": "test_context_for_is_cached() -> None",
          "doc_one_liner": "",
          "defined_at": "/home/paul/kgfoundry/tests/tools/test_cli_context_registry.py:75"
        },
        {
          "name": "test_duplicate_registration_raises",
          "kind": "function",
          "signature": "test_duplicate_registration_raises() -> None",
          "doc_one_liner": "",
          "defined_at": "/home/paul/kgfoundry/tests/tools/test_cli_context_registry.py:98"
        },
        {
          "name": "test_unknown_key_raises_key_error",
          "kind": "function",
          "signature": "test_unknown_key_raises_key_error() -> None",
          "doc_one_liner": "",
          "defined_at": "/home/paul/kgfoundry/tests/tools/test_cli_context_registry.py:113"
        },
        {
          "name": "test_version_resolver_fallback",
          "kind": "function",
          "signature": "test_version_resolver_fallback() -> None",
          "doc_one_liner": "",
          "defined_at": "/home/paul/kgfoundry/tests/tools/test_cli_context_registry.py:118"
        },
        {
          "name": "test_operation_override_dispatch",
          "kind": "function",
          "signature": "test_operation_override_dispatch(monkeypatch: pytest.MonkeyPatch) -> None",
          "doc_one_liner": "",
          "defined_at": "/home/paul/kgfoundry/tests/tools/test_cli_context_registry.py:128"
        }
      ],
      "raises": {}
    },
    {
      "module": "tests.tools.test_generate_pr_summary",
      "path": "/home/paul/kgfoundry/tests/tools/test_generate_pr_summary.py",
      "is_test": true,
      "imports": [
        "__future__.annotations",
        "typing.TYPE_CHECKING",
        "tools.generate_pr_summary.collect_artifact_snapshot",
        "tools.generate_pr_summary.generate_summary",
        "pathlib.Path"
      ],
      "public_api": [
        "test_collect_artifact_snapshot_detects_numbered_codemod_logs",
        "test_collect_artifact_snapshot_orders_double_digit_logs",
        "test_generate_summary_lists_all_codemod_logs",
        "test_generate_summary_with_empty_checks_emits_only_headers"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 0,
        "class_with_doc": 0,
        "func_total": 4,
        "func_with_doc": 4
      },
      "typing": {
        "functions": 4,
        "annotated_returns": 4,
        "total_params": 4,
        "annotated_params": 4
      },
      "complexity": {
        "branch_points": 2,
        "max_nesting": 2
      },
      "loc": 66,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "tools.generate_pr_summary.collect_artifact_snapshot",
          "tools.generate_pr_summary.generate_summary",
          "typing.TYPE_CHECKING"
        ],
        "type_checking_imports": [
          "pathlib.Path"
        ],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "test_collect_artifact_snapshot_detects_numbered_codemod_logs",
          "kind": "function",
          "signature": "test_collect_artifact_snapshot_detects_numbered_codemod_logs(tmp_path: Path) -> None",
          "doc_one_liner": "Snapshot should include all codemod log files with numeric suffixes.",
          "defined_at": "/home/paul/kgfoundry/tests/tools/test_generate_pr_summary.py:13"
        },
        {
          "name": "test_collect_artifact_snapshot_orders_double_digit_logs",
          "kind": "function",
          "signature": "test_collect_artifact_snapshot_orders_double_digit_logs(tmp_path: Path) -> None",
          "doc_one_liner": "Codemod logs should be sorted using natural order for numeric suffixes.",
          "defined_at": "/home/paul/kgfoundry/tests/tools/test_generate_pr_summary.py:31"
        },
        {
          "name": "test_generate_summary_lists_all_codemod_logs",
          "kind": "function",
          "signature": "test_generate_summary_lists_all_codemod_logs(tmp_path: Path) -> None",
          "doc_one_liner": "Rendered summary should include every detected codemod log entry.",
          "defined_at": "/home/paul/kgfoundry/tests/tools/test_generate_pr_summary.py:46"
        },
        {
          "name": "test_generate_summary_with_empty_checks_emits_only_headers",
          "kind": "function",
          "signature": "test_generate_summary_with_empty_checks_emits_only_headers(tmp_path: Path) -> None",
          "doc_one_liner": "Explicit empty checks should result in no table rows beyond the header.",
          "defined_at": "/home/paul/kgfoundry/tests/tools/test_generate_pr_summary.py:59"
        }
      ],
      "raises": {}
    },
    {
      "module": "tests.tools.test_check_stub_parity",
      "path": "/home/paul/kgfoundry/tests/tools/test_check_stub_parity.py",
      "is_test": true,
      "imports": [
        "__future__.annotations",
        "importlib",
        "sys",
        "types.ModuleType",
        "typing.TYPE_CHECKING",
        "typing.Any",
        "typing.cast",
        "pytest",
        "kgfoundry_common.errors.ConfigurationError",
        "pathlib.Path",
        "tools.check_stub_parity.StubParityContext",
        "tools.check_stub_parity.StubParityIssueRecord",
        "tools.check_stub_parity.StubParityReport"
      ],
      "public_api": [
        "test_evaluate_stub_reports_any_usage",
        "test_run_stub_parity_checks_success",
        "test_report_from_context_validates_counts",
        "test_run_stub_parity_checks_raises_with_context"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 0,
        "class_with_doc": 0,
        "func_total": 6,
        "func_with_doc": 4
      },
      "typing": {
        "functions": 6,
        "annotated_returns": 6,
        "total_params": 8,
        "annotated_params": 8
      },
      "complexity": {
        "branch_points": 5,
        "max_nesting": 2
      },
      "loc": 124,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "importlib",
          "kgfoundry_common.errors.ConfigurationError",
          "pytest",
          "sys",
          "types.ModuleType",
          "typing.Any",
          "typing.TYPE_CHECKING",
          "typing.cast"
        ],
        "type_checking_imports": [
          "pathlib.Path",
          "tools.check_stub_parity.StubParityContext",
          "tools.check_stub_parity.StubParityIssueRecord",
          "tools.check_stub_parity.StubParityReport"
        ],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "test_evaluate_stub_reports_any_usage",
          "kind": "function",
          "signature": "test_evaluate_stub_reports_any_usage(tmp_path: Path) -> None",
          "doc_one_liner": "`evaluate_stub` should capture Any usages for downstream reporting.",
          "defined_at": "/home/paul/kgfoundry/tests/tools/test_check_stub_parity.py:46"
        },
        {
          "name": "test_run_stub_parity_checks_success",
          "kind": "function",
          "signature": "test_run_stub_parity_checks_success(tmp_path: Path) -> None",
          "doc_one_liner": "A fully matching stub should complete without raising.",
          "defined_at": "/home/paul/kgfoundry/tests/tools/test_check_stub_parity.py:64"
        },
        {
          "name": "test_report_from_context_validates_counts",
          "kind": "function",
          "signature": "test_report_from_context_validates_counts(tmp_path: Path) -> None",
          "doc_one_liner": "from_context should reject mismatched issue/error counts.",
          "defined_at": "/home/paul/kgfoundry/tests/tools/test_check_stub_parity.py:78"
        },
        {
          "name": "test_run_stub_parity_checks_raises_with_context",
          "kind": "function",
          "signature": "test_run_stub_parity_checks_raises_with_context(tmp_path: Path) -> None",
          "doc_one_liner": "Missing runtime exports should surface through `ConfigurationError` context.",
          "defined_at": "/home/paul/kgfoundry/tests/tools/test_check_stub_parity.py:100"
        }
      ],
      "raises": {}
    },
    {
      "module": "tests.tools.test_repo_scan",
      "path": "/home/paul/kgfoundry/tests/tools/test_repo_scan.py",
      "is_test": true,
      "imports": [
        "__future__.annotations",
        "json",
        "sys",
        "pathlib.Path",
        "textwrap.dedent",
        "typing.Any",
        "pytest",
        "tools.repo_scan"
      ],
      "public_api": [
        "test_iter_py_files_skips_virtual_env_content",
        "test_iter_py_files_include_subdir_filters",
        "test_is_test_file_heuristics",
        "test_repo_scan_main_generates_expected_payload",
        "test_module_name_strips_src_prefix",
        "test_repo_scan_with_libcst_flag",
        "test_repo_scan_with_griffe_flag",
        "test_repo_scan_handles_missing_repo_root"
      ],
      "doc": {
        "module_doc": false,
        "class_total": 0,
        "class_with_doc": 0,
        "func_total": 9,
        "func_with_doc": 9
      },
      "typing": {
        "functions": 9,
        "annotated_returns": 9,
        "total_params": 20,
        "annotated_params": 20
      },
      "complexity": {
        "branch_points": 11,
        "max_nesting": 3
      },
      "loc": 349,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "json",
          "pathlib.Path",
          "pytest",
          "sys",
          "textwrap.dedent",
          "tools.repo_scan",
          "typing.Any"
        ],
        "type_checking_imports": [],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "test_iter_py_files_skips_virtual_env_content",
          "kind": "function",
          "signature": "test_iter_py_files_skips_virtual_env_content(tmp_path: Path) -> None",
          "doc_one_liner": "Ensure skip rules prevent generated folders from polluting metrics.",
          "defined_at": "/home/paul/kgfoundry/tests/tools/test_repo_scan.py:64"
        },
        {
          "name": "test_iter_py_files_include_subdir_filters",
          "kind": "function",
          "signature": "test_iter_py_files_include_subdir_filters(tmp_path: Path) -> None",
          "doc_one_liner": "Restrict scanning to the requested subdirectories.",
          "defined_at": "/home/paul/kgfoundry/tests/tools/test_repo_scan.py:81"
        },
        {
          "name": "test_is_test_file_heuristics",
          "kind": "function",
          "signature": "test_is_test_file_heuristics(tmp_path: Path, relative_parts: tuple[str, ...], module_name: str, *, expected: bool) -> None",
          "doc_one_liner": "Confirm the test-file heuristic covers path- and name-based patterns.",
          "defined_at": "/home/paul/kgfoundry/tests/tools/test_repo_scan.py:105"
        },
        {
          "name": "test_repo_scan_main_generates_expected_payload",
          "kind": "function",
          "signature": "test_repo_scan_main_generates_expected_payload(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -> None",
          "doc_one_liner": "Run the CLI end-to-end on a synthetic repo to validate the payload shape.",
          "defined_at": "/home/paul/kgfoundry/tests/tools/test_repo_scan.py:115"
        },
        {
          "name": "test_module_name_strips_src_prefix",
          "kind": "function",
          "signature": "test_module_name_strips_src_prefix(tmp_path: Path) -> None",
          "doc_one_liner": "Ensure module names drop the leading `src` segment by default.",
          "defined_at": "/home/paul/kgfoundry/tests/tools/test_repo_scan.py:229"
        },
        {
          "name": "test_repo_scan_with_libcst_flag",
          "kind": "function",
          "signature": "test_repo_scan_with_libcst_flag(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -> None",
          "doc_one_liner": "Ensure LibCST enrichment is enabled by default and can be disabled.",
          "defined_at": "/home/paul/kgfoundry/tests/tools/test_repo_scan.py:240"
        },
        {
          "name": "test_repo_scan_with_griffe_flag",
          "kind": "function",
          "signature": "test_repo_scan_with_griffe_flag(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -> None",
          "doc_one_liner": "Confirm Griffe-powered API extraction populates api_symbols.",
          "defined_at": "/home/paul/kgfoundry/tests/tools/test_repo_scan.py:279"
        },
        {
          "name": "test_repo_scan_handles_missing_repo_root",
          "kind": "function",
          "signature": "test_repo_scan_handles_missing_repo_root(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -> None",
          "doc_one_liner": "CLI should fall back gracefully when --repo-root points to nowhere.",
          "defined_at": "/home/paul/kgfoundry/tests/tools/test_repo_scan.py:336"
        }
      ],
      "raises": {}
    },
    {
      "module": "tests.tools.test_mkdocs_serve",
      "path": "/home/paul/kgfoundry/tests/tools/test_mkdocs_serve.py",
      "is_test": true,
      "imports": [
        "__future__.annotations",
        "importlib",
        "importlib.util",
        "socket",
        "sys",
        "types",
        "collections.abc.Iterator",
        "functools.cache",
        "pathlib.Path",
        "typing.Any",
        "typing.cast",
        "pytest"
      ],
      "public_api": [
        "test_find_available_port_prefers_unbound_port"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 1,
        "class_with_doc": 0,
        "func_total": 7,
        "func_with_doc": 0
      },
      "typing": {
        "functions": 7,
        "annotated_returns": 7,
        "total_params": 13,
        "annotated_params": 12
      },
      "complexity": {
        "branch_points": 24,
        "max_nesting": 5
      },
      "loc": 148,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "collections.abc.Iterator",
          "functools.cache",
          "importlib",
          "importlib.util",
          "pathlib.Path",
          "pytest",
          "socket",
          "sys",
          "types",
          "typing.Any",
          "typing.cast"
        ],
        "type_checking_imports": [],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "test_find_available_port_prefers_unbound_port",
          "kind": "function",
          "signature": "test_find_available_port_prefers_unbound_port(host: str, family: int) -> None",
          "doc_one_liner": "",
          "defined_at": "/home/paul/kgfoundry/tests/tools/test_mkdocs_serve.py:109"
        }
      ],
      "raises": {
        "_load_serve_module_with_stubs": [
          "NotImplementedError",
          "RuntimeError"
        ],
        "_run_tool_stub": [
          "NotImplementedError"
        ]
      }
    },
    {
      "module": "tests.tools.test_typing_gate_metrics",
      "path": "/home/paul/kgfoundry/tests/tools/test_typing_gate_metrics.py",
      "is_test": true,
      "imports": [
        "__future__.annotations",
        "json",
        "typing.TYPE_CHECKING",
        "typing.cast",
        "tools.lint.typing_gate_metrics.TypingGateMetrics",
        "tools.lint.typing_gate_metrics.ViolationRecord",
        "tests.helpers.assert_frozen_attribute",
        "pathlib.Path"
      ],
      "public_api": [
        "TestViolationRecord",
        "TestTypingGateMetrics"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 2,
        "class_with_doc": 2,
        "func_total": 18,
        "func_with_doc": 18
      },
      "typing": {
        "functions": 18,
        "annotated_returns": 18,
        "total_params": 20,
        "annotated_params": 2
      },
      "complexity": {
        "branch_points": 2,
        "max_nesting": 3
      },
      "loc": 294,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "json",
          "tests.helpers.assert_frozen_attribute",
          "tools.lint.typing_gate_metrics.TypingGateMetrics",
          "tools.lint.typing_gate_metrics.ViolationRecord",
          "typing.TYPE_CHECKING",
          "typing.cast"
        ],
        "type_checking_imports": [
          "pathlib.Path"
        ],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "TestViolationRecord",
          "kind": "class",
          "signature": "class TestViolationRecord",
          "doc_one_liner": "Test ViolationRecord data class.",
          "defined_at": "/home/paul/kgfoundry/tests/tools/test_typing_gate_metrics.py:26"
        },
        {
          "name": "TestTypingGateMetrics",
          "kind": "class",
          "signature": "class TestTypingGateMetrics",
          "doc_one_liner": "Test TypingGateMetrics collection and emission.",
          "defined_at": "/home/paul/kgfoundry/tests/tools/test_typing_gate_metrics.py:53"
        }
      ],
      "raises": {}
    },
    {
      "module": "tests.tools.test_check_new_suppressions",
      "path": "/home/paul/kgfoundry/tests/tools/test_check_new_suppressions.py",
      "is_test": true,
      "imports": [
        "__future__.annotations",
        "typing.TYPE_CHECKING",
        "pytest",
        "tools.check_new_suppressions.SuppressionGuardReport",
        "tools.check_new_suppressions.build_guard_context",
        "tools.check_new_suppressions.check_directory",
        "tools.check_new_suppressions.resolve_target_directories",
        "tools.check_new_suppressions.run_suppression_guard",
        "kgfoundry_common.errors.ConfigurationError",
        "pathlib.Path"
      ],
      "public_api": [
        "test_run_suppression_guard_detects_missing_ticket",
        "test_run_suppression_guard_allows_ticket_metadata",
        "test_report_from_context_validates_violation_count",
        "test_resolve_target_directories_validates_input",
        "test_resolve_target_directories_accepts_existing_directory"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 0,
        "class_with_doc": 0,
        "func_total": 6,
        "func_with_doc": 5
      },
      "typing": {
        "functions": 6,
        "annotated_returns": 6,
        "total_params": 9,
        "annotated_params": 9
      },
      "complexity": {
        "branch_points": 5,
        "max_nesting": 2
      },
      "loc": 84,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "kgfoundry_common.errors.ConfigurationError",
          "pytest",
          "tools.check_new_suppressions.SuppressionGuardReport",
          "tools.check_new_suppressions.build_guard_context",
          "tools.check_new_suppressions.check_directory",
          "tools.check_new_suppressions.resolve_target_directories",
          "tools.check_new_suppressions.run_suppression_guard",
          "typing.TYPE_CHECKING"
        ],
        "type_checking_imports": [
          "pathlib.Path"
        ],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "test_run_suppression_guard_detects_missing_ticket",
          "kind": "function",
          "signature": "test_run_suppression_guard_detects_missing_ticket(tmp_path: Path) -> None",
          "doc_one_liner": "The guard should raise when a suppression lacks ``TICKET:`` metadata.",
          "defined_at": "/home/paul/kgfoundry/tests/tools/test_check_new_suppressions.py:32"
        },
        {
          "name": "test_run_suppression_guard_allows_ticket_metadata",
          "kind": "function",
          "signature": "test_run_suppression_guard_allows_ticket_metadata(tmp_path: Path) -> None",
          "doc_one_liner": "Files with ticket metadata should pass without raising.",
          "defined_at": "/home/paul/kgfoundry/tests/tools/test_check_new_suppressions.py:44"
        },
        {
          "name": "test_report_from_context_validates_violation_count",
          "kind": "function",
          "signature": "test_report_from_context_validates_violation_count(tmp_path: Path, violation_count: int) -> None",
          "doc_one_liner": "from_context should reject mismatched violation counts.",
          "defined_at": "/home/paul/kgfoundry/tests/tools/test_check_new_suppressions.py:54"
        },
        {
          "name": "test_resolve_target_directories_validates_input",
          "kind": "function",
          "signature": "test_resolve_target_directories_validates_input(tmp_path: Path) -> None",
          "doc_one_liner": "Invalid directories should surface as configuration errors.",
          "defined_at": "/home/paul/kgfoundry/tests/tools/test_check_new_suppressions.py:68"
        },
        {
          "name": "test_resolve_target_directories_accepts_existing_directory",
          "kind": "function",
          "signature": "test_resolve_target_directories_accepts_existing_directory(tmp_path: Path) -> None",
          "doc_one_liner": "Valid directories should be resolved and returned.",
          "defined_at": "/home/paul/kgfoundry/tests/tools/test_check_new_suppressions.py:80"
        }
      ],
      "raises": {}
    },
    {
      "module": "tests.faiss_gpu.test_040_cuvs_toggle",
      "path": "/home/paul/kgfoundry/tests/faiss_gpu/test_040_cuvs_toggle.py",
      "is_test": true,
      "imports": [
        "typing.Any",
        "typing.cast",
        "faiss",
        "pytest"
      ],
      "public_api": [
        "test_ivfflat_cuvs_enabled_if_available"
      ],
      "doc": {
        "module_doc": false,
        "class_total": 0,
        "class_with_doc": 0,
        "func_total": 1,
        "func_with_doc": 0
      },
      "typing": {
        "functions": 1,
        "annotated_returns": 0,
        "total_params": 4,
        "annotated_params": 0
      },
      "complexity": {
        "branch_points": 2,
        "max_nesting": 2
      },
      "loc": 33,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "faiss",
          "pytest",
          "typing.Any",
          "typing.cast"
        ],
        "type_checking_imports": [],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "test_ivfflat_cuvs_enabled_if_available",
          "kind": "function",
          "signature": "test_ivfflat_cuvs_enabled_if_available(train_db, query_db, k, gpu_require)",
          "doc_one_liner": "",
          "defined_at": "/home/paul/kgfoundry/tests/faiss_gpu/test_040_cuvs_toggle.py:8"
        }
      ],
      "raises": {}
    },
    {
      "module": "tests.faiss_gpu.test_010_flat_gpu_correctness",
      "path": "/home/paul/kgfoundry/tests/faiss_gpu/test_010_flat_gpu_correctness.py",
      "is_test": true,
      "imports": [
        "typing.Any",
        "typing.cast",
        "faiss",
        "numpy",
        "pytest"
      ],
      "public_api": [
        "test_gpu_flat_matches_cpu"
      ],
      "doc": {
        "module_doc": false,
        "class_total": 0,
        "class_with_doc": 0,
        "func_total": 1,
        "func_with_doc": 0
      },
      "typing": {
        "functions": 1,
        "annotated_returns": 0,
        "total_params": 5,
        "annotated_params": 0
      },
      "complexity": {
        "branch_points": 2,
        "max_nesting": 2
      },
      "loc": 39,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "faiss",
          "np",
          "pytest",
          "typing.Any",
          "typing.cast"
        ],
        "type_checking_imports": [],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "test_gpu_flat_matches_cpu",
          "kind": "function",
          "signature": "test_gpu_flat_matches_cpu(train_db, query_db, k, index_classes, gpu_require)",
          "doc_one_liner": "",
          "defined_at": "/home/paul/kgfoundry/tests/faiss_gpu/test_010_flat_gpu_correctness.py:16"
        }
      ],
      "raises": {}
    },
    {
      "module": "tests.faiss_gpu.test_030_ivf_gpu_correctness",
      "path": "/home/paul/kgfoundry/tests/faiss_gpu/test_030_ivf_gpu_correctness.py",
      "is_test": true,
      "imports": [
        "typing.Any",
        "typing.cast",
        "faiss",
        "pytest"
      ],
      "public_api": [
        "recall_at_k",
        "test_ivfflat_gpu_vs_cpu_recall"
      ],
      "doc": {
        "module_doc": false,
        "class_total": 0,
        "class_with_doc": 0,
        "func_total": 2,
        "func_with_doc": 0
      },
      "typing": {
        "functions": 2,
        "annotated_returns": 0,
        "total_params": 7,
        "annotated_params": 0
      },
      "complexity": {
        "branch_points": 0,
        "max_nesting": 1
      },
      "loc": 40,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "faiss",
          "pytest",
          "typing.Any",
          "typing.cast"
        ],
        "type_checking_imports": [],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "recall_at_k",
          "kind": "function",
          "signature": "recall_at_k(ids_gold, ids_test)",
          "doc_one_liner": "",
          "defined_at": "/home/paul/kgfoundry/tests/faiss_gpu/test_030_ivf_gpu_correctness.py:8"
        },
        {
          "name": "test_ivfflat_gpu_vs_cpu_recall",
          "kind": "function",
          "signature": "test_ivfflat_gpu_vs_cpu_recall(train_db, query_db, k, ivf_params, gpu_require)",
          "doc_one_liner": "",
          "defined_at": "/home/paul/kgfoundry/tests/faiss_gpu/test_030_ivf_gpu_correctness.py:14"
        }
      ],
      "raises": {}
    },
    {
      "module": "tests.faiss_gpu.test_050_multi_gpu_optional",
      "path": "/home/paul/kgfoundry/tests/faiss_gpu/test_050_multi_gpu_optional.py",
      "is_test": true,
      "imports": [
        "typing.Any",
        "typing.cast",
        "faiss",
        "numpy",
        "pytest"
      ],
      "public_api": [
        "test_multi_gpu_all_gpus"
      ],
      "doc": {
        "module_doc": false,
        "class_total": 0,
        "class_with_doc": 0,
        "func_total": 1,
        "func_with_doc": 0
      },
      "typing": {
        "functions": 1,
        "annotated_returns": 0,
        "total_params": 3,
        "annotated_params": 0
      },
      "complexity": {
        "branch_points": 1,
        "max_nesting": 2
      },
      "loc": 25,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "faiss",
          "np",
          "pytest",
          "typing.Any",
          "typing.cast"
        ],
        "type_checking_imports": [],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "test_multi_gpu_all_gpus",
          "kind": "function",
          "signature": "test_multi_gpu_all_gpus(train_db, query_db, k)",
          "doc_one_liner": "",
          "defined_at": "/home/paul/kgfoundry/tests/faiss_gpu/test_050_multi_gpu_optional.py:9"
        }
      ],
      "raises": {}
    },
    {
      "module": "tests.faiss_gpu.test_020_index_transfer",
      "path": "/home/paul/kgfoundry/tests/faiss_gpu/test_020_index_transfer.py",
      "is_test": true,
      "imports": [
        "typing.Any",
        "typing.cast",
        "faiss",
        "numpy"
      ],
      "public_api": [
        "test_cpu_to_gpu_and_back_roundtrip"
      ],
      "doc": {
        "module_doc": false,
        "class_total": 0,
        "class_with_doc": 0,
        "func_total": 1,
        "func_with_doc": 0
      },
      "typing": {
        "functions": 1,
        "annotated_returns": 0,
        "total_params": 4,
        "annotated_params": 0
      },
      "complexity": {
        "branch_points": 0,
        "max_nesting": 1
      },
      "loc": 27,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "faiss",
          "np",
          "typing.Any",
          "typing.cast"
        ],
        "type_checking_imports": [],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "test_cpu_to_gpu_and_back_roundtrip",
          "kind": "function",
          "signature": "test_cpu_to_gpu_and_back_roundtrip(train_db, query_db, k, gpu_require)",
          "doc_one_liner": "",
          "defined_at": "/home/paul/kgfoundry/tests/faiss_gpu/test_020_index_transfer.py:8"
        }
      ],
      "raises": {}
    },
    {
      "module": "tests.faiss_gpu.test_001_import_and_env",
      "path": "/home/paul/kgfoundry/tests/faiss_gpu/test_001_import_and_env.py",
      "is_test": true,
      "imports": [
        "importlib.util",
        "typing.Any",
        "typing.cast",
        "faiss"
      ],
      "public_api": [
        "test_gpu_wrapper_present_and_device_visible",
        "test_standard_gpu_resources_constructs"
      ],
      "doc": {
        "module_doc": false,
        "class_total": 0,
        "class_with_doc": 0,
        "func_total": 2,
        "func_with_doc": 0
      },
      "typing": {
        "functions": 2,
        "annotated_returns": 0,
        "total_params": 1,
        "annotated_params": 0
      },
      "complexity": {
        "branch_points": 1,
        "max_nesting": 2
      },
      "loc": 23,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "faiss",
          "typing.Any",
          "typing.cast",
          "u"
        ],
        "type_checking_imports": [],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "test_gpu_wrapper_present_and_device_visible",
          "kind": "function",
          "signature": "test_gpu_wrapper_present_and_device_visible(gpu_require)",
          "doc_one_liner": "",
          "defined_at": "/home/paul/kgfoundry/tests/faiss_gpu/test_001_import_and_env.py:9"
        },
        {
          "name": "test_standard_gpu_resources_constructs",
          "kind": "function",
          "signature": "test_standard_gpu_resources_constructs()",
          "doc_one_liner": "",
          "defined_at": "/home/paul/kgfoundry/tests/faiss_gpu/test_001_import_and_env.py:19"
        }
      ],
      "raises": {}
    },
    {
      "module": "tests.helpers.typing_facades",
      "path": "/home/paul/kgfoundry/tests/helpers/typing_facades.py",
      "is_test": true,
      "imports": [
        "__future__.annotations",
        "importlib.import_module",
        "typing.TYPE_CHECKING",
        "types.ModuleType"
      ],
      "public_api": [
        "load_facade_module",
        "load_facade_attribute",
        "load_facade_attribute_typed"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 0,
        "class_with_doc": 0,
        "func_total": 3,
        "func_with_doc": 3
      },
      "typing": {
        "functions": 3,
        "annotated_returns": 3,
        "total_params": 6,
        "annotated_params": 6
      },
      "complexity": {
        "branch_points": 2,
        "max_nesting": 2
      },
      "loc": 125,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "importlib.import_module",
          "typing.TYPE_CHECKING"
        ],
        "type_checking_imports": [
          "types.ModuleType"
        ],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "load_facade_module",
          "kind": "function",
          "signature": "load_facade_module(module_name: str) -> ModuleType",
          "doc_one_liner": "Load a fa\u00e7ade module using importlib.",
          "defined_at": "/home/paul/kgfoundry/tests/helpers/typing_facades.py:38"
        },
        {
          "name": "load_facade_attribute",
          "kind": "function",
          "signature": "load_facade_attribute(module_name: str, attribute: str) -> object",
          "doc_one_liner": "Load an attribute from a fa\u00e7ade module.",
          "defined_at": "/home/paul/kgfoundry/tests/helpers/typing_facades.py:63"
        },
        {
          "name": "load_facade_attribute_typed",
          "kind": "function",
          "signature": "load_facade_attribute_typed(module_name: str, attribute: str, expected_type: type[T]) -> T",
          "doc_one_liner": "Load an attribute from a fa\u00e7ade module with runtime type checking.",
          "defined_at": "/home/paul/kgfoundry/tests/helpers/typing_facades.py:88"
        }
      ],
      "raises": {
        "load_facade_attribute_typed": [
          "TypeError"
        ]
      }
    },
    {
      "module": "tests.helpers.immutability",
      "path": "/home/paul/kgfoundry/tests/helpers/immutability.py",
      "is_test": true,
      "imports": [
        "__future__.annotations",
        "dataclasses.FrozenInstanceError",
        "typing.Protocol",
        "pytest"
      ],
      "public_api": [
        "assert_frozen_attribute",
        "assert_frozen_attributes",
        "assert_frozen_mutation"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 1,
        "class_with_doc": 1,
        "func_total": 4,
        "func_with_doc": 4
      },
      "typing": {
        "functions": 4,
        "annotated_returns": 4,
        "total_params": 9,
        "annotated_params": 8
      },
      "complexity": {
        "branch_points": 3,
        "max_nesting": 2
      },
      "loc": 76,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "dataclasses.FrozenInstanceError",
          "pytest",
          "typing.Protocol"
        ],
        "type_checking_imports": [],
        "exports": [
          "assert_frozen_attribute",
          "assert_frozen_attributes",
          "assert_frozen_mutation"
        ],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "assert_frozen_attribute",
          "kind": "function",
          "signature": "assert_frozen_attribute(obj: object, attr: str, value: object) -> None",
          "doc_one_liner": "Assert that assigning ``value`` to ``attr`` raises ``FrozenInstanceError``.",
          "defined_at": "/home/paul/kgfoundry/tests/helpers/immutability.py:34"
        },
        {
          "name": "assert_frozen_attributes",
          "kind": "function",
          "signature": "assert_frozen_attributes(obj: object, **updates: object) -> None",
          "doc_one_liner": "Assert that each attribute in ``updates`` rejects reassignment.",
          "defined_at": "/home/paul/kgfoundry/tests/helpers/immutability.py:40"
        },
        {
          "name": "assert_frozen_mutation",
          "kind": "function",
          "signature": "assert_frozen_mutation(obj: T, mutate: _Mutator[T]) -> None",
          "doc_one_liner": "Assert that executing mutate on obj raises FrozenInstanceError.",
          "defined_at": "/home/paul/kgfoundry/tests/helpers/immutability.py:65"
        }
      ],
      "raises": {}
    },
    {
      "module": "tests.helpers.importing",
      "path": "/home/paul/kgfoundry/tests/helpers/importing.py",
      "is_test": true,
      "imports": [
        "__future__.annotations",
        "importlib.import_module",
        "typing.TYPE_CHECKING",
        "typing.TypeVar",
        "types.ModuleType"
      ],
      "public_api": [
        "load_module",
        "load_attribute",
        "load_typed_attribute"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 0,
        "class_with_doc": 0,
        "func_total": 3,
        "func_with_doc": 3
      },
      "typing": {
        "functions": 3,
        "annotated_returns": 3,
        "total_params": 6,
        "annotated_params": 6
      },
      "complexity": {
        "branch_points": 2,
        "max_nesting": 2
      },
      "loc": 84,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "importlib.import_module",
          "typing.TYPE_CHECKING",
          "typing.TypeVar"
        ],
        "type_checking_imports": [
          "types.ModuleType"
        ],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "load_module",
          "kind": "function",
          "signature": "load_module(module_name: str) -> ModuleType",
          "doc_one_liner": "Import and return the module identified by ``module_name``.",
          "defined_at": "/home/paul/kgfoundry/tests/helpers/importing.py:21"
        },
        {
          "name": "load_attribute",
          "kind": "function",
          "signature": "load_attribute(module_name: str, attribute: str) -> object",
          "doc_one_liner": "Load ``attribute`` from ``module_name`` and return the value.",
          "defined_at": "/home/paul/kgfoundry/tests/helpers/importing.py:37"
        },
        {
          "name": "load_typed_attribute",
          "kind": "function",
          "signature": "load_typed_attribute(module_name: str, attribute: str, expected_type: type[T]) -> T",
          "doc_one_liner": "Load attribute and ensure it matches expected_type at runtime.",
          "defined_at": "/home/paul/kgfoundry/tests/helpers/importing.py:57"
        }
      ],
      "raises": {
        "load_typed_attribute": [
          "TypeError"
        ]
      }
    },
    {
      "module": "tests.codeintel_rev.test_service_context_paths",
      "path": "/home/paul/kgfoundry/tests/codeintel_rev/test_service_context_paths.py",
      "is_test": true,
      "imports": [
        "__future__.annotations",
        "pathlib.Path",
        "typing.Any",
        "typing.cast",
        "pytest",
        "codeintel_rev.app.config_context",
        "codeintel_rev.mcp_server.service_context"
      ],
      "public_api": [
        "RecordingFAISSManager",
        "RecordingDuckDBCatalog",
        "DummyVLLMClient",
        "test_service_context_resolves_paths"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 3,
        "class_with_doc": 3,
        "func_total": 11,
        "func_with_doc": 5
      },
      "typing": {
        "functions": 11,
        "annotated_returns": 11,
        "total_params": 23,
        "annotated_params": 16
      },
      "complexity": {
        "branch_points": 1,
        "max_nesting": 2
      },
      "loc": 137,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "codeintel_rev.app.config_context",
          "codeintel_rev.mcp_server.service_context",
          "pathlib.Path",
          "pytest",
          "typing.Any",
          "typing.cast"
        ],
        "type_checking_imports": [],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "RecordingFAISSManager",
          "kind": "class",
          "signature": "class RecordingFAISSManager",
          "doc_one_liner": "Stub FAISS manager capturing constructor arguments.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_service_context_paths.py:13"
        },
        {
          "name": "RecordingDuckDBCatalog",
          "kind": "class",
          "signature": "class RecordingDuckDBCatalog",
          "doc_one_liner": "Stub DuckDB catalog capturing constructor arguments.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_service_context_paths.py:51"
        },
        {
          "name": "DummyVLLMClient",
          "kind": "class",
          "signature": "class DummyVLLMClient",
          "doc_one_liner": "Minimal vLLM client placeholder used for dependency injection.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_service_context_paths.py:69"
        },
        {
          "name": "test_service_context_resolves_paths",
          "kind": "function",
          "signature": "test_service_context_resolves_paths(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -> None",
          "doc_one_liner": "Relative configuration paths resolve against ``REPO_ROOT``.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_service_context_paths.py:76"
        }
      ],
      "raises": {}
    },
    {
      "module": "tests.codeintel_rev.test_observability_common",
      "path": "/home/paul/kgfoundry/tests/codeintel_rev/test_observability_common.py",
      "is_test": true,
      "imports": [
        "__future__.annotations",
        "typing.NoReturn",
        "typing.cast",
        "pytest",
        "codeintel_rev.mcp_server.common.observability.observe_duration",
        "prometheus_client.CollectorRegistry",
        "kgfoundry_common.observability.MetricsProvider",
        "kgfoundry_common.prometheus.HAVE_PROMETHEUS",
        "kgfoundry_common.prometheus.HistogramLike"
      ],
      "public_api": [
        "test_observe_duration_records_success",
        "test_observe_duration_records_error_on_exception",
        "test_observe_duration_noop_when_histogram_labels_disabled",
        "test_observe_duration_noop_when_base_observer_raises_value_error"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 1,
        "class_with_doc": 0,
        "func_total": 8,
        "func_with_doc": 5
      },
      "typing": {
        "functions": 8,
        "annotated_returns": 8,
        "total_params": 15,
        "annotated_params": 13
      },
      "complexity": {
        "branch_points": 4,
        "max_nesting": 3
      },
      "loc": 188,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "codeintel_rev.mcp_server.common.observability.observe_duration",
          "kgfoundry_common.observability.MetricsProvider",
          "kgfoundry_common.prometheus.HAVE_PROMETHEUS",
          "kgfoundry_common.prometheus.HistogramLike",
          "prometheus_client.CollectorRegistry",
          "pytest",
          "typing.NoReturn",
          "typing.cast"
        ],
        "type_checking_imports": [],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "test_observe_duration_records_success",
          "kind": "function",
          "signature": "test_observe_duration_records_success(prometheus_registry: CollectorRegistry) -> None",
          "doc_one_liner": "Successful observations increment the success counters and histograms.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_observability_common.py:45"
        },
        {
          "name": "test_observe_duration_records_error_on_exception",
          "kind": "function",
          "signature": "test_observe_duration_records_error_on_exception(prometheus_registry: CollectorRegistry) -> None",
          "doc_one_liner": "Exceptions propagate while recording error metrics.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_observability_common.py:71"
        },
        {
          "name": "test_observe_duration_noop_when_histogram_labels_disabled",
          "kind": "function",
          "signature": "test_observe_duration_noop_when_histogram_labels_disabled(prometheus_registry: CollectorRegistry) -> None",
          "doc_one_liner": "Observations fall back to no-op when histograms do not expose labels.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_observability_common.py:116"
        },
        {
          "name": "test_observe_duration_noop_when_base_observer_raises_value_error",
          "kind": "function",
          "signature": "test_observe_duration_noop_when_base_observer_raises_value_error(prometheus_registry: CollectorRegistry, monkeypatch: pytest.MonkeyPatch) -> None",
          "doc_one_liner": "ValueError from base observer triggers noop fallback.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_observability_common.py:155"
        }
      ],
      "raises": {
        "test_observe_duration_records_error_on_exception": [
          "RuntimeError"
        ],
        "test_observe_duration_noop_when_base_observer_raises_value_error": [
          "ValueError"
        ],
        "_raise_value_error": [
          "ValueError"
        ]
      }
    },
    {
      "module": "tests.codeintel_rev.test_error_handling",
      "path": "/home/paul/kgfoundry/tests/codeintel_rev/test_error_handling.py",
      "is_test": true,
      "imports": [
        "__future__.annotations",
        "typing.cast",
        "pytest",
        "codeintel_rev.errors.FileOperationError",
        "codeintel_rev.errors.FileReadError",
        "codeintel_rev.errors.GitOperationError",
        "codeintel_rev.errors.InvalidLineRangeError",
        "codeintel_rev.errors.PathNotDirectoryError",
        "codeintel_rev.errors.PathNotFoundError",
        "codeintel_rev.io.path_utils.PathOutsideRepositoryError",
        "codeintel_rev.mcp_server.error_handling.convert_exception_to_envelope",
        "codeintel_rev.mcp_server.error_handling.format_error_response",
        "codeintel_rev.mcp_server.error_handling.handle_adapter_errors",
        "kgfoundry_common.errors.EmbeddingError",
        "kgfoundry_common.errors.KgFoundryError",
        "kgfoundry_common.errors.VectorSearchError",
        "kgfoundry_common.problem_details.ProblemDetails",
        "asyncio",
        "logging"
      ],
      "public_api": [
        "test_format_error_response_path_outside_repo",
        "test_format_error_response_path_not_directory",
        "test_format_error_response_path_not_found",
        "test_format_error_response_not_implemented",
        "test_format_error_response_unknown_exception",
        "test_kgfoundry_error_conversion",
        "test_file_not_found_error_conversion",
        "test_path_outside_repository_error_conversion",
        "test_unicode_decode_error_conversion",
        "test_value_error_conversion",
        "test_unknown_exception_conversion",
        "test_exception_conversion_preserves_empty_result",
        "test_exception_conversion_with_context",
        "test_decorator_success_case",
        "test_decorator_catches_exception",
        "test_decorator_preserves_function_signature",
        "test_decorator_async_function",
        "test_decorator_async_function_error",
        "test_decorator_multiple_exception_types",
        "test_decorator_with_kgfoundry_error",
        "test_decorator_empty_result_variations",
        "test_kgfoundry_error_logging",
        "test_file_not_found_error_logging",
        "test_unknown_exception_logging"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 0,
        "class_with_doc": 0,
        "func_total": 33,
        "func_with_doc": 25
      },
      "typing": {
        "functions": 33,
        "annotated_returns": 33,
        "total_params": 8,
        "annotated_params": 8
      },
      "complexity": {
        "branch_points": 6,
        "max_nesting": 3
      },
      "loc": 536,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "asyncio",
          "codeintel_rev.errors.FileOperationError",
          "codeintel_rev.errors.FileReadError",
          "codeintel_rev.errors.GitOperationError",
          "codeintel_rev.errors.InvalidLineRangeError",
          "codeintel_rev.errors.PathNotDirectoryError",
          "codeintel_rev.errors.PathNotFoundError",
          "codeintel_rev.io.path_utils.PathOutsideRepositoryError",
          "codeintel_rev.mcp_server.error_handling.convert_exception_to_envelope",
          "codeintel_rev.mcp_server.error_handling.format_error_response",
          "codeintel_rev.mcp_server.error_handling.handle_adapter_errors",
          "kgfoundry_common.errors.EmbeddingError",
          "kgfoundry_common.errors.KgFoundryError",
          "kgfoundry_common.errors.VectorSearchError",
          "kgfoundry_common.problem_details.ProblemDetails",
          "logging",
          "pytest",
          "typing.cast"
        ],
        "type_checking_imports": [],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "test_format_error_response_path_outside_repo",
          "kind": "function",
          "signature": "test_format_error_response_path_outside_repo() -> None",
          "doc_one_liner": "format_error_response maps PathOutsideRepositoryError to 400.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_error_handling.py:31"
        },
        {
          "name": "test_format_error_response_path_not_directory",
          "kind": "function",
          "signature": "test_format_error_response_path_not_directory() -> None",
          "doc_one_liner": "format_error_response maps PathNotDirectoryError to 400.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_error_handling.py:49"
        },
        {
          "name": "test_format_error_response_path_not_found",
          "kind": "function",
          "signature": "test_format_error_response_path_not_found() -> None",
          "doc_one_liner": "format_error_response maps PathNotFoundError to 404.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_error_handling.py:64"
        },
        {
          "name": "test_format_error_response_not_implemented",
          "kind": "function",
          "signature": "test_format_error_response_not_implemented() -> None",
          "doc_one_liner": "format_error_response maps NotImplementedError to 501 Problem Details.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_error_handling.py:76"
        },
        {
          "name": "test_format_error_response_unknown_exception",
          "kind": "function",
          "signature": "test_format_error_response_unknown_exception() -> None",
          "doc_one_liner": "format_error_response falls back to internal-error for unknown exceptions.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_error_handling.py:94"
        },
        {
          "name": "test_kgfoundry_error_conversion",
          "kind": "function",
          "signature": "test_kgfoundry_error_conversion(exception: Exception, expected_status: int, expected_code: str) -> None",
          "doc_one_liner": "Test that KgFoundryError exceptions convert correctly.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_error_handling.py:147"
        },
        {
          "name": "test_file_not_found_error_conversion",
          "kind": "function",
          "signature": "test_file_not_found_error_conversion() -> None",
          "doc_one_liner": "Test FileNotFoundError conversion to 404 error envelope.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_error_handling.py:174"
        },
        {
          "name": "test_path_outside_repository_error_conversion",
          "kind": "function",
          "signature": "test_path_outside_repository_error_conversion() -> None",
          "doc_one_liner": "Test PathOutsideRepositoryError conversion to 403 error envelope.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_error_handling.py:195"
        },
        {
          "name": "test_unicode_decode_error_conversion",
          "kind": "function",
          "signature": "test_unicode_decode_error_conversion() -> None",
          "doc_one_liner": "Test UnicodeDecodeError conversion to 415 error envelope.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_error_handling.py:210"
        },
        {
          "name": "test_value_error_conversion",
          "kind": "function",
          "signature": "test_value_error_conversion() -> None",
          "doc_one_liner": "Test ValueError conversion to 400 error envelope.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_error_handling.py:227"
        },
        {
          "name": "test_unknown_exception_conversion",
          "kind": "function",
          "signature": "test_unknown_exception_conversion() -> None",
          "doc_one_liner": "Test unknown exception conversion to 500 error envelope.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_error_handling.py:242"
        },
        {
          "name": "test_exception_conversion_preserves_empty_result",
          "kind": "function",
          "signature": "test_exception_conversion_preserves_empty_result() -> None",
          "doc_one_liner": "Test that empty_result fields are preserved in error envelope.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_error_handling.py:258"
        },
        {
          "name": "test_exception_conversion_with_context",
          "kind": "function",
          "signature": "test_exception_conversion_with_context() -> None",
          "doc_one_liner": "Test that exception context is included in Problem Details extensions.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_error_handling.py:281"
        },
        {
          "name": "test_decorator_success_case",
          "kind": "function",
          "signature": "test_decorator_success_case() -> None",
          "doc_one_liner": "Test decorator passes through successful results unchanged.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_error_handling.py:302"
        },
        {
          "name": "test_decorator_catches_exception",
          "kind": "function",
          "signature": "test_decorator_catches_exception() -> None",
          "doc_one_liner": "Test decorator catches exceptions and converts to error envelope.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_error_handling.py:318"
        },
        {
          "name": "test_decorator_preserves_function_signature",
          "kind": "function",
          "signature": "test_decorator_preserves_function_signature() -> None",
          "doc_one_liner": "Test decorator preserves function name, docstring, and annotations.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_error_handling.py:335"
        },
        {
          "name": "test_decorator_async_function",
          "kind": "function",
          "signature": "test_decorator_async_function() -> None",
          "doc_one_liner": "Test decorator works with async functions.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_error_handling.py:365"
        },
        {
          "name": "test_decorator_async_function_error",
          "kind": "function",
          "signature": "test_decorator_async_function_error() -> None",
          "doc_one_liner": "Test decorator catches exceptions in async functions.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_error_handling.py:383"
        },
        {
          "name": "test_decorator_multiple_exception_types",
          "kind": "function",
          "signature": "test_decorator_multiple_exception_types() -> None",
          "doc_one_liner": "Test decorator handles multiple exception types correctly.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_error_handling.py:402"
        },
        {
          "name": "test_decorator_with_kgfoundry_error",
          "kind": "function",
          "signature": "test_decorator_with_kgfoundry_error() -> None",
          "doc_one_liner": "Test decorator handles KgFoundryError exceptions.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_error_handling.py:432"
        },
        {
          "name": "test_decorator_empty_result_variations",
          "kind": "function",
          "signature": "test_decorator_empty_result_variations() -> None",
          "doc_one_liner": "Test decorator works with different empty_result structures.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_error_handling.py:450"
        },
        {
          "name": "test_kgfoundry_error_logging",
          "kind": "function",
          "signature": "test_kgfoundry_error_logging(caplog: pytest.LogCaptureFixture) -> None",
          "doc_one_liner": "Test that KgFoundryError exceptions are logged with structured context.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_error_handling.py:483"
        },
        {
          "name": "test_file_not_found_error_logging",
          "kind": "function",
          "signature": "test_file_not_found_error_logging(caplog: pytest.LogCaptureFixture) -> None",
          "doc_one_liner": "Test that FileNotFoundError is logged at WARNING level.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_error_handling.py:503"
        },
        {
          "name": "test_unknown_exception_logging",
          "kind": "function",
          "signature": "test_unknown_exception_logging(caplog: pytest.LogCaptureFixture) -> None",
          "doc_one_liner": "Test that unknown exceptions are logged at EXCEPTION level with stack trace.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_error_handling.py:520"
        }
      ],
      "raises": {
        "test_decorator_catches_exception": [
          "FileNotFoundError"
        ],
        "test_decorator_async_function_error": [
          "ValueError"
        ],
        "test_decorator_multiple_exception_types": [
          "FileNotFoundError",
          "RuntimeError",
          "ValueError"
        ],
        "test_decorator_with_kgfoundry_error": [
          "VectorSearchError"
        ],
        "test_decorator_empty_result_variations": [
          "FileNotFoundError",
          "ValueError"
        ],
        "test_func": [
          "VectorSearchError"
        ],
        "async_test_func": [
          "ValueError"
        ],
        "open_file_func": [
          "FileNotFoundError"
        ],
        "list_paths_func": [
          "ValueError"
        ]
      }
    },
    {
      "module": "tests.codeintel_rev.test_semantic_adapter",
      "path": "/home/paul/kgfoundry/tests/codeintel_rev/test_semantic_adapter.py",
      "is_test": true,
      "imports": [
        "__future__.annotations",
        "types",
        "collections.abc.Iterator",
        "collections.abc.Sequence",
        "contextlib.contextmanager",
        "dataclasses.dataclass",
        "dataclasses.replace",
        "pathlib.Path",
        "types.SimpleNamespace",
        "typing.TYPE_CHECKING",
        "typing.Any",
        "typing.Self",
        "typing.cast",
        "unittest.mock.patch",
        "numpy",
        "pytest",
        "codeintel_rev.mcp_server.adapters.semantic.semantic_search",
        "codeintel_rev.mcp_server.schemas.ScopeIn",
        "kgfoundry_common.errors.EmbeddingError",
        "kgfoundry_common.errors.VectorSearchError",
        "codeintel_rev.app.config_context.ApplicationContext",
        "fnmatch",
        "tempfile"
      ],
      "public_api": [
        "observe_duration_calls",
        "test_semantic_search_observes_duration",
        "StubDuckDBCatalog",
        "StubVLLMClient",
        "StubContextConfig",
        "StubContext",
        "test_semantic_search_gpu_success",
        "test_semantic_search_gpu_fallback",
        "test_semantic_search_limit_truncates_to_max_results",
        "test_semantic_search_limit_enforces_minimum",
        "test_semantic_search_respects_configured_nprobe",
        "test_semantic_search_with_scope_filters",
        "test_semantic_search_no_scope",
        "test_semantic_search_hybrid_merges_channels",
        "test_semantic_search_faiss_not_ready",
        "test_semantic_search_embedding_error",
        "test_semantic_search_faiss_search_error"
      ],
      "doc": {
        "module_doc": false,
        "class_total": 8,
        "class_with_doc": 6,
        "func_total": 36,
        "func_with_doc": 18
      },
      "typing": {
        "functions": 36,
        "annotated_returns": 36,
        "total_params": 54,
        "annotated_params": 34
      },
      "complexity": {
        "branch_points": 29,
        "max_nesting": 4
      },
      "loc": 918,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "codeintel_rev.mcp_server.adapters.semantic.semantic_search",
          "codeintel_rev.mcp_server.schemas.ScopeIn",
          "collections.abc.Iterator",
          "collections.abc.Sequence",
          "contextlib.contextmanager",
          "dataclasses.dataclass",
          "dataclasses.replace",
          "fnmatch",
          "kgfoundry_common.errors.EmbeddingError",
          "kgfoundry_common.errors.VectorSearchError",
          "np",
          "pathlib.Path",
          "pytest",
          "tempfile",
          "types",
          "types.SimpleNamespace",
          "typing.Any",
          "typing.Self",
          "typing.TYPE_CHECKING",
          "typing.cast",
          "unittest.mock.patch"
        ],
        "type_checking_imports": [
          "codeintel_rev.app.config_context.ApplicationContext"
        ],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "observe_duration_calls",
          "kind": "function",
          "signature": "observe_duration_calls() -> list[_ObservationRecord]",
          "doc_one_liner": "Return recorded observation calls from the semantic adapter.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_semantic_adapter.py:74"
        },
        {
          "name": "test_semantic_search_observes_duration",
          "kind": "function",
          "signature": "test_semantic_search_observes_duration(observe_duration_calls: list[_ObservationRecord]) -> None",
          "doc_one_liner": "",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_semantic_adapter.py:86"
        },
        {
          "name": "StubDuckDBCatalog",
          "kind": "class",
          "signature": "class StubDuckDBCatalog",
          "doc_one_liner": "Stub DuckDB catalog for testing.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_semantic_adapter.py:114"
        },
        {
          "name": "StubVLLMClient",
          "kind": "class",
          "signature": "class StubVLLMClient",
          "doc_one_liner": "Stub vLLM client for testing.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_semantic_adapter.py:269"
        },
        {
          "name": "StubContextConfig",
          "kind": "class",
          "signature": "class StubContextConfig",
          "doc_one_liner": "Configuration for StubContext initialization.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_semantic_adapter.py:388"
        },
        {
          "name": "StubContext",
          "kind": "class",
          "signature": "class StubContext",
          "doc_one_liner": "Stub ApplicationContext for semantic adapter tests.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_semantic_adapter.py:404"
        },
        {
          "name": "test_semantic_search_gpu_success",
          "kind": "function",
          "signature": "test_semantic_search_gpu_success() -> None",
          "doc_one_liner": "",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_semantic_adapter.py:487"
        },
        {
          "name": "test_semantic_search_gpu_fallback",
          "kind": "function",
          "signature": "test_semantic_search_gpu_fallback() -> None",
          "doc_one_liner": "",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_semantic_adapter.py:518"
        },
        {
          "name": "test_semantic_search_limit_truncates_to_max_results",
          "kind": "function",
          "signature": "test_semantic_search_limit_truncates_to_max_results() -> None",
          "doc_one_liner": "",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_semantic_adapter.py:550"
        },
        {
          "name": "test_semantic_search_limit_enforces_minimum",
          "kind": "function",
          "signature": "test_semantic_search_limit_enforces_minimum() -> None",
          "doc_one_liner": "",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_semantic_adapter.py:583"
        },
        {
          "name": "test_semantic_search_respects_configured_nprobe",
          "kind": "function",
          "signature": "test_semantic_search_respects_configured_nprobe() -> None",
          "doc_one_liner": "",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_semantic_adapter.py:616"
        },
        {
          "name": "test_semantic_search_with_scope_filters",
          "kind": "function",
          "signature": "test_semantic_search_with_scope_filters() -> None",
          "doc_one_liner": "Test semantic search applies scope filters (language filter).",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_semantic_adapter.py:639"
        },
        {
          "name": "test_semantic_search_no_scope",
          "kind": "function",
          "signature": "test_semantic_search_no_scope() -> None",
          "doc_one_liner": "Test semantic search without scope filters returns all files.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_semantic_adapter.py:709"
        },
        {
          "name": "test_semantic_search_hybrid_merges_channels",
          "kind": "function",
          "signature": "test_semantic_search_hybrid_merges_channels() -> None",
          "doc_one_liner": "",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_semantic_adapter.py:768"
        },
        {
          "name": "test_semantic_search_faiss_not_ready",
          "kind": "function",
          "signature": "test_semantic_search_faiss_not_ready() -> None",
          "doc_one_liner": "Test semantic_search raises VectorSearchError when FAISS is not ready.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_semantic_adapter.py:845"
        },
        {
          "name": "test_semantic_search_embedding_error",
          "kind": "function",
          "signature": "test_semantic_search_embedding_error() -> None",
          "doc_one_liner": "Test semantic_search raises EmbeddingError when embedding fails.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_semantic_adapter.py:867"
        },
        {
          "name": "test_semantic_search_faiss_search_error",
          "kind": "function",
          "signature": "test_semantic_search_faiss_search_error() -> None",
          "doc_one_liner": "Test semantic_search raises VectorSearchError when FAISS search fails.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_semantic_adapter.py:894"
        }
      ],
      "raises": {}
    },
    {
      "module": "tests.codeintel_rev.test_faiss_manager_adaptive",
      "path": "/home/paul/kgfoundry/tests/codeintel_rev/test_faiss_manager_adaptive.py",
      "is_test": true,
      "imports": [
        "__future__.annotations",
        "pathlib.Path",
        "typing.Any",
        "typing.cast",
        "numpy",
        "pytest",
        "codeintel_rev.io.faiss_manager.FAISSManager",
        "tests.conftest.FAISS_MODULE",
        "tests.conftest.HAS_FAISS_SUPPORT"
      ],
      "public_api": [
        "tmp_index_path",
        "test_adaptive_index_selection",
        "test_small_corpus_flat_index",
        "test_small_corpus_search_returns_results",
        "test_medium_corpus_ivf_flat_nlist",
        "test_large_corpus_ivf_pq_nlist",
        "test_memory_estimation_small_corpus",
        "test_memory_estimation_medium_corpus",
        "test_memory_estimation_large_corpus",
        "test_memory_estimation_accuracy"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 0,
        "class_with_doc": 0,
        "func_total": 11,
        "func_with_doc": 11
      },
      "typing": {
        "functions": 11,
        "annotated_returns": 11,
        "total_params": 13,
        "annotated_params": 13
      },
      "complexity": {
        "branch_points": 6,
        "max_nesting": 4
      },
      "loc": 396,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "codeintel_rev.io.faiss_manager.FAISSManager",
          "np",
          "pathlib.Path",
          "pytest",
          "tests.conftest.FAISS_MODULE",
          "tests.conftest.HAS_FAISS_SUPPORT",
          "typing.Any",
          "typing.cast"
        ],
        "type_checking_imports": [],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "tmp_index_path",
          "kind": "function",
          "signature": "tmp_index_path(tmp_path: Path) -> Path",
          "doc_one_liner": "Create a temporary index path for testing.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_faiss_manager_adaptive.py:48"
        },
        {
          "name": "test_adaptive_index_selection",
          "kind": "function",
          "signature": "test_adaptive_index_selection(tmp_index_path: Path, n_vectors: int, expected_type: str) -> None",
          "doc_one_liner": "Test that index type is selected based on corpus size.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_faiss_manager_adaptive.py:74"
        },
        {
          "name": "test_small_corpus_flat_index",
          "kind": "function",
          "signature": "test_small_corpus_flat_index(tmp_index_path: Path) -> None",
          "doc_one_liner": "Test that small corpus (<5K) uses flat index with no training.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_faiss_manager_adaptive.py:161"
        },
        {
          "name": "test_small_corpus_search_returns_results",
          "kind": "function",
          "signature": "test_small_corpus_search_returns_results(tmp_index_path: Path) -> None",
          "doc_one_liner": "Regression: searching flat indexes skips nprobe assignment and succeeds.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_faiss_manager_adaptive.py:191"
        },
        {
          "name": "test_medium_corpus_ivf_flat_nlist",
          "kind": "function",
          "signature": "test_medium_corpus_ivf_flat_nlist(tmp_index_path: Path) -> None",
          "doc_one_liner": "Test that medium corpus (5K-50K) uses IVFFlat with dynamic nlist.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_faiss_manager_adaptive.py:213"
        },
        {
          "name": "test_large_corpus_ivf_pq_nlist",
          "kind": "function",
          "signature": "test_large_corpus_ivf_pq_nlist(tmp_index_path: Path) -> None",
          "doc_one_liner": "Test that large corpus (>50K) uses IVF-PQ with dynamic nlist.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_faiss_manager_adaptive.py:250"
        },
        {
          "name": "test_memory_estimation_small_corpus",
          "kind": "function",
          "signature": "test_memory_estimation_small_corpus(tmp_index_path: Path) -> None",
          "doc_one_liner": "Test memory estimation for small corpus (flat index).",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_faiss_manager_adaptive.py:287"
        },
        {
          "name": "test_memory_estimation_medium_corpus",
          "kind": "function",
          "signature": "test_memory_estimation_medium_corpus(tmp_index_path: Path) -> None",
          "doc_one_liner": "Test memory estimation for medium corpus (IVFFlat).",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_faiss_manager_adaptive.py:308"
        },
        {
          "name": "test_memory_estimation_large_corpus",
          "kind": "function",
          "signature": "test_memory_estimation_large_corpus(tmp_index_path: Path) -> None",
          "doc_one_liner": "Test memory estimation for large corpus (IVF-PQ).",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_faiss_manager_adaptive.py:330"
        },
        {
          "name": "test_memory_estimation_accuracy",
          "kind": "function",
          "signature": "test_memory_estimation_accuracy(tmp_index_path: Path) -> None",
          "doc_one_liner": "Test that memory estimates are reasonable (within 20% of actual).",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_faiss_manager_adaptive.py:354"
        }
      ],
      "raises": {
        "test_adaptive_index_selection": [
          "AssertionError"
        ]
      }
    },
    {
      "module": "tests.codeintel_rev.test_splade_manager",
      "path": "/home/paul/kgfoundry/tests/codeintel_rev/test_splade_manager.py",
      "is_test": true,
      "imports": [
        "__future__.annotations",
        "json",
        "collections.abc.Callable",
        "pathlib.Path",
        "typing.Any",
        "msgspec",
        "pytest",
        "codeintel_rev.config.settings.load_settings",
        "codeintel_rev.io.splade_manager.SpladeArtifactMetadata",
        "codeintel_rev.io.splade_manager.SpladeArtifactsManager",
        "codeintel_rev.io.splade_manager.SpladeBenchmarkOptions",
        "codeintel_rev.io.splade_manager.SpladeBuildOptions",
        "codeintel_rev.io.splade_manager.SpladeEncodeOptions",
        "codeintel_rev.io.splade_manager.SpladeEncoderService",
        "codeintel_rev.io.splade_manager.SpladeEncodingMetadata",
        "codeintel_rev.io.splade_manager.SpladeExportOptions",
        "codeintel_rev.io.splade_manager.SpladeIndexManager",
        "codeintel_rev.io.splade_manager.SpladeIndexMetadata",
        "kgfoundry_common.subprocess_utils.SubprocessError"
      ],
      "public_api": [
        "test_export_onnx_writes_metadata",
        "test_encode_corpus_writes_vectors",
        "test_benchmark_queries_reports_latency",
        "test_build_index_persists_metadata",
        "test_build_index_raises_when_subprocess_fails"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 1,
        "class_with_doc": 1,
        "func_total": 16,
        "func_with_doc": 6
      },
      "typing": {
        "functions": 16,
        "annotated_returns": 16,
        "total_params": 31,
        "annotated_params": 26
      },
      "complexity": {
        "branch_points": 4,
        "max_nesting": 3
      },
      "loc": 318,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "codeintel_rev.config.settings.load_settings",
          "codeintel_rev.io.splade_manager.SpladeArtifactMetadata",
          "codeintel_rev.io.splade_manager.SpladeArtifactsManager",
          "codeintel_rev.io.splade_manager.SpladeBenchmarkOptions",
          "codeintel_rev.io.splade_manager.SpladeBuildOptions",
          "codeintel_rev.io.splade_manager.SpladeEncodeOptions",
          "codeintel_rev.io.splade_manager.SpladeEncoderService",
          "codeintel_rev.io.splade_manager.SpladeEncodingMetadata",
          "codeintel_rev.io.splade_manager.SpladeExportOptions",
          "codeintel_rev.io.splade_manager.SpladeIndexManager",
          "codeintel_rev.io.splade_manager.SpladeIndexMetadata",
          "collections.abc.Callable",
          "json",
          "kgfoundry_common.subprocess_utils.SubprocessError",
          "msgspec",
          "pathlib.Path",
          "pytest",
          "typing.Any"
        ],
        "type_checking_imports": [],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "test_export_onnx_writes_metadata",
          "kind": "function",
          "signature": "test_export_onnx_writes_metadata(monkeypatch: pytest.MonkeyPatch, tmp_path: Path) -> None",
          "doc_one_liner": "Exporting ONNX artifacts should persist metadata and respect configuration overrides.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_splade_manager.py:124"
        },
        {
          "name": "test_encode_corpus_writes_vectors",
          "kind": "function",
          "signature": "test_encode_corpus_writes_vectors(monkeypatch: pytest.MonkeyPatch, tmp_path: Path) -> None",
          "doc_one_liner": "Encoding should emit JsonVectorCollection shards and metadata.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_splade_manager.py:169"
        },
        {
          "name": "test_benchmark_queries_reports_latency",
          "kind": "function",
          "signature": "test_benchmark_queries_reports_latency(monkeypatch: pytest.MonkeyPatch, tmp_path: Path) -> None",
          "doc_one_liner": "Benchmarking should report latency percentiles for SPLADE query encoding.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_splade_manager.py:213"
        },
        {
          "name": "test_build_index_persists_metadata",
          "kind": "function",
          "signature": "test_build_index_persists_metadata(monkeypatch: pytest.MonkeyPatch, tmp_path: Path) -> None",
          "doc_one_liner": "Index builds should invoke Pyserini via subprocess and record metadata.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_splade_manager.py:248"
        },
        {
          "name": "test_build_index_raises_when_subprocess_fails",
          "kind": "function",
          "signature": "test_build_index_raises_when_subprocess_fails(monkeypatch: pytest.MonkeyPatch, tmp_path: Path) -> None",
          "doc_one_liner": "Pyserini failures should surface as SubprocessError.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_splade_manager.py:302"
        }
      ],
      "raises": {
        "test_build_index_raises_when_subprocess_fails": [
          "SubprocessError"
        ],
        "fake_run": [
          "SubprocessError"
        ]
      }
    },
    {
      "module": "tests.codeintel_rev.test_faiss_dual_index",
      "path": "/home/paul/kgfoundry/tests/codeintel_rev/test_faiss_dual_index.py",
      "is_test": true,
      "imports": [
        "__future__.annotations",
        "json",
        "sys",
        "types",
        "pathlib.Path",
        "typing.Any",
        "numpy",
        "pytest",
        "codeintel_rev.config.settings.IndexConfig",
        "codeintel_rev.io.faiss_dual_index.FAISSDualIndexManager",
        "codeintel_rev.io.faiss_dual_index.IndexManifest",
        "tests.conftest.FAISS_MODULE",
        "tests.conftest.HAS_FAISS_SUPPORT"
      ],
      "public_api": [
        "test_ensure_ready_loads_indexes_without_gpu",
        "test_ensure_ready_missing_primary",
        "test_ensure_ready_dimension_mismatch",
        "test_manifest_round_trip",
        "test_manifest_optional_fields",
        "test_manifest_invalid_payload",
        "test_manifest_missing_required_fields",
        "test_gpu_secondary_clone_reuses_cloner_options",
        "test_search_primary_only",
        "test_search_merges_secondary",
        "test_add_incremental_persists_secondary",
        "test_add_incremental_dimension_mismatch",
        "test_needs_compaction_threshold"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 1,
        "class_with_doc": 1,
        "func_total": 17,
        "func_with_doc": 15
      },
      "typing": {
        "functions": 17,
        "annotated_returns": 17,
        "total_params": 21,
        "annotated_params": 20
      },
      "complexity": {
        "branch_points": 4,
        "max_nesting": 3
      },
      "loc": 350,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "codeintel_rev.config.settings.IndexConfig",
          "codeintel_rev.io.faiss_dual_index.FAISSDualIndexManager",
          "codeintel_rev.io.faiss_dual_index.IndexManifest",
          "json",
          "np",
          "pathlib.Path",
          "pytest",
          "sys",
          "tests.conftest.FAISS_MODULE",
          "tests.conftest.HAS_FAISS_SUPPORT",
          "types",
          "typing.Any"
        ],
        "type_checking_imports": [],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "test_ensure_ready_loads_indexes_without_gpu",
          "kind": "function",
          "signature": "test_ensure_ready_loads_indexes_without_gpu(tmp_path: Path) -> None",
          "doc_one_liner": "Primary index loads, secondary auto-creates, and manifest is attached.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_faiss_dual_index.py:73"
        },
        {
          "name": "test_ensure_ready_missing_primary",
          "kind": "function",
          "signature": "test_ensure_ready_missing_primary(tmp_path: Path) -> None",
          "doc_one_liner": "Missing primary index returns explicit failure reason.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_faiss_dual_index.py:97"
        },
        {
          "name": "test_ensure_ready_dimension_mismatch",
          "kind": "function",
          "signature": "test_ensure_ready_dimension_mismatch(tmp_path: Path) -> None",
          "doc_one_liner": "Primary index dimension mismatch fails fast with message.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_faiss_dual_index.py:112"
        },
        {
          "name": "test_manifest_round_trip",
          "kind": "function",
          "signature": "test_manifest_round_trip(tmp_path: Path) -> None",
          "doc_one_liner": "Manifest JSON round-trips and preserves optional fields.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_faiss_dual_index.py:127"
        },
        {
          "name": "test_manifest_optional_fields",
          "kind": "function",
          "signature": "test_manifest_optional_fields(tmp_path: Path) -> None",
          "doc_one_liner": "Optional manifest fields survive serialization.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_faiss_dual_index.py:138"
        },
        {
          "name": "test_manifest_invalid_payload",
          "kind": "function",
          "signature": "test_manifest_invalid_payload(tmp_path: Path) -> None",
          "doc_one_liner": "Non-object JSON payloads raise TypeError.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_faiss_dual_index.py:165"
        },
        {
          "name": "test_manifest_missing_required_fields",
          "kind": "function",
          "signature": "test_manifest_missing_required_fields(tmp_path: Path) -> None",
          "doc_one_liner": "Missing required keys raise ValueError with context.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_faiss_dual_index.py:174"
        },
        {
          "name": "test_gpu_secondary_clone_reuses_cloner_options",
          "kind": "function",
          "signature": "test_gpu_secondary_clone_reuses_cloner_options(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -> None",
          "doc_one_liner": "GPU cloning shares cloner options across primary and secondary indexes.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_faiss_dual_index.py:184"
        },
        {
          "name": "test_search_primary_only",
          "kind": "function",
          "signature": "test_search_primary_only(tmp_path: Path) -> None",
          "doc_one_liner": "Search returns primary results when no secondary index exists.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_faiss_dual_index.py:231"
        },
        {
          "name": "test_search_merges_secondary",
          "kind": "function",
          "signature": "test_search_merges_secondary(tmp_path: Path) -> None",
          "doc_one_liner": "Secondary results are merged and deduplicated.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_faiss_dual_index.py:256"
        },
        {
          "name": "test_add_incremental_persists_secondary",
          "kind": "function",
          "signature": "test_add_incremental_persists_secondary(tmp_path: Path) -> None",
          "doc_one_liner": "Incremental adds populate the secondary index and persist to disk.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_faiss_dual_index.py:284"
        },
        {
          "name": "test_add_incremental_dimension_mismatch",
          "kind": "function",
          "signature": "test_add_incremental_dimension_mismatch(tmp_path: Path) -> None",
          "doc_one_liner": "Dimension mismatches raise ValueError to protect index integrity.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_faiss_dual_index.py:313"
        },
        {
          "name": "test_needs_compaction_threshold",
          "kind": "function",
          "signature": "test_needs_compaction_threshold(tmp_path: Path) -> None",
          "doc_one_liner": "Compaction triggers once the secondary ratio exceeds the threshold.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_faiss_dual_index.py:330"
        }
      ],
      "raises": {}
    },
    {
      "module": "tests.codeintel_rev.test_scope_store",
      "path": "/home/paul/kgfoundry/tests/codeintel_rev/test_scope_store.py",
      "is_test": true,
      "imports": [
        "__future__.annotations",
        "asyncio",
        "time",
        "concurrent.futures.ThreadPoolExecutor",
        "typing.cast",
        "pytest",
        "codeintel_rev.app.scope_store.AsyncSingleFlight",
        "codeintel_rev.app.scope_store.LRUCache",
        "codeintel_rev.app.scope_store.ScopeStore",
        "codeintel_rev.mcp_server.schemas.ScopeIn"
      ],
      "public_api": [
        "FakeClock",
        "test_lru_cache_evicts_least_recently_used",
        "test_lru_cache_ttl_expires_entries_on_access",
        "test_lru_cache_is_thread_safe",
        "FakeRedis",
        "test_scope_store_prefers_l1_cache",
        "test_scope_store_l2_fetch_coalesces_requests",
        "test_scope_store_delete_clears_l1_and_l2",
        "test_scope_store_without_l2_ttl_uses_set",
        "test_async_single_flight_coalesces_calls",
        "test_async_single_flight_propagates_exceptions_and_allows_retry"
      ],
      "doc": {
        "module_doc": false,
        "class_total": 2,
        "class_with_doc": 2,
        "func_total": 24,
        "func_with_doc": 0
      },
      "typing": {
        "functions": 24,
        "annotated_returns": 24,
        "total_params": 20,
        "annotated_params": 10
      },
      "complexity": {
        "branch_points": 7,
        "max_nesting": 4
      },
      "loc": 238,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "asyncio",
          "codeintel_rev.app.scope_store.AsyncSingleFlight",
          "codeintel_rev.app.scope_store.LRUCache",
          "codeintel_rev.app.scope_store.ScopeStore",
          "codeintel_rev.mcp_server.schemas.ScopeIn",
          "concurrent.futures.ThreadPoolExecutor",
          "pytest",
          "time_module",
          "typing.cast"
        ],
        "type_checking_imports": [],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "FakeClock",
          "kind": "class",
          "signature": "class FakeClock",
          "doc_one_liner": "Simple monotonic clock for deterministic TTL testing.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_scope_store.py:13"
        },
        {
          "name": "test_lru_cache_evicts_least_recently_used",
          "kind": "function",
          "signature": "test_lru_cache_evicts_least_recently_used() -> None",
          "doc_one_liner": "",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_scope_store.py:26"
        },
        {
          "name": "test_lru_cache_ttl_expires_entries_on_access",
          "kind": "function",
          "signature": "test_lru_cache_ttl_expires_entries_on_access() -> None",
          "doc_one_liner": "",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_scope_store.py:43"
        },
        {
          "name": "test_lru_cache_is_thread_safe",
          "kind": "function",
          "signature": "test_lru_cache_is_thread_safe() -> None",
          "doc_one_liner": "",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_scope_store.py:59"
        },
        {
          "name": "FakeRedis",
          "kind": "class",
          "signature": "class FakeRedis",
          "doc_one_liner": "Minimal in-memory Redis analogue for testing.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_scope_store.py:74"
        },
        {
          "name": "test_scope_store_prefers_l1_cache",
          "kind": "function",
          "signature": "test_scope_store_prefers_l1_cache() -> None",
          "doc_one_liner": "",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_scope_store.py:133"
        },
        {
          "name": "test_scope_store_l2_fetch_coalesces_requests",
          "kind": "function",
          "signature": "test_scope_store_l2_fetch_coalesces_requests() -> None",
          "doc_one_liner": "",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_scope_store.py:151"
        },
        {
          "name": "test_scope_store_delete_clears_l1_and_l2",
          "kind": "function",
          "signature": "test_scope_store_delete_clears_l1_and_l2() -> None",
          "doc_one_liner": "",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_scope_store.py:171"
        },
        {
          "name": "test_scope_store_without_l2_ttl_uses_set",
          "kind": "function",
          "signature": "test_scope_store_without_l2_ttl_uses_set() -> None",
          "doc_one_liner": "",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_scope_store.py:187"
        },
        {
          "name": "test_async_single_flight_coalesces_calls",
          "kind": "function",
          "signature": "test_async_single_flight_coalesces_calls() -> None",
          "doc_one_liner": "",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_scope_store.py:200"
        },
        {
          "name": "test_async_single_flight_propagates_exceptions_and_allows_retry",
          "kind": "function",
          "signature": "test_async_single_flight_propagates_exceptions_and_allows_retry() -> None",
          "doc_one_liner": "",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_scope_store.py:217"
        }
      ],
      "raises": {
        "test_async_single_flight_propagates_exceptions_and_allows_retry": [
          "RuntimeError"
        ],
        "failing_call": [
          "RuntimeError"
        ]
      }
    },
    {
      "module": "tests.codeintel_rev.test_faiss_manager",
      "path": "/home/paul/kgfoundry/tests/codeintel_rev/test_faiss_manager.py",
      "is_test": true,
      "imports": [
        "__future__.annotations",
        "pathlib.Path",
        "typing.Any",
        "pytest",
        "codeintel_rev.io.faiss_manager.FAISSManager",
        "tests.conftest.FAISS_MODULE",
        "tests.conftest.HAS_FAISS_SUPPORT"
      ],
      "public_api": [
        "faiss_manager",
        "test_clone_to_gpu_success",
        "test_clone_to_gpu_falls_back"
      ],
      "doc": {
        "module_doc": false,
        "class_total": 2,
        "class_with_doc": 0,
        "func_total": 6,
        "func_with_doc": 2
      },
      "typing": {
        "functions": 6,
        "annotated_returns": 6,
        "total_params": 11,
        "annotated_params": 10
      },
      "complexity": {
        "branch_points": 2,
        "max_nesting": 3
      },
      "loc": 84,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "codeintel_rev.io.faiss_manager.FAISSManager",
          "pathlib.Path",
          "pytest",
          "tests.conftest.FAISS_MODULE",
          "tests.conftest.HAS_FAISS_SUPPORT",
          "typing.Any"
        ],
        "type_checking_imports": [],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "faiss_manager",
          "kind": "function",
          "signature": "faiss_manager(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -> FAISSManager",
          "doc_one_liner": "",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_faiss_manager.py:27"
        },
        {
          "name": "test_clone_to_gpu_success",
          "kind": "function",
          "signature": "test_clone_to_gpu_success(monkeypatch: pytest.MonkeyPatch, faiss_manager: FAISSManager) -> None",
          "doc_one_liner": "GPU cloning succeeds when FAISS GPU helpers work.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_faiss_manager.py:41"
        },
        {
          "name": "test_clone_to_gpu_falls_back",
          "kind": "function",
          "signature": "test_clone_to_gpu_falls_back(monkeypatch: pytest.MonkeyPatch, faiss_manager: FAISSManager) -> None",
          "doc_one_liner": "GPU cloning failure is logged and returns False without raising.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_faiss_manager.py:67"
        }
      ],
      "raises": {
        "test_clone_to_gpu_falls_back": [
          "RuntimeError"
        ],
        "failing_resources": [
          "RuntimeError"
        ]
      }
    },
    {
      "module": "tests.codeintel_rev.test_faiss_incremental",
      "path": "/home/paul/kgfoundry/tests/codeintel_rev/test_faiss_incremental.py",
      "is_test": true,
      "imports": [
        "__future__.annotations",
        "pathlib.Path",
        "typing.Any",
        "numpy",
        "pytest",
        "codeintel_rev.io.faiss_manager.FAISSManager",
        "tests.conftest.FAISS_MODULE",
        "tests.conftest.HAS_FAISS_SUPPORT"
      ],
      "public_api": [
        "tmp_index_path",
        "test_update_index_creates_secondary",
        "test_update_index_skips_duplicates",
        "test_update_index_skips_primary_duplicates",
        "test_dual_index_search",
        "test_merged_search_results_are_unique",
        "test_merge_indexes_combines_vectors",
        "test_merge_indexes_no_secondary",
        "test_incremental_workflow_end_to_end",
        "test_save_load_secondary_index"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 0,
        "class_with_doc": 0,
        "func_total": 17,
        "func_with_doc": 17
      },
      "typing": {
        "functions": 17,
        "annotated_returns": 17,
        "total_params": 31,
        "annotated_params": 31
      },
      "complexity": {
        "branch_points": 2,
        "max_nesting": 1
      },
      "loc": 541,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "codeintel_rev.io.faiss_manager.FAISSManager",
          "np",
          "pathlib.Path",
          "pytest",
          "tests.conftest.FAISS_MODULE",
          "tests.conftest.HAS_FAISS_SUPPORT",
          "typing.Any"
        ],
        "type_checking_imports": [],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "tmp_index_path",
          "kind": "function",
          "signature": "tmp_index_path(tmp_path: Path) -> Path",
          "doc_one_liner": "Create a temporary index path for testing.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_faiss_incremental.py:37"
        },
        {
          "name": "test_update_index_creates_secondary",
          "kind": "function",
          "signature": "test_update_index_creates_secondary(tmp_index_path: Path) -> None",
          "doc_one_liner": "Test that update_index creates secondary index on first call.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_faiss_incremental.py:53"
        },
        {
          "name": "test_update_index_skips_duplicates",
          "kind": "function",
          "signature": "test_update_index_skips_duplicates(tmp_index_path: Path) -> None",
          "doc_one_liner": "Test that update_index skips duplicate IDs.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_faiss_incremental.py:82"
        },
        {
          "name": "test_update_index_skips_primary_duplicates",
          "kind": "function",
          "signature": "test_update_index_skips_primary_duplicates(tmp_index_path: Path) -> None",
          "doc_one_liner": "IDs already present in the primary index are ignored during updates.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_faiss_incremental.py:113"
        },
        {
          "name": "test_dual_index_search",
          "kind": "function",
          "signature": "test_dual_index_search(tmp_index_path: Path) -> None",
          "doc_one_liner": "Test that search returns results from both primary and secondary indexes.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_faiss_incremental.py:135"
        },
        {
          "name": "test_merged_search_results_are_unique",
          "kind": "function",
          "signature": "test_merged_search_results_are_unique(tmp_index_path: Path) -> None",
          "doc_one_liner": "Merged dual-index search results deduplicate overlapping chunk IDs.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_faiss_incremental.py:346"
        },
        {
          "name": "test_merge_indexes_combines_vectors",
          "kind": "function",
          "signature": "test_merge_indexes_combines_vectors(tmp_index_path: Path) -> None",
          "doc_one_liner": "Test that merge_indexes combines secondary into primary and clears secondary.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_faiss_incremental.py:376"
        },
        {
          "name": "test_merge_indexes_no_secondary",
          "kind": "function",
          "signature": "test_merge_indexes_no_secondary(tmp_index_path: Path) -> None",
          "doc_one_liner": "Test that merge_indexes handles case where no secondary index exists.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_faiss_incremental.py:417"
        },
        {
          "name": "test_incremental_workflow_end_to_end",
          "kind": "function",
          "signature": "test_incremental_workflow_end_to_end(tmp_index_path: Path, primary_size: int, secondary_size: int) -> None",
          "doc_one_liner": "Test complete incremental workflow: initial \u2192 incremental \u2192 merge \u2192 search.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_faiss_incremental.py:451"
        },
        {
          "name": "test_save_load_secondary_index",
          "kind": "function",
          "signature": "test_save_load_secondary_index(tmp_index_path: Path) -> None",
          "doc_one_liner": "Test that secondary index can be saved and loaded.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_faiss_incremental.py:504"
        }
      ],
      "raises": {}
    },
    {
      "module": "tests.codeintel_rev.test_scope_integration",
      "path": "/home/paul/kgfoundry/tests/codeintel_rev/test_scope_integration.py",
      "is_test": true,
      "imports": [
        "__future__.annotations",
        "pathlib.Path",
        "typing.cast",
        "unittest.mock.AsyncMock",
        "unittest.mock.MagicMock",
        "pytest",
        "codeintel_rev.app.config_context.ApplicationContext",
        "codeintel_rev.app.config_context.ResolvedPaths",
        "codeintel_rev.app.middleware.session_id_var",
        "codeintel_rev.app.scope_store.ScopeStore",
        "codeintel_rev.config.settings.BM25Config",
        "codeintel_rev.config.settings.CodeRankConfig",
        "codeintel_rev.config.settings.CodeRankLLMConfig",
        "codeintel_rev.config.settings.IndexConfig",
        "codeintel_rev.config.settings.PathsConfig",
        "codeintel_rev.config.settings.RedisConfig",
        "codeintel_rev.config.settings.ServerLimits",
        "codeintel_rev.config.settings.Settings",
        "codeintel_rev.config.settings.SpladeConfig",
        "codeintel_rev.config.settings.VLLMConfig",
        "codeintel_rev.config.settings.WarpConfig",
        "codeintel_rev.config.settings.XTRConfig",
        "codeintel_rev.io.duckdb_manager.DuckDBConfig",
        "codeintel_rev.io.duckdb_manager.DuckDBManager",
        "codeintel_rev.io.faiss_manager.FAISSManager",
        "codeintel_rev.io.git_client.AsyncGitClient",
        "codeintel_rev.io.git_client.GitClient",
        "codeintel_rev.io.vllm_client.VLLMClient",
        "codeintel_rev.mcp_server.adapters.files",
        "codeintel_rev.mcp_server.schemas.ScopeIn",
        "codeintel_rev.mcp_server.scope_utils.merge_scope_filters"
      ],
      "public_api": [
        "test_set_scope_persists_in_store",
        "test_list_paths_honours_scope_filters",
        "test_merge_scope_filters_precedence"
      ],
      "doc": {
        "module_doc": false,
        "class_total": 1,
        "class_with_doc": 1,
        "func_total": 11,
        "func_with_doc": 0
      },
      "typing": {
        "functions": 11,
        "annotated_returns": 11,
        "total_params": 19,
        "annotated_params": 13
      },
      "complexity": {
        "branch_points": 2,
        "max_nesting": 4
      },
      "loc": 198,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "codeintel_rev.app.config_context.ApplicationContext",
          "codeintel_rev.app.config_context.ResolvedPaths",
          "codeintel_rev.app.middleware.session_id_var",
          "codeintel_rev.app.scope_store.ScopeStore",
          "codeintel_rev.config.settings.BM25Config",
          "codeintel_rev.config.settings.CodeRankConfig",
          "codeintel_rev.config.settings.CodeRankLLMConfig",
          "codeintel_rev.config.settings.IndexConfig",
          "codeintel_rev.config.settings.PathsConfig",
          "codeintel_rev.config.settings.RedisConfig",
          "codeintel_rev.config.settings.ServerLimits",
          "codeintel_rev.config.settings.Settings",
          "codeintel_rev.config.settings.SpladeConfig",
          "codeintel_rev.config.settings.VLLMConfig",
          "codeintel_rev.config.settings.WarpConfig",
          "codeintel_rev.config.settings.XTRConfig",
          "codeintel_rev.io.duckdb_manager.DuckDBConfig",
          "codeintel_rev.io.duckdb_manager.DuckDBManager",
          "codeintel_rev.io.faiss_manager.FAISSManager",
          "codeintel_rev.io.git_client.AsyncGitClient",
          "codeintel_rev.io.git_client.GitClient",
          "codeintel_rev.io.vllm_client.VLLMClient",
          "codeintel_rev.mcp_server.adapters.files",
          "codeintel_rev.mcp_server.schemas.ScopeIn",
          "codeintel_rev.mcp_server.scope_utils.merge_scope_filters",
          "pathlib.Path",
          "pytest",
          "typing.cast",
          "unittest.mock.AsyncMock",
          "unittest.mock.MagicMock"
        ],
        "type_checking_imports": [],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "test_set_scope_persists_in_store",
          "kind": "function",
          "signature": "test_set_scope_persists_in_store(tmp_path: Path, mock_session_id: str) -> None",
          "doc_one_liner": "",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_scope_integration.py:157"
        },
        {
          "name": "test_list_paths_honours_scope_filters",
          "kind": "function",
          "signature": "test_list_paths_honours_scope_filters(tmp_path: Path, mock_session_id: str) -> None",
          "doc_one_liner": "",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_scope_integration.py:170"
        },
        {
          "name": "test_merge_scope_filters_precedence",
          "kind": "function",
          "signature": "test_merge_scope_filters_precedence() -> None",
          "doc_one_liner": "",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_scope_integration.py:186"
        }
      ],
      "raises": {}
    },
    {
      "module": "tests.codeintel_rev.test_scope_utils",
      "path": "/home/paul/kgfoundry/tests/codeintel_rev/test_scope_utils.py",
      "is_test": true,
      "imports": [
        "__future__.annotations",
        "typing.cast",
        "pytest",
        "codeintel_rev.app.config_context.ApplicationContext",
        "codeintel_rev.mcp_server.schemas.ScopeIn",
        "codeintel_rev.mcp_server.scope_utils.apply_language_filter",
        "codeintel_rev.mcp_server.scope_utils.apply_path_filters",
        "codeintel_rev.mcp_server.scope_utils.get_effective_scope",
        "codeintel_rev.mcp_server.scope_utils.merge_scope_filters",
        "codeintel_rev.mcp_server.scope_utils.path_matches_glob"
      ],
      "public_api": [
        "TestGetEffectiveScope",
        "TestMergeScopeFilters",
        "TestApplyPathFilters",
        "TestApplyLanguageFilter",
        "TestPathMatchesGlob"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 5,
        "class_with_doc": 5,
        "func_total": 26,
        "func_with_doc": 26
      },
      "typing": {
        "functions": 26,
        "annotated_returns": 26,
        "total_params": 39,
        "annotated_params": 13
      },
      "complexity": {
        "branch_points": 0,
        "max_nesting": 2
      },
      "loc": 387,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "codeintel_rev.app.config_context.ApplicationContext",
          "codeintel_rev.mcp_server.schemas.ScopeIn",
          "codeintel_rev.mcp_server.scope_utils.apply_language_filter",
          "codeintel_rev.mcp_server.scope_utils.apply_path_filters",
          "codeintel_rev.mcp_server.scope_utils.get_effective_scope",
          "codeintel_rev.mcp_server.scope_utils.merge_scope_filters",
          "codeintel_rev.mcp_server.scope_utils.path_matches_glob",
          "pytest",
          "typing.cast"
        ],
        "type_checking_imports": [],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "TestGetEffectiveScope",
          "kind": "class",
          "signature": "class TestGetEffectiveScope",
          "doc_one_liner": "Tests for get_effective_scope function.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_scope_utils.py:23"
        },
        {
          "name": "TestMergeScopeFilters",
          "kind": "class",
          "signature": "class TestMergeScopeFilters",
          "doc_one_liner": "Tests for merge_scope_filters function.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_scope_utils.py:66"
        },
        {
          "name": "TestApplyPathFilters",
          "kind": "class",
          "signature": "class TestApplyPathFilters",
          "doc_one_liner": "Tests for apply_path_filters function.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_scope_utils.py:133"
        },
        {
          "name": "TestApplyLanguageFilter",
          "kind": "class",
          "signature": "class TestApplyLanguageFilter",
          "doc_one_liner": "Tests for apply_language_filter function.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_scope_utils.py:245"
        },
        {
          "name": "TestPathMatchesGlob",
          "kind": "class",
          "signature": "class TestPathMatchesGlob",
          "doc_one_liner": "Tests for path_matches_glob function.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/test_scope_utils.py:336"
        }
      ],
      "raises": {}
    },
    {
      "module": "tests.vector_ingestion.test_vector_cli",
      "path": "/home/paul/kgfoundry/tests/vector_ingestion/test_vector_cli.py",
      "is_test": true,
      "imports": [
        "__future__.annotations",
        "json",
        "logging",
        "typing.TYPE_CHECKING",
        "typing.cast",
        "typer.testing.CliRunner",
        "orchestration.cli.app",
        "collections.abc.Callable",
        "pathlib.Path",
        "uuid.UUID",
        "pytest",
        "_pytest.logging.LogCaptureFixture"
      ],
      "public_api": [
        "test_index_faiss_cli_success",
        "test_index_faiss_cli_problem_details"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 0,
        "class_with_doc": 0,
        "func_total": 4,
        "func_with_doc": 4
      },
      "typing": {
        "functions": 4,
        "annotated_returns": 4,
        "total_params": 11,
        "annotated_params": 11
      },
      "complexity": {
        "branch_points": 10,
        "max_nesting": 3
      },
      "loc": 165,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "json",
          "logging",
          "orchestration.cli.app",
          "typer.testing.CliRunner",
          "typing.TYPE_CHECKING",
          "typing.cast"
        ],
        "type_checking_imports": [
          "_pytest.logging.LogCaptureFixture",
          "collections.abc.Callable",
          "pathlib.Path",
          "pytest",
          "uuid.UUID"
        ],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "test_index_faiss_cli_success",
          "kind": "function",
          "signature": "test_index_faiss_cli_success(tmp_path: Path, canonical_vector_payload: list[dict[str, object]], caplog: LogCaptureFixture) -> None",
          "doc_one_liner": "Running the CLI with valid payloads should succeed and emit metrics.",
          "defined_at": "/home/paul/kgfoundry/tests/vector_ingestion/test_vector_cli.py:86"
        },
        {
          "name": "test_index_faiss_cli_problem_details",
          "kind": "function",
          "signature": "test_index_faiss_cli_problem_details(tmp_path: Path, deterministic_uuid_factory: Callable[[], UUID], caplog: LogCaptureFixture, monkeypatch: pytest.MonkeyPatch) -> None",
          "doc_one_liner": "Invalid payloads should return RFC 9457 Problem Details envelopes.",
          "defined_at": "/home/paul/kgfoundry/tests/vector_ingestion/test_vector_cli.py:125"
        }
      ],
      "raises": {
        "_parse_problem": [
          "AssertionError"
        ]
      }
    },
    {
      "module": "tests.vector_ingestion.test_vector_schema",
      "path": "/home/paul/kgfoundry/tests/vector_ingestion/test_vector_schema.py",
      "is_test": true,
      "imports": [
        "__future__.annotations",
        "typing.TYPE_CHECKING",
        "pytest",
        "kgfoundry_common.jsonschema_utils.ValidationError",
        "kgfoundry_common.jsonschema_utils.Draft202012ValidatorProtocol"
      ],
      "public_api": [
        "test_vector_schema_accepts_canonical_payload",
        "test_vector_schema_rejects_missing_key",
        "test_vector_schema_rejects_empty_vector",
        "test_vector_schema_rejects_non_numeric_entries",
        "test_vector_schema_rejects_additional_properties"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 0,
        "class_with_doc": 0,
        "func_total": 5,
        "func_with_doc": 5
      },
      "typing": {
        "functions": 5,
        "annotated_returns": 5,
        "total_params": 6,
        "annotated_params": 6
      },
      "complexity": {
        "branch_points": 5,
        "max_nesting": 2
      },
      "loc": 64,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "kgfoundry_common.jsonschema_utils.ValidationError",
          "pytest",
          "typing.TYPE_CHECKING"
        ],
        "type_checking_imports": [
          "kgfoundry_common.jsonschema_utils.Draft202012ValidatorProtocol"
        ],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "test_vector_schema_accepts_canonical_payload",
          "kind": "function",
          "signature": "test_vector_schema_accepts_canonical_payload(vector_validator: Draft202012ValidatorProtocol, canonical_vector_payload: list[dict[str, object]]) -> None",
          "doc_one_liner": "Canonical payloads should pass JSON Schema validation.",
          "defined_at": "/home/paul/kgfoundry/tests/vector_ingestion/test_vector_schema.py:19"
        },
        {
          "name": "test_vector_schema_rejects_missing_key",
          "kind": "function",
          "signature": "test_vector_schema_rejects_missing_key(vector_validator: Draft202012ValidatorProtocol) -> None",
          "doc_one_liner": "Missing `key` entries must produce a validation error.",
          "defined_at": "/home/paul/kgfoundry/tests/vector_ingestion/test_vector_schema.py:27"
        },
        {
          "name": "test_vector_schema_rejects_empty_vector",
          "kind": "function",
          "signature": "test_vector_schema_rejects_empty_vector(vector_validator: Draft202012ValidatorProtocol) -> None",
          "doc_one_liner": "Vectors must contain at least one element.",
          "defined_at": "/home/paul/kgfoundry/tests/vector_ingestion/test_vector_schema.py:37"
        },
        {
          "name": "test_vector_schema_rejects_non_numeric_entries",
          "kind": "function",
          "signature": "test_vector_schema_rejects_non_numeric_entries(vector_validator: Draft202012ValidatorProtocol) -> None",
          "doc_one_liner": "Vector elements must be numeric values.",
          "defined_at": "/home/paul/kgfoundry/tests/vector_ingestion/test_vector_schema.py:47"
        },
        {
          "name": "test_vector_schema_rejects_additional_properties",
          "kind": "function",
          "signature": "test_vector_schema_rejects_additional_properties(vector_validator: Draft202012ValidatorProtocol) -> None",
          "doc_one_liner": "Additional properties should be disallowed to keep payloads strict.",
          "defined_at": "/home/paul/kgfoundry/tests/vector_ingestion/test_vector_schema.py:57"
        }
      ],
      "raises": {}
    },
    {
      "module": "tests.vector_ingestion.test_vector_types",
      "path": "/home/paul/kgfoundry/tests/vector_ingestion/test_vector_types.py",
      "is_test": true,
      "imports": [
        "__future__.annotations",
        "typing.TYPE_CHECKING",
        "typing.cast",
        "numpy",
        "pytest",
        "kgfoundry_common.vector_types.VectorBatch",
        "kgfoundry_common.vector_types.VectorId",
        "kgfoundry_common.vector_types.VectorValidationError",
        "kgfoundry_common.vector_types.assert_vector_matrix",
        "kgfoundry_common.vector_types.coerce_vector_batch",
        "kgfoundry_common.vector_types.validate_vector_batch",
        "collections.abc.Iterable",
        "collections.abc.Mapping",
        "collections.abc.Sequence",
        "kgfoundry_common.vector_types.VectorMatrix"
      ],
      "public_api": [
        "test_coerce_vector_batch_produces_float32_matrix",
        "test_coerce_vector_batch_rejects_inconsistent_dimensions",
        "test_coerce_vector_batch_rejects_non_numeric",
        "test_coerce_vector_batch_requires_mapping",
        "test_coerce_vector_batch_rejects_empty_or_duplicate_keys",
        "test_assert_vector_matrix_accepts_float_lists",
        "test_assert_vector_matrix_invalid_inputs",
        "test_validate_vector_batch_returns_same_instance",
        "test_validate_vector_batch_detects_mismatched_ids",
        "test_vector_batch_dimension_and_count_properties"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 0,
        "class_with_doc": 0,
        "func_total": 10,
        "func_with_doc": 10
      },
      "typing": {
        "functions": 10,
        "annotated_returns": 10,
        "total_params": 6,
        "annotated_params": 6
      },
      "complexity": {
        "branch_points": 10,
        "max_nesting": 3
      },
      "loc": 137,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "kgfoundry_common.vector_types.VectorBatch",
          "kgfoundry_common.vector_types.VectorId",
          "kgfoundry_common.vector_types.VectorValidationError",
          "kgfoundry_common.vector_types.assert_vector_matrix",
          "kgfoundry_common.vector_types.coerce_vector_batch",
          "kgfoundry_common.vector_types.validate_vector_batch",
          "np",
          "pytest",
          "typing.TYPE_CHECKING",
          "typing.cast"
        ],
        "type_checking_imports": [
          "collections.abc.Iterable",
          "collections.abc.Mapping",
          "collections.abc.Sequence",
          "kgfoundry_common.vector_types.VectorMatrix"
        ],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "test_coerce_vector_batch_produces_float32_matrix",
          "kind": "function",
          "signature": "test_coerce_vector_batch_produces_float32_matrix(canonical_vector_payload: list[dict[str, object]]) -> None",
          "doc_one_liner": "`coerce_vector_batch` converts payloads into contiguous float32 batches.",
          "defined_at": "/home/paul/kgfoundry/tests/vector_ingestion/test_vector_types.py:32"
        },
        {
          "name": "test_coerce_vector_batch_rejects_inconsistent_dimensions",
          "kind": "function",
          "signature": "test_coerce_vector_batch_rejects_inconsistent_dimensions(inconsistent_dimension_payload: list[dict[str, object]]) -> None",
          "doc_one_liner": "Ragged vectors should trigger a `VectorValidationError`.",
          "defined_at": "/home/paul/kgfoundry/tests/vector_ingestion/test_vector_types.py:45"
        },
        {
          "name": "test_coerce_vector_batch_rejects_non_numeric",
          "kind": "function",
          "signature": "test_coerce_vector_batch_rejects_non_numeric(non_numeric_payload: list[dict[str, object]]) -> None",
          "doc_one_liner": "Non-numeric vector entries bubble up as validation errors.",
          "defined_at": "/home/paul/kgfoundry/tests/vector_ingestion/test_vector_types.py:53"
        },
        {
          "name": "test_coerce_vector_batch_requires_mapping",
          "kind": "function",
          "signature": "test_coerce_vector_batch_requires_mapping() -> None",
          "doc_one_liner": "Vector records must be mapping objects with `key`/`vector` entries.",
          "defined_at": "/home/paul/kgfoundry/tests/vector_ingestion/test_vector_types.py:61"
        },
        {
          "name": "test_coerce_vector_batch_rejects_empty_or_duplicate_keys",
          "kind": "function",
          "signature": "test_coerce_vector_batch_rejects_empty_or_duplicate_keys() -> None",
          "doc_one_liner": "Empty datasets or duplicate ids should fail validation.",
          "defined_at": "/home/paul/kgfoundry/tests/vector_ingestion/test_vector_types.py:69"
        },
        {
          "name": "test_assert_vector_matrix_accepts_float_lists",
          "kind": "function",
          "signature": "test_assert_vector_matrix_accepts_float_lists() -> None",
          "doc_one_liner": "`assert_vector_matrix` coerces nested sequences into contiguous float32 matrices.",
          "defined_at": "/home/paul/kgfoundry/tests/vector_ingestion/test_vector_types.py:85"
        },
        {
          "name": "test_assert_vector_matrix_invalid_inputs",
          "kind": "function",
          "signature": "test_assert_vector_matrix_invalid_inputs() -> None",
          "doc_one_liner": "Invalid matrices raise `VectorValidationError` with descriptive messages.",
          "defined_at": "/home/paul/kgfoundry/tests/vector_ingestion/test_vector_types.py:94"
        },
        {
          "name": "test_validate_vector_batch_returns_same_instance",
          "kind": "function",
          "signature": "test_validate_vector_batch_returns_same_instance(canonical_vector_payload: list[dict[str, object]]) -> None",
          "doc_one_liner": "`validate_vector_batch` should not copy when invariants hold.",
          "defined_at": "/home/paul/kgfoundry/tests/vector_ingestion/test_vector_types.py:103"
        },
        {
          "name": "test_validate_vector_batch_detects_mismatched_ids",
          "kind": "function",
          "signature": "test_validate_vector_batch_detects_mismatched_ids(canonical_vector_matrix: VectorMatrix) -> None",
          "doc_one_liner": "Row count mismatches raise `VectorValidationError`.",
          "defined_at": "/home/paul/kgfoundry/tests/vector_ingestion/test_vector_types.py:113"
        },
        {
          "name": "test_vector_batch_dimension_and_count_properties",
          "kind": "function",
          "signature": "test_vector_batch_dimension_and_count_properties(canonical_vector_payload: list[dict[str, object]]) -> None",
          "doc_one_liner": "`VectorBatch` exposes convenience properties for dimension and count.",
          "defined_at": "/home/paul/kgfoundry/tests/vector_ingestion/test_vector_types.py:130"
        }
      ],
      "raises": {}
    },
    {
      "module": "tests.vector_ingestion.conftest",
      "path": "/home/paul/kgfoundry/tests/vector_ingestion/conftest.py",
      "is_test": true,
      "imports": [
        "__future__.annotations",
        "pathlib.Path",
        "typing.TYPE_CHECKING",
        "typing.Final",
        "typing.cast",
        "uuid.UUID",
        "numpy",
        "pytest",
        "kgfoundry_common.jsonschema_utils.create_draft202012_validator",
        "kgfoundry_common.schema_helpers.load_schema",
        "collections.abc.Callable",
        "collections.abc.Sequence",
        "kgfoundry_common.jsonschema_utils.Draft202012ValidatorProtocol",
        "kgfoundry_common.types.JsonValue",
        "kgfoundry_common.vector_types.VectorMatrix"
      ],
      "public_api": [],
      "doc": {
        "module_doc": true,
        "class_total": 0,
        "class_with_doc": 0,
        "func_total": 11,
        "func_with_doc": 10
      },
      "typing": {
        "functions": 11,
        "annotated_returns": 11,
        "total_params": 5,
        "annotated_params": 5
      },
      "complexity": {
        "branch_points": 1,
        "max_nesting": 2
      },
      "loc": 229,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "kgfoundry_common.jsonschema_utils.create_draft202012_validator",
          "kgfoundry_common.schema_helpers.load_schema",
          "np",
          "pathlib.Path",
          "pytest",
          "typing.Final",
          "typing.TYPE_CHECKING",
          "typing.cast",
          "uuid.UUID"
        ],
        "type_checking_imports": [
          "collections.abc.Callable",
          "collections.abc.Sequence",
          "kgfoundry_common.jsonschema_utils.Draft202012ValidatorProtocol",
          "kgfoundry_common.types.JsonValue",
          "kgfoundry_common.vector_types.VectorMatrix"
        ],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [],
      "raises": {}
    },
    {
      "module": "tests.kgfoundry_common.test_configuration_error",
      "path": "/home/paul/kgfoundry/tests/kgfoundry_common/test_configuration_error.py",
      "is_test": true,
      "imports": [
        "__future__.annotations",
        "inspect.signature",
        "typing.TYPE_CHECKING",
        "typing.cast",
        "pytest",
        "kgfoundry_common.errors.ConfigurationError",
        "kgfoundry_common.errors.ErrorCode",
        "kgfoundry_common.problem_details.build_configuration_problem",
        "kgfoundry_common.problem_details.render_problem",
        "kgfoundry_common.problem_details.validate_problem_details",
        "collections.abc.Mapping",
        "kgfoundry_common.problem_details.ProblemDetails",
        "kgfoundry_common.types.JsonValue"
      ],
      "public_api": [
        "TestConfigurationErrorWithDetails",
        "TestBuildConfigurationProblem",
        "TestConfigurationErrorIntegration"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 3,
        "class_with_doc": 3,
        "func_total": 23,
        "func_with_doc": 23
      },
      "typing": {
        "functions": 23,
        "annotated_returns": 23,
        "total_params": 23,
        "annotated_params": 2
      },
      "complexity": {
        "branch_points": 5,
        "max_nesting": 3
      },
      "loc": 305,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "inspect.signature",
          "kgfoundry_common.errors.ConfigurationError",
          "kgfoundry_common.errors.ErrorCode",
          "kgfoundry_common.problem_details.build_configuration_problem",
          "kgfoundry_common.problem_details.render_problem",
          "kgfoundry_common.problem_details.validate_problem_details",
          "pytest",
          "typing.TYPE_CHECKING",
          "typing.cast"
        ],
        "type_checking_imports": [
          "collections.abc.Mapping",
          "kgfoundry_common.problem_details.ProblemDetails",
          "kgfoundry_common.types.JsonValue"
        ],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "TestConfigurationErrorWithDetails",
          "kind": "class",
          "signature": "class TestConfigurationErrorWithDetails",
          "doc_one_liner": "Test ConfigurationError.with_details() class method.",
          "defined_at": "/home/paul/kgfoundry/tests/kgfoundry_common/test_configuration_error.py:59"
        },
        {
          "name": "TestBuildConfigurationProblem",
          "kind": "class",
          "signature": "class TestBuildConfigurationProblem",
          "doc_one_liner": "Test build_configuration_problem() helper function.",
          "defined_at": "/home/paul/kgfoundry/tests/kgfoundry_common/test_configuration_error.py:141"
        },
        {
          "name": "TestConfigurationErrorIntegration",
          "kind": "class",
          "signature": "class TestConfigurationErrorIntegration",
          "doc_one_liner": "Integration tests for ConfigurationError and Problem Details.",
          "defined_at": "/home/paul/kgfoundry/tests/kgfoundry_common/test_configuration_error.py:264"
        }
      ],
      "raises": {}
    },
    {
      "module": "tests.kgfoundry_common.test_subprocess_utils",
      "path": "/home/paul/kgfoundry/tests/kgfoundry_common/test_subprocess_utils.py",
      "is_test": true,
      "imports": [
        "__future__.annotations",
        "collections.UserDict",
        "typing.TYPE_CHECKING",
        "pytest",
        "kgfoundry_common.subprocess_utils.SubprocessError",
        "kgfoundry_common.subprocess_utils.SubprocessTimeoutError",
        "kgfoundry_common.subprocess_utils.run_subprocess",
        "pathlib.Path"
      ],
      "public_api": [
        "TestSubprocessExecution",
        "TestWorkingDirectory",
        "TestEnvironmentVariables",
        "TestErrorReporting",
        "TestComplexCommands"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 5,
        "class_with_doc": 5,
        "func_total": 21,
        "func_with_doc": 21
      },
      "typing": {
        "functions": 21,
        "annotated_returns": 21,
        "total_params": 24,
        "annotated_params": 3
      },
      "complexity": {
        "branch_points": 11,
        "max_nesting": 3
      },
      "loc": 217,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "collections.UserDict",
          "kgfoundry_common.subprocess_utils.SubprocessError",
          "kgfoundry_common.subprocess_utils.SubprocessTimeoutError",
          "kgfoundry_common.subprocess_utils.run_subprocess",
          "pytest",
          "typing.TYPE_CHECKING"
        ],
        "type_checking_imports": [
          "pathlib.Path"
        ],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "TestSubprocessExecution",
          "kind": "class",
          "signature": "class TestSubprocessExecution",
          "doc_one_liner": "Test suite for subprocess execution.",
          "defined_at": "/home/paul/kgfoundry/tests/kgfoundry_common/test_subprocess_utils.py:20"
        },
        {
          "name": "TestWorkingDirectory",
          "kind": "class",
          "signature": "class TestWorkingDirectory",
          "doc_one_liner": "Test suite for working directory handling.",
          "defined_at": "/home/paul/kgfoundry/tests/kgfoundry_common/test_subprocess_utils.py:98"
        },
        {
          "name": "TestEnvironmentVariables",
          "kind": "class",
          "signature": "class TestEnvironmentVariables",
          "doc_one_liner": "Test suite for environment variable handling.",
          "defined_at": "/home/paul/kgfoundry/tests/kgfoundry_common/test_subprocess_utils.py:132"
        },
        {
          "name": "TestErrorReporting",
          "kind": "class",
          "signature": "class TestErrorReporting",
          "doc_one_liner": "Test suite for error messages.",
          "defined_at": "/home/paul/kgfoundry/tests/kgfoundry_common/test_subprocess_utils.py:165"
        },
        {
          "name": "TestComplexCommands",
          "kind": "class",
          "signature": "class TestComplexCommands",
          "doc_one_liner": "Test suite for complex command scenarios.",
          "defined_at": "/home/paul/kgfoundry/tests/kgfoundry_common/test_subprocess_utils.py:181"
        }
      ],
      "raises": {}
    },
    {
      "module": "tests.kgfoundry_common.test_configuration_problem_schema",
      "path": "/home/paul/kgfoundry/tests/kgfoundry_common/test_configuration_problem_schema.py",
      "is_test": true,
      "imports": [
        "__future__.annotations",
        "json",
        "pathlib.Path",
        "typing.TYPE_CHECKING",
        "typing.cast",
        "kgfoundry_common.errors.ConfigurationError",
        "kgfoundry_common.problem_details.build_configuration_problem",
        "kgfoundry_common.problem_details.validate_problem_details",
        "collections.abc.Mapping",
        "kgfoundry_common.problem_details.ProblemDetails",
        "kgfoundry_common.types.JsonValue"
      ],
      "public_api": [
        "TestConfigurationProblemSchema",
        "TestConfigurationProblemSchemaParity",
        "TestConfigurationProblemDocumentation"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 3,
        "class_with_doc": 3,
        "func_total": 17,
        "func_with_doc": 17
      },
      "typing": {
        "functions": 17,
        "annotated_returns": 17,
        "total_params": 16,
        "annotated_params": 2
      },
      "complexity": {
        "branch_points": 4,
        "max_nesting": 3
      },
      "loc": 226,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "json",
          "kgfoundry_common.errors.ConfigurationError",
          "kgfoundry_common.problem_details.build_configuration_problem",
          "kgfoundry_common.problem_details.validate_problem_details",
          "pathlib.Path",
          "typing.TYPE_CHECKING",
          "typing.cast"
        ],
        "type_checking_imports": [
          "collections.abc.Mapping",
          "kgfoundry_common.problem_details.ProblemDetails",
          "kgfoundry_common.types.JsonValue"
        ],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "TestConfigurationProblemSchema",
          "kind": "class",
          "signature": "class TestConfigurationProblemSchema",
          "doc_one_liner": "Test schema validation for configuration error Problem Details.",
          "defined_at": "/home/paul/kgfoundry/tests/kgfoundry_common/test_configuration_problem_schema.py:76"
        },
        {
          "name": "TestConfigurationProblemSchemaParity",
          "kind": "class",
          "signature": "class TestConfigurationProblemSchemaParity",
          "doc_one_liner": "Test that generated problems maintain schema parity.",
          "defined_at": "/home/paul/kgfoundry/tests/kgfoundry_common/test_configuration_problem_schema.py:146"
        },
        {
          "name": "TestConfigurationProblemDocumentation",
          "kind": "class",
          "signature": "class TestConfigurationProblemDocumentation",
          "doc_one_liner": "Test that Problem Details are properly documented.",
          "defined_at": "/home/paul/kgfoundry/tests/kgfoundry_common/test_configuration_problem_schema.py:199"
        }
      ],
      "raises": {}
    },
    {
      "module": "tests.kgfoundry_common.test_prometheus_metrics",
      "path": "/home/paul/kgfoundry/tests/kgfoundry_common/test_prometheus_metrics.py",
      "is_test": true,
      "imports": [
        "__future__.annotations",
        "logging",
        "typing.TYPE_CHECKING",
        "typing.Final",
        "pytest",
        "prometheus_client.Counter",
        "prometheus_client.Histogram",
        "_pytest.logging.LogCaptureFixture",
        "prometheus_client.registry.CollectorRegistry",
        "prometheus_client.samples.Sample"
      ],
      "public_api": [
        "TestCounterMetrics",
        "TestHistogramMetrics",
        "TestMetricsIntegration",
        "TestMetricsOnErrorPaths"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 4,
        "class_with_doc": 4,
        "func_total": 12,
        "func_with_doc": 12
      },
      "typing": {
        "functions": 12,
        "annotated_returns": 12,
        "total_params": 28,
        "annotated_params": 18
      },
      "complexity": {
        "branch_points": 14,
        "max_nesting": 4
      },
      "loc": 437,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "logging",
          "prometheus_client.Counter",
          "prometheus_client.Histogram",
          "pytest",
          "typing.Final",
          "typing.TYPE_CHECKING"
        ],
        "type_checking_imports": [
          "_pytest.logging.LogCaptureFixture",
          "prometheus_client.registry.CollectorRegistry",
          "prometheus_client.samples.Sample"
        ],
        "exports": [
          "TestCounterMetrics",
          "TestHistogramMetrics",
          "TestMetricsIntegration",
          "TestMetricsOnErrorPaths"
        ],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "TestCounterMetrics",
          "kind": "class",
          "signature": "class TestCounterMetrics",
          "doc_one_liner": "Verify counter metrics increment correctly.",
          "defined_at": "/home/paul/kgfoundry/tests/kgfoundry_common/test_prometheus_metrics.py:70"
        },
        {
          "name": "TestHistogramMetrics",
          "kind": "class",
          "signature": "class TestHistogramMetrics",
          "doc_one_liner": "Verify histogram metrics record durations.",
          "defined_at": "/home/paul/kgfoundry/tests/kgfoundry_common/test_prometheus_metrics.py:185"
        },
        {
          "name": "TestMetricsOnErrorPaths",
          "kind": "class",
          "signature": "class TestMetricsOnErrorPaths",
          "doc_one_liner": "Verify metrics are emitted on error scenarios.",
          "defined_at": "/home/paul/kgfoundry/tests/kgfoundry_common/test_prometheus_metrics.py:277"
        },
        {
          "name": "TestMetricsIntegration",
          "kind": "class",
          "signature": "class TestMetricsIntegration",
          "doc_one_liner": "Verify counter and histogram work together.",
          "defined_at": "/home/paul/kgfoundry/tests/kgfoundry_common/test_prometheus_metrics.py:383"
        }
      ],
      "raises": {
        "_simulate_value_error": [
          "ValueError"
        ],
        "_simulate_error_of_type": [
          "error_class"
        ]
      }
    },
    {
      "module": "tests.kgfoundry_common.test_optional_deps",
      "path": "/home/paul/kgfoundry/tests/kgfoundry_common/test_optional_deps.py",
      "is_test": true,
      "imports": [
        "__future__.annotations",
        "collections.abc.Mapping",
        "typing.TYPE_CHECKING",
        "typing.Any",
        "unittest.mock",
        "pytest",
        "kgfoundry_common.errors.ArtifactDependencyError",
        "kgfoundry_common.optional_deps.OptionalDependencyError",
        "kgfoundry_common.optional_deps.safe_import_autoapi",
        "kgfoundry_common.optional_deps.safe_import_griffe",
        "kgfoundry_common.optional_deps.safe_import_sphinx",
        "collections.abc.Callable"
      ],
      "public_api": [
        "TestOptionalDependencyError",
        "TestSafeImportGriffe",
        "TestSafeImportAutoapi",
        "TestSafeImportSphinx",
        "TestImportFunctionsParametrized"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 5,
        "class_with_doc": 5,
        "func_total": 15,
        "func_with_doc": 14
      },
      "typing": {
        "functions": 15,
        "annotated_returns": 15,
        "total_params": 20,
        "annotated_params": 6
      },
      "complexity": {
        "branch_points": 17,
        "max_nesting": 4
      },
      "loc": 217,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "collections.abc.Mapping",
          "kgfoundry_common.errors.ArtifactDependencyError",
          "kgfoundry_common.optional_deps.OptionalDependencyError",
          "kgfoundry_common.optional_deps.safe_import_autoapi",
          "kgfoundry_common.optional_deps.safe_import_griffe",
          "kgfoundry_common.optional_deps.safe_import_sphinx",
          "pytest",
          "typing.Any",
          "typing.TYPE_CHECKING",
          "unittest.mock"
        ],
        "type_checking_imports": [
          "collections.abc.Callable"
        ],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "TestOptionalDependencyError",
          "kind": "class",
          "signature": "class TestOptionalDependencyError",
          "doc_one_liner": "Test suite for OptionalDependencyError class.",
          "defined_at": "/home/paul/kgfoundry/tests/kgfoundry_common/test_optional_deps.py:37"
        },
        {
          "name": "TestSafeImportGriffe",
          "kind": "class",
          "signature": "class TestSafeImportGriffe",
          "doc_one_liner": "Test suite for safe_import_griffe function.",
          "defined_at": "/home/paul/kgfoundry/tests/kgfoundry_common/test_optional_deps.py:81"
        },
        {
          "name": "TestSafeImportAutoapi",
          "kind": "class",
          "signature": "class TestSafeImportAutoapi",
          "doc_one_liner": "Test suite for safe_import_autoapi function.",
          "defined_at": "/home/paul/kgfoundry/tests/kgfoundry_common/test_optional_deps.py:137"
        },
        {
          "name": "TestSafeImportSphinx",
          "kind": "class",
          "signature": "class TestSafeImportSphinx",
          "doc_one_liner": "Test suite for safe_import_sphinx function.",
          "defined_at": "/home/paul/kgfoundry/tests/kgfoundry_common/test_optional_deps.py:164"
        },
        {
          "name": "TestImportFunctionsParametrized",
          "kind": "class",
          "signature": "class TestImportFunctionsParametrized",
          "doc_one_liner": "Parametrized tests for all safe import functions.",
          "defined_at": "/home/paul/kgfoundry/tests/kgfoundry_common/test_optional_deps.py:199"
        }
      ],
      "raises": {
        "_expect_mapping": [
          "TypeError"
        ]
      }
    },
    {
      "module": "tests.kgfoundry_common.test_sequence_guards",
      "path": "/home/paul/kgfoundry/tests/kgfoundry_common/test_sequence_guards.py",
      "is_test": true,
      "imports": [
        "__future__.annotations",
        "collections.abc.Sequence",
        "typing.TYPE_CHECKING",
        "typing.Protocol",
        "pytest",
        "kgfoundry_common.errors.VectorSearchError",
        "kgfoundry_common.sequence_guards.first_or_error",
        "kgfoundry_common.sequence_guards.first_or_error_multi_device"
      ],
      "public_api": [
        "SequenceGuard",
        "MultiDeviceGuard",
        "sequence_guard_fixture",
        "multi_device_guard_fixture",
        "TestFirstOrError",
        "TestFirstOrErrorMultiDevice",
        "TestErrorObservability",
        "TestFirstOrErrorParametrized"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 6,
        "class_with_doc": 6,
        "func_total": 23,
        "func_with_doc": 23
      },
      "typing": {
        "functions": 23,
        "annotated_returns": 23,
        "total_params": 51,
        "annotated_params": 30
      },
      "complexity": {
        "branch_points": 15,
        "max_nesting": 4
      },
      "loc": 306,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "collections.abc.Sequence",
          "kgfoundry_common.errors.VectorSearchError",
          "kgfoundry_common.sequence_guards.first_or_error",
          "kgfoundry_common.sequence_guards.first_or_error_multi_device",
          "pytest",
          "typing.Protocol",
          "typing.TYPE_CHECKING"
        ],
        "type_checking_imports": [
          "collections.abc.Sequence"
        ],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "SequenceGuard",
          "kind": "class",
          "signature": "class SequenceGuard(Protocol)",
          "doc_one_liner": "Protocol describing the generic sequence guard callable contract.",
          "defined_at": "/home/paul/kgfoundry/tests/kgfoundry_common/test_sequence_guards.py:23"
        },
        {
          "name": "MultiDeviceGuard",
          "kind": "class",
          "signature": "class MultiDeviceGuard(Protocol)",
          "doc_one_liner": "Protocol describing the multi-device guard callable contract.",
          "defined_at": "/home/paul/kgfoundry/tests/kgfoundry_common/test_sequence_guards.py:52"
        },
        {
          "name": "sequence_guard_fixture",
          "kind": "function",
          "signature": "sequence_guard_fixture() -> SequenceGuard",
          "doc_one_liner": "Provide a typed fixture for the generic sequence guard.",
          "defined_at": "/home/paul/kgfoundry/tests/kgfoundry_common/test_sequence_guards.py:82"
        },
        {
          "name": "multi_device_guard_fixture",
          "kind": "function",
          "signature": "multi_device_guard_fixture() -> MultiDeviceGuard",
          "doc_one_liner": "Provide a typed fixture for the multi-device sequence guard.",
          "defined_at": "/home/paul/kgfoundry/tests/kgfoundry_common/test_sequence_guards.py:94"
        },
        {
          "name": "TestFirstOrError",
          "kind": "class",
          "signature": "class TestFirstOrError",
          "doc_one_liner": "Tests for first_or_error guard function.",
          "defined_at": "/home/paul/kgfoundry/tests/kgfoundry_common/test_sequence_guards.py:105"
        },
        {
          "name": "TestFirstOrErrorMultiDevice",
          "kind": "class",
          "signature": "class TestFirstOrErrorMultiDevice",
          "doc_one_liner": "Tests for first_or_error_multi_device specialized variant.",
          "defined_at": "/home/paul/kgfoundry/tests/kgfoundry_common/test_sequence_guards.py:196"
        },
        {
          "name": "TestErrorObservability",
          "kind": "class",
          "signature": "class TestErrorObservability",
          "doc_one_liner": "Tests for observability aspects of guards (logs, metrics).",
          "defined_at": "/home/paul/kgfoundry/tests/kgfoundry_common/test_sequence_guards.py:257"
        },
        {
          "name": "TestFirstOrErrorParametrized",
          "kind": "class",
          "signature": "class TestFirstOrErrorParametrized",
          "doc_one_liner": "Parametrized tests for comprehensive coverage.",
          "defined_at": "/home/paul/kgfoundry/tests/kgfoundry_common/test_sequence_guards.py:288"
        }
      ],
      "raises": {}
    },
    {
      "module": "tests.kgfoundry_common.test_safe_pickle_v2",
      "path": "/home/paul/kgfoundry/tests/kgfoundry_common/test_safe_pickle_v2.py",
      "is_test": true,
      "imports": [
        "__future__.annotations",
        "io",
        "os",
        "typing.TYPE_CHECKING",
        "typing.ParamSpec",
        "typing.TypeVar",
        "typing.cast",
        "pytest",
        "kgfoundry_common.safe_pickle_v2.SignedPickleWrapper",
        "kgfoundry_common.safe_pickle_v2.UnsafeSerializationError",
        "kgfoundry_common.safe_pickle_v2.create_unsigned_pickle_payload",
        "collections.abc.Callable",
        "_pytest.logging.LogCaptureFixture"
      ],
      "public_api": [
        "signing_key",
        "wrapper",
        "TestSignedPickleWrapper",
        "TestUnsafeSerializationError",
        "TestPickleRoundTrip"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 5,
        "class_with_doc": 5,
        "func_total": 15,
        "func_with_doc": 15
      },
      "typing": {
        "functions": 15,
        "annotated_returns": 15,
        "total_params": 24,
        "annotated_params": 12
      },
      "complexity": {
        "branch_points": 10,
        "max_nesting": 3
      },
      "loc": 259,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "io",
          "kgfoundry_common.safe_pickle_v2.SignedPickleWrapper",
          "kgfoundry_common.safe_pickle_v2.UnsafeSerializationError",
          "kgfoundry_common.safe_pickle_v2.create_unsigned_pickle_payload",
          "os",
          "pytest",
          "typing.ParamSpec",
          "typing.TYPE_CHECKING",
          "typing.TypeVar",
          "typing.cast"
        ],
        "type_checking_imports": [
          "_pytest.logging.LogCaptureFixture",
          "collections.abc.Callable"
        ],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "signing_key",
          "kind": "function",
          "signature": "signing_key() -> bytes",
          "doc_one_liner": "Provide a valid signing key.",
          "defined_at": "/home/paul/kgfoundry/tests/kgfoundry_common/test_safe_pickle_v2.py:48"
        },
        {
          "name": "wrapper",
          "kind": "function",
          "signature": "wrapper(signing_key: bytes) -> SignedPickleWrapper",
          "doc_one_liner": "Provide a wrapper instance with a random signing key.",
          "defined_at": "/home/paul/kgfoundry/tests/kgfoundry_common/test_safe_pickle_v2.py:60"
        },
        {
          "name": "TestSignedPickleWrapper",
          "kind": "class",
          "signature": "class TestSignedPickleWrapper",
          "doc_one_liner": "Test suite for SignedPickleWrapper.",
          "defined_at": "/home/paul/kgfoundry/tests/kgfoundry_common/test_safe_pickle_v2.py:76"
        },
        {
          "name": "TestUnsafeSerializationError",
          "kind": "class",
          "signature": "class TestUnsafeSerializationError",
          "doc_one_liner": "Test suite for error reporting.",
          "defined_at": "/home/paul/kgfoundry/tests/kgfoundry_common/test_safe_pickle_v2.py:215"
        },
        {
          "name": "TestPickleRoundTrip",
          "kind": "class",
          "signature": "class TestPickleRoundTrip",
          "doc_one_liner": "Integration tests for pickle round-tripping.",
          "defined_at": "/home/paul/kgfoundry/tests/kgfoundry_common/test_safe_pickle_v2.py:229"
        }
      ],
      "raises": {}
    },
    {
      "module": "tests.codeintel_rev.benchmarks.test_faiss_performance",
      "path": "/home/paul/kgfoundry/tests/codeintel_rev/benchmarks/test_faiss_performance.py",
      "is_test": true,
      "imports": [
        "__future__.annotations",
        "os",
        "pathlib.Path",
        "typing.TYPE_CHECKING",
        "typing.Any",
        "typing.cast",
        "numpy",
        "pytest",
        "codeintel_rev.io.faiss_manager.FAISSManager",
        "tests.conftest.FAISS_MODULE",
        "tests.conftest.HAS_FAISS_SUPPORT",
        "faiss"
      ],
      "public_api": [
        "tmp_index_path",
        "test_small_corpus_flat_vs_ivf_pq",
        "test_medium_corpus_ivf_flat_vs_ivf_pq",
        "test_large_corpus_adaptive_vs_fixed",
        "test_training_time_scaling"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 0,
        "class_with_doc": 0,
        "func_total": 10,
        "func_with_doc": 10
      },
      "typing": {
        "functions": 10,
        "annotated_returns": 10,
        "total_params": 11,
        "annotated_params": 6
      },
      "complexity": {
        "branch_points": 3,
        "max_nesting": 3
      },
      "loc": 247,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "codeintel_rev.io.faiss_manager.FAISSManager",
          "np",
          "os",
          "pathlib.Path",
          "pytest",
          "tests.conftest.FAISS_MODULE",
          "tests.conftest.HAS_FAISS_SUPPORT",
          "typing.Any",
          "typing.TYPE_CHECKING",
          "typing.cast"
        ],
        "type_checking_imports": [
          "faiss"
        ],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "tmp_index_path",
          "kind": "function",
          "signature": "tmp_index_path(tmp_path: Path) -> Path",
          "doc_one_liner": "Create a temporary index path for benchmarking.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/benchmarks/test_faiss_performance.py:66"
        },
        {
          "name": "test_small_corpus_flat_vs_ivf_pq",
          "kind": "function",
          "signature": "test_small_corpus_flat_vs_ivf_pq(benchmark, tmp_index_path: Path) -> None",
          "doc_one_liner": "Benchmark small corpus: flat index vs fixed IVF-PQ.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/benchmarks/test_faiss_performance.py:83"
        },
        {
          "name": "test_medium_corpus_ivf_flat_vs_ivf_pq",
          "kind": "function",
          "signature": "test_medium_corpus_ivf_flat_vs_ivf_pq(benchmark, tmp_index_path: Path) -> None",
          "doc_one_liner": "Benchmark medium corpus: IVFFlat vs fixed IVF-PQ.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/benchmarks/test_faiss_performance.py:124"
        },
        {
          "name": "test_large_corpus_adaptive_vs_fixed",
          "kind": "function",
          "signature": "test_large_corpus_adaptive_vs_fixed(benchmark, tmp_index_path: Path) -> None",
          "doc_one_liner": "Benchmark large corpus: adaptive vs fixed IVF-PQ.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/benchmarks/test_faiss_performance.py:166"
        },
        {
          "name": "test_training_time_scaling",
          "kind": "function",
          "signature": "test_training_time_scaling(benchmark, tmp_index_path: Path) -> None",
          "doc_one_liner": "Benchmark training time scaling across corpus sizes.",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/benchmarks/test_faiss_performance.py:212"
        }
      ],
      "raises": {}
    },
    {
      "module": "tests.codeintel_rev.io.test_vllm_engine",
      "path": "/home/paul/kgfoundry/tests/codeintel_rev/io/test_vllm_engine.py",
      "is_test": true,
      "imports": [
        "__future__.annotations",
        "collections.abc.Sequence",
        "dataclasses.dataclass",
        "types.ModuleType",
        "types.SimpleNamespace",
        "typing.Any",
        "numpy",
        "pytest",
        "codeintel_rev.config.settings.VLLMConfig",
        "codeintel_rev.config.settings.VLLMRunMode",
        "sys",
        "codeintel_rev.io.vllm_engine",
        "codeintel_rev.io.vllm_engine.InprocessVLLMEmbedder"
      ],
      "public_api": [
        "test_embed_batch_returns_expected_shape",
        "test_embed_batch_handles_empty_input"
      ],
      "doc": {
        "module_doc": false,
        "class_total": 4,
        "class_with_doc": 0,
        "func_total": 9,
        "func_with_doc": 0
      },
      "typing": {
        "functions": 9,
        "annotated_returns": 9,
        "total_params": 14,
        "annotated_params": 10
      },
      "complexity": {
        "branch_points": 0,
        "max_nesting": 3
      },
      "loc": 108,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "codeintel_rev.config.settings.VLLMConfig",
          "codeintel_rev.config.settings.VLLMRunMode",
          "codeintel_rev.io.vllm_engine",
          "codeintel_rev.io.vllm_engine.InprocessVLLMEmbedder",
          "collections.abc.Sequence",
          "dataclasses.dataclass",
          "np",
          "pytest",
          "sys",
          "types.ModuleType",
          "types.SimpleNamespace",
          "typing.Any"
        ],
        "type_checking_imports": [],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "test_embed_batch_returns_expected_shape",
          "kind": "function",
          "signature": "test_embed_batch_returns_expected_shape() -> None",
          "doc_one_liner": "",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/io/test_vllm_engine.py:83"
        },
        {
          "name": "test_embed_batch_handles_empty_input",
          "kind": "function",
          "signature": "test_embed_batch_handles_empty_input() -> None",
          "doc_one_liner": "",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/io/test_vllm_engine.py:97"
        }
      ],
      "raises": {}
    },
    {
      "module": "tests.codeintel_rev.io.test_rerank_coderankllm",
      "path": "/home/paul/kgfoundry/tests/codeintel_rev/io/test_rerank_coderankllm.py",
      "is_test": true,
      "imports": [
        "__future__.annotations",
        "types.SimpleNamespace",
        "typing.Any",
        "pytest",
        "codeintel_rev.io.rerank_coderankllm",
        "codeintel_rev.io.rerank_coderankllm.CodeRankListwiseReranker"
      ],
      "public_api": [
        "test_reranker_reorders_when_json_valid",
        "test_reranker_falls_back_on_invalid_output"
      ],
      "doc": {
        "module_doc": false,
        "class_total": 4,
        "class_with_doc": 0,
        "func_total": 14,
        "func_with_doc": 0
      },
      "typing": {
        "functions": 14,
        "annotated_returns": 14,
        "total_params": 28,
        "annotated_params": 16
      },
      "complexity": {
        "branch_points": 0,
        "max_nesting": 3
      },
      "loc": 104,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "codeintel_rev.io.rerank_coderankllm",
          "codeintel_rev.io.rerank_coderankllm.CodeRankListwiseReranker",
          "pytest",
          "types.SimpleNamespace",
          "typing.Any"
        ],
        "type_checking_imports": [],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "test_reranker_reorders_when_json_valid",
          "kind": "function",
          "signature": "test_reranker_reorders_when_json_valid(monkeypatch) -> None",
          "doc_one_liner": "",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/io/test_rerank_coderankllm.py:71"
        },
        {
          "name": "test_reranker_falls_back_on_invalid_output",
          "kind": "function",
          "signature": "test_reranker_falls_back_on_invalid_output(monkeypatch) -> None",
          "doc_one_liner": "",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/io/test_rerank_coderankllm.py:90"
        }
      ],
      "raises": {}
    },
    {
      "module": "tests.codeintel_rev.mcp_server.test_semantic_pro_adapter",
      "path": "/home/paul/kgfoundry/tests/codeintel_rev/mcp_server/test_semantic_pro_adapter.py",
      "is_test": true,
      "imports": [
        "__future__.annotations",
        "asyncio",
        "collections.abc.Iterator",
        "contextlib.AbstractContextManager",
        "contextlib.contextmanager",
        "pathlib.Path",
        "types.SimpleNamespace",
        "typing.cast",
        "numpy",
        "pytest",
        "codeintel_rev.app.config_context.ApplicationContext",
        "codeintel_rev.mcp_server.adapters.semantic_pro",
        "codeintel_rev.retrieval.types.HybridResultDoc",
        "codeintel_rev.retrieval.types.HybridSearchResult",
        "kgfoundry_common.errors.VectorSearchError"
      ],
      "public_api": [
        "test_semantic_pro_produces_findings",
        "test_semantic_pro_requires_coderank_enabled",
        "test_merge_explainability_into_findings"
      ],
      "doc": {
        "module_doc": false,
        "class_total": 6,
        "class_with_doc": 0,
        "func_total": 20,
        "func_with_doc": 0
      },
      "typing": {
        "functions": 20,
        "annotated_returns": 20,
        "total_params": 33,
        "annotated_params": 18
      },
      "complexity": {
        "branch_points": 3,
        "max_nesting": 4
      },
      "loc": 246,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "asyncio",
          "codeintel_rev.app.config_context.ApplicationContext",
          "codeintel_rev.mcp_server.adapters.semantic_pro",
          "codeintel_rev.retrieval.types.HybridResultDoc",
          "codeintel_rev.retrieval.types.HybridSearchResult",
          "collections.abc.Iterator",
          "contextlib.AbstractContextManager",
          "contextlib.contextmanager",
          "kgfoundry_common.errors.VectorSearchError",
          "np",
          "pathlib.Path",
          "pytest",
          "types.SimpleNamespace",
          "typing.cast"
        ],
        "type_checking_imports": [],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "test_semantic_pro_produces_findings",
          "kind": "function",
          "signature": "test_semantic_pro_produces_findings(tmp_path: Path) -> None",
          "doc_one_liner": "",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/mcp_server/test_semantic_pro_adapter.py:184"
        },
        {
          "name": "test_semantic_pro_requires_coderank_enabled",
          "kind": "function",
          "signature": "test_semantic_pro_requires_coderank_enabled(tmp_path: Path) -> None",
          "doc_one_liner": "",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/mcp_server/test_semantic_pro_adapter.py:215"
        },
        {
          "name": "test_merge_explainability_into_findings",
          "kind": "function",
          "signature": "test_merge_explainability_into_findings() -> None",
          "doc_one_liner": "",
          "defined_at": "/home/paul/kgfoundry/tests/codeintel_rev/mcp_server/test_semantic_pro_adapter.py:228"
        }
      ],
      "raises": {}
    },
    {
      "module": "tests.tools.docstring_builder.test_orchestrator_additional",
      "path": "/home/paul/kgfoundry/tests/tools/docstring_builder/test_orchestrator_additional.py",
      "is_test": true,
      "imports": [
        "__future__.annotations",
        "typing.Protocol",
        "typing.cast",
        "pytest",
        "tools.docstring_builder.orchestrator",
        "tools.docstring_builder.config_models.DocstringBuildConfig",
        "tools.docstring_builder.orchestrator.run_build",
        "tools.docstring_builder.orchestrator.run_legacy"
      ],
      "public_api": [
        "TestPositionalArgumentRejection",
        "TestDeprecationPath",
        "TestDocstringExamples"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 4,
        "class_with_doc": 3,
        "func_total": 12,
        "func_with_doc": 10
      },
      "typing": {
        "functions": 12,
        "annotated_returns": 12,
        "total_params": 15,
        "annotated_params": 4
      },
      "complexity": {
        "branch_points": 12,
        "max_nesting": 4
      },
      "loc": 145,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "orchestrator_module",
          "pytest",
          "tools.docstring_builder.config_models.DocstringBuildConfig",
          "tools.docstring_builder.orchestrator.run_build",
          "tools.docstring_builder.orchestrator.run_legacy",
          "typing.Protocol",
          "typing.cast"
        ],
        "type_checking_imports": [],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "TestPositionalArgumentRejection",
          "kind": "class",
          "signature": "class TestPositionalArgumentRejection",
          "doc_one_liner": "Tests verifying that positional arguments are rejected.",
          "defined_at": "/home/paul/kgfoundry/tests/tools/docstring_builder/test_orchestrator_additional.py:28"
        },
        {
          "name": "TestDeprecationPath",
          "kind": "class",
          "signature": "class TestDeprecationPath",
          "doc_one_liner": "Detailed tests for the deprecation warning path.",
          "defined_at": "/home/paul/kgfoundry/tests/tools/docstring_builder/test_orchestrator_additional.py:62"
        },
        {
          "name": "TestDocstringExamples",
          "kind": "class",
          "signature": "class TestDocstringExamples",
          "doc_one_liner": "Tests verifying that docstring examples are correct and runnable.",
          "defined_at": "/home/paul/kgfoundry/tests/tools/docstring_builder/test_orchestrator_additional.py:112"
        }
      ],
      "raises": {}
    },
    {
      "module": "tests.tools.docstring_builder.test_docfacts_invariants",
      "path": "/home/paul/kgfoundry/tests/tools/docstring_builder/test_docfacts_invariants.py",
      "is_test": true,
      "imports": [
        "__future__.annotations",
        "pathlib.Path",
        "types.SimpleNamespace",
        "typing.TYPE_CHECKING",
        "typing.cast",
        "pytest",
        "tools.docstring_builder.docfacts.build_docfacts",
        "tools.docstring_builder.models.SchemaViolationError",
        "tools.docstring_builder.models.validate_docfacts_payload",
        "tools.docstring_builder.schema.DocstringSchema",
        "tools.docstring_builder.semantics.SemanticResult",
        "tools.docstring_builder.harvest.ParameterHarvest",
        "tools.docstring_builder.harvest.SymbolHarvest",
        "tools.docstring_builder.models.DocfactsDocumentPayload",
        "tools.docstring_builder.models.DocfactsEntry",
        "tools.docstring_builder.models.DocfactsParameter",
        "tools.docstring_builder.models.DocfactsRaise",
        "tools.docstring_builder.models.DocfactsReturn"
      ],
      "public_api": [
        "test_build_docfacts_normalizes_invalid_line_numbers",
        "test_validate_docfacts_payload_surfaces_schema_violation_details"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 0,
        "class_with_doc": 0,
        "func_total": 3,
        "func_with_doc": 0
      },
      "typing": {
        "functions": 3,
        "annotated_returns": 3,
        "total_params": 2,
        "annotated_params": 2
      },
      "complexity": {
        "branch_points": 2,
        "max_nesting": 2
      },
      "loc": 104,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "pathlib.Path",
          "pytest",
          "tools.docstring_builder.docfacts.build_docfacts",
          "tools.docstring_builder.models.SchemaViolationError",
          "tools.docstring_builder.models.validate_docfacts_payload",
          "tools.docstring_builder.schema.DocstringSchema",
          "tools.docstring_builder.semantics.SemanticResult",
          "types.SimpleNamespace",
          "typing.TYPE_CHECKING",
          "typing.cast"
        ],
        "type_checking_imports": [
          "tools.docstring_builder.harvest.ParameterHarvest",
          "tools.docstring_builder.harvest.SymbolHarvest",
          "tools.docstring_builder.models.DocfactsDocumentPayload",
          "tools.docstring_builder.models.DocfactsEntry",
          "tools.docstring_builder.models.DocfactsParameter",
          "tools.docstring_builder.models.DocfactsRaise",
          "tools.docstring_builder.models.DocfactsReturn"
        ],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "test_build_docfacts_normalizes_invalid_line_numbers",
          "kind": "function",
          "signature": "test_build_docfacts_normalizes_invalid_line_numbers() -> None",
          "doc_one_liner": "",
          "defined_at": "/home/paul/kgfoundry/tests/tools/docstring_builder/test_docfacts_invariants.py:55"
        },
        {
          "name": "test_validate_docfacts_payload_surfaces_schema_violation_details",
          "kind": "function",
          "signature": "test_validate_docfacts_payload_surfaces_schema_violation_details() -> None",
          "doc_one_liner": "",
          "defined_at": "/home/paul/kgfoundry/tests/tools/docstring_builder/test_docfacts_invariants.py:64"
        }
      ],
      "raises": {}
    },
    {
      "module": "tests.tools.docstring_builder.test_orchestrator_new_api",
      "path": "/home/paul/kgfoundry/tests/tools/docstring_builder/test_orchestrator_new_api.py",
      "is_test": true,
      "imports": [
        "__future__.annotations",
        "tempfile",
        "time",
        "dataclasses.dataclass",
        "dataclasses.field",
        "pathlib.Path",
        "typing.TYPE_CHECKING",
        "typing.Protocol",
        "typing.cast",
        "pytest",
        "tools.docstring_builder.orchestrator",
        "tools.docstring_builder.builder_types.DocstringBuildResult",
        "tools.docstring_builder.builder_types.ExitStatus",
        "tools.docstring_builder.cache.DocstringBuilderCache",
        "tools.docstring_builder.config.BuilderConfig",
        "tools.docstring_builder.config.ConfigSelection",
        "tools.docstring_builder.config_models.CachePolicy",
        "tools.docstring_builder.config_models.DocstringBuildConfig",
        "tools.docstring_builder.orchestrator.run_build",
        "tools.docstring_builder.orchestrator.run_docstring_builder",
        "tools.docstring_builder.orchestrator.run_legacy",
        "tools.docstring_builder.builder_types.DocstringBuildRequest"
      ],
      "public_api": [
        "RecordingCache",
        "TestRunBuild",
        "TestRunLegacy",
        "TestPublicAPIMigration"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 7,
        "class_with_doc": 5,
        "func_total": 32,
        "func_with_doc": 20
      },
      "typing": {
        "functions": 32,
        "annotated_returns": 32,
        "total_params": 51,
        "annotated_params": 23
      },
      "complexity": {
        "branch_points": 10,
        "max_nesting": 4
      },
      "loc": 365,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "dataclasses.dataclass",
          "dataclasses.field",
          "orchestrator_module",
          "pathlib.Path",
          "pytest",
          "tempfile",
          "time",
          "tools.docstring_builder.builder_types.DocstringBuildResult",
          "tools.docstring_builder.builder_types.ExitStatus",
          "tools.docstring_builder.cache.DocstringBuilderCache",
          "tools.docstring_builder.config.BuilderConfig",
          "tools.docstring_builder.config.ConfigSelection",
          "tools.docstring_builder.config_models.CachePolicy",
          "tools.docstring_builder.config_models.DocstringBuildConfig",
          "tools.docstring_builder.orchestrator.run_build",
          "tools.docstring_builder.orchestrator.run_docstring_builder",
          "tools.docstring_builder.orchestrator.run_legacy",
          "typing.Protocol",
          "typing.TYPE_CHECKING",
          "typing.cast"
        ],
        "type_checking_imports": [
          "tools.docstring_builder.builder_types.DocstringBuildRequest"
        ],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "RecordingCache",
          "kind": "class",
          "signature": "class RecordingCache(DocstringBuilderCache)",
          "doc_one_liner": "Test double implementing :class:`DocstringBuilderCache` for assertions.",
          "defined_at": "/home/paul/kgfoundry/tests/tools/docstring_builder/test_orchestrator_new_api.py:112"
        },
        {
          "name": "TestRunBuild",
          "kind": "class",
          "signature": "class TestRunBuild",
          "doc_one_liner": "Tests for the new run_build() function.",
          "defined_at": "/home/paul/kgfoundry/tests/tools/docstring_builder/test_orchestrator_new_api.py:172"
        },
        {
          "name": "TestRunLegacy",
          "kind": "class",
          "signature": "class TestRunLegacy",
          "doc_one_liner": "Tests for the deprecation wrapper run_legacy().",
          "defined_at": "/home/paul/kgfoundry/tests/tools/docstring_builder/test_orchestrator_new_api.py:306"
        },
        {
          "name": "TestPublicAPIMigration",
          "kind": "class",
          "signature": "class TestPublicAPIMigration",
          "doc_one_liner": "Integration tests for migration from legacy to new API.",
          "defined_at": "/home/paul/kgfoundry/tests/tools/docstring_builder/test_orchestrator_new_api.py:353"
        }
      ],
      "raises": {}
    },
    {
      "module": "tests.tools.docstring_builder.test_pipeline_helpers",
      "path": "/home/paul/kgfoundry/tests/tools/docstring_builder/test_pipeline_helpers.py",
      "is_test": true,
      "imports": [
        "__future__.annotations",
        "logging",
        "dataclasses.dataclass",
        "dataclasses.field",
        "typing.TYPE_CHECKING",
        "pytest",
        "tools.docstring_builder.builder_types.ExitStatus",
        "tools.docstring_builder.failure_summary.FailureSummaryRenderer",
        "tools.docstring_builder.failure_summary.RunSummarySnapshot",
        "tools.docstring_builder.metrics.MetricsRecorder",
        "tools.docstring_builder.models.RunStatus",
        "tools.docstring_builder.paths.OBSERVABILITY_PATH",
        "tools.docstring_builder.pipeline_types.ErrorEnvelope",
        "tools.docstring_builder.pipeline_types.FileOutcome",
        "_pytest.logging.LogCaptureFixture",
        "tools.docstring_builder.docfacts.DocFact"
      ],
      "public_api": [
        "TestFailureSummaryRenderer",
        "TestMetricsRecorder",
        "TestErrorEnvelope",
        "TestFileOutcomeTracking",
        "TestStatusMapping"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 7,
        "class_with_doc": 5,
        "func_total": 13,
        "func_with_doc": 9
      },
      "typing": {
        "functions": 13,
        "annotated_returns": 13,
        "total_params": 21,
        "annotated_params": 10
      },
      "complexity": {
        "branch_points": 1,
        "max_nesting": 2
      },
      "loc": 204,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "dataclasses.dataclass",
          "dataclasses.field",
          "logging",
          "pytest",
          "tools.docstring_builder.builder_types.ExitStatus",
          "tools.docstring_builder.failure_summary.FailureSummaryRenderer",
          "tools.docstring_builder.failure_summary.RunSummarySnapshot",
          "tools.docstring_builder.metrics.MetricsRecorder",
          "tools.docstring_builder.models.RunStatus",
          "tools.docstring_builder.paths.OBSERVABILITY_PATH",
          "tools.docstring_builder.pipeline_types.ErrorEnvelope",
          "tools.docstring_builder.pipeline_types.FileOutcome",
          "typing.TYPE_CHECKING"
        ],
        "type_checking_imports": [
          "_pytest.logging.LogCaptureFixture",
          "tools.docstring_builder.docfacts.DocFact"
        ],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "TestFailureSummaryRenderer",
          "kind": "class",
          "signature": "class TestFailureSummaryRenderer",
          "doc_one_liner": "Tests for FailureSummaryRenderer.",
          "defined_at": "/home/paul/kgfoundry/tests/tools/docstring_builder/test_pipeline_helpers.py:78"
        },
        {
          "name": "TestMetricsRecorder",
          "kind": "class",
          "signature": "class TestMetricsRecorder",
          "doc_one_liner": "Tests for MetricsRecorder.",
          "defined_at": "/home/paul/kgfoundry/tests/tools/docstring_builder/test_pipeline_helpers.py:132"
        },
        {
          "name": "TestErrorEnvelope",
          "kind": "class",
          "signature": "class TestErrorEnvelope",
          "doc_one_liner": "Tests for ErrorEnvelope.",
          "defined_at": "/home/paul/kgfoundry/tests/tools/docstring_builder/test_pipeline_helpers.py:154"
        },
        {
          "name": "TestFileOutcomeTracking",
          "kind": "class",
          "signature": "class TestFileOutcomeTracking",
          "doc_one_liner": "Tests for FileOutcome data structure.",
          "defined_at": "/home/paul/kgfoundry/tests/tools/docstring_builder/test_pipeline_helpers.py:170"
        },
        {
          "name": "TestStatusMapping",
          "kind": "class",
          "signature": "class TestStatusMapping",
          "doc_one_liner": "Tests for status value mappings.",
          "defined_at": "/home/paul/kgfoundry/tests/tools/docstring_builder/test_pipeline_helpers.py:197"
        }
      ],
      "raises": {}
    },
    {
      "module": "tests.tools.docstring_builder.test_cache_interfaces",
      "path": "/home/paul/kgfoundry/tests/tools/docstring_builder/test_cache_interfaces.py",
      "is_test": true,
      "imports": [
        "__future__.annotations",
        "tempfile",
        "pathlib.Path",
        "typing.TYPE_CHECKING",
        "typing.cast",
        "tests.helpers.load_attribute",
        "tools.docstring_builder.cache.BuilderCache",
        "tools.docstring_builder.cache.DocstringBuilderCache"
      ],
      "public_api": [
        "TestCacheProtocol",
        "TestCacheProtocolContract"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 2,
        "class_with_doc": 2,
        "func_total": 8,
        "func_with_doc": 8
      },
      "typing": {
        "functions": 8,
        "annotated_returns": 8,
        "total_params": 8,
        "annotated_params": 0
      },
      "complexity": {
        "branch_points": 9,
        "max_nesting": 3
      },
      "loc": 153,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "pathlib.Path",
          "tempfile",
          "tests.helpers.load_attribute",
          "typing.TYPE_CHECKING",
          "typing.cast"
        ],
        "type_checking_imports": [
          "tools.docstring_builder.cache.BuilderCache",
          "tools.docstring_builder.cache.DocstringBuilderCache"
        ],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "TestCacheProtocol",
          "kind": "class",
          "signature": "class TestCacheProtocol",
          "doc_one_liner": "Tests verifying the DocstringBuilderCache Protocol.",
          "defined_at": "/home/paul/kgfoundry/tests/tools/docstring_builder/test_cache_interfaces.py:28"
        },
        {
          "name": "TestCacheProtocolContract",
          "kind": "class",
          "signature": "class TestCacheProtocolContract",
          "doc_one_liner": "Tests verifying the semantic contract of DocstringBuilderCache.",
          "defined_at": "/home/paul/kgfoundry/tests/tools/docstring_builder/test_cache_interfaces.py:118"
        }
      ],
      "raises": {}
    },
    {
      "module": "tests.tools.docs.test_build_graphs_cli",
      "path": "/home/paul/kgfoundry/tests/tools/docs/test_build_graphs_cli.py",
      "is_test": true,
      "imports": [
        "__future__.annotations",
        "importlib",
        "json",
        "pathlib.Path",
        "typing.Any",
        "typing.cast",
        "pytest"
      ],
      "public_api": [
        "test_main_emits_success_envelope",
        "test_main_records_validation_failure"
      ],
      "doc": {
        "module_doc": false,
        "class_total": 0,
        "class_with_doc": 0,
        "func_total": 5,
        "func_with_doc": 0
      },
      "typing": {
        "functions": 5,
        "annotated_returns": 5,
        "total_params": 8,
        "annotated_params": 8
      },
      "complexity": {
        "branch_points": 0,
        "max_nesting": 2
      },
      "loc": 83,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "importlib",
          "json",
          "pathlib.Path",
          "pytest",
          "typing.Any",
          "typing.cast"
        ],
        "type_checking_imports": [],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "test_main_emits_success_envelope",
          "kind": "function",
          "signature": "test_main_emits_success_envelope(monkeypatch: pytest.MonkeyPatch, cli_paths: Path) -> None",
          "doc_one_liner": "",
          "defined_at": "/home/paul/kgfoundry/tests/tools/docs/test_build_graphs_cli.py:28"
        },
        {
          "name": "test_main_records_validation_failure",
          "kind": "function",
          "signature": "test_main_records_validation_failure(monkeypatch: pytest.MonkeyPatch, cli_paths: Path) -> None",
          "doc_one_liner": "",
          "defined_at": "/home/paul/kgfoundry/tests/tools/docs/test_build_graphs_cli.py:63"
        }
      ],
      "raises": {
        "test_main_records_validation_failure": [
          "ValidationError"
        ],
        "fake_prepare_cache": [
          "ValidationError"
        ]
      }
    },
    {
      "module": "tests.tools.mkdocs_suite.test_operation_links",
      "path": "/home/paul/kgfoundry/tests/tools/mkdocs_suite/test_operation_links.py",
      "is_test": true,
      "imports": [
        "__future__.annotations",
        "importlib",
        "collections.abc.Callable",
        "pathlib.Path",
        "typing.cast",
        "pytest"
      ],
      "public_api": [
        "test_build_operation_href_known_specs",
        "test_build_operation_href_encodes_operation_id",
        "test_build_operation_href_rejects_unknown_specs",
        "test_build_operation_href_requires_operation_identifier"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 0,
        "class_with_doc": 0,
        "func_total": 4,
        "func_with_doc": 4
      },
      "typing": {
        "functions": 4,
        "annotated_returns": 4,
        "total_params": 4,
        "annotated_params": 4
      },
      "complexity": {
        "branch_points": 0,
        "max_nesting": 1
      },
      "loc": 60,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "collections.abc.Callable",
          "importlib",
          "pathlib.Path",
          "pytest",
          "typing.cast"
        ],
        "type_checking_imports": [],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "test_build_operation_href_known_specs",
          "kind": "function",
          "signature": "test_build_operation_href_known_specs(spec_path: str | Path, operation_id: str, expected: str) -> None",
          "doc_one_liner": "CLI and HTTP specs should resolve to their rendered Markdown pages.",
          "defined_at": "/home/paul/kgfoundry/tests/tools/mkdocs_suite/test_operation_links.py:34"
        },
        {
          "name": "test_build_operation_href_encodes_operation_id",
          "kind": "function",
          "signature": "test_build_operation_href_encodes_operation_id() -> None",
          "doc_one_liner": "Operation identifiers must be percent-encoded within anchors.",
          "defined_at": "/home/paul/kgfoundry/tests/tools/mkdocs_suite/test_operation_links.py:43"
        },
        {
          "name": "test_build_operation_href_rejects_unknown_specs",
          "kind": "function",
          "signature": "test_build_operation_href_rejects_unknown_specs(spec_path: object) -> None",
          "doc_one_liner": "Unknown specification files should not produce hyperlinks.",
          "defined_at": "/home/paul/kgfoundry/tests/tools/mkdocs_suite/test_operation_links.py:51"
        },
        {
          "name": "test_build_operation_href_requires_operation_identifier",
          "kind": "function",
          "signature": "test_build_operation_href_requires_operation_identifier() -> None",
          "doc_one_liner": "Empty or missing operation identifiers should return ``None``.",
          "defined_at": "/home/paul/kgfoundry/tests/tools/mkdocs_suite/test_operation_links.py:58"
        }
      ],
      "raises": {}
    },
    {
      "module": "tests.tools.mkdocs_suite.test_gen_module_pages",
      "path": "/home/paul/kgfoundry/tests/tools/mkdocs_suite/test_gen_module_pages.py",
      "is_test": true,
      "imports": [
        "__future__.annotations",
        "ast",
        "importlib",
        "importlib.machinery",
        "importlib.util",
        "io",
        "logging",
        "sys",
        "types",
        "collections.abc.Callable",
        "pathlib.Path",
        "typing.Any",
        "typing.cast",
        "griffe",
        "pytest"
      ],
      "public_api": [
        "fixture_gen_module_pages",
        "test_inline_d2_neighborhood_uses_relative_doc_paths",
        "test_render_module_pages_warns_and_continues_on_invalid_api_usage"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 5,
        "class_with_doc": 0,
        "func_total": 25,
        "func_with_doc": 3
      },
      "typing": {
        "functions": 25,
        "annotated_returns": 25,
        "total_params": 43,
        "annotated_params": 36
      },
      "complexity": {
        "branch_points": 13,
        "max_nesting": 4
      },
      "loc": 321,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "ast",
          "collections.abc.Callable",
          "griffe",
          "importlib",
          "importlib.machinery",
          "importlib.util",
          "io",
          "logging",
          "pathlib.Path",
          "pytest",
          "sys",
          "types",
          "typing.Any",
          "typing.cast"
        ],
        "type_checking_imports": [],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "fixture_gen_module_pages",
          "kind": "function",
          "signature": "fixture_gen_module_pages(monkeypatch: pytest.MonkeyPatch) -> types.ModuleType",
          "doc_one_liner": "Load ``gen_module_pages`` without executing its expensive side effects.",
          "defined_at": "/home/paul/kgfoundry/tests/tools/mkdocs_suite/test_gen_module_pages.py:213"
        },
        {
          "name": "test_inline_d2_neighborhood_uses_relative_doc_paths",
          "kind": "function",
          "signature": "test_inline_d2_neighborhood_uses_relative_doc_paths(gen_module_pages: types.ModuleType) -> None",
          "doc_one_liner": "D2 neighborhood links should point to relative module documentation paths.",
          "defined_at": "/home/paul/kgfoundry/tests/tools/mkdocs_suite/test_gen_module_pages.py:246"
        },
        {
          "name": "test_render_module_pages_warns_and_continues_on_invalid_api_usage",
          "kind": "function",
          "signature": "test_render_module_pages_warns_and_continues_on_invalid_api_usage(tmp_path: Path, monkeypatch: pytest.MonkeyPatch, caplog: pytest.LogCaptureFixture) -> None",
          "doc_one_liner": "Invalid API usage JSON should be ignored with a warning during builds.",
          "defined_at": "/home/paul/kgfoundry/tests/tools/mkdocs_suite/test_gen_module_pages.py:276"
        }
      ],
      "raises": {
        "_patch_importlib_for_navmap": [
          "RuntimeError"
        ],
        "_load_gen_module_pages_without_render": [
          "RuntimeError"
        ],
        "test_render_module_pages_warns_and_continues_on_invalid_api_usage": [
          "GriffeError"
        ],
        "_fake_spec_from_file_location": [
          "RuntimeError"
        ],
        "_raise_loader_error": [
          "GriffeError"
        ]
      }
    },
    {
      "module": "tests.tools.mkdocs_suite.test_gen_cli_diagram",
      "path": "/home/paul/kgfoundry/tests/tools/mkdocs_suite/test_gen_cli_diagram.py",
      "is_test": true,
      "imports": [
        "__future__.annotations",
        "contextlib",
        "importlib",
        "io",
        "pathlib.Path",
        "typing.TYPE_CHECKING",
        "typing.Any",
        "typing.ClassVar",
        "pytest",
        "tools.mkdocs_suite.docs.cli_diagram.collect_operations",
        "tools.mkdocs_suite.docs.cli_diagram.write_diagram",
        "collections.abc.Iterator"
      ],
      "public_api": [
        "test_write_diagram_emits_single_node_for_multi_tag_operations",
        "test_write_diagram_escapes_special_characters",
        "test_collect_operations_surface_loader_error",
        "test_ensure_cli_index_entry_preserves_existing_content",
        "test_update_cli_index_entry_preserves_double_newline",
        "test_main_skips_diagram_when_dependency_missing"
      ],
      "doc": {
        "module_doc": false,
        "class_total": 2,
        "class_with_doc": 0,
        "func_total": 17,
        "func_with_doc": 0
      },
      "typing": {
        "functions": 17,
        "annotated_returns": 17,
        "total_params": 35,
        "annotated_params": 33
      },
      "complexity": {
        "branch_points": 11,
        "max_nesting": 4
      },
      "loc": 278,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "contextlib",
          "importlib",
          "io",
          "pathlib.Path",
          "pytest",
          "tools.mkdocs_suite.docs.cli_diagram.collect_operations",
          "tools.mkdocs_suite.docs.cli_diagram.write_diagram",
          "typing.Any",
          "typing.ClassVar",
          "typing.TYPE_CHECKING"
        ],
        "type_checking_imports": [
          "collections.abc.Iterator"
        ],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "test_write_diagram_emits_single_node_for_multi_tag_operations",
          "kind": "function",
          "signature": "test_write_diagram_emits_single_node_for_multi_tag_operations(monkeypatch: pytest.MonkeyPatch) -> None",
          "doc_one_liner": "",
          "defined_at": "/home/paul/kgfoundry/tests/tools/mkdocs_suite/test_gen_cli_diagram.py:37"
        },
        {
          "name": "test_write_diagram_escapes_special_characters",
          "kind": "function",
          "signature": "test_write_diagram_escapes_special_characters(monkeypatch: pytest.MonkeyPatch) -> None",
          "doc_one_liner": "",
          "defined_at": "/home/paul/kgfoundry/tests/tools/mkdocs_suite/test_gen_cli_diagram.py:113"
        },
        {
          "name": "test_collect_operations_surface_loader_error",
          "kind": "function",
          "signature": "test_collect_operations_surface_loader_error(monkeypatch: pytest.MonkeyPatch) -> None",
          "doc_one_liner": "",
          "defined_at": "/home/paul/kgfoundry/tests/tools/mkdocs_suite/test_gen_cli_diagram.py:150"
        },
        {
          "name": "test_ensure_cli_index_entry_preserves_existing_content",
          "kind": "function",
          "signature": "test_ensure_cli_index_entry_preserves_existing_content(monkeypatch: pytest.MonkeyPatch) -> None",
          "doc_one_liner": "",
          "defined_at": "/home/paul/kgfoundry/tests/tools/mkdocs_suite/test_gen_cli_diagram.py:174"
        },
        {
          "name": "test_update_cli_index_entry_preserves_double_newline",
          "kind": "function",
          "signature": "test_update_cli_index_entry_preserves_double_newline(monkeypatch: pytest.MonkeyPatch) -> None",
          "doc_one_liner": "",
          "defined_at": "/home/paul/kgfoundry/tests/tools/mkdocs_suite/test_gen_cli_diagram.py:215"
        },
        {
          "name": "test_main_skips_diagram_when_dependency_missing",
          "kind": "function",
          "signature": "test_main_skips_diagram_when_dependency_missing(monkeypatch: pytest.MonkeyPatch, caplog: pytest.LogCaptureFixture) -> None",
          "doc_one_liner": "",
          "defined_at": "/home/paul/kgfoundry/tests/tools/mkdocs_suite/test_gen_cli_diagram.py:250"
        }
      ],
      "raises": {
        "_capture_write": [
          "FileNotFoundError"
        ],
        "test_collect_operations_surface_loader_error": [
          "error_cls"
        ],
        "test_main_skips_diagram_when_dependency_missing": [
          "ModuleNotFoundError"
        ],
        "failing_loader": [
          "error_cls"
        ],
        "missing_dependency_loader": [
          "ModuleNotFoundError"
        ]
      }
    },
    {
      "module": "tests.tools.mkdocs_suite.test_gen_interface_pages",
      "path": "/home/paul/kgfoundry/tests/tools/mkdocs_suite/test_gen_interface_pages.py",
      "is_test": true,
      "imports": [
        "__future__.annotations",
        "importlib",
        "io",
        "json",
        "logging",
        "sys",
        "types",
        "pathlib.Path",
        "typing.Any",
        "typing.Self",
        "typing.cast",
        "pytest"
      ],
      "public_api": [
        "fixture_temporary_repo",
        "test_collect_nav_interfaces_skips_malformed_json",
        "test_render_interface_catalog_links_full_module_path",
        "test_render_interface_catalog_includes_module_source_link",
        "test_write_interface_table_escapes_markdown_control_characters",
        "test_operation_href_returns_relative_anchor"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 1,
        "class_with_doc": 1,
        "func_total": 12,
        "func_with_doc": 8
      },
      "typing": {
        "functions": 12,
        "annotated_returns": 12,
        "total_params": 20,
        "annotated_params": 17
      },
      "complexity": {
        "branch_points": 1,
        "max_nesting": 2
      },
      "loc": 286,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "importlib",
          "io",
          "json",
          "logging",
          "pathlib.Path",
          "pytest",
          "sys",
          "types",
          "typing.Any",
          "typing.Self",
          "typing.cast"
        ],
        "type_checking_imports": [],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "fixture_temporary_repo",
          "kind": "function",
          "signature": "fixture_temporary_repo(tmp_path: Path) -> Path",
          "doc_one_liner": "Create a temporary repository layout for nav discovery tests.",
          "defined_at": "/home/paul/kgfoundry/tests/tools/mkdocs_suite/test_gen_interface_pages.py:20"
        },
        {
          "name": "test_collect_nav_interfaces_skips_malformed_json",
          "kind": "function",
          "signature": "test_collect_nav_interfaces_skips_malformed_json(temporary_repo: Path, caplog: pytest.LogCaptureFixture, monkeypatch: pytest.MonkeyPatch) -> None",
          "doc_one_liner": "Malformed nav files should be ignored without raising errors.",
          "defined_at": "/home/paul/kgfoundry/tests/tools/mkdocs_suite/test_gen_interface_pages.py:47"
        },
        {
          "name": "test_render_interface_catalog_links_full_module_path",
          "kind": "function",
          "signature": "test_render_interface_catalog_links_full_module_path(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -> None",
          "doc_one_liner": "Interfaces nested under packages should link using the full dotted path.",
          "defined_at": "/home/paul/kgfoundry/tests/tools/mkdocs_suite/test_gen_interface_pages.py:115"
        },
        {
          "name": "test_render_interface_catalog_includes_module_source_link",
          "kind": "function",
          "signature": "test_render_interface_catalog_includes_module_source_link(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -> None",
          "doc_one_liner": "Detail sections should include module and source links when available.",
          "defined_at": "/home/paul/kgfoundry/tests/tools/mkdocs_suite/test_gen_interface_pages.py:149"
        },
        {
          "name": "test_write_interface_table_escapes_markdown_control_characters",
          "kind": "function",
          "signature": "test_write_interface_table_escapes_markdown_control_characters() -> None",
          "doc_one_liner": "User-controlled metadata should be escaped before inserting into tables.",
          "defined_at": "/home/paul/kgfoundry/tests/tools/mkdocs_suite/test_gen_interface_pages.py:191"
        },
        {
          "name": "test_operation_href_returns_relative_anchor",
          "kind": "function",
          "signature": "test_operation_href_returns_relative_anchor(tmp_path: Path) -> None",
          "doc_one_liner": "Operation links should include encoded anchors relative to the doc path.",
          "defined_at": "/home/paul/kgfoundry/tests/tools/mkdocs_suite/test_gen_interface_pages.py:225"
        }
      ],
      "raises": {}
    },
    {
      "module": "tests.tools.navmap.test_cli_api",
      "path": "/home/paul/kgfoundry/tests/tools/navmap/test_cli_api.py",
      "is_test": true,
      "imports": [
        "__future__.annotations",
        "contextlib",
        "tempfile",
        "pathlib.Path",
        "typing.TYPE_CHECKING",
        "typing.cast",
        "tools.navmap.api.repair_all_with_config",
        "tools.navmap.api.repair_module_with_config",
        "tools.navmap.config.NavmapRepairOptions",
        "tools.navmap.repair_navmaps.RepairResult",
        "kgfoundry_common.errors.ConfigurationError",
        "tests.helpers.assert_frozen_attribute",
        "tools.navmap.build_navmap.ModuleInfo"
      ],
      "public_api": [
        "TestConfigBasedAPIUsage",
        "TestConfigValidation",
        "TestAPITypeEnforcement",
        "TestCLIOutputHandling",
        "TestProblemDetailsIntegration",
        "TestAPIDocumentation"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 6,
        "class_with_doc": 6,
        "func_total": 17,
        "func_with_doc": 17
      },
      "typing": {
        "functions": 17,
        "annotated_returns": 17,
        "total_params": 17,
        "annotated_params": 0
      },
      "complexity": {
        "branch_points": 10,
        "max_nesting": 4
      },
      "loc": 178,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "contextlib",
          "kgfoundry_common.errors.ConfigurationError",
          "pathlib.Path",
          "tempfile",
          "tests.helpers.assert_frozen_attribute",
          "tools.navmap.api.repair_all_with_config",
          "tools.navmap.api.repair_module_with_config",
          "tools.navmap.config.NavmapRepairOptions",
          "tools.navmap.repair_navmaps.RepairResult",
          "typing.TYPE_CHECKING",
          "typing.cast"
        ],
        "type_checking_imports": [
          "tools.navmap.build_navmap.ModuleInfo"
        ],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "TestConfigBasedAPIUsage",
          "kind": "class",
          "signature": "class TestConfigBasedAPIUsage",
          "doc_one_liner": "Test that the new config-based API works correctly.",
          "defined_at": "/home/paul/kgfoundry/tests/tools/navmap/test_cli_api.py:21"
        },
        {
          "name": "TestConfigValidation",
          "kind": "class",
          "signature": "class TestConfigValidation",
          "doc_one_liner": "Test configuration validation with Problem Details.",
          "defined_at": "/home/paul/kgfoundry/tests/tools/navmap/test_cli_api.py:63"
        },
        {
          "name": "TestAPITypeEnforcement",
          "kind": "class",
          "signature": "class TestAPITypeEnforcement",
          "doc_one_liner": "Test that new API enforces type safety.",
          "defined_at": "/home/paul/kgfoundry/tests/tools/navmap/test_cli_api.py:84"
        },
        {
          "name": "TestCLIOutputHandling",
          "kind": "class",
          "signature": "class TestCLIOutputHandling",
          "doc_one_liner": "Test CLI output and envelope handling.",
          "defined_at": "/home/paul/kgfoundry/tests/tools/navmap/test_cli_api.py:110"
        },
        {
          "name": "TestProblemDetailsIntegration",
          "kind": "class",
          "signature": "class TestProblemDetailsIntegration",
          "doc_one_liner": "Test Problem Details integration for error cases.",
          "defined_at": "/home/paul/kgfoundry/tests/tools/navmap/test_cli_api.py:137"
        },
        {
          "name": "TestAPIDocumentation",
          "kind": "class",
          "signature": "class TestAPIDocumentation",
          "doc_one_liner": "Test that API functions are properly documented.",
          "defined_at": "/home/paul/kgfoundry/tests/tools/navmap/test_cli_api.py:154"
        }
      ],
      "raises": {}
    },
    {
      "module": "tests.tools.navmap.test_build_navmap_cli",
      "path": "/home/paul/kgfoundry/tests/tools/navmap/test_build_navmap_cli.py",
      "is_test": true,
      "imports": [
        "__future__.annotations",
        "json",
        "pathlib.Path",
        "typing.Any",
        "typing.cast",
        "pytest",
        "tools.navmap.build_navmap"
      ],
      "public_api": [
        "test_main_emits_success_envelope",
        "test_main_records_failure"
      ],
      "doc": {
        "module_doc": false,
        "class_total": 0,
        "class_with_doc": 0,
        "func_total": 6,
        "func_with_doc": 0
      },
      "typing": {
        "functions": 6,
        "annotated_returns": 6,
        "total_params": 11,
        "annotated_params": 11
      },
      "complexity": {
        "branch_points": 1,
        "max_nesting": 2
      },
      "loc": 66,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "json",
          "pathlib.Path",
          "pytest",
          "tools.navmap.build_navmap",
          "typing.Any",
          "typing.cast"
        ],
        "type_checking_imports": [],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "test_main_emits_success_envelope",
          "kind": "function",
          "signature": "test_main_emits_success_envelope(monkeypatch: pytest.MonkeyPatch, tmp_path: Path) -> None",
          "doc_one_liner": "",
          "defined_at": "/home/paul/kgfoundry/tests/tools/navmap/test_build_navmap_cli.py:24"
        },
        {
          "name": "test_main_records_failure",
          "kind": "function",
          "signature": "test_main_records_failure(monkeypatch: pytest.MonkeyPatch, tmp_path: Path) -> None",
          "doc_one_liner": "",
          "defined_at": "/home/paul/kgfoundry/tests/tools/navmap/test_build_navmap_cli.py:48"
        }
      ],
      "raises": {
        "test_main_records_failure": [
          "RuntimeError"
        ],
        "fake_build_index": [
          "RuntimeError"
        ]
      }
    },
    {
      "module": "tests.tools.navmap.test_check_navmap_cli",
      "path": "/home/paul/kgfoundry/tests/tools/navmap/test_check_navmap_cli.py",
      "is_test": true,
      "imports": [
        "__future__.annotations",
        "json",
        "pathlib.Path",
        "typing.Any",
        "typing.cast",
        "pytest",
        "tools.navmap.check_navmap"
      ],
      "public_api": [
        "test_main_emits_success_envelope",
        "test_main_records_validation_failure"
      ],
      "doc": {
        "module_doc": false,
        "class_total": 0,
        "class_with_doc": 0,
        "func_total": 8,
        "func_with_doc": 0
      },
      "typing": {
        "functions": 8,
        "annotated_returns": 8,
        "total_params": 9,
        "annotated_params": 9
      },
      "complexity": {
        "branch_points": 1,
        "max_nesting": 2
      },
      "loc": 67,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "json",
          "pathlib.Path",
          "pytest",
          "tools.navmap.check_navmap",
          "typing.Any",
          "typing.cast"
        ],
        "type_checking_imports": [],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "test_main_emits_success_envelope",
          "kind": "function",
          "signature": "test_main_emits_success_envelope(monkeypatch: pytest.MonkeyPatch, index_path: Path) -> None",
          "doc_one_liner": "",
          "defined_at": "/home/paul/kgfoundry/tests/tools/navmap/test_check_navmap_cli.py:24"
        },
        {
          "name": "test_main_records_validation_failure",
          "kind": "function",
          "signature": "test_main_records_validation_failure(monkeypatch: pytest.MonkeyPatch, index_path: Path) -> None",
          "doc_one_liner": "",
          "defined_at": "/home/paul/kgfoundry/tests/tools/navmap/test_check_navmap_cli.py:50"
        }
      ],
      "raises": {}
    },
    {
      "module": "tests.tools.navmap.test_cache_interfaces",
      "path": "/home/paul/kgfoundry/tests/tools/navmap/test_cache_interfaces.py",
      "is_test": true,
      "imports": [
        "__future__.annotations",
        "tempfile",
        "pathlib.Path",
        "typing.TYPE_CHECKING",
        "typing.cast",
        "tools.navmap.cache.NavmapCollectorCache",
        "tools.navmap.cache.NavmapRepairCache",
        "tests.helpers.load_attribute",
        "collections.abc.Sequence",
        "tools.navmap.build_navmap.ModuleInfo",
        "tools.navmap.repair_navmaps.RepairResult"
      ],
      "public_api": [
        "MockCollectorCache",
        "MockRepairCache",
        "TestNavmapCollectorCacheProtocol",
        "TestNavmapRepairCacheProtocol",
        "TestCacheInterfaceContracts",
        "TestProtocolDocumentation"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 6,
        "class_with_doc": 6,
        "func_total": 24,
        "func_with_doc": 22
      },
      "typing": {
        "functions": 24,
        "annotated_returns": 24,
        "total_params": 28,
        "annotated_params": 4
      },
      "complexity": {
        "branch_points": 10,
        "max_nesting": 4
      },
      "loc": 267,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "pathlib.Path",
          "tempfile",
          "tests.helpers.load_attribute",
          "tools.navmap.cache.NavmapCollectorCache",
          "tools.navmap.cache.NavmapRepairCache",
          "typing.TYPE_CHECKING",
          "typing.cast"
        ],
        "type_checking_imports": [
          "collections.abc.Sequence",
          "tools.navmap.build_navmap.ModuleInfo",
          "tools.navmap.repair_navmaps.RepairResult"
        ],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "MockCollectorCache",
          "kind": "class",
          "signature": "class MockCollectorCache",
          "doc_one_liner": "Mock implementation of NavmapCollectorCache for testing.",
          "defined_at": "/home/paul/kgfoundry/tests/tools/navmap/test_cache_interfaces.py:32"
        },
        {
          "name": "MockRepairCache",
          "kind": "class",
          "signature": "class MockRepairCache",
          "doc_one_liner": "Mock implementation of NavmapRepairCache for testing.",
          "defined_at": "/home/paul/kgfoundry/tests/tools/navmap/test_cache_interfaces.py:87"
        },
        {
          "name": "TestNavmapCollectorCacheProtocol",
          "kind": "class",
          "signature": "class TestNavmapCollectorCacheProtocol",
          "doc_one_liner": "Test structural typing for NavmapCollectorCache.",
          "defined_at": "/home/paul/kgfoundry/tests/tools/navmap/test_cache_interfaces.py:133"
        },
        {
          "name": "TestNavmapRepairCacheProtocol",
          "kind": "class",
          "signature": "class TestNavmapRepairCacheProtocol",
          "doc_one_liner": "Test structural typing for NavmapRepairCache.",
          "defined_at": "/home/paul/kgfoundry/tests/tools/navmap/test_cache_interfaces.py:167"
        },
        {
          "name": "TestCacheInterfaceContracts",
          "kind": "class",
          "signature": "class TestCacheInterfaceContracts",
          "doc_one_liner": "Test interface contracts and invariants.",
          "defined_at": "/home/paul/kgfoundry/tests/tools/navmap/test_cache_interfaces.py:213"
        },
        {
          "name": "TestProtocolDocumentation",
          "kind": "class",
          "signature": "class TestProtocolDocumentation",
          "doc_one_liner": "Test that Protocol docstrings are complete.",
          "defined_at": "/home/paul/kgfoundry/tests/tools/navmap/test_cache_interfaces.py:256"
        }
      ],
      "raises": {}
    },
    {
      "module": "tests.tools.codemods.test_transformers",
      "path": "/home/paul/kgfoundry/tests/tools/codemods/test_transformers.py",
      "is_test": true,
      "imports": [
        "__future__.annotations",
        "textwrap",
        "typing.TYPE_CHECKING",
        "libcst",
        "tools.codemods.blind_except_fix.BlindExceptTransformer",
        "tools.codemods.pathlib_fix.PathlibTransformer",
        "tools.codemods.pathlib_fix.ensure_pathlib_import",
        "tools.docstring_builder.config.BuilderConfig",
        "tools.docstring_builder.harvest.ParameterHarvest",
        "tools.docstring_builder.harvest.SymbolHarvest",
        "tools.docstring_builder.parameters.ParameterKind",
        "tools.docstring_builder.plugins.base.PluginContext",
        "tools.docstring_builder.plugins.dataclass_fields.DataclassFieldDocPlugin",
        "tools.docstring_builder.schema.DocstringSchema",
        "tools.docstring_builder.schema.ParameterDoc",
        "tools.docstring_builder.semantics.SemanticResult",
        "pathlib.Path"
      ],
      "public_api": [
        "test_blind_except_transformer_records_changes",
        "test_pathlib_transformer_tracks_updates",
        "test_dataclass_field_plugin_caches_metadata"
      ],
      "doc": {
        "module_doc": true,
        "class_total": 0,
        "class_with_doc": 0,
        "func_total": 4,
        "func_with_doc": 0
      },
      "typing": {
        "functions": 4,
        "annotated_returns": 4,
        "total_params": 3,
        "annotated_params": 3
      },
      "complexity": {
        "branch_points": 2,
        "max_nesting": 2
      },
      "loc": 153,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "cst",
          "textwrap",
          "tools.codemods.blind_except_fix.BlindExceptTransformer",
          "tools.codemods.pathlib_fix.PathlibTransformer",
          "tools.codemods.pathlib_fix.ensure_pathlib_import",
          "tools.docstring_builder.config.BuilderConfig",
          "tools.docstring_builder.harvest.ParameterHarvest",
          "tools.docstring_builder.harvest.SymbolHarvest",
          "tools.docstring_builder.parameters.ParameterKind",
          "tools.docstring_builder.plugins.base.PluginContext",
          "tools.docstring_builder.plugins.dataclass_fields.DataclassFieldDocPlugin",
          "tools.docstring_builder.schema.DocstringSchema",
          "tools.docstring_builder.schema.ParameterDoc",
          "tools.docstring_builder.semantics.SemanticResult",
          "typing.TYPE_CHECKING"
        ],
        "type_checking_imports": [
          "pathlib.Path"
        ],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "test_blind_except_transformer_records_changes",
          "kind": "function",
          "signature": "test_blind_except_transformer_records_changes() -> None",
          "doc_one_liner": "",
          "defined_at": "/home/paul/kgfoundry/tests/tools/codemods/test_transformers.py:23"
        },
        {
          "name": "test_pathlib_transformer_tracks_updates",
          "kind": "function",
          "signature": "test_pathlib_transformer_tracks_updates() -> None",
          "doc_one_liner": "",
          "defined_at": "/home/paul/kgfoundry/tests/tools/codemods/test_transformers.py:40"
        },
        {
          "name": "test_dataclass_field_plugin_caches_metadata",
          "kind": "function",
          "signature": "test_dataclass_field_plugin_caches_metadata(tmp_path: Path) -> None",
          "doc_one_liner": "",
          "defined_at": "/home/paul/kgfoundry/tests/tools/codemods/test_transformers.py:95"
        }
      ],
      "raises": {}
    },
    {
      "module": "tests.tools.mkdocs_suite.docs._scripts.test_gen_module_pages",
      "path": "/home/paul/kgfoundry/tests/tools/mkdocs_suite/docs/_scripts/test_gen_module_pages.py",
      "is_test": true,
      "imports": [
        "__future__.annotations",
        "importlib",
        "sys",
        "types",
        "pathlib.Path",
        "typing.Any",
        "typing.cast",
        "pytest"
      ],
      "public_api": [
        "fixture_module",
        "test_collect_modules_discovers_new_package"
      ],
      "doc": {
        "module_doc": false,
        "class_total": 0,
        "class_with_doc": 0,
        "func_total": 4,
        "func_with_doc": 3
      },
      "typing": {
        "functions": 4,
        "annotated_returns": 4,
        "total_params": 8,
        "annotated_params": 8
      },
      "complexity": {
        "branch_points": 2,
        "max_nesting": 2
      },
      "loc": 94,
      "parse_ok": true,
      "parse_error": null,
      "imports_cst": {
        "imports": [
          "__future__.annotations",
          "importlib",
          "pathlib.Path",
          "pytest",
          "sys",
          "types",
          "typing.Any",
          "typing.cast"
        ],
        "type_checking_imports": [],
        "exports": [],
        "star_imports": [],
        "has_parse_errors": false
      },
      "test_count": 0,
      "has_tests": false,
      "public_api_without_tests": [],
      "public_api_details": [
        {
          "name": "fixture_module",
          "kind": "function",
          "signature": "fixture_module() -> types.ModuleType",
          "doc_one_liner": "Return the module under test reloaded for isolation.",
          "defined_at": "/home/paul/kgfoundry/tests/tools/mkdocs_suite/docs/_scripts/test_gen_module_pages.py:15"
        },
        {
          "name": "test_collect_modules_discovers_new_package",
          "kind": "function",
          "signature": "test_collect_modules_discovers_new_package(tmp_path: Path, monkeypatch: pytest.MonkeyPatch, module: types.ModuleType) -> None",
          "doc_one_liner": "Newly added packages should be collected without manual configuration.",
          "defined_at": "/home/paul/kgfoundry/tests/tools/mkdocs_suite/docs/_scripts/test_gen_module_pages.py:53"
        }
      ],
      "raises": {}
    }
  ],
  "import_edges": [
    [
      "tests.kgfoundry_common.test_safe_pickle_v2",
      "io"
    ],
    [
      "tests.kgfoundry_common.test_safe_pickle_v2",
      "io.bm25_manager"
    ],
    [
      "tests.kgfoundry_common.test_safe_pickle_v2",
      "io.coderank_embedder"
    ],
    [
      "tests.kgfoundry_common.test_safe_pickle_v2",
      "io.duckdb_catalog"
    ],
    [
      "tests.kgfoundry_common.test_safe_pickle_v2",
      "io.duckdb_manager"
    ],
    [
      "tests.kgfoundry_common.test_safe_pickle_v2",
      "io.faiss_dual_index"
    ],
    [
      "tests.kgfoundry_common.test_safe_pickle_v2",
      "io.faiss_manager"
    ],
    [
      "tests.kgfoundry_common.test_safe_pickle_v2",
      "io.git_client"
    ],
    [
      "tests.kgfoundry_common.test_safe_pickle_v2",
      "io.hybrid_search"
    ],
    [
      "tests.kgfoundry_common.test_safe_pickle_v2",
      "io.parquet_store"
    ],
    [
      "tests.kgfoundry_common.test_safe_pickle_v2",
      "io.path_utils"
    ],
    [
      "tests.kgfoundry_common.test_safe_pickle_v2",
      "io.rerank_coderankllm"
    ],
    [
      "tests.kgfoundry_common.test_safe_pickle_v2",
      "io.rrf"
    ],
    [
      "tests.kgfoundry_common.test_safe_pickle_v2",
      "io.splade_manager"
    ],
    [
      "tests.kgfoundry_common.test_safe_pickle_v2",
      "io.symbol_catalog"
    ],
    [
      "tests.kgfoundry_common.test_safe_pickle_v2",
      "io.vllm_client"
    ],
    [
      "tests.kgfoundry_common.test_safe_pickle_v2",
      "io.vllm_engine"
    ],
    [
      "tests.kgfoundry_common.test_safe_pickle_v2",
      "io.warp_engine"
    ],
    [
      "tests.kgfoundry_common.test_safe_pickle_v2",
      "io.xtr_manager"
    ],
    [
      "tests.tools.mkdocs_suite.test_gen_cli_diagram",
      "io"
    ],
    [
      "tests.tools.mkdocs_suite.test_gen_cli_diagram",
      "io.bm25_manager"
    ],
    [
      "tests.tools.mkdocs_suite.test_gen_cli_diagram",
      "io.coderank_embedder"
    ],
    [
      "tests.tools.mkdocs_suite.test_gen_cli_diagram",
      "io.duckdb_catalog"
    ],
    [
      "tests.tools.mkdocs_suite.test_gen_cli_diagram",
      "io.duckdb_manager"
    ],
    [
      "tests.tools.mkdocs_suite.test_gen_cli_diagram",
      "io.faiss_dual_index"
    ],
    [
      "tests.tools.mkdocs_suite.test_gen_cli_diagram",
      "io.faiss_manager"
    ],
    [
      "tests.tools.mkdocs_suite.test_gen_cli_diagram",
      "io.git_client"
    ],
    [
      "tests.tools.mkdocs_suite.test_gen_cli_diagram",
      "io.hybrid_search"
    ],
    [
      "tests.tools.mkdocs_suite.test_gen_cli_diagram",
      "io.parquet_store"
    ],
    [
      "tests.tools.mkdocs_suite.test_gen_cli_diagram",
      "io.path_utils"
    ],
    [
      "tests.tools.mkdocs_suite.test_gen_cli_diagram",
      "io.rerank_coderankllm"
    ],
    [
      "tests.tools.mkdocs_suite.test_gen_cli_diagram",
      "io.rrf"
    ],
    [
      "tests.tools.mkdocs_suite.test_gen_cli_diagram",
      "io.splade_manager"
    ],
    [
      "tests.tools.mkdocs_suite.test_gen_cli_diagram",
      "io.symbol_catalog"
    ],
    [
      "tests.tools.mkdocs_suite.test_gen_cli_diagram",
      "io.vllm_client"
    ],
    [
      "tests.tools.mkdocs_suite.test_gen_cli_diagram",
      "io.vllm_engine"
    ],
    [
      "tests.tools.mkdocs_suite.test_gen_cli_diagram",
      "io.warp_engine"
    ],
    [
      "tests.tools.mkdocs_suite.test_gen_cli_diagram",
      "io.xtr_manager"
    ],
    [
      "tests.tools.mkdocs_suite.test_gen_interface_pages",
      "io"
    ],
    [
      "tests.tools.mkdocs_suite.test_gen_interface_pages",
      "io.bm25_manager"
    ],
    [
      "tests.tools.mkdocs_suite.test_gen_interface_pages",
      "io.coderank_embedder"
    ],
    [
      "tests.tools.mkdocs_suite.test_gen_interface_pages",
      "io.duckdb_catalog"
    ],
    [
      "tests.tools.mkdocs_suite.test_gen_interface_pages",
      "io.duckdb_manager"
    ],
    [
      "tests.tools.mkdocs_suite.test_gen_interface_pages",
      "io.faiss_dual_index"
    ],
    [
      "tests.tools.mkdocs_suite.test_gen_interface_pages",
      "io.faiss_manager"
    ],
    [
      "tests.tools.mkdocs_suite.test_gen_interface_pages",
      "io.git_client"
    ],
    [
      "tests.tools.mkdocs_suite.test_gen_interface_pages",
      "io.hybrid_search"
    ],
    [
      "tests.tools.mkdocs_suite.test_gen_interface_pages",
      "io.parquet_store"
    ],
    [
      "tests.tools.mkdocs_suite.test_gen_interface_pages",
      "io.path_utils"
    ],
    [
      "tests.tools.mkdocs_suite.test_gen_interface_pages",
      "io.rerank_coderankllm"
    ],
    [
      "tests.tools.mkdocs_suite.test_gen_interface_pages",
      "io.rrf"
    ],
    [
      "tests.tools.mkdocs_suite.test_gen_interface_pages",
      "io.splade_manager"
    ],
    [
      "tests.tools.mkdocs_suite.test_gen_interface_pages",
      "io.symbol_catalog"
    ],
    [
      "tests.tools.mkdocs_suite.test_gen_interface_pages",
      "io.vllm_client"
    ],
    [
      "tests.tools.mkdocs_suite.test_gen_interface_pages",
      "io.vllm_engine"
    ],
    [
      "tests.tools.mkdocs_suite.test_gen_interface_pages",
      "io.warp_engine"
    ],
    [
      "tests.tools.mkdocs_suite.test_gen_interface_pages",
      "io.xtr_manager"
    ],
    [
      "tests.tools.mkdocs_suite.test_gen_module_pages",
      "io"
    ],
    [
      "tests.tools.mkdocs_suite.test_gen_module_pages",
      "io.bm25_manager"
    ],
    [
      "tests.tools.mkdocs_suite.test_gen_module_pages",
      "io.coderank_embedder"
    ],
    [
      "tests.tools.mkdocs_suite.test_gen_module_pages",
      "io.duckdb_catalog"
    ],
    [
      "tests.tools.mkdocs_suite.test_gen_module_pages",
      "io.duckdb_manager"
    ],
    [
      "tests.tools.mkdocs_suite.test_gen_module_pages",
      "io.faiss_dual_index"
    ],
    [
      "tests.tools.mkdocs_suite.test_gen_module_pages",
      "io.faiss_manager"
    ],
    [
      "tests.tools.mkdocs_suite.test_gen_module_pages",
      "io.git_client"
    ],
    [
      "tests.tools.mkdocs_suite.test_gen_module_pages",
      "io.hybrid_search"
    ],
    [
      "tests.tools.mkdocs_suite.test_gen_module_pages",
      "io.parquet_store"
    ],
    [
      "tests.tools.mkdocs_suite.test_gen_module_pages",
      "io.path_utils"
    ],
    [
      "tests.tools.mkdocs_suite.test_gen_module_pages",
      "io.rerank_coderankllm"
    ],
    [
      "tests.tools.mkdocs_suite.test_gen_module_pages",
      "io.rrf"
    ],
    [
      "tests.tools.mkdocs_suite.test_gen_module_pages",
      "io.splade_manager"
    ],
    [
      "tests.tools.mkdocs_suite.test_gen_module_pages",
      "io.symbol_catalog"
    ],
    [
      "tests.tools.mkdocs_suite.test_gen_module_pages",
      "io.vllm_client"
    ],
    [
      "tests.tools.mkdocs_suite.test_gen_module_pages",
      "io.vllm_engine"
    ],
    [
      "tests.tools.mkdocs_suite.test_gen_module_pages",
      "io.warp_engine"
    ],
    [
      "tests.tools.mkdocs_suite.test_gen_module_pages",
      "io.xtr_manager"
    ]
  ],
  "tests_to_modules": {
    "tests.app._context_factory": [
      "tests.app.test_capz",
      "tests.app.test_lifespan_runtime_cleanup"
    ],
    "io.vllm_client": [
      "tests.kgfoundry_common.test_safe_pickle_v2",
      "tests.tools.mkdocs_suite.test_gen_cli_diagram",
      "tests.tools.mkdocs_suite.test_gen_interface_pages",
      "tests.tools.mkdocs_suite.test_gen_module_pages"
    ],
    "io.duckdb_manager": [
      "tests.kgfoundry_common.test_safe_pickle_v2",
      "tests.tools.mkdocs_suite.test_gen_cli_diagram",
      "tests.tools.mkdocs_suite.test_gen_interface_pages",
      "tests.tools.mkdocs_suite.test_gen_module_pages"
    ],
    "tests.bootstrap": [
      "tests.conftest"
    ],
    "io.warp_engine": [
      "tests.kgfoundry_common.test_safe_pickle_v2",
      "tests.tools.mkdocs_suite.test_gen_cli_diagram",
      "tests.tools.mkdocs_suite.test_gen_interface_pages",
      "tests.tools.mkdocs_suite.test_gen_module_pages"
    ],
    "io.path_utils": [
      "tests.kgfoundry_common.test_safe_pickle_v2",
      "tests.tools.mkdocs_suite.test_gen_cli_diagram",
      "tests.tools.mkdocs_suite.test_gen_interface_pages",
      "tests.tools.mkdocs_suite.test_gen_module_pages"
    ],
    "io.faiss_manager": [
      "tests.kgfoundry_common.test_safe_pickle_v2",
      "tests.tools.mkdocs_suite.test_gen_cli_diagram",
      "tests.tools.mkdocs_suite.test_gen_interface_pages",
      "tests.tools.mkdocs_suite.test_gen_module_pages"
    ],
    "io.splade_manager": [
      "tests.kgfoundry_common.test_safe_pickle_v2",
      "tests.tools.mkdocs_suite.test_gen_cli_diagram",
      "tests.tools.mkdocs_suite.test_gen_interface_pages",
      "tests.tools.mkdocs_suite.test_gen_module_pages"
    ],
    "io.rerank_coderankllm": [
      "tests.kgfoundry_common.test_safe_pickle_v2",
      "tests.tools.mkdocs_suite.test_gen_cli_diagram",
      "tests.tools.mkdocs_suite.test_gen_interface_pages",
      "tests.tools.mkdocs_suite.test_gen_module_pages"
    ],
    "io.rrf": [
      "tests.kgfoundry_common.test_safe_pickle_v2",
      "tests.tools.mkdocs_suite.test_gen_cli_diagram",
      "tests.tools.mkdocs_suite.test_gen_interface_pages",
      "tests.tools.mkdocs_suite.test_gen_module_pages"
    ],
    "io.symbol_catalog": [
      "tests.kgfoundry_common.test_safe_pickle_v2",
      "tests.tools.mkdocs_suite.test_gen_cli_diagram",
      "tests.tools.mkdocs_suite.test_gen_interface_pages",
      "tests.tools.mkdocs_suite.test_gen_module_pages"
    ],
    "io.faiss_dual_index": [
      "tests.kgfoundry_common.test_safe_pickle_v2",
      "tests.tools.mkdocs_suite.test_gen_cli_diagram",
      "tests.tools.mkdocs_suite.test_gen_interface_pages",
      "tests.tools.mkdocs_suite.test_gen_module_pages"
    ],
    "io.xtr_manager": [
      "tests.kgfoundry_common.test_safe_pickle_v2",
      "tests.tools.mkdocs_suite.test_gen_cli_diagram",
      "tests.tools.mkdocs_suite.test_gen_interface_pages",
      "tests.tools.mkdocs_suite.test_gen_module_pages"
    ],
    "tests.conftest": [
      "tests.codeintel_rev.benchmarks.test_faiss_performance",
      "tests.codeintel_rev.test_faiss_dual_index",
      "tests.codeintel_rev.test_faiss_incremental",
      "tests.codeintel_rev.test_faiss_manager",
      "tests.codeintel_rev.test_faiss_manager_adaptive"
    ],
    "io.bm25_manager": [
      "tests.kgfoundry_common.test_safe_pickle_v2",
      "tests.tools.mkdocs_suite.test_gen_cli_diagram",
      "tests.tools.mkdocs_suite.test_gen_interface_pages",
      "tests.tools.mkdocs_suite.test_gen_module_pages"
    ],
    "io": [
      "tests.kgfoundry_common.test_safe_pickle_v2",
      "tests.test_logging",
      "tests.test_logging_contexts",
      "tests.tools.mkdocs_suite.test_gen_cli_diagram",
      "tests.tools.mkdocs_suite.test_gen_interface_pages",
      "tests.tools.mkdocs_suite.test_gen_module_pages"
    ],
    "typing": [
      "tests.app._context_factory",
      "tests.app.test_capz",
      "tests.app.test_lifespan_runtime_cleanup",
      "tests.bootstrap",
      "tests.codeintel_rev.benchmarks.test_faiss_performance",
      "tests.codeintel_rev.io.test_rerank_coderankllm",
      "tests.codeintel_rev.io.test_vllm_engine",
      "tests.codeintel_rev.mcp_server.test_semantic_pro_adapter",
      "tests.codeintel_rev.test_error_handling",
      "tests.codeintel_rev.test_faiss_dual_index",
      "tests.codeintel_rev.test_faiss_incremental",
      "tests.codeintel_rev.test_faiss_manager",
      "tests.codeintel_rev.test_faiss_manager_adaptive",
      "tests.codeintel_rev.test_observability_common",
      "tests.codeintel_rev.test_scope_integration",
      "tests.codeintel_rev.test_scope_store",
      "tests.codeintel_rev.test_scope_utils",
      "tests.codeintel_rev.test_semantic_adapter",
      "tests.codeintel_rev.test_service_context_paths",
      "tests.codeintel_rev.test_splade_manager",
      "tests.conftest",
      "tests.docs.conftest",
      "tests.docs.test_artifact_models",
      "tests.docs.test_doc_artifacts",
      "tests.docs.test_griffe_facade",
      "tests.docs.test_scripts_testing_helpers",
      "tests.docs.test_validate_artifacts_script",
      "tests.docstring_builder.test_pipeline_helpers",
      "tests.docstring_builder.test_pipeline_runner",
      "tests.docstring_builder.test_plugin_registry",
      "tests.faiss_gpu.test_001_import_and_env",
      "tests.faiss_gpu.test_010_flat_gpu_correctness",
      "tests.faiss_gpu.test_020_index_transfer",
      "tests.faiss_gpu.test_030_ivf_gpu_correctness",
      "tests.faiss_gpu.test_040_cuvs_toggle",
      "tests.faiss_gpu.test_050_multi_gpu_optional",
      "tests.helpers.immutability",
      "tests.helpers.importing",
      "tests.helpers.typing_facades",
      "tests.io.test_hybrid_search_paths",
      "tests.kgfoundry_common.test_configuration_error",
      "tests.kgfoundry_common.test_configuration_problem_schema",
      "tests.kgfoundry_common.test_optional_deps",
      "tests.kgfoundry_common.test_prometheus_metrics",
      "tests.kgfoundry_common.test_safe_pickle_v2",
      "tests.kgfoundry_common.test_sequence_guards",
      "tests.kgfoundry_common.test_subprocess_utils",
      "tests.orchestration.test_cli_configuration_error",
      "tests.orchestration.test_cli_envelopes",
      "tests.orchestration.test_cli_refactor",
      "tests.orchestration.test_index_cli_idempotency",
      "tests.search_api.test_client_idempotency",
      "tests.search_api.test_faiss_adapter",
      "tests.test_logging",
      "tests.test_logging_contexts",
      "tests.test_namespace_proxy",
      "tests.test_regression_public_api_hardening",
      "tests.test_runtime_determinism",
      "tests.tools.codemods.test_transformers",
      "tests.tools.docs.test_build_graphs_cli",
      "tests.tools.docstring_builder.test_cache_interfaces",
      "tests.tools.docstring_builder.test_docfacts_invariants",
      "tests.tools.docstring_builder.test_orchestrator_additional",
      "tests.tools.docstring_builder.test_orchestrator_new_api",
      "tests.tools.docstring_builder.test_pipeline_helpers",
      "tests.tools.mkdocs_suite.docs._scripts.test_gen_module_pages",
      "tests.tools.mkdocs_suite.test_gen_cli_diagram",
      "tests.tools.mkdocs_suite.test_gen_interface_pages",
      "tests.tools.mkdocs_suite.test_gen_module_pages",
      "tests.tools.mkdocs_suite.test_operation_links",
      "tests.tools.navmap.test_build_navmap_cli",
      "tests.tools.navmap.test_cache_interfaces",
      "tests.tools.navmap.test_check_navmap_cli",
      "tests.tools.navmap.test_cli_api",
      "tests.tools.test_check_new_suppressions",
      "tests.tools.test_check_stub_parity",
      "tests.tools.test_check_typing_gates",
      "tests.tools.test_cli_context_registry",
      "tests.tools.test_generate_pr_summary",
      "tests.tools.test_mkdocs_serve",
      "tests.tools.test_repo_scan",
      "tests.tools.test_typing_gate_metrics",
      "tests.vector_ingestion.conftest",
      "tests.vector_ingestion.test_vector_cli",
      "tests.vector_ingestion.test_vector_schema",
      "tests.vector_ingestion.test_vector_types"
    ],
    "io.hybrid_search": [
      "tests.kgfoundry_common.test_safe_pickle_v2",
      "tests.tools.mkdocs_suite.test_gen_cli_diagram",
      "tests.tools.mkdocs_suite.test_gen_interface_pages",
      "tests.tools.mkdocs_suite.test_gen_module_pages"
    ],
    "io.duckdb_catalog": [
      "tests.kgfoundry_common.test_safe_pickle_v2",
      "tests.tools.mkdocs_suite.test_gen_cli_diagram",
      "tests.tools.mkdocs_suite.test_gen_interface_pages",
      "tests.tools.mkdocs_suite.test_gen_module_pages"
    ],
    "io.coderank_embedder": [
      "tests.kgfoundry_common.test_safe_pickle_v2",
      "tests.tools.mkdocs_suite.test_gen_cli_diagram",
      "tests.tools.mkdocs_suite.test_gen_interface_pages",
      "tests.tools.mkdocs_suite.test_gen_module_pages"
    ],
    "io.vllm_engine": [
      "tests.kgfoundry_common.test_safe_pickle_v2",
      "tests.tools.mkdocs_suite.test_gen_cli_diagram",
      "tests.tools.mkdocs_suite.test_gen_interface_pages",
      "tests.tools.mkdocs_suite.test_gen_module_pages"
    ],
    "io.git_client": [
      "tests.kgfoundry_common.test_safe_pickle_v2",
      "tests.tools.mkdocs_suite.test_gen_cli_diagram",
      "tests.tools.mkdocs_suite.test_gen_interface_pages",
      "tests.tools.mkdocs_suite.test_gen_module_pages"
    ],
    "io.parquet_store": [
      "tests.kgfoundry_common.test_safe_pickle_v2",
      "tests.tools.mkdocs_suite.test_gen_cli_diagram",
      "tests.tools.mkdocs_suite.test_gen_interface_pages",
      "tests.tools.mkdocs_suite.test_gen_module_pages"
    ]
  },
  "git": {
    "/home/paul/kgfoundry/codeintel_rev/_lazy_imports.py": {
      "last_epoch": 1762846620,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/bin/index_all.py": {
      "last_epoch": 1762846620,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/indexing/xtr_build.py": {
      "last_epoch": 1762846620,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/io/__init__.py": {
      "last_epoch": 1762846620,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/io/duckdb_catalog.py": {
      "last_epoch": 1762846620,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/io/faiss_dual_index.py": {
      "last_epoch": 1762846620,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/io/faiss_manager.py": {
      "last_epoch": 1762846620,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/io/parquet_store.py": {
      "last_epoch": 1762846620,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/io/rerank_coderankllm.py": {
      "last_epoch": 1762846620,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/io/vllm_client.py": {
      "last_epoch": 1762846620,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/io/vllm_engine.py": {
      "last_epoch": 1762846620,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/io/warp_engine.py": {
      "last_epoch": 1762846620,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/mcp_server/adapters/semantic.py": {
      "last_epoch": 1762846620,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/mcp_server/tools/gpu_doctor.py": {
      "last_epoch": 1762846620,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/typing.py": {
      "last_epoch": 1762846620,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/README.md": {
      "last_epoch": 1762819155,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/app/capabilities.py": {
      "last_epoch": 1762819155,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/app/config_context.py": {
      "last_epoch": 1762819155,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/app/gpu_warmup.py": {
      "last_epoch": 1762819155,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/app/main.py": {
      "last_epoch": 1762819155,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/app/readiness.py": {
      "last_epoch": 1762819155,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/io/coderank_embedder.py": {
      "last_epoch": 1762819155,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/io/duckdb_manager.py": {
      "last_epoch": 1762819155,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/io/xtr_manager.py": {
      "last_epoch": 1762819155,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/patches/Type_Gating_Factory_Scope_phase2.md": {
      "last_epoch": 1762814892,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/mcp_server/adapters/semantic_pro.py": {
      "last_epoch": 1762807686,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/mcp_server/server.py": {
      "last_epoch": 1762807686,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/mcp_server/server_semantic.py": {
      "last_epoch": 1762807686,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/mcp_server/server_symbols.py": {
      "last_epoch": 1762807686,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/patches/Type_Gating_Factory_Scope.md": {
      "last_epoch": 1762807686,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/mcp_server/service_context.py": {
      "last_epoch": 1762796412,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/ops/runtime/xtr_open.py": {
      "last_epoch": 1762791268,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/runtime/__init__.py": {
      "last_epoch": 1762791268,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/runtime/cells.py": {
      "last_epoch": 1762791268,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/patches/RuntimeCells.md": {
      "last_epoch": 1762785915,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/patches/Runtime_Cells_Followup_Scope.md": {
      "last_epoch": 1762785915,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/patches/SeriesofBugFixes .md": {
      "last_epoch": 1762785915,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/patches/elaborated_hybridsearch.md": {
      "last_epoch": 1762785915,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/patches/vLLM Implementation Instructions.md": {
      "last_epoch": 1762785915,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/patches/warp_implementation.md": {
      "last_epoch": 1762785915,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/errors.py": {
      "last_epoch": 1762781921,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/io/splade_manager.py": {
      "last_epoch": 1762781921,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/mcp_server/retrieval/xtr_cli.py": {
      "last_epoch": 1762781921,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/ops/__init__.py": {
      "last_epoch": 1762781921,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/ops/runtime/__init__.py": {
      "last_epoch": 1762781921,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/mcp_server/schemas.py": {
      "last_epoch": 1762756855,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/app/middleware.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/config/settings.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/config/utils.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/docs/operations/hybrid_search.md": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/mcp_server/scope_utils.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/retrieval/fusion/weighted_rrf.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/retrieval/gating.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/retrieval/telemetry.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/LICENSE": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/README.md": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/__init__.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/conda_env.yml": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/conda_env_cpu.yml": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/executor.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/experiments/configs/warp_eval_dev_sets.json": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/experiments/configs/warp_eval_dev_sets_gcloud.json": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/experiments/configs/warp_eval_runtimes.json": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/experiments/configs/warp_scale_datasets.json": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/experiments/configs/warp_scale_threads.json": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/experiments/configs/xtr_warp_eval_test_sets.json": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/experiments/configs/xtr_warp_eval_test_sets_16.json": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/experiments/configs/xtr_warp_index_sizes_dev_sets.json": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/experiments/configs/xtr_warp_index_sizes_test_sets.json": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/index.scip": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/scripts/__init__.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/scripts/build_indexes.sh": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/scripts/load_pickle_dev.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/utility/__init__.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/utility/executor_utils.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/utility/extract_collection.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/utility/index_sizes.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/utility/latency_runner.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/utility/runner_utils.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/utility/utils/__init__.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/utility/utils/save_metadata.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/utils.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/__init__.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/engine/__init__.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/engine/config.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/engine/constants.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/engine/runtime/__init__.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/engine/runtime/coreml_model.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/engine/runtime/onnx_model.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/engine/runtime/openvino_model.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/engine/runtime/torchscript_model.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/engine/search/__init__.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/engine/search/annotated_stride_view.hpp": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/engine/search/decompress_centroids.cpp": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/engine/search/index_storage.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/engine/search/merge_candidate_scores.cpp": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/engine/search/parallel/__init__.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/engine/search/parallel/parallel_decompress_centroids.cpp": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/engine/search/parallel/parallel_fused_decompress_merge.cpp": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/engine/search/parallel/parallel_index_storage.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/engine/search/parallel/parallel_merge_candidate_scores.cpp": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/engine/search/parallel/parallel_warp_select_centroids.cpp": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/engine/search/parallel/task_graph.hpp": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/engine/search/warp_select_centroids.cpp": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/engine/searcher.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/engine/setup.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/engine/utils/__init__.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/engine/utils/collection_indexer.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/engine/utils/index_converter.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/evaluation/__init__.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/evaluation/load_model.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/evaluation/loaders.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/indexer.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/indexing/__init__.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/indexing/codecs/__init__.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/indexing/codecs/decompress_residuals.cpp": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/indexing/codecs/decompress_residuals.cu": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/indexing/codecs/packbits.cpp": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/indexing/codecs/packbits.cu": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/indexing/codecs/residual.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/indexing/codecs/residual_embeddings.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/indexing/codecs/residual_embeddings_strided.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/indexing/collection_encoder.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/indexing/collection_indexer.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/indexing/index_manager.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/indexing/index_saver.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/indexing/loaders.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/indexing/utils.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/infra/__init__.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/infra/config/__init__.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/infra/config/base_config.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/infra/config/config.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/infra/config/core_config.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/infra/config/settings.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/infra/launcher.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/infra/provenance.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/infra/run.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/modeling/__init__.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/modeling/base_colbert.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/modeling/checkpoint.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/modeling/colbert.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/modeling/hf_colbert.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/modeling/segmented_maxsim.cpp": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/modeling/tokenization/__init__.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/modeling/tokenization/doc_tokenization.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/modeling/tokenization/query_tokenization.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/modeling/tokenization/utils.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/modeling/xtr.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/parameters.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/search/__init__.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/search/candidate_generation.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/search/decompress_residuals.cpp": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/search/filter_pids.cpp": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/search/index_loader.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/search/index_storage.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/search/segmented_lookup.cpp": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/search/strided_tensor.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/search/strided_tensor_core.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/searcher.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/utils/__init__.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/utils/amp.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/utils/distributed.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/utils/logging.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/utils/runs.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/utils/tracker.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp/warp/utils/utils.py": {
      "last_epoch": 1762745602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/app/scope_registry.py": {
      "last_epoch": 1762733219,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/app/scope_store.py": {
      "last_epoch": 1762733219,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/cli/xtr.py": {
      "last_epoch": 1762733219,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/docs/architecture/scope-management.md": {
      "last_epoch": 1762733219,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/indexing/cast_chunker.py": {
      "last_epoch": 1762733219,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/mcp_server/retrieval/__init__.py": {
      "last_epoch": 1762733219,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/cli/__init__.py": {
      "last_epoch": 1762728629,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/cli/bm25.py": {
      "last_epoch": 1762728629,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/indexing/scip_reader.py": {
      "last_epoch": 1762728629,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/io/bm25_manager.py": {
      "last_epoch": 1762728629,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/io/hybrid_search.py": {
      "last_epoch": 1762728629,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/io/rrf.py": {
      "last_epoch": 1762728629,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/io/symbol_catalog.py": {
      "last_epoch": 1762728629,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/mcp_server/adapters/files.py": {
      "last_epoch": 1762728629,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/mcp_server/adapters/history.py": {
      "last_epoch": 1762728629,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/mcp_server/adapters/text_search.py": {
      "last_epoch": 1762728629,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/mcp_server/common/observability.py": {
      "last_epoch": 1762728629,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/mcp_server/error_handling.py": {
      "last_epoch": 1762728629,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/patches/2501.17788v3.pdf": {
      "last_epoch": 1762728629,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/patches/warp_technical_overview.md": {
      "last_epoch": 1762728629,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/retrieval/fusion/__init__.py": {
      "last_epoch": 1762728629,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/retrieval/types.py": {
      "last_epoch": 1762728629,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/io/TEMP_BM25+SPLADE_GUIDE/Implementation_Plan_bm25+spladev3.md": {
      "last_epoch": 1762707602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/io/TEMP_BM25+SPLADE_GUIDE/bm-25+spladev3.mak": {
      "last_epoch": 1762707602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/io/TEMP_BM25+SPLADE_GUIDE/bm25+spladev3_instructions+background.md": {
      "last_epoch": 1762707602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/io/TEMP_BM25+SPLADE_GUIDE/one-time setup (CPU stack + ORT).sh": {
      "last_epoch": 1762707602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/io/TEMP_BM25+SPLADE_GUIDE/playbook.py": {
      "last_epoch": 1762707602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/patches/Chunking_patches.md": {
      "last_epoch": 1762707602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/patches/search_enhancement.md": {
      "last_epoch": 1762707602,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/xtr-warp": {
      "last_epoch": 1762690516,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/cli/splade.py": {
      "last_epoch": 1762687614,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/io/git_client.py": {
      "last_epoch": 1762687614,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/CodeIntel MCP: Design Review and Improve.md": {
      "last_epoch": 1762644027,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/CodeIntel MCP_ Design Improvement Recommendations.pdf": {
      "last_epoch": 1762644027,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/ErrorhandlingDraftimplementationplan": {
      "last_epoch": 1762644027,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/GPTProDataPlan2.md": {
      "last_epoch": 1762644027,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/GPTProDetailedDataPlan1.md": {
      "last_epoch": 1762644027,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/MetricsDetailedPRs.md": {
      "last_epoch": 1762644027,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/answerflow_pr.patch": {
      "last_epoch": 1762644027,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/codeintel_rev_answerflow_pr.zip": {
      "last_epoch": 1762644027,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/docs/CONFIGURATION.md": {
      "last_epoch": 1762639141,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/docs/architecture/splade.md": {
      "last_epoch": 1762639141,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/docs/Bugs and improvement opportunites in codeintel_rev.md": {
      "last_epoch": 1762627891,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/docs/architecture/bm25.md": {
      "last_epoch": 1762627891,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/tests/__init__.py": {
      "last_epoch": 1762620571,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/tests/_faiss_stub.py": {
      "last_epoch": 1762620571,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/tests/conftest.py": {
      "last_epoch": 1762620571,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/tests/test_duckdb_catalog.py": {
      "last_epoch": 1762620571,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/tests/test_files_adapter.py": {
      "last_epoch": 1762620571,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/tests/test_integration.py": {
      "last_epoch": 1762620571,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/tests/test_service_context_paths.py": {
      "last_epoch": 1762620571,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/tests/test_text_search.py": {
      "last_epoch": 1762619217,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/docs/architecture/observability.md": {
      "last_epoch": 1762613698,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/mcp_server/common/__init__.py": {
      "last_epoch": 1762601255,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/docs/error_handling_guide.md": {
      "last_epoch": 1762594005,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/docs/migration/scope-management-v2.md": {
      "last_epoch": 1762573855,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/IMPLEMENTATION_REPORT.md": {
      "last_epoch": 1762566080,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/SCIP+Embedding.md": {
      "last_epoch": 1762566080,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/STATUS.md": {
      "last_epoch": 1762566080,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/SUCCESS.md": {
      "last_epoch": 1762566080,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/QUICKSTART.md": {
      "last_epoch": 1762559381,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/io/path_utils.py": {
      "last_epoch": 1762556156,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/__init__.py": {
      "last_epoch": 1762548844,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/app/__init__.py": {
      "last_epoch": 1762548844,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/bin/__init__.py": {
      "last_epoch": 1762548844,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/cache/__init__.py": {
      "last_epoch": 1762548844,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/config/__init__.py": {
      "last_epoch": 1762548844,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/indexing/__init__.py": {
      "last_epoch": 1762548844,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/mcp_server/__init__.py": {
      "last_epoch": 1762548844,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/mcp_server/tools/__init__.py": {
      "last_epoch": 1762548844,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/retrieval/__init__.py": {
      "last_epoch": 1762548844,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/retrieval/hybrid.py": {
      "last_epoch": 1762548844,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/app/hypercorn.toml": {
      "last_epoch": 1762547254,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/config/nginx/codeintel-mcp.conf": {
      "last_epoch": 1762547254,
      "last_author": "paul-heyse"
    },
    "/home/paul/kgfoundry/codeintel_rev/mcp_server/adapters/__init__.py": {
      "last_epoch": 1762547254,
      "last_author": "paul-heyse"
    }
  },
  "api_symbols": [
    {
      "full_name": "_lazy_imports",
      "short_name": "_lazy_imports",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Helpers for lazily importing heavy optional dependencies.",
      "doc_raw": "Helpers for lazily importing heavy optional dependencies.",
      "docstyle": "google"
    },
    {
      "full_name": "_lazy_imports.LazyModule",
      "short_name": "LazyModule",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "module_name",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "purpose",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Proxy object that imports a module only when accessed.",
      "doc_raw": "Proxy object that imports a module only when accessed.",
      "docstyle": "google"
    },
    {
      "full_name": "_lazy_imports.LazyModule.__setattr__",
      "short_name": "__setattr__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "name",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "value",
          "kind": "positional_or_keyword",
          "annotated_type": "object",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Allow monkeypatching proxied modules in tests.",
      "doc_raw": "Allow monkeypatching proxied modules in tests.",
      "docstyle": "google"
    },
    {
      "full_name": "_lazy_imports.LazyModule.__getattr__",
      "short_name": "__getattr__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "name",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "object",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "_lazy_imports.LazyModule.module",
      "short_name": "module",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "ModuleType",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Return the concrete module, importing it on first access.",
      "doc_raw": "Return the concrete module, importing it on first access.\n\nReturns\n-------\nModuleType\n    Imported module referenced by this proxy.",
      "docstyle": "google"
    },
    {
      "full_name": "_lazy_imports.LazyModule._module",
      "short_name": "_module",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "_lazy_imports.LazyModule._purpose",
      "short_name": "_purpose",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "_lazy_imports.LazyModule._module_name",
      "short_name": "_module_name",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "_lazy_imports.LazyModule.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "module_name",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "purpose",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "_lazy_imports.LazyModule.__slots__",
      "short_name": "__slots__",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app",
      "short_name": "app",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "FastAPI application wiring for the CodeIntel MCP server.",
      "doc_raw": "FastAPI application wiring for the CodeIntel MCP server.",
      "docstyle": "google"
    },
    {
      "full_name": "app.readiness",
      "short_name": "readiness",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Application readiness checks for Kubernetes health probes.",
      "doc_raw": "Application readiness checks for Kubernetes health probes.\n\nThis module provides comprehensive readiness checks for all critical application\nresources including filesystem paths, FAISS indexes, DuckDB catalogs, and\nexternal services (vLLM). The ReadinessProbe class manages these checks and\nexposes results via the /readyz endpoint for Kubernetes integration.\n\nKey Components\n--------------\nCheckResult : dataclass\n    Immutable result of a single readiness check with healthy status and detail.\nReadinessProbe : class\n    Manages readiness checks across all dependencies with async refresh.\n\nDesign Principles\n-----------------\n- **Comprehensive**: Checks all critical resources (files, directories, services)\n- **Non-blocking**: HTTP checks use short timeouts to prevent blocking\n- **Graceful Degradation**: Optional resources (SCIP index) don't fail readiness\n- **Structured Results**: CheckResult provides JSON-serializable payloads\n\nExample Usage\n-------------\nDuring application startup:\n\n>>> # In lifespan() function\n>>> readiness = ReadinessProbe(context)\n>>> await readiness.initialize()\n>>> app.state.readiness = readiness\n\nIn readiness endpoint:\n\n>>> # In /readyz handler\n>>> results = await readiness.refresh()\n>>> return {\"ready\": all(r.healthy for r in results.values()), \"checks\": results}\n\nSee Also\n--------\ncodeintel_rev.app.config_context : ApplicationContext with configuration\ncodeintel_rev.app.main : FastAPI application with /readyz endpoint",
      "docstyle": "google"
    },
    {
      "full_name": "app.readiness.ReadinessProbe",
      "short_name": "ReadinessProbe",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "context",
          "kind": "positional_or_keyword",
          "annotated_type": "ApplicationContext",
          "default": null,
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Manages readiness checks across core dependencies.",
      "doc_raw": "Manages readiness checks across core dependencies.\n\nThis class performs comprehensive health checks on all critical application\nresources including filesystem paths, indexes, databases, and external\nservices. Checks are performed synchronously in a thread pool to avoid\nblocking the event loop.\n\nParameters\n----------\ncontext : ApplicationContext\n    Application context containing configuration and clients.\n\nExamples\n--------\nInitialize during application startup:\n\n>>> readiness = ReadinessProbe(context)\n>>> await readiness.initialize()\n\nRefresh checks on demand:\n\n>>> results = await readiness.refresh()\n>>> all_healthy = all(r.healthy for r in results.values())\n\nGet cached snapshot:\n\n>>> snapshot = readiness.snapshot()\n>>> faiss_status = snapshot[\"faiss_index\"]\n\nNotes\n-----\nThe probe maintains a cache of check results to avoid recomputing on every\nrequest. The cache is updated atomically via async lock during refresh().\n\nInternal attributes (not part of public API):\n- ``_context``: Application context with configuration and paths\n- ``_lock``: Lock protecting _last_checks cache during concurrent refresh calls\n- ``_last_checks``: Cache of most recent check results keyed by resource name",
      "docstyle": "google"
    },
    {
      "full_name": "app.readiness.ReadinessProbe._check_vllm_http",
      "short_name": "_check_vllm_http",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "staticmethod"
      ],
      "params": [
        {
          "name": "base_url",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "CheckResult",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Validate HTTP vLLM endpoint reachability.",
      "doc_raw": "Validate HTTP vLLM endpoint reachability.\n\nExtended Summary\n----------------\nThis static method performs a health check on a remote vLLM HTTP endpoint\nby sending a GET request to the /health endpoint. It validates the URL format,\nchecks connectivity, and verifies that the endpoint returns a successful HTTP\nstatus code. This is used by the readiness probe to determine if the vLLM\nservice is available and responding correctly when running in HTTP mode.\n\nParameters\n----------\nbase_url : str\n    Base URL of the vLLM HTTP service (e.g., \"http://localhost:8001/v1\").\n    Must be a valid HTTP or HTTPS URL with a netloc component. Invalid URLs\n    result in an unhealthy CheckResult.\n\nReturns\n-------\nCheckResult\n    Status representing endpoint availability. healthy=True if the endpoint\n    responds successfully, healthy=False with detail message if the endpoint\n    is unreachable, returns an error status, or the URL is invalid.\n\nNotes\n-----\nTime complexity O(1) plus network latency. Space complexity O(1) aside from\nHTTP response buffers. The method performs network I/O with a timeout defined\nby HTTP_HEALTH_TIMEOUT_S. Thread-safe as it's a static method with no shared\nstate. Network errors are caught and converted to unhealthy CheckResult.",
      "docstyle": "google"
    },
    {
      "full_name": "app.readiness.ReadinessProbe._check_vllm_inprocess",
      "short_name": "_check_vllm_inprocess",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "CheckResult",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Perform an embedding smoke test when running vLLM in-process.",
      "doc_raw": "Perform an embedding smoke test when running vLLM in-process.\n\nReturns\n-------\nCheckResult\n    Healthy status along with diagnostic detail when failures occur.",
      "docstyle": "google"
    },
    {
      "full_name": "app.readiness.ReadinessProbe.check_vllm_connection",
      "short_name": "check_vllm_connection",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "CheckResult",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Verify vLLM availability for the configured execution mode.",
      "doc_raw": "Verify vLLM availability for the configured execution mode.\n\nReturns\n-------\nCheckResult\n    Result of the probe indicating health and optional detail.",
      "docstyle": "google"
    },
    {
      "full_name": "app.readiness.ReadinessProbe._check_search_tools",
      "short_name": "_check_search_tools",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "staticmethod"
      ],
      "params": [],
      "returns": {
        "annotated_type": "CheckResult",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Ensure either ripgrep or grep is available for text search.",
      "doc_raw": "Ensure either ripgrep or grep is available for text search.\n\nReturns\n-------\nCheckResult\n    Healthy status if ripgrep or grep is available, otherwise error detail.",
      "docstyle": "google"
    },
    {
      "full_name": "app.readiness.ReadinessProbe._duckdb_index_exists",
      "short_name": "_duckdb_index_exists",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "staticmethod"
      ],
      "params": [
        {
          "name": "conn",
          "kind": "positional_or_keyword",
          "annotated_type": "duckdb.DuckDBPyConnection",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "bool",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Return True when `idx_chunks_materialized_uri` index exists.",
      "doc_raw": "Return True when `idx_chunks_materialized_uri` index exists.\n\nParameters\n----------\nconn : duckdb.DuckDBPyConnection\n    DuckDB database connection.\n\nReturns\n-------\nbool\n    ``True`` when the index exists, ``False`` otherwise.",
      "docstyle": "google"
    },
    {
      "full_name": "app.readiness.ReadinessProbe._duckdb_table_exists",
      "short_name": "_duckdb_table_exists",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "staticmethod"
      ],
      "params": [
        {
          "name": "conn",
          "kind": "positional_or_keyword",
          "annotated_type": "duckdb.DuckDBPyConnection",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "bool",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Return True when `chunks_materialized` table exists.",
      "doc_raw": "Return True when `chunks_materialized` table exists.\n\nParameters\n----------\nconn : duckdb.DuckDBPyConnection\n    DuckDB database connection.\n\nReturns\n-------\nbool\n    ``True`` when the materialized table exists, ``False`` otherwise.",
      "docstyle": "google"
    },
    {
      "full_name": "app.readiness.ReadinessProbe._check_xtr_artifacts",
      "short_name": "_check_xtr_artifacts",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "CheckResult",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Verify that XTR token artifacts are present when enabled.",
      "doc_raw": "Verify that XTR token artifacts are present when enabled.\n\nReturns\n-------\nCheckResult\n    Healthy status describing artifact availability.",
      "docstyle": "google"
    },
    {
      "full_name": "app.readiness.ReadinessProbe._check_duckdb_catalog",
      "short_name": "_check_duckdb_catalog",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "path",
          "kind": "positional_or_keyword",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "CheckResult",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Validate DuckDB catalog presence and optional materialization state.",
      "doc_raw": "Validate DuckDB catalog presence and optional materialization state.\n\nParameters\n----------\npath : Path\n    Path to the DuckDB catalog file.\n\nReturns\n-------\nCheckResult\n    Healthy status and diagnostic detail when validation fails.",
      "docstyle": "google"
    },
    {
      "full_name": "app.readiness.ReadinessProbe.check_file",
      "short_name": "check_file",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "staticmethod"
      ],
      "params": [
        {
          "name": "path",
          "kind": "positional_or_keyword",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        },
        {
          "name": "description",
          "kind": "keyword_only",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "optional",
          "kind": "keyword_only",
          "annotated_type": "bool",
          "default": "False",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "CheckResult",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Validate existence of a filesystem resource.",
      "doc_raw": "Validate existence of a filesystem resource.\n\nParameters\n----------\npath : Path\n    Target filesystem path.\ndescription : str\n    Human-readable resource description for diagnostics.\noptional : bool, optional\n    When True, missing resources mark the check as healthy but include\n    detail. Defaults to False (missing resources fail the check).\n\nReturns\n-------\nCheckResult\n    Healthy status and contextual detail.\n\nExamples\n--------\n>>> result = ReadinessProbe.check_file(\n...     Path(\"/tmp/test.txt\"), description=\"test file\", optional=False\n... )\n>>> result.healthy\nFalse  # File doesn't exist\n\n>>> result = ReadinessProbe.check_file(\n...     Path(\"/tmp/test.txt\"), description=\"test file\", optional=True\n... )\n>>> result.healthy\nTrue  # Optional file missing is OK\n>>> result.detail\n'test file not found at /tmp/test.txt'",
      "docstyle": "google"
    },
    {
      "full_name": "app.readiness.ReadinessProbe.check_directory",
      "short_name": "check_directory",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "staticmethod"
      ],
      "params": [
        {
          "name": "path",
          "kind": "positional_or_keyword",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        },
        {
          "name": "create",
          "kind": "keyword_only",
          "annotated_type": "bool",
          "default": "False",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "CheckResult",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Ensure a directory exists (creating it if requested).",
      "doc_raw": "Ensure a directory exists (creating it if requested).\n\nParameters\n----------\npath : Path\n    Directory path to validate.\ncreate : bool, optional\n    When True, create the directory hierarchy if it is missing.\n    Defaults to False.\n\nReturns\n-------\nCheckResult\n    Healthy status and diagnostic detail when unavailable.\n\nExamples\n--------\n>>> result = ReadinessProbe.check_directory(Path(\"/tmp/test\"))\n>>> result.healthy\nTrue\n\n>>> result = ReadinessProbe.check_directory(Path(\"/nonexistent\"), create=True)\n>>> result.healthy\nTrue  # Directory was created",
      "docstyle": "google"
    },
    {
      "full_name": "app.readiness.ReadinessProbe._run_checks",
      "short_name": "_run_checks",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "dict[str, CheckResult]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Execute all readiness checks synchronously.",
      "doc_raw": "Execute all readiness checks synchronously.\n\nPerforms checks on all critical resources including filesystem paths,\nindex files, and external services. This method runs in a thread pool\nto avoid blocking the event loop.\n\nReturns\n-------\ndict[str, CheckResult]\n    Check results keyed by resource name.",
      "docstyle": "google"
    },
    {
      "full_name": "app.readiness.ReadinessProbe.snapshot",
      "short_name": "snapshot",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "Mapping[str, CheckResult]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Return the latest readiness snapshot.",
      "doc_raw": "Return the latest readiness snapshot.\n\nReturns the cached check results without performing new checks. Use\nrefresh() to update the cache with fresh results.\n\nReturns\n-------\nMapping[str, CheckResult]\n    Most recent readiness results from the last refresh() call.\n\nRaises\n------\nRuntimeError\n    If the probe has not been initialized yet (no refresh() called).\n\nExamples\n--------\n>>> snapshot = readiness.snapshot()\n>>> if snapshot[\"faiss_index\"].healthy:\n...     # FAISS is ready\n...     pass",
      "docstyle": "google"
    },
    {
      "full_name": "app.readiness.ReadinessProbe.shutdown",
      "short_name": "shutdown",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Clear readiness state on shutdown.",
      "doc_raw": "Clear readiness state on shutdown.\n\nClears the internal cache of check results. Should be called during\napplication shutdown to free resources.\n\nExamples\n--------\n>>> await readiness.shutdown()",
      "docstyle": "google"
    },
    {
      "full_name": "app.readiness.ReadinessProbe.refresh",
      "short_name": "refresh",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "Mapping[str, CheckResult]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Recompute readiness checks asynchronously.",
      "doc_raw": "Recompute readiness checks asynchronously.\n\nRuns all checks in a thread pool to avoid blocking the event loop.\nUpdates the internal cache atomically and returns the latest results.\n\nReturns\n-------\nMapping[str, CheckResult]\n    Latest readiness results keyed by resource name. Keys include:\n    - \"repo_root\": Repository root directory check\n    - \"data_dir\": Data directory check (created if missing)\n    - \"vectors_dir\": Vectors directory check (created if missing)\n    - \"faiss_index\": FAISS index file check\n    - \"duckdb_catalog\": DuckDB catalog file check\n    - \"scip_index\": SCIP index file check (optional)\n    - \"vllm_service\": vLLM service connectivity check\n\nExamples\n--------\n>>> results = await readiness.refresh()\n>>> faiss_healthy = results[\"faiss_index\"].healthy",
      "docstyle": "google"
    },
    {
      "full_name": "app.readiness.ReadinessProbe.initialize",
      "short_name": "initialize",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Prime readiness state on application startup.",
      "doc_raw": "Prime readiness state on application startup.\n\nPerforms initial readiness checks and caches results. This should be\ncalled once during application startup before serving requests.\n\nExamples\n--------\n>>> readiness = ReadinessProbe(context)\n>>> await readiness.initialize()",
      "docstyle": "google"
    },
    {
      "full_name": "app.readiness.ReadinessProbe._last_checks",
      "short_name": "_last_checks",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.readiness.ReadinessProbe._lock",
      "short_name": "_lock",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.readiness.ReadinessProbe._context",
      "short_name": "_context",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.readiness.ReadinessProbe.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "context",
          "kind": "positional_or_keyword",
          "annotated_type": "ApplicationContext",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.readiness.CheckResult",
      "short_name": "CheckResult",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "dataclass(slots=True, frozen=True)"
      ],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "healthy",
          "kind": "positional_or_keyword",
          "annotated_type": "bool",
          "default": null,
          "doc": null
        },
        {
          "name": "detail",
          "kind": "positional_or_keyword",
          "annotated_type": "str | None",
          "default": "None",
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Outcome of a single readiness check.",
      "doc_raw": "Outcome of a single readiness check.\n\nAttributes\n----------\nhealthy : bool\n    Whether the resource is ready for use.\ndetail : str | None\n    Diagnostic detail when unhealthy or degraded. None when healthy.\n\nExamples\n--------\n>>> result = CheckResult(healthy=True)\n>>> result.as_payload()\n{'healthy': True}\n\n>>> result = CheckResult(healthy=False, detail=\"FAISS index not found\")\n>>> result.as_payload()\n{'healthy': False, 'detail': 'FAISS index not found'}",
      "docstyle": "google"
    },
    {
      "full_name": "app.readiness.CheckResult.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "healthy",
          "kind": "positional_or_keyword",
          "annotated_type": "bool",
          "default": null,
          "doc": null
        },
        {
          "name": "detail",
          "kind": "positional_or_keyword",
          "annotated_type": "str | None",
          "default": "None",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.readiness.CheckResult.as_payload",
      "short_name": "as_payload",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "dict[str, Any]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Convert to JSON-serializable dictionary.",
      "doc_raw": "Convert to JSON-serializable dictionary.\n\nReturns\n-------\ndict[str, Any]\n    Dictionary with \"healthy\" boolean and optional \"detail\" string.",
      "docstyle": "google"
    },
    {
      "full_name": "app.readiness.CheckResult.detail",
      "short_name": "detail",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.readiness.CheckResult.healthy",
      "short_name": "healthy",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.readiness._EMBED_BATCH_MIN_ROWS",
      "short_name": "_EMBED_BATCH_MIN_ROWS",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.readiness._EMBED_BATCH_RANK",
      "short_name": "_EMBED_BATCH_RANK",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.readiness.HTTP_HEALTH_TIMEOUT_S",
      "short_name": "HTTP_HEALTH_TIMEOUT_S",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.readiness.LOGGER",
      "short_name": "LOGGER",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.capabilities",
      "short_name": "capabilities",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Capability snapshot helpers for conditional tool registration and /capz.",
      "doc_raw": "Capability snapshot helpers for conditional tool registration and /capz.",
      "docstyle": "google"
    },
    {
      "full_name": "app.capabilities.Capabilities",
      "short_name": "Capabilities",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "dataclass(frozen=True, slots=True)"
      ],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "faiss_index",
          "kind": "positional_or_keyword",
          "annotated_type": "bool",
          "default": "False",
          "doc": null
        },
        {
          "name": "duckdb",
          "kind": "positional_or_keyword",
          "annotated_type": "bool",
          "default": "False",
          "doc": null
        },
        {
          "name": "scip_index",
          "kind": "positional_or_keyword",
          "annotated_type": "bool",
          "default": "False",
          "doc": null
        },
        {
          "name": "vllm_client",
          "kind": "positional_or_keyword",
          "annotated_type": "bool",
          "default": "False",
          "doc": null
        },
        {
          "name": "coderank_index_present",
          "kind": "positional_or_keyword",
          "annotated_type": "bool",
          "default": "False",
          "doc": null
        },
        {
          "name": "warp_index_present",
          "kind": "positional_or_keyword",
          "annotated_type": "bool",
          "default": "False",
          "doc": null
        },
        {
          "name": "xtr_index_present",
          "kind": "positional_or_keyword",
          "annotated_type": "bool",
          "default": "False",
          "doc": null
        },
        {
          "name": "faiss_importable",
          "kind": "positional_or_keyword",
          "annotated_type": "bool",
          "default": "False",
          "doc": null
        },
        {
          "name": "duckdb_importable",
          "kind": "positional_or_keyword",
          "annotated_type": "bool",
          "default": "False",
          "doc": null
        },
        {
          "name": "httpx_importable",
          "kind": "positional_or_keyword",
          "annotated_type": "bool",
          "default": "False",
          "doc": null
        },
        {
          "name": "torch_importable",
          "kind": "positional_or_keyword",
          "annotated_type": "bool",
          "default": "False",
          "doc": null
        },
        {
          "name": "faiss_gpu_available",
          "kind": "positional_or_keyword",
          "annotated_type": "bool",
          "default": "False",
          "doc": null
        },
        {
          "name": "faiss_gpu_disabled_reason",
          "kind": "positional_or_keyword",
          "annotated_type": "str | None",
          "default": "None",
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Capability snapshot used for MCP tool gating and the /capz endpoint.",
      "doc_raw": "Capability snapshot used for MCP tool gating and the /capz endpoint.",
      "docstyle": "google"
    },
    {
      "full_name": "app.capabilities.Capabilities.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "faiss_index",
          "kind": "positional_or_keyword",
          "annotated_type": "bool",
          "default": "False",
          "doc": null
        },
        {
          "name": "duckdb",
          "kind": "positional_or_keyword",
          "annotated_type": "bool",
          "default": "False",
          "doc": null
        },
        {
          "name": "scip_index",
          "kind": "positional_or_keyword",
          "annotated_type": "bool",
          "default": "False",
          "doc": null
        },
        {
          "name": "vllm_client",
          "kind": "positional_or_keyword",
          "annotated_type": "bool",
          "default": "False",
          "doc": null
        },
        {
          "name": "coderank_index_present",
          "kind": "positional_or_keyword",
          "annotated_type": "bool",
          "default": "False",
          "doc": null
        },
        {
          "name": "warp_index_present",
          "kind": "positional_or_keyword",
          "annotated_type": "bool",
          "default": "False",
          "doc": null
        },
        {
          "name": "xtr_index_present",
          "kind": "positional_or_keyword",
          "annotated_type": "bool",
          "default": "False",
          "doc": null
        },
        {
          "name": "faiss_importable",
          "kind": "positional_or_keyword",
          "annotated_type": "bool",
          "default": "False",
          "doc": null
        },
        {
          "name": "duckdb_importable",
          "kind": "positional_or_keyword",
          "annotated_type": "bool",
          "default": "False",
          "doc": null
        },
        {
          "name": "httpx_importable",
          "kind": "positional_or_keyword",
          "annotated_type": "bool",
          "default": "False",
          "doc": null
        },
        {
          "name": "torch_importable",
          "kind": "positional_or_keyword",
          "annotated_type": "bool",
          "default": "False",
          "doc": null
        },
        {
          "name": "faiss_gpu_available",
          "kind": "positional_or_keyword",
          "annotated_type": "bool",
          "default": "False",
          "doc": null
        },
        {
          "name": "faiss_gpu_disabled_reason",
          "kind": "positional_or_keyword",
          "annotated_type": "str | None",
          "default": "None",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.capabilities.Capabilities.from_context",
      "short_name": "from_context",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "classmethod"
      ],
      "params": [
        {
          "name": "cls",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "context",
          "kind": "positional_or_keyword",
          "annotated_type": "ApplicationContext",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "Capabilities",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Build a capability snapshot from the provided application context.",
      "doc_raw": "Build a capability snapshot from the provided application context.\n\nReturns\n-------\nCapabilities\n    Snapshot computed from the context.",
      "docstyle": "google"
    },
    {
      "full_name": "app.capabilities.Capabilities.model_dump",
      "short_name": "model_dump",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "dict[str, object]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Return a JSON-serializable payload suitable for `/capz` responses.",
      "doc_raw": "Return a JSON-serializable payload suitable for `/capz` responses.\n\nReturns\n-------\ndict[str, object]\n    Structured capability payload.",
      "docstyle": "google"
    },
    {
      "full_name": "app.capabilities.Capabilities.has_symbols",
      "short_name": "has_symbols",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Return ``True`` when symbol MCP tools can be registered safely.",
      "doc_raw": "Return ``True`` when symbol MCP tools can be registered safely.\n\nReturns\n-------\nbool\n    Symbol capability flag.",
      "docstyle": "google"
    },
    {
      "full_name": "app.capabilities.Capabilities.has_semantic",
      "short_name": "has_semantic",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Return ``True`` when semantic MCP tools can be registered safely.",
      "doc_raw": "Return ``True`` when semantic MCP tools can be registered safely.\n\nReturns\n-------\nbool\n    Semantic capability flag.",
      "docstyle": "google"
    },
    {
      "full_name": "app.capabilities.Capabilities.faiss_gpu_disabled_reason",
      "short_name": "faiss_gpu_disabled_reason",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.capabilities.Capabilities.faiss_gpu_available",
      "short_name": "faiss_gpu_available",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.capabilities.Capabilities.torch_importable",
      "short_name": "torch_importable",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.capabilities.Capabilities.httpx_importable",
      "short_name": "httpx_importable",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.capabilities.Capabilities.duckdb_importable",
      "short_name": "duckdb_importable",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.capabilities.Capabilities.faiss_importable",
      "short_name": "faiss_importable",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.capabilities.Capabilities.xtr_index_present",
      "short_name": "xtr_index_present",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.capabilities.Capabilities.warp_index_present",
      "short_name": "warp_index_present",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.capabilities.Capabilities.coderank_index_present",
      "short_name": "coderank_index_present",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.capabilities.Capabilities.vllm_client",
      "short_name": "vllm_client",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.capabilities.Capabilities.scip_index",
      "short_name": "scip_index",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.capabilities.Capabilities.duckdb",
      "short_name": "duckdb",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.capabilities.Capabilities.faiss_index",
      "short_name": "faiss_index",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.capabilities._record_metrics",
      "short_name": "_record_metrics",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "payload",
          "kind": "positional_or_keyword",
          "annotated_type": "dict[str, object]",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Update Prometheus gauges with the latest capability snapshot.",
      "doc_raw": "Update Prometheus gauges with the latest capability snapshot.",
      "docstyle": "google"
    },
    {
      "full_name": "app.capabilities._path_exists",
      "short_name": "_path_exists",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "path",
          "kind": "positional_or_keyword",
          "annotated_type": "Path | None",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "bool",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Return True when ``path`` is populated and exists on the filesystem.",
      "doc_raw": "Return True when ``path`` is populated and exists on the filesystem.\n\nReturns\n-------\nbool\n    ``True`` when the path exists, otherwise ``False``.",
      "docstyle": "google"
    },
    {
      "full_name": "app.capabilities._probe_faiss_gpu",
      "short_name": "_probe_faiss_gpu",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "module",
          "kind": "positional_or_keyword",
          "annotated_type": "ModuleType | None",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "tuple[bool, str | None]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Return FAISS GPU availability and optional reason for failure.",
      "doc_raw": "Return FAISS GPU availability and optional reason for failure.\n\nReturns\n-------\ntuple[bool, str | None]\n    Availability flag and optional reason string.",
      "docstyle": "google"
    },
    {
      "full_name": "app.capabilities._import_optional",
      "short_name": "_import_optional",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "module_name",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "ModuleType | None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Return imported module when available, otherwise ``None``.",
      "doc_raw": "Return imported module when available, otherwise ``None``.\n\nReturns\n-------\nModuleType | None\n    Imported module instance or ``None`` when unavailable.",
      "docstyle": "google"
    },
    {
      "full_name": "app.capabilities.__all__",
      "short_name": "__all__",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.capabilities._CAPABILITY_GAUGES",
      "short_name": "_CAPABILITY_GAUGES",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.capabilities._build_capability_gauge",
      "short_name": "_build_capability_gauge",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "metric",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "description",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "GaugeLike",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.capabilities.LOGGER",
      "short_name": "LOGGER",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.scope_store",
      "short_name": "scope_store",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Scope store utilities for session state management.",
      "doc_raw": "Scope store utilities for session state management.",
      "docstyle": "google"
    },
    {
      "full_name": "app.scope_store.__all__",
      "short_name": "__all__",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.scope_store.ScopeStore",
      "short_name": "ScopeStore",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "redis_client",
          "kind": "positional_or_keyword",
          "annotated_type": "SupportsAsyncRedis",
          "default": null,
          "doc": null
        },
        {
          "name": "l1_maxsize",
          "kind": "keyword_only",
          "annotated_type": "int",
          "default": "256",
          "doc": null
        },
        {
          "name": "l1_ttl_seconds",
          "kind": "keyword_only",
          "annotated_type": "float | None",
          "default": "300.0",
          "doc": null
        },
        {
          "name": "l2_ttl_seconds",
          "kind": "keyword_only",
          "annotated_type": "int | None",
          "default": "3600",
          "doc": null
        },
        {
          "name": "key_prefix",
          "kind": "keyword_only",
          "annotated_type": "str",
          "default": "'scope'",
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Redis-backed scope store with L1/L2 caching and single-flight coalescing.",
      "doc_raw": "Redis-backed scope store with L1/L2 caching and single-flight coalescing.",
      "docstyle": "google"
    },
    {
      "full_name": "app.scope_store.ScopeStore._fetch_from_l2",
      "short_name": "_fetch_from_l2",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "session_id",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "ScopeIn | None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.scope_store.ScopeStore._redis_key",
      "short_name": "_redis_key",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "session_id",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "str",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.scope_store.ScopeStore.close",
      "short_name": "close",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Close underlying Redis resources.",
      "doc_raw": "Close underlying Redis resources.",
      "docstyle": "google"
    },
    {
      "full_name": "app.scope_store.ScopeStore.evict_l1",
      "short_name": "evict_l1",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "session_id",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Remove ``session_id`` from the L1 cache only.",
      "doc_raw": "Remove ``session_id`` from the L1 cache only.\n\nParameters\n----------\nsession_id : str\n    Session identifier to evict.\n\nRaises\n------\nValueError\n    If ``session_id`` is empty.",
      "docstyle": "google"
    },
    {
      "full_name": "app.scope_store.ScopeStore.delete",
      "short_name": "delete",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "session_id",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Remove cached scope for ``session_id`` from both layers.",
      "doc_raw": "Remove cached scope for ``session_id`` from both layers.\n\nParameters\n----------\nsession_id : str\n    Session identifier to remove.\n\nRaises\n------\nValueError\n    If ``session_id`` is empty.",
      "docstyle": "google"
    },
    {
      "full_name": "app.scope_store.ScopeStore.set",
      "short_name": "set",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "session_id",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "scope",
          "kind": "positional_or_keyword",
          "annotated_type": "ScopeIn",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Persist scope for ``session_id`` in both caches.",
      "doc_raw": "Persist scope for ``session_id`` in both caches.\n\nParameters\n----------\nsession_id : str\n    Session identifier to update.\nscope : ScopeIn\n    Scope payload to cache.\n\nRaises\n------\nValueError\n    If ``session_id`` is empty.",
      "docstyle": "google"
    },
    {
      "full_name": "app.scope_store.ScopeStore.get",
      "short_name": "get",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "session_id",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "ScopeIn | None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Retrieve scope for ``session_id``, favouring the L1 cache.",
      "doc_raw": "Retrieve scope for ``session_id``, favouring the L1 cache.\n\nParameters\n----------\nsession_id : str\n    Session identifier to retrieve.\n\nReturns\n-------\nScopeIn | None\n    Scope data when present; otherwise ``None``.\n\nRaises\n------\nValueError\n    If ``session_id`` is empty.",
      "docstyle": "google"
    },
    {
      "full_name": "app.scope_store.ScopeStore.metrics",
      "short_name": "metrics",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Return live cache metrics.",
      "doc_raw": "Return live cache metrics.",
      "docstyle": "google"
    },
    {
      "full_name": "app.scope_store.ScopeStore._key_prefix",
      "short_name": "_key_prefix",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.scope_store.ScopeStore._l2_ttl_seconds",
      "short_name": "_l2_ttl_seconds",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.scope_store.ScopeStore._metrics",
      "short_name": "_metrics",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.scope_store.ScopeStore._flight",
      "short_name": "_flight",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.scope_store.ScopeStore._l1",
      "short_name": "_l1",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.scope_store.ScopeStore._redis",
      "short_name": "_redis",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.scope_store.ScopeStore.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "redis_client",
          "kind": "positional_or_keyword",
          "annotated_type": "SupportsAsyncRedis",
          "default": null,
          "doc": null
        },
        {
          "name": "l1_maxsize",
          "kind": "keyword_only",
          "annotated_type": "int",
          "default": "256",
          "doc": null
        },
        {
          "name": "l1_ttl_seconds",
          "kind": "keyword_only",
          "annotated_type": "float | None",
          "default": "300.0",
          "doc": null
        },
        {
          "name": "l2_ttl_seconds",
          "kind": "keyword_only",
          "annotated_type": "int | None",
          "default": "3600",
          "doc": null
        },
        {
          "name": "key_prefix",
          "kind": "keyword_only",
          "annotated_type": "str",
          "default": "'scope'",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.scope_store.ScopeStoreMetrics",
      "short_name": "ScopeStoreMetrics",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "dataclass(slots=True, frozen=True)"
      ],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "l1_hits",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": "0",
          "doc": null
        },
        {
          "name": "l1_misses",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": "0",
          "doc": null
        },
        {
          "name": "l2_hits",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": "0",
          "doc": null
        },
        {
          "name": "l2_misses",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": "0",
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Runtime counters describing scope store cache performance.",
      "doc_raw": "Runtime counters describing scope store cache performance.",
      "docstyle": "google"
    },
    {
      "full_name": "app.scope_store.ScopeStoreMetrics.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "l1_hits",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": "0",
          "doc": null
        },
        {
          "name": "l1_misses",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": "0",
          "doc": null
        },
        {
          "name": "l2_hits",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": "0",
          "doc": null
        },
        {
          "name": "l2_misses",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": "0",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.scope_store.ScopeStoreMetrics.as_dict",
      "short_name": "as_dict",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "dict[str, float | int]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Return a serialisable snapshot of the metrics.",
      "doc_raw": "Return a serialisable snapshot of the metrics.\n\nReturns\n-------\ndict[str, float | int]\n    Dictionary containing counters and hit rates.",
      "docstyle": "google"
    },
    {
      "full_name": "app.scope_store.ScopeStoreMetrics.l2_hit_rate",
      "short_name": "l2_hit_rate",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Return the L2 hit rate as a floating point ratio.",
      "doc_raw": "Return the L2 hit rate as a floating point ratio.",
      "docstyle": "google"
    },
    {
      "full_name": "app.scope_store.ScopeStoreMetrics.l1_hit_rate",
      "short_name": "l1_hit_rate",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Return the L1 hit rate as a floating point ratio.",
      "doc_raw": "Return the L1 hit rate as a floating point ratio.",
      "docstyle": "google"
    },
    {
      "full_name": "app.scope_store.ScopeStoreMetrics.record_l2_miss",
      "short_name": "record_l2_miss",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "ScopeStoreMetrics",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Return a new metrics instance with an incremented L2 miss counter.",
      "doc_raw": "Return a new metrics instance with an incremented L2 miss counter.\n\nReturns\n-------\nScopeStoreMetrics\n    Fresh metrics snapshot reflecting the increment.",
      "docstyle": "google"
    },
    {
      "full_name": "app.scope_store.ScopeStoreMetrics.record_l2_hit",
      "short_name": "record_l2_hit",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "ScopeStoreMetrics",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Return a new metrics instance with an incremented L2 hit counter.",
      "doc_raw": "Return a new metrics instance with an incremented L2 hit counter.\n\nReturns\n-------\nScopeStoreMetrics\n    Fresh metrics snapshot reflecting the increment.",
      "docstyle": "google"
    },
    {
      "full_name": "app.scope_store.ScopeStoreMetrics.record_l1_miss",
      "short_name": "record_l1_miss",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "ScopeStoreMetrics",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Return a new metrics instance with an incremented L1 miss counter.",
      "doc_raw": "Return a new metrics instance with an incremented L1 miss counter.\n\nReturns\n-------\nScopeStoreMetrics\n    Fresh metrics snapshot reflecting the increment.",
      "docstyle": "google"
    },
    {
      "full_name": "app.scope_store.ScopeStoreMetrics.record_l1_hit",
      "short_name": "record_l1_hit",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "ScopeStoreMetrics",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Return a new metrics instance with an incremented L1 hit counter.",
      "doc_raw": "Return a new metrics instance with an incremented L1 hit counter.\n\nReturns\n-------\nScopeStoreMetrics\n    Fresh metrics snapshot reflecting the increment.",
      "docstyle": "google"
    },
    {
      "full_name": "app.scope_store.ScopeStoreMetrics.l2_misses",
      "short_name": "l2_misses",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.scope_store.ScopeStoreMetrics.l2_hits",
      "short_name": "l2_hits",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.scope_store.ScopeStoreMetrics.l1_misses",
      "short_name": "l1_misses",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.scope_store.ScopeStoreMetrics.l1_hits",
      "short_name": "l1_hits",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.scope_store.AsyncSingleFlight",
      "short_name": "AsyncSingleFlight",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Deduplicate concurrent coroutine execution keyed by ``KeyT``.",
      "doc_raw": "Deduplicate concurrent coroutine execution keyed by ``KeyT``.",
      "docstyle": "google"
    },
    {
      "full_name": "app.scope_store.AsyncSingleFlight._execute",
      "short_name": "_execute",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "key",
          "kind": "positional_or_keyword",
          "annotated_type": "KeyT",
          "default": null,
          "doc": null
        },
        {
          "name": "fn",
          "kind": "positional_or_keyword",
          "annotated_type": "Callable[[], Awaitable[ValueT]]",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "ValueT",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.scope_store.AsyncSingleFlight.do",
      "short_name": "do",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "key",
          "kind": "positional_or_keyword",
          "annotated_type": "KeyT",
          "default": null,
          "doc": null
        },
        {
          "name": "fn",
          "kind": "positional_or_keyword",
          "annotated_type": "Callable[[], Awaitable[ValueT]]",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "ValueT",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Execute ``fn`` once for all concurrent callers associated with ``key``.",
      "doc_raw": "Execute ``fn`` once for all concurrent callers associated with ``key``.\n\nParameters\n----------\nkey : KeyT\n    Deduplication key.\nfn : Callable[[], Awaitable[ValueT]]\n    Awaitable factory executed at most once while in-flight for ``key``.\n\nReturns\n-------\nValueT\n    Result produced by ``fn``.",
      "docstyle": "google"
    },
    {
      "full_name": "app.scope_store.AsyncSingleFlight._inflight",
      "short_name": "_inflight",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.scope_store.AsyncSingleFlight._lock",
      "short_name": "_lock",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.scope_store.AsyncSingleFlight.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.scope_store.LRUCache",
      "short_name": "LRUCache",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "maxsize",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": "256",
          "doc": null
        },
        {
          "name": "ttl_seconds",
          "kind": "positional_or_keyword",
          "annotated_type": "float | None",
          "default": "300.0",
          "doc": null
        },
        {
          "name": "now_fn",
          "kind": "keyword_only",
          "annotated_type": "Callable[[], float]",
          "default": "time.monotonic",
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Thread-safe least-recently-used cache with TTL-based eviction.",
      "doc_raw": "Thread-safe least-recently-used cache with TTL-based eviction.\n\nParameters\n----------\nmaxsize : int, optional\n    Maximum number of entries to retain. Must be positive.\nttl_seconds : float | None, optional\n    Time-to-live for each entry in seconds. When ``None``, entries never\n    expire due to age.\nnow_fn : Callable[[], float], optional\n    Injectable monotonic time source, primarily for testing. Defaults to\n    ``time.monotonic``.\n\nRaises\n------\nValueError\n    If ``maxsize`` is not positive or if ``ttl_seconds`` is provided but\n    not positive (when not ``None``).",
      "docstyle": "google"
    },
    {
      "full_name": "app.scope_store.LRUCache._has_expired",
      "short_name": "_has_expired",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "inserted_at",
          "kind": "positional_or_keyword",
          "annotated_type": "float",
          "default": null,
          "doc": null
        },
        {
          "name": "now",
          "kind": "positional_or_keyword",
          "annotated_type": "float",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "bool",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.scope_store.LRUCache._is_expired",
      "short_name": "_is_expired",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "record",
          "kind": "positional_or_keyword",
          "annotated_type": "_CacheRecord[ValueT]",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "bool",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.scope_store.LRUCache._purge_expired_entries",
      "short_name": "_purge_expired_entries",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.scope_store.LRUCache._enforce_size",
      "short_name": "_enforce_size",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.scope_store.LRUCache.snapshot",
      "short_name": "snapshot",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "MutableMapping[KeyT, ValueT]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Return a shallow copy of the cache contents.",
      "doc_raw": "Return a shallow copy of the cache contents.\n\nReturns\n-------\nMutableMapping[KeyT, ValueT]\n    Ordered mapping containing live cache entries.",
      "docstyle": "google"
    },
    {
      "full_name": "app.scope_store.LRUCache.items",
      "short_name": "items",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "Iterator[tuple[KeyT, ValueT]]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Yield current cache entries, purging expired ones as needed.",
      "doc_raw": "Yield current cache entries, purging expired ones as needed.\n\nYields\n------\ntuple[KeyT, ValueT]\n    Key-value pairs for each live cache entry in LRU order.",
      "docstyle": "google"
    },
    {
      "full_name": "app.scope_store.LRUCache.__len__",
      "short_name": "__len__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "int",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Return the number of live entries in the cache.",
      "doc_raw": "Return the number of live entries in the cache.\n\nReturns\n-------\nint\n    Count of entries that have not expired.",
      "docstyle": "google"
    },
    {
      "full_name": "app.scope_store.LRUCache.__contains__",
      "short_name": "__contains__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "key",
          "kind": "positional_or_keyword",
          "annotated_type": "object",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "bool",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Return ``True`` when ``key`` is present and not expired.",
      "doc_raw": "Return ``True`` when ``key`` is present and not expired.\n\nParameters\n----------\nkey : object\n    Candidate cache key.\n\nReturns\n-------\nbool\n    ``True`` if the key exists and has not expired; otherwise ``False``.",
      "docstyle": "google"
    },
    {
      "full_name": "app.scope_store.LRUCache.clear",
      "short_name": "clear",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Remove all entries from the cache.",
      "doc_raw": "Remove all entries from the cache.",
      "docstyle": "google"
    },
    {
      "full_name": "app.scope_store.LRUCache.delete",
      "short_name": "delete",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "key",
          "kind": "positional_or_keyword",
          "annotated_type": "KeyT",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Remove ``key`` from the cache if present.",
      "doc_raw": "Remove ``key`` from the cache if present.",
      "docstyle": "google"
    },
    {
      "full_name": "app.scope_store.LRUCache.set",
      "short_name": "set",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "key",
          "kind": "positional_or_keyword",
          "annotated_type": "KeyT",
          "default": null,
          "doc": null
        },
        {
          "name": "value",
          "kind": "positional_or_keyword",
          "annotated_type": "ValueT",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Insert or update ``key`` with ``value`` and refresh its recency.",
      "doc_raw": "Insert or update ``key`` with ``value`` and refresh its recency.",
      "docstyle": "google"
    },
    {
      "full_name": "app.scope_store.LRUCache.get",
      "short_name": "get",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "key",
          "kind": "positional_or_keyword",
          "annotated_type": "KeyT",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "ValueT | None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Return the cached value for ``key`` or ``None`` if it is missing or stale.",
      "doc_raw": "Return the cached value for ``key`` or ``None`` if it is missing or stale.\n\nParameters\n----------\nkey : KeyT\n    Cache key to retrieve.\n\nReturns\n-------\nValueT | None\n    Cached value when present and not expired; otherwise ``None``.",
      "docstyle": "google"
    },
    {
      "full_name": "app.scope_store.LRUCache._store",
      "short_name": "_store",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.scope_store.LRUCache._lock",
      "short_name": "_lock",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.scope_store.LRUCache._now",
      "short_name": "_now",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.scope_store.LRUCache._ttl_seconds",
      "short_name": "_ttl_seconds",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.scope_store.LRUCache._maxsize",
      "short_name": "_maxsize",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.scope_store.LRUCache.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "maxsize",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": "256",
          "doc": null
        },
        {
          "name": "ttl_seconds",
          "kind": "positional_or_keyword",
          "annotated_type": "float | None",
          "default": "300.0",
          "doc": null
        },
        {
          "name": "now_fn",
          "kind": "keyword_only",
          "annotated_type": "Callable[[], float]",
          "default": "time.monotonic",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.scope_store._CacheRecord",
      "short_name": "_CacheRecord",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "dataclass(slots=True, frozen=True)"
      ],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "value",
          "kind": "positional_or_keyword",
          "annotated_type": "ValueT",
          "default": null,
          "doc": null
        },
        {
          "name": "inserted_at",
          "kind": "positional_or_keyword",
          "annotated_type": "float",
          "default": null,
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Internal cache record containing a value and its insertion timestamp.",
      "doc_raw": "Internal cache record containing a value and its insertion timestamp.",
      "docstyle": "google"
    },
    {
      "full_name": "app.scope_store._CacheRecord.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "value",
          "kind": "positional_or_keyword",
          "annotated_type": "ValueT",
          "default": null,
          "doc": null
        },
        {
          "name": "inserted_at",
          "kind": "positional_or_keyword",
          "annotated_type": "float",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.scope_store._CacheRecord.inserted_at",
      "short_name": "inserted_at",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.scope_store._CacheRecord.value",
      "short_name": "value",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.scope_store.SupportsAsyncRedis",
      "short_name": "SupportsAsyncRedis",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [
        "Protocol"
      ],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Protocol describing the Redis operations required by ``ScopeStore``.",
      "doc_raw": "Protocol describing the Redis operations required by ``ScopeStore``.",
      "docstyle": "google"
    },
    {
      "full_name": "app.scope_store.SupportsAsyncRedis.close",
      "short_name": "close",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Close open Redis connections.",
      "doc_raw": "Close open Redis connections.",
      "docstyle": "google"
    },
    {
      "full_name": "app.scope_store.SupportsAsyncRedis.delete",
      "short_name": "delete",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "names",
          "kind": "var_positional",
          "annotated_type": "str",
          "default": "()",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "int | None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Delete ``key`` if present.",
      "doc_raw": "Delete ``key`` if present.",
      "docstyle": "google"
    },
    {
      "full_name": "app.scope_store.SupportsAsyncRedis.set",
      "short_name": "set",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "name",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "value",
          "kind": "positional_or_keyword",
          "annotated_type": "bytes",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "bool | None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Set ``key`` to ``value`` without TTL semantics.",
      "doc_raw": "Set ``key`` to ``value`` without TTL semantics.",
      "docstyle": "google"
    },
    {
      "full_name": "app.scope_store.SupportsAsyncRedis.setex",
      "short_name": "setex",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "name",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "time",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "value",
          "kind": "positional_or_keyword",
          "annotated_type": "bytes",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "bool | None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Set ``key`` to ``value`` with the provided TTL in seconds.",
      "doc_raw": "Set ``key`` to ``value`` with the provided TTL in seconds.",
      "docstyle": "google"
    },
    {
      "full_name": "app.scope_store.SupportsAsyncRedis.get",
      "short_name": "get",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "name",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "bytes | None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Retrieve a value by ``key``.",
      "doc_raw": "Retrieve a value by ``key``.",
      "docstyle": "google"
    },
    {
      "full_name": "app.scope_store.ScopeIn",
      "short_name": "ScopeIn",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.main",
      "short_name": "main",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "FastAPI application with MCP server mount.",
      "doc_raw": "FastAPI application with MCP server mount.\n\nProvides health/readiness endpoints, CORS, and streaming support.",
      "docstyle": "google"
    },
    {
      "full_name": "app.main.__all__",
      "short_name": "__all__",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.main.sse_demo",
      "short_name": "sse_demo",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "app.get('/sse')"
      ],
      "params": [],
      "returns": {
        "annotated_type": "StreamingResponse",
        "doc": null
      },
      "raises": [],
      "doc_summary": "SSE streaming demo endpoint.",
      "doc_raw": "SSE streaming demo endpoint.\n\nReturns\n-------\nStreamingResponse\n    Server-sent events stream.",
      "docstyle": "google"
    },
    {
      "full_name": "app.main.capz",
      "short_name": "capz",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "app.get('/capz')"
      ],
      "params": [
        {
          "name": "request",
          "kind": "positional_or_keyword",
          "annotated_type": "Request",
          "default": null,
          "doc": null
        },
        {
          "name": "refresh",
          "kind": "keyword_only",
          "annotated_type": "bool",
          "default": "False",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "JSONResponse",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Return a cached capability snapshot (refreshable via query flag).",
      "doc_raw": "Return a cached capability snapshot (refreshable via query flag).\n\nReturns\n-------\nJSONResponse\n    Capability payload.",
      "docstyle": "google"
    },
    {
      "full_name": "app.main.readyz",
      "short_name": "readyz",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "app.get('/readyz')"
      ],
      "params": [
        {
          "name": "request",
          "kind": "positional_or_keyword",
          "annotated_type": "Request",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "JSONResponse",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Readiness check endpoint.",
      "doc_raw": "Readiness check endpoint.\n\nVerifies that dependent services are available. This endpoint always returns\nHTTP 200, but the payload indicates whether all resources are healthy. Kubernetes\nreadiness probes should check the \"ready\" field in the response.\n\nParameters\n----------\nrequest : Request\n    FastAPI request object.\n\nReturns\n-------\nJSONResponse\n    Readiness status with detailed check results.",
      "docstyle": "google"
    },
    {
      "full_name": "app.main.healthz",
      "short_name": "healthz",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "app.get('/healthz')"
      ],
      "params": [],
      "returns": {
        "annotated_type": "JSONResponse",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Health check endpoint (network-only).",
      "doc_raw": "Health check endpoint (network-only).\n\nReturns\n-------\nJSONResponse\n    Health status.",
      "docstyle": "google"
    },
    {
      "full_name": "app.main.disable_nginx_buffering",
      "short_name": "disable_nginx_buffering",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "app.middleware('http')"
      ],
      "params": [
        {
          "name": "request",
          "kind": "positional_or_keyword",
          "annotated_type": "Request",
          "default": null,
          "doc": null
        },
        {
          "name": "call_next",
          "kind": "positional_or_keyword",
          "annotated_type": "Callable[[Request], Awaitable[Response]]",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "Response",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Disable NGINX buffering for streaming responses.",
      "doc_raw": "Disable NGINX buffering for streaming responses.\n\nThis middleware sets the X-Accel-Buffering header to \"no\" on all responses,\nwhich instructs NGINX to disable buffering and enable streaming. This is\ncritical for Server-Sent Events (SSE) and other streaming protocols where\nbackpressure and real-time delivery are important.\n\nThe middleware runs after the request handler executes, modifying the\nresponse headers before it's sent to the client. This ensures that NGINX\nwill stream the response directly to the client rather than buffering it\nin memory, which is essential for long-running streams and prevents memory\nissues with large responses.\n\nParameters\n----------\nrequest : Request\n    Incoming HTTP request from FastAPI/Starlette.\ncall_next : Callable[[Request], Awaitable[Response]]\n    Next middleware or route handler in the chain. This is an async callable\n    that takes a Request and returns an awaitable Response.\n\nReturns\n-------\nResponse\n    Response object with X-Accel-Buffering header set to \"no\". The response\n    is the same as returned by call_next, but with the streaming header added.",
      "docstyle": "google"
    },
    {
      "full_name": "app.main.set_mcp_context",
      "short_name": "set_mcp_context",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "app.middleware('http')"
      ],
      "params": [
        {
          "name": "request",
          "kind": "positional_or_keyword",
          "annotated_type": "Request",
          "default": null,
          "doc": null
        },
        {
          "name": "call_next",
          "kind": "positional_or_keyword",
          "annotated_type": "Callable[[Request], Awaitable[Response]]",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "Response",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Set ApplicationContext in context variable for MCP tool handlers.",
      "doc_raw": "Set ApplicationContext in context variable for MCP tool handlers.\n\nThis middleware sets the ApplicationContext in a context variable that\ncan be accessed by FastMCP tool handlers. FastMCP doesn't support Request\ninjection directly, so we use contextvars to pass the context.\n\nParameters\n----------\nrequest : Request\n    Incoming HTTP request from FastAPI/Starlette.\ncall_next : Callable[[Request], Awaitable[Response]]\n    Next middleware or route handler in the chain.\n\nReturns\n-------\nResponse\n    Response from the next handler.",
      "docstyle": "google"
    },
    {
      "full_name": "app.main.app",
      "short_name": "app",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.main.lifespan",
      "short_name": "lifespan",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "asynccontextmanager"
      ],
      "params": [
        {
          "name": "app",
          "kind": "positional_or_keyword",
          "annotated_type": "FastAPI",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "AsyncIterator[None]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Application lifespan manager with explicit configuration initialization.",
      "doc_raw": "Application lifespan manager with explicit configuration initialization.\n\nThis function runs during FastAPI startup and shutdown, managing the\nconfiguration lifecycle explicitly rather than relying on lazy loading.\n\nParameters\n----------\napp : FastAPI\n    FastAPI application instance. Used to store application context and\n    readiness probe in app.state.\n\nYields\n------\nNone\n    Control to the FastAPI application after successful initialization.\n\nRaises\n------\nConfigurationError\n    If configuration is invalid or required resources are missing.\n    FastAPI will fail to start, preventing broken deployment. The exception\n    includes RFC 9457 Problem Details with context fields for debugging.\n\nNotes\n-----\nStartup sequence:\n1. Load configuration from environment (fail fast if invalid)\n2. Perform GPU warmup sequence (verify CUDA/torch/FAISS GPU availability)\n3. Initialize long-lived clients (vLLM, FAISS manager)\n4. Initialize scope registry for session-scoped query constraints\n5. Run readiness checks (verify indexes exist, vLLM reachable)\n6. Optionally pre-load FAISS index (controlled by FAISS_PRELOAD env var)\n7. Start background pruning task for expired sessions\n\nShutdown sequence:\n1. Cancel background pruning task\n2. Clear readiness state\n3. Explicitly close any open resources",
      "docstyle": "google"
    },
    {
      "full_name": "app.main._shutdown_context",
      "short_name": "_shutdown_context",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "context",
          "kind": "positional_or_keyword",
          "annotated_type": "ApplicationContext | None",
          "default": null,
          "doc": null
        },
        {
          "name": "readiness",
          "kind": "positional_or_keyword",
          "annotated_type": "ReadinessProbe | None",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Shut down mutable runtimes and readiness probes.",
      "doc_raw": "Shut down mutable runtimes and readiness probes.",
      "docstyle": "google"
    },
    {
      "full_name": "app.main._initialize_context",
      "short_name": "_initialize_context",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "app",
          "kind": "positional_or_keyword",
          "annotated_type": "FastAPI",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "tuple[ApplicationContext, ReadinessProbe]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Initialize application context, readiness probe, and optional runtimes.",
      "doc_raw": "Initialize application context, readiness probe, and optional runtimes.\n\nExtended Summary\n----------------\nThis function orchestrates the application startup sequence by creating the\nApplicationContext, performing GPU warmup, initializing the readiness probe,\nand optionally pre-loading FAISS, XTR, and hybrid search runtimes. It stores\nthe context and readiness probe in the FastAPI app.state for access by request\nhandlers. This function is called once during application startup from the\nlifespan() context manager.\n\nParameters\n----------\napp : FastAPI\n    FastAPI application instance. Used to store application context and\n    readiness probe in app.state for access by request handlers.\n\nReturns\n-------\ntuple[ApplicationContext, ReadinessProbe]\n    Pair containing the initialized context and readiness probe. The context\n    contains all configuration and long-lived clients. The readiness probe\n    monitors the health of dependent services and resources.\n\nNotes\n-----\nTime complexity depends on runtime pre-loading configuration. GPU warmup and\noptional pre-loading operations may take several seconds. The function performs\nI/O operations (filesystem access, network requests for readiness checks) and\nmay allocate GPU resources. Thread-safe if called from a single async context\nduring startup. The function is not idempotent - it should only be called once\nper application lifecycle.\n\nThis function may propagate ConfigurationError from ApplicationContext.create()\nif application configuration is invalid or required resources are missing. The\nexception propagates to lifespan(), causing FastAPI startup to fail.\n\nExamples\n--------\n>>> # Called from lifespan() context manager\n>>> context, readiness = await _initialize_context(app)\n>>> assert context is not None\n>>> assert readiness is not None",
      "docstyle": "google"
    },
    {
      "full_name": "app.main._preload_hybrid_if_configured",
      "short_name": "_preload_hybrid_if_configured",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "context",
          "kind": "positional_or_keyword",
          "annotated_type": "ApplicationContext",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Preload HybridSearchEngine when toggle is enabled.",
      "doc_raw": "Preload HybridSearchEngine when toggle is enabled.",
      "docstyle": "google"
    },
    {
      "full_name": "app.main._preload_xtr_if_configured",
      "short_name": "_preload_xtr_if_configured",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "context",
          "kind": "positional_or_keyword",
          "annotated_type": "ApplicationContext",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Preload XTR runtime when toggle is enabled.",
      "doc_raw": "Preload XTR runtime when toggle is enabled.",
      "docstyle": "google"
    },
    {
      "full_name": "app.main._preload_faiss_if_configured",
      "short_name": "_preload_faiss_if_configured",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "context",
          "kind": "positional_or_keyword",
          "annotated_type": "ApplicationContext",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Preload FAISS indexes when configured to do so.",
      "doc_raw": "Preload FAISS indexes when configured to do so.",
      "docstyle": "google"
    },
    {
      "full_name": "app.main._log_gpu_warmup",
      "short_name": "_log_gpu_warmup",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "status",
          "kind": "positional_or_keyword",
          "annotated_type": "Mapping[str, object]",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Log the GPU warmup status summary.",
      "doc_raw": "Log the GPU warmup status summary.\n\nParameters\n----------\nstatus : Mapping[str, object]\n    Warmup status payload emitted by :func:`warmup_gpu`.",
      "docstyle": "google"
    },
    {
      "full_name": "app.main._env_flag",
      "short_name": "_env_flag",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "name",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "bool",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Return ``True`` when an environment flag is explicitly enabled.",
      "doc_raw": "Return ``True`` when an environment flag is explicitly enabled.\n\nParameters\n----------\nname : str\n    Environment variable name to inspect.\n\nReturns\n-------\nbool\n    ``True`` if the variable is set to a truthy value.",
      "docstyle": "google"
    },
    {
      "full_name": "app.main._preload_faiss_index",
      "short_name": "_preload_faiss_index",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "context",
          "kind": "positional_or_keyword",
          "annotated_type": "ApplicationContext",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "bool",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Pre-load FAISS index during startup to avoid first-request latency.",
      "doc_raw": "Pre-load FAISS index during startup to avoid first-request latency.\n\nParameters\n----------\ncontext : ApplicationContext\n    Application context containing FAISS manager.\n\nReturns\n-------\nbool\n    True if index loaded successfully, False otherwise.",
      "docstyle": "google"
    },
    {
      "full_name": "app.main.LOGGER",
      "short_name": "LOGGER",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.config_context",
      "short_name": "config_context",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Application-level configuration context manager.",
      "doc_raw": "Application-level configuration context manager.\n\nThis module provides centralized configuration lifecycle management for the\nCodeIntel MCP application. Instead of loading settings repeatedly from environment\nvariables on each request, configuration is loaded exactly once during FastAPI\napplication startup and shared across all request handlers via explicit dependency\ninjection.\n\nKey Components\n--------------\nResolvedPaths : dataclass\n    Canonicalized absolute filesystem paths for all application resources.\nApplicationContext : dataclass\n    Application-wide context holding configuration and long-lived clients.\nresolve_application_paths : function\n    Validates and resolves all configured paths relative to repository root.\n\nDesign Principles\n-----------------\n- **Load Once**: Configuration parsed from environment exactly once at startup\n- **Explicit Injection**: Context passed as parameter (no global state)\n- **Fail-Fast**: Invalid configuration prevents application startup\n- **Immutable**: Settings frozen after creation (thread-safe)\n- **RFC 9457**: All errors use Problem Details format\n\nExample Usage\n-------------\nDuring FastAPI application startup:\n\n>>> # In lifespan() function\n>>> context = ApplicationContext.create()\n>>> app.state.context = context\n\nIn request handlers:\n\n>>> # In MCP tool wrapper\n>>> context = request.app.state.context\n>>> files_adapter.list_paths(context, path=\"src\")\n\nSee Also\n--------\ncodeintel_rev.app.readiness : Readiness probe system for health checks\ncodeintel_rev.config.settings : Settings dataclasses and environment loading",
      "docstyle": "google"
    },
    {
      "full_name": "app.config_context.ApplicationContext",
      "short_name": "ApplicationContext",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "dataclass(slots=True, frozen=True)"
      ],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "settings",
          "kind": "positional_or_keyword",
          "annotated_type": "Settings",
          "default": null,
          "doc": null
        },
        {
          "name": "paths",
          "kind": "positional_or_keyword",
          "annotated_type": "ResolvedPaths",
          "default": null,
          "doc": null
        },
        {
          "name": "vllm_client",
          "kind": "positional_or_keyword",
          "annotated_type": "VLLMClient",
          "default": null,
          "doc": null
        },
        {
          "name": "faiss_manager",
          "kind": "positional_or_keyword",
          "annotated_type": "FAISSManager",
          "default": null,
          "doc": null
        },
        {
          "name": "scope_store",
          "kind": "positional_or_keyword",
          "annotated_type": "ScopeStore",
          "default": null,
          "doc": null
        },
        {
          "name": "duckdb_manager",
          "kind": "positional_or_keyword",
          "annotated_type": "DuckDBManager",
          "default": null,
          "doc": null
        },
        {
          "name": "git_client",
          "kind": "positional_or_keyword",
          "annotated_type": "GitClient",
          "default": null,
          "doc": null
        },
        {
          "name": "async_git_client",
          "kind": "positional_or_keyword",
          "annotated_type": "AsyncGitClient",
          "default": null,
          "doc": null
        },
        {
          "name": "runtime_observer",
          "kind": "positional_or_keyword",
          "annotated_type": "RuntimeCellObserver",
          "default": "NullRuntimeCellObserver()",
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Application-wide context holding all configuration and long-lived clients.",
      "doc_raw": "Application-wide context holding all configuration and long-lived clients.\n\nThis is the single source of truth for configuration throughout the application.\nIt's initialized once during FastAPI startup (in lifespan() function) and\ninjected into request handlers via app.state.\n\nThe context is NOT a global singleton - it's explicitly passed as a parameter\nto all functions that need it. This makes dependencies explicit and testing\nstraightforward.\n\nAttributes\n----------\nsettings : Settings\n    Immutable application settings loaded from environment variables. Frozen\n    after creation to ensure thread-safe access.\npaths : ResolvedPaths\n    Canonicalized filesystem paths for all resources (repo root, indexes, etc.).\n    All paths are absolute.\nvllm_client : VLLMClient\n    vLLM embedding service client with persistent HTTP connection pool.\n    Shared across all requests for efficiency.\nfaiss_manager : FAISSManager\n    FAISS index manager that handles CPU and GPU indexes. GPU resources are\n    lazily initialized on first search or optionally pre-loaded at startup.\nscope_store : ScopeStore\n    Redis-backed scope store for session-scoped query filters with L1/L2 caching.\nduckdb_manager : DuckDBManager\n    DuckDB manager for managing the DuckDB catalog database.\ngit_client : GitClient\n    Typed Git operations client using GitPython. Provides structured APIs for\n    blame and history operations without subprocess overhead. Lazy-initializes\n    Git repository on first access.\nasync_git_client : AsyncGitClient\n    Async wrapper around git_client for non-blocking Git operations. Runs\n    synchronous GitPython operations in threadpool via asyncio.to_thread.\nruntime_observer : RuntimeCellObserver\n    Observer instance that receives lifecycle callbacks from runtime cells\n    (hybrid engine, FAISS manager, XTR index). Defaults to NullRuntimeCellObserver\n    when not provided. Used for instrumentation, monitoring, and diagnostics.\n\nExamples\n--------\nCreate context during application startup:\n\n>>> context = ApplicationContext.create()\n>>> context.settings.paths.repo_root\n'/home/user/kgfoundry'\n\nUse context in adapter functions:\n\n>>> def list_paths(context: ApplicationContext, ...) -> dict:\n...     repo_root = context.paths.repo_root\n...     # ... use repo_root for file operations\n\nAccess from FastAPI request handler:\n\n>>> @app.get(\"/api/endpoint\")\n>>> async def handler(request: Request):\n...     context = request.app.state.context\n...     # ... use context\n\nNotes\n-----\nThe context is designed to be immutable after creation (settings and paths\nare frozen dataclasses). The FAISS manager and vLLM client maintain internal\nstate (connection pools, loaded indexes) but their configuration cannot be\nchanged after initialization.\n\nSee Also\n--------\nresolve_application_paths : Creates ResolvedPaths from Settings\nApplicationContext.create : Factory method for creating context",
      "docstyle": "google"
    },
    {
      "full_name": "app.config_context.ApplicationContext.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "settings",
          "kind": "positional_or_keyword",
          "annotated_type": "Settings",
          "default": null,
          "doc": null
        },
        {
          "name": "paths",
          "kind": "positional_or_keyword",
          "annotated_type": "ResolvedPaths",
          "default": null,
          "doc": null
        },
        {
          "name": "vllm_client",
          "kind": "positional_or_keyword",
          "annotated_type": "VLLMClient",
          "default": null,
          "doc": null
        },
        {
          "name": "faiss_manager",
          "kind": "positional_or_keyword",
          "annotated_type": "FAISSManager",
          "default": null,
          "doc": null
        },
        {
          "name": "scope_store",
          "kind": "positional_or_keyword",
          "annotated_type": "ScopeStore",
          "default": null,
          "doc": null
        },
        {
          "name": "duckdb_manager",
          "kind": "positional_or_keyword",
          "annotated_type": "DuckDBManager",
          "default": null,
          "doc": null
        },
        {
          "name": "git_client",
          "kind": "positional_or_keyword",
          "annotated_type": "GitClient",
          "default": null,
          "doc": null
        },
        {
          "name": "async_git_client",
          "kind": "positional_or_keyword",
          "annotated_type": "AsyncGitClient",
          "default": null,
          "doc": null
        },
        {
          "name": "runtime_observer",
          "kind": "positional_or_keyword",
          "annotated_type": "RuntimeCellObserver",
          "default": "NullRuntimeCellObserver()",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.config_context.ApplicationContext.close_all_runtimes",
      "short_name": "close_all_runtimes",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Best-effort shutdown for mutable runtimes.",
      "doc_raw": "Best-effort shutdown for mutable runtimes.",
      "docstyle": "google"
    },
    {
      "full_name": "app.config_context.ApplicationContext.with_overrides",
      "short_name": "with_overrides",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "settings",
          "kind": "keyword_only",
          "annotated_type": "Settings | None",
          "default": "None",
          "doc": null
        },
        {
          "name": "paths",
          "kind": "keyword_only",
          "annotated_type": "ResolvedPaths | None",
          "default": "None",
          "doc": null
        },
        {
          "name": "components",
          "kind": "var_keyword",
          "annotated_type": "object",
          "default": "{}",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "ApplicationContext",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Return a new context with the provided overrides.",
      "doc_raw": "Return a new context with the provided overrides.\n\nExtended Summary\n----------------\nThis method creates a new ApplicationContext instance with selective overrides\nto the current context's dependencies. It is used for testing, dependency injection,\nand creating specialized contexts (e.g., with mocked components or different\nconfiguration). The method preserves all non-overridden dependencies from the\ncurrent context, allowing incremental customization without full reinitialization.\nThis is particularly useful in test fixtures where specific components need to\nbe replaced while keeping the rest of the context intact.\n\nParameters\n----------\nsettings : Settings | None, optional\n    Application settings to override. If None, uses the current context's\n    settings. Defaults to None.\npaths : ResolvedPaths | None, optional\n    Resolved file system paths to override. If None, uses the current context's\n    paths. Defaults to None.\n**components : object\n    Keyword arguments for component overrides. Accepted keys are:\n    ``vllm_client``, ``faiss_manager``, ``scope_store``, ``duckdb_manager``,\n    ``git_client``, ``async_git_client``. Each override replaces the corresponding\n    component in the new context. Unsupported keys raise ValueError.\n\nReturns\n-------\nApplicationContext\n    Fresh context instance sharing the existing dependencies unless\n    overridden via keyword arguments. The new context is independent of the\n    original and can be modified without affecting it.\n\nRaises\n------\nValueError\n    If unsupported override keys are supplied in **components. Only the\n    accepted component names listed in Parameters are allowed.\n\nNotes\n-----\nTime complexity O(1) for context creation. Space complexity O(1) aside from\nthe new context object and any overridden components. The method performs no\nI/O and has no side effects. Thread-safe if all components are thread-safe.\nOverrides are shallow; nested component dependencies are not automatically\nupdated to match overridden components.",
      "docstyle": "google"
    },
    {
      "full_name": "app.config_context.ApplicationContext.open_catalog",
      "short_name": "open_catalog",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "contextmanager"
      ],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "Iterator[DuckDBCatalog]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Yield a DuckDB catalog context manager.",
      "doc_raw": "Yield a DuckDB catalog context manager.\n\nOpens a connection to the DuckDB catalog containing chunk metadata,\nyields the catalog instance for querying, and ensures the connection\nis closed even if an exception occurs.\n\nThe catalog provides SQL access to chunk metadata (URIs, line numbers,\npreview text) stored in Parquet files. It's used to hydrate FAISS\nsearch results with full chunk information.\n\nYields\n------\nDuckDBCatalog\n    Catalog instance with active database connection. Supports querying\n    by chunk IDs, URIs, and other metadata fields.\n\nExamples\n--------\n>>> with context.open_catalog() as catalog:\n...     chunks = catalog.query_by_ids([1, 2, 3])\n...     for chunk in chunks:\n...         print(chunk[\"uri\"], chunk[\"preview\"])\n\nNotes\n-----\nThe catalog connection is automatically closed when the context manager\nexits, even if an exception is raised. This ensures no connection leaks.\n\nSee Also\n--------\ncodeintel_rev.io.duckdb_catalog.DuckDBCatalog : Catalog implementation",
      "docstyle": "google"
    },
    {
      "full_name": "app.config_context.ApplicationContext.ensure_faiss_ready",
      "short_name": "ensure_faiss_ready",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "tuple[bool, list[str], str | None]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Load FAISS index (once) and attempt GPU clone.",
      "doc_raw": "Load FAISS index (once) and attempt GPU clone.\n\nThis method is thread-safe and idempotent. On first call, it loads the\nCPU index from disk. On subsequent calls, it returns cached state.\nGPU cloning is attempted once (if not already done during pre-loading).\n\nThe method is typically called from semantic search adapter on first\nsearch request (lazy loading) or optionally during application startup\n(eager loading controlled by FAISS_PRELOAD environment variable).\n\nReturns\n-------\ntuple[bool, list[str], str | None]\n    Three-element tuple:\n    - ready (bool): True if FAISS index is available for searching\n    - limits (list[str]): Warning messages about degraded mode (e.g.,\n      \"GPU unavailable\", \"Index not found\"). Empty list if fully ready.\n    - error (str | None): Error message if index loading failed, None\n      if successful or already loaded.\n\nExamples\n--------\n>>> context = ApplicationContext.create()\n>>> ready, limits, error = context.ensure_faiss_ready()\n>>> if ready:\n...     # Proceed with search\n...     results = context.faiss_manager.search(query_vector, k=20)\n... else:\n...     # Handle error (return error response to client)\n...     print(f\"FAISS unavailable: {error}\")\n\nNotes\n-----\nThe method uses a threading.Lock to ensure only one thread loads the\nindex even under concurrent requests. Subsequent calls skip loading\nand immediately return the cached state.\n\nGPU initialization failures are non-fatal - the method returns ready=True\nwith a warning in the limits list. Semantic search will fall back to\nCPU index automatically.",
      "docstyle": "google"
    },
    {
      "full_name": "app.config_context.ApplicationContext._build_hybrid_engine",
      "short_name": "_build_hybrid_engine",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "HybridSearchEngine",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Construct the hybrid search engine with dependency gates per channel.",
      "doc_raw": "Construct the hybrid search engine with dependency gates per channel.\n\nReturns\n-------\nHybridSearchEngine\n    Configured hybrid search engine instance.",
      "docstyle": "google"
    },
    {
      "full_name": "app.config_context.ApplicationContext._build_xtr_index",
      "short_name": "_build_xtr_index",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "XTRIndex",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Construct the XTR index runtime with artifact and dependency gates.",
      "doc_raw": "Construct the XTR index runtime with artifact and dependency gates.\n\nReturns\n-------\nXTRIndex\n    Ready XTR index instance.\n\nRaises\n------\nRuntimeUnavailableError\n    If configuration disables XTR or required artifacts/dependencies are missing.",
      "docstyle": "google"
    },
    {
      "full_name": "app.config_context.ApplicationContext._build_coderank_faiss_manager",
      "short_name": "_build_coderank_faiss_manager",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "vec_dim",
          "kind": "keyword_only",
          "annotated_type": "int",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "FAISSManager",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Construct the CodeRank FAISS manager with dependency gates.",
      "doc_raw": "Construct the CodeRank FAISS manager with dependency gates.\n\nExtended Summary\n----------------\nBuilds a FAISSManager instance for CodeRank vector search by\nvalidating the index path exists, ensuring FAISS is importable,\nand loading the pre-built index from disk. This method gates\naccess to the CodeRank runtime, failing fast if dependencies\nor resources are missing. The manager is configured with\napplication settings (nlist, cuvs preference) and loaded\ninto CPU memory for immediate use.\n\nParameters\n----------\nvec_dim : int\n    Vector dimensionality expected by the CodeRank index.\n    Must match the dimension used when the index was built.\n    Typically 768 or 1536 for transformer-based embeddings.\n\nReturns\n-------\nFAISSManager\n    Ready-to-use FAISS manager configured for the CodeRank index.\n    The index is loaded into CPU memory and ready for search queries.\n    GPU support is enabled if `use_cuvs` is True and CUDA is available.\n\nNotes\n-----\nTime O(1) for validation; index loading time depends on index size.\nThe manager loads the index synchronously; no lazy loading.\nGPU support (cuvs) is determined by application settings and\nruntime availability. This method is called during ApplicationContext\ninitialization, not per-request.\n\nMay propagate `RuntimeUnavailableError` from `_ensure_path_exists()`\nif the index path does not exist, or from `_require_dependency()`\nif the FAISS library cannot be imported.\n\nSee Also\n--------\nApplicationContext._build_xtr_index : Similar pattern for XTR index\ncodeintel_rev.io.faiss_manager.FAISSManager : Manager implementation",
      "docstyle": "google"
    },
    {
      "full_name": "app.config_context.ApplicationContext.get_xtr_index",
      "short_name": "get_xtr_index",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "XTRIndex | None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Return the lazily initialized XTR token index when enabled.",
      "doc_raw": "Return the lazily initialized XTR token index when enabled.\n\nReturns\n-------\nXTRIndex | None\n    Ready XTR index instance or ``None`` when disabled/unavailable.\n\nRaises\n------\nRuntimeUnavailableError\n    If configuration enables XTR but artifacts or dependencies are missing.",
      "docstyle": "google"
    },
    {
      "full_name": "app.config_context.ApplicationContext.get_coderank_faiss_manager",
      "short_name": "get_coderank_faiss_manager",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "vec_dim",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "FAISSManager",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Return a lazily loaded FAISS manager for CodeRank search.",
      "doc_raw": "Return a lazily loaded FAISS manager for CodeRank search.\n\nParameters\n----------\nvec_dim : int\n    Expected embedding dimension for the CodeRank index.\n\nReturns\n-------\nFAISSManager\n    Configured FAISS manager instance pointing to the CodeRank index.\n\nRaises\n------\nValueError\n    If ``vec_dim`` is non-positive or mismatched with the cached index.",
      "docstyle": "google"
    },
    {
      "full_name": "app.config_context.ApplicationContext.get_hybrid_engine",
      "short_name": "get_hybrid_engine",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "HybridSearchEngine",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Return the hybrid search engine, instantiating it lazily.",
      "doc_raw": "Return the hybrid search engine, instantiating it lazily.\n\nReturns\n-------\nHybridSearchEngine\n    Shared hybrid retrieval engine configured for the current settings.\n\nRaises\n------\nRuntimeError\n    If the engine fails to initialize.",
      "docstyle": "google"
    },
    {
      "full_name": "app.config_context.ApplicationContext._iter_runtime_cells",
      "short_name": "_iter_runtime_cells",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "tuple[tuple[str, RuntimeCell[Any]], ...]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Return managed runtime cells for diagnostics and cleanup.",
      "doc_raw": "Return managed runtime cells for diagnostics and cleanup.\n\nReturns\n-------\ntuple[tuple[str, RuntimeCell[Any]], ...]\n    Tuple of runtime cell name/value pairs.",
      "docstyle": "google"
    },
    {
      "full_name": "app.config_context.ApplicationContext.create",
      "short_name": "create",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "classmethod"
      ],
      "params": [
        {
          "name": "cls",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "runtime_observer",
          "kind": "keyword_only",
          "annotated_type": "RuntimeCellObserver | None",
          "default": "None",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "ApplicationContext",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Create application context from environment variables.",
      "doc_raw": "Create application context from environment variables.\n\nExtended Summary\n----------------\nThis is the primary way to create an ApplicationContext. It loads settings\nfrom environment variables, resolves and validates all filesystem paths,\ncreates long-lived HTTP and index manager clients, and logs successful\ninitialization with key configuration values. The method is designed to\nbe called exactly once during application startup (typically in the FastAPI\nlifespan() function). Configuration errors cause ConfigurationError to be\nraised by resolve_application_paths(), preventing application startup with\nclear error messages including RFC 9457 Problem Details.\n\nParameters\n----------\nruntime_observer : RuntimeCellObserver | None, optional\n    Observer instance that receives lifecycle callbacks from runtime cells\n    (hybrid engine, FAISS manager, XTR index). Used for instrumentation,\n    monitoring, and diagnostics. If None (default), uses NullRuntimeCellObserver\n    which suppresses all callbacks. Defaults to None.\n\nReturns\n-------\nApplicationContext\n    Initialized context with all clients and configuration ready. The context\n    is frozen after creation and thread-safe for concurrent access.\n\nExamples\n--------\n>>> # In FastAPI lifespan() function\n>>> @asynccontextmanager\n>>> async def lifespan(app: FastAPI):\n...     context = ApplicationContext.create()\n...     app.state.context = context\n...     yield\n\n>>> # With custom observer for instrumentation\n>>> observer = MyCustomObserver()\n>>> context = ApplicationContext.create(runtime_observer=observer)\n\nNotes\n-----\nTime complexity O(1) for context creation; I/O occurs during path resolution\nand client initialization. The method performs filesystem operations to validate\npaths and may establish network connections for HTTP clients. Thread-safe after\ncreation due to frozen dataclass design. The method is idempotent in the sense\nthat calling it multiple times creates independent contexts, but it should only\nbe called once per application lifecycle.\n\nThis method may propagate ConfigurationError from resolve_application_paths()\nif paths cannot be resolved or validated. The exception includes RFC 9457 Problem\nDetails with context fields for debugging (repo_root value, source environment\nvariable) and causes application startup to fail.\n\nSee Also\n--------\nload_settings : Loads Settings from environment variables\nresolve_application_paths : Validates and resolves paths",
      "docstyle": "google"
    },
    {
      "full_name": "app.config_context.ApplicationContext.__post_init__",
      "short_name": "__post_init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Attach the configured observer to all runtime cells.",
      "doc_raw": "Attach the configured observer to all runtime cells.",
      "docstyle": "google"
    },
    {
      "full_name": "app.config_context.ApplicationContext._runtime",
      "short_name": "_runtime",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.config_context.ApplicationContext.runtime_observer",
      "short_name": "runtime_observer",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.config_context.ApplicationContext.async_git_client",
      "short_name": "async_git_client",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.config_context.ApplicationContext.git_client",
      "short_name": "git_client",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.config_context.ApplicationContext.duckdb_manager",
      "short_name": "duckdb_manager",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.config_context.ApplicationContext.scope_store",
      "short_name": "scope_store",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.config_context.ApplicationContext.faiss_manager",
      "short_name": "faiss_manager",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.config_context.ApplicationContext.vllm_client",
      "short_name": "vllm_client",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.config_context.ApplicationContext.paths",
      "short_name": "paths",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.config_context.ApplicationContext.settings",
      "short_name": "settings",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.config_context._ContextRuntimeState",
      "short_name": "_ContextRuntimeState",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "dataclass(slots=True, frozen=True)"
      ],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "hybrid",
          "kind": "positional_or_keyword",
          "annotated_type": "RuntimeCell[HybridSearchEngine]",
          "default": "(lambda: RuntimeCell(name='hybrid-engine'))()",
          "doc": null
        },
        {
          "name": "coderank_faiss",
          "kind": "positional_or_keyword",
          "annotated_type": "RuntimeCell[FAISSManager]",
          "default": "(lambda: RuntimeCell(name='coderank-faiss'))()",
          "doc": null
        },
        {
          "name": "xtr",
          "kind": "positional_or_keyword",
          "annotated_type": "RuntimeCell[XTRIndex]",
          "default": "(lambda: RuntimeCell(name='xtr-index'))()",
          "doc": null
        },
        {
          "name": "faiss",
          "kind": "positional_or_keyword",
          "annotated_type": "_FaissRuntimeState",
          "default": "_FaissRuntimeState()",
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Mutable runtime state backing the frozen ApplicationContext.",
      "doc_raw": "Mutable runtime state backing the frozen ApplicationContext.",
      "docstyle": "google"
    },
    {
      "full_name": "app.config_context._ContextRuntimeState.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "hybrid",
          "kind": "positional_or_keyword",
          "annotated_type": "RuntimeCell[HybridSearchEngine]",
          "default": "(lambda: RuntimeCell(name='hybrid-engine'))()",
          "doc": null
        },
        {
          "name": "coderank_faiss",
          "kind": "positional_or_keyword",
          "annotated_type": "RuntimeCell[FAISSManager]",
          "default": "(lambda: RuntimeCell(name='coderank-faiss'))()",
          "doc": null
        },
        {
          "name": "xtr",
          "kind": "positional_or_keyword",
          "annotated_type": "RuntimeCell[XTRIndex]",
          "default": "(lambda: RuntimeCell(name='xtr-index'))()",
          "doc": null
        },
        {
          "name": "faiss",
          "kind": "positional_or_keyword",
          "annotated_type": "_FaissRuntimeState",
          "default": "_FaissRuntimeState()",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.config_context._ContextRuntimeState.iter_cells",
      "short_name": "iter_cells",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "tuple[tuple[str, RuntimeCell[Any]], ...]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Return ordered tuples of runtime cell names and instances.",
      "doc_raw": "Return ordered tuples of runtime cell names and instances.\n\nReturns\n-------\ntuple[tuple[str, RuntimeCell[Any]], ...]\n    Ordered collection of runtime cell name/value pairs.",
      "docstyle": "google"
    },
    {
      "full_name": "app.config_context._ContextRuntimeState.attach_observer",
      "short_name": "attach_observer",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "observer",
          "kind": "positional_or_keyword",
          "annotated_type": "RuntimeCellObserver",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Attach observer to each runtime cell.",
      "doc_raw": "Attach observer to each runtime cell.",
      "docstyle": "google"
    },
    {
      "full_name": "app.config_context._ContextRuntimeState.faiss",
      "short_name": "faiss",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.config_context._ContextRuntimeState.xtr",
      "short_name": "xtr",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.config_context._ContextRuntimeState.coderank_faiss",
      "short_name": "coderank_faiss",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.config_context._ContextRuntimeState.hybrid",
      "short_name": "hybrid",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.config_context._FaissRuntimeState",
      "short_name": "_FaissRuntimeState",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Runtime bookkeeping for FAISS initialization.",
      "doc_raw": "Runtime bookkeeping for FAISS initialization.",
      "docstyle": "google"
    },
    {
      "full_name": "app.config_context._FaissRuntimeState.gpu_attempted",
      "short_name": "gpu_attempted",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.config_context._FaissRuntimeState.loaded",
      "short_name": "loaded",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.config_context._FaissRuntimeState.lock",
      "short_name": "lock",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.config_context._FaissRuntimeState.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.config_context._FaissRuntimeState.__slots__",
      "short_name": "__slots__",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.config_context.T",
      "short_name": "T",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.config_context.resolve_application_paths",
      "short_name": "resolve_application_paths",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "settings",
          "kind": "positional_or_keyword",
          "annotated_type": "Settings",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "ResolvedPaths",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Resolve all configured paths to absolute paths.",
      "doc_raw": "Resolve all configured paths to absolute paths.\n\nConverts relative paths to absolute paths relative to repo_root, validates\nthat repo_root exists and is a directory, and returns a frozen dataclass\ncontaining all resolved paths.\n\nThis function is called once during application startup. Path resolution\nfailures cause ConfigurationError to be raised, which prevents the\napplication from starting.\n\nParameters\n----------\nsettings : Settings\n    Application settings containing path configuration loaded from\n    environment variables.\n\nReturns\n-------\nResolvedPaths\n    Fully resolved absolute paths for all application resources.\n\nRaises\n------\nConfigurationError\n    If repo_root does not exist, is not a directory, or cannot be accessed.\n    Error includes RFC 9457 Problem Details with context fields for\n    debugging (repo_root value, source environment variable).\n\nExamples\n--------\n>>> settings = Settings(\n...     paths=PathsConfig(\n...         repo_root=\"/home/user/kgfoundry\",\n...         data_dir=\"data\",\n...         faiss_index=\"data/faiss/code.ivfpq.faiss\",\n...     ),\n...     # ... other settings\n... )\n>>> paths = resolve_application_paths(settings)\n>>> paths.data_dir.is_absolute()\nTrue\n>>> paths.data_dir.parent == paths.repo_root\nTrue",
      "docstyle": "google"
    },
    {
      "full_name": "app.config_context.ResolvedPaths",
      "short_name": "ResolvedPaths",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "dataclass(slots=True, frozen=True)"
      ],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "repo_root",
          "kind": "positional_or_keyword",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        },
        {
          "name": "data_dir",
          "kind": "positional_or_keyword",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        },
        {
          "name": "vectors_dir",
          "kind": "positional_or_keyword",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        },
        {
          "name": "faiss_index",
          "kind": "positional_or_keyword",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        },
        {
          "name": "duckdb_path",
          "kind": "positional_or_keyword",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        },
        {
          "name": "scip_index",
          "kind": "positional_or_keyword",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        },
        {
          "name": "coderank_vectors_dir",
          "kind": "positional_or_keyword",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        },
        {
          "name": "coderank_faiss_index",
          "kind": "positional_or_keyword",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        },
        {
          "name": "warp_index_dir",
          "kind": "positional_or_keyword",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        },
        {
          "name": "xtr_dir",
          "kind": "positional_or_keyword",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Canonicalized filesystem paths for runtime operations.",
      "doc_raw": "Canonicalized filesystem paths for runtime operations.\n\nAll paths are absolute and resolved relative to repo_root. This eliminates\nambiguity and ensures consistent path handling throughout the application.\nPath resolution is performed once at application startup rather than on\neach request.\n\nAttributes\n----------\nrepo_root : Path\n    Absolute path to repository root directory. This is the base directory\n    for all source code and must exist before application startup.\ndata_dir : Path\n    Absolute path to base data directory containing indexes and databases.\nvectors_dir : Path\n    Absolute path to directory containing Parquet files with vector embeddings.\nfaiss_index : Path\n    Absolute path to FAISS IVF-PQ index file (CPU version).\nduckdb_path : Path\n    Absolute path to DuckDB catalog database file.\nscip_index : Path\n    Absolute path to SCIP index file (JSON or protobuf format).\ncoderank_vectors_dir : Path\n    Directory storing CodeRank chunk embeddings or shards.\ncoderank_faiss_index : Path\n    Path to the CodeRank FAISS index used for Stage-A retrieval.\nwarp_index_dir : Path\n    Directory containing WARP/XTR index artifacts.\nxtr_dir : Path\n    Directory containing XTR token-level artifacts (memmaps + metadata).\n\nExamples\n--------\nPaths are created during application startup:\n\n>>> settings = load_settings()\n>>> paths = resolve_application_paths(settings)\n>>> paths.repo_root\nPosixPath('/home/user/kgfoundry')\n>>> paths.faiss_index\nPosixPath('/home/user/kgfoundry/data/faiss/code.ivfpq.faiss')",
      "docstyle": "google"
    },
    {
      "full_name": "app.config_context.ResolvedPaths.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "repo_root",
          "kind": "positional_or_keyword",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        },
        {
          "name": "data_dir",
          "kind": "positional_or_keyword",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        },
        {
          "name": "vectors_dir",
          "kind": "positional_or_keyword",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        },
        {
          "name": "faiss_index",
          "kind": "positional_or_keyword",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        },
        {
          "name": "duckdb_path",
          "kind": "positional_or_keyword",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        },
        {
          "name": "scip_index",
          "kind": "positional_or_keyword",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        },
        {
          "name": "coderank_vectors_dir",
          "kind": "positional_or_keyword",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        },
        {
          "name": "coderank_faiss_index",
          "kind": "positional_or_keyword",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        },
        {
          "name": "warp_index_dir",
          "kind": "positional_or_keyword",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        },
        {
          "name": "xtr_dir",
          "kind": "positional_or_keyword",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.config_context.ResolvedPaths.xtr_dir",
      "short_name": "xtr_dir",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.config_context.ResolvedPaths.warp_index_dir",
      "short_name": "warp_index_dir",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.config_context.ResolvedPaths.coderank_faiss_index",
      "short_name": "coderank_faiss_index",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.config_context.ResolvedPaths.coderank_vectors_dir",
      "short_name": "coderank_vectors_dir",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.config_context.ResolvedPaths.scip_index",
      "short_name": "scip_index",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.config_context.ResolvedPaths.duckdb_path",
      "short_name": "duckdb_path",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.config_context.ResolvedPaths.faiss_index",
      "short_name": "faiss_index",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.config_context.ResolvedPaths.vectors_dir",
      "short_name": "vectors_dir",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.config_context.ResolvedPaths.data_dir",
      "short_name": "data_dir",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.config_context.ResolvedPaths.repo_root",
      "short_name": "repo_root",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.config_context._ensure_path_exists",
      "short_name": "_ensure_path_exists",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "path",
          "kind": "positional_or_keyword",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        },
        {
          "name": "runtime",
          "kind": "keyword_only",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "description",
          "kind": "keyword_only",
          "annotated_type": "str",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Validate that a filesystem path exists for a given runtime.",
      "doc_raw": "Validate that a filesystem path exists for a given runtime.\n\nExtended Summary\n----------------\nChecks filesystem existence of a required resource path (index files,\ndata directories, etc.) before constructing runtime components.\nUsed during ApplicationContext initialization to fail-fast when\nconfigured resources are missing. This prevents runtime errors\nduring request handling by catching missing resources at startup.\n\nParameters\n----------\npath : Path\n    Filesystem path to validate. Must be absolute or relative\n    to the repository root. Resolved via `pathlib.Path.resolve()`.\nruntime : str\n    Human-readable runtime identifier for error messages\n    (e.g., \"coderank-faiss\", \"xtr-index\").\ndescription : str\n    Brief description of what the path represents,\n    included in error messages (e.g., \"CodeRank FAISS index\").\n\nRaises\n------\nRuntimeUnavailableError\n    If ``path`` does not exist. The error includes the runtime\n    identifier, description, and the absolute path string.\n\nNotes\n-----\nTime O(1) filesystem stat; no I/O beyond existence check.\nThis is a fail-fast validation helper, not a lazy loader.\nPaths are expected to be pre-resolved by `resolve_application_paths()`.\n\nExamples\n--------\n>>> from pathlib import Path\n>>> import tempfile\n>>> # doctest: +SKIP\n>>> # Example with existing path (requires temp directory)\n>>> with tempfile.TemporaryDirectory() as tmpdir:\n...     _ensure_path_exists(Path(tmpdir), runtime=\"test\", description=\"temp\")\n>>> # Missing path raises error:\n>>> _ensure_path_exists(Path(\"/nonexistent/path/xyz\"), runtime=\"test\", description=\"index\")\nTraceback (most recent call last):\n    ...\nRuntimeUnavailableError: ...index not found...",
      "docstyle": "google"
    },
    {
      "full_name": "app.config_context._require_dependency",
      "short_name": "_require_dependency",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "module",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "runtime",
          "kind": "keyword_only",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "purpose",
          "kind": "keyword_only",
          "annotated_type": "str",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Ensure a heavy dependency is available, raising RuntimeUnavailableError.",
      "doc_raw": "Ensure a heavy dependency is available, raising RuntimeUnavailableError.\n\nExtended Summary\n----------------\nValidates that an optional runtime dependency can be imported before\nconstructing runtime components. This function gates access to heavy\ndependencies (e.g., FAISS, CUDA libraries) that may not be installed\nin all deployment environments. Used during ApplicationContext\ninitialization to fail-fast when required runtimes are unavailable.\n\nParameters\n----------\nmodule : str\n    Python module name to import (e.g., \"faiss\", \"cupy\").\n    Must be importable via `importlib.import_module()`.\nruntime : str\n    Human-readable runtime identifier for error messages\n    (e.g., \"coderank-faiss\", \"xtr-index\").\npurpose : str\n    Brief description of why this dependency is needed,\n    included in error messages for diagnostics.\n\nRaises\n------\nRuntimeUnavailableError\n    If ``module`` cannot be imported. The error includes the\n    runtime identifier, purpose, and underlying ImportError detail.\n\nNotes\n-----\nUses `gate_import()` from `kgfoundry_common.typing` to safely\nattempt the import. Time O(1); no I/O or state mutations.\nThis is a fail-fast validation helper, not a lazy loader.\n\nExamples\n--------\n>>> # doctest: +SKIP\n>>> # Example requires faiss to be installed\n>>> _require_dependency(\"faiss\", runtime=\"test\", purpose=\"vector search\")\n>>> # If module is not installed:\n>>> _require_dependency(\"nonexistent_module_xyz\", runtime=\"test\", purpose=\"demo\")\nTraceback (most recent call last):\n    ...\nRuntimeUnavailableError: ...test runtime unavailable: demo...",
      "docstyle": "google"
    },
    {
      "full_name": "app.config_context._import_xtr_index_cls",
      "short_name": "_import_xtr_index_cls",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": {
        "annotated_type": "type[XTRIndex]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Import ``XTRIndex`` lazily to avoid eager heavy dependencies.",
      "doc_raw": "Import ``XTRIndex`` lazily to avoid eager heavy dependencies.\n\nReturns\n-------\ntype[XTRIndex]\n    XTR index class.",
      "docstyle": "google"
    },
    {
      "full_name": "app.config_context._import_hybrid_engine_cls",
      "short_name": "_import_hybrid_engine_cls",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": {
        "annotated_type": "type[HybridSearchEngine]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Import ``HybridSearchEngine`` lazily for runtime cell initialization.",
      "doc_raw": "Import ``HybridSearchEngine`` lazily for runtime cell initialization.\n\nReturns\n-------\ntype[HybridSearchEngine]\n    Hybrid search engine class.",
      "docstyle": "google"
    },
    {
      "full_name": "app.config_context._import_faiss_manager_cls",
      "short_name": "_import_faiss_manager_cls",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": {
        "annotated_type": "type[FAISSManager]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Import ``FAISSManager`` lazily to keep module import costs low.",
      "doc_raw": "Import ``FAISSManager`` lazily to keep module import costs low.\n\nReturns\n-------\ntype[FAISSManager]\n    FAISS manager class implementation.",
      "docstyle": "google"
    },
    {
      "full_name": "app.config_context.__all__",
      "short_name": "__all__",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.config_context.LOGGER",
      "short_name": "LOGGER",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.gpu_warmup",
      "short_name": "gpu_warmup",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "GPU warmup and initialization sequence.",
      "doc_raw": "GPU warmup and initialization sequence.\n\nPerforms comprehensive GPU availability checks and warmup operations to ensure\nGPU is reachable and functional before expensive operations begin.",
      "docstyle": "google"
    },
    {
      "full_name": "app.gpu_warmup.warmup_gpu",
      "short_name": "warmup_gpu",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "lru_cache(maxsize=1)",
        "lru_cache(maxsize=1)"
      ],
      "params": [],
      "returns": {
        "annotated_type": "dict[str, bool | str]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Perform GPU warmup sequence to verify GPU availability and functionality.",
      "doc_raw": "Perform GPU warmup sequence to verify GPU availability and functionality.\n\nResults are cached after the first run; call ``warmup_gpu.cache_clear()`` in tests\nto force a re-run.\n\nChecks:\n1. CUDA availability via PyTorch\n2. FAISS GPU support\n3. Basic GPU tensor operations (torch)\n4. FAISS GPU resource initialization\n\nReturns\n-------\ndict[str, bool | str]\n    Dictionary with warmup results:\n    - ``cuda_available``: True if CUDA is available via PyTorch\n    - ``faiss_gpu_available``: True if FAISS GPU symbols are available\n    - ``torch_gpu_test``: True if basic torch GPU operations succeed\n    - ``faiss_gpu_test``: True if FAISS GPU resource initialization succeeds\n    - ``overall_status``: \"ready\" if all checks pass, \"degraded\" if some fail,\n      \"unavailable\" if all fail\n    - ``details``: Human-readable status message\n\nExamples\n--------\n>>> result = warmup_gpu()\n>>> if result[\"overall_status\"] == \"ready\":\n...     print(\"GPU is ready for use\")\n... else:\n...     print(f\"GPU status: {result['details']}\")",
      "docstyle": "google"
    },
    {
      "full_name": "app.gpu_warmup._test_faiss_gpu_resources",
      "short_name": "_test_faiss_gpu_resources",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": {
        "annotated_type": "tuple[bool, str]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Test FAISS GPU resource initialization.",
      "doc_raw": "Test FAISS GPU resource initialization.\n\nReturns\n-------\ntuple[bool, str]\n    (test_passed, status_message)",
      "docstyle": "google"
    },
    {
      "full_name": "app.gpu_warmup._test_torch_gpu_operations",
      "short_name": "_test_torch_gpu_operations",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": {
        "annotated_type": "tuple[bool, str]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Test basic GPU tensor operations using PyTorch.",
      "doc_raw": "Test basic GPU tensor operations using PyTorch.\n\nReturns\n-------\ntuple[bool, str]\n    (test_passed, status_message)",
      "docstyle": "google"
    },
    {
      "full_name": "app.gpu_warmup._check_faiss_gpu_support",
      "short_name": "_check_faiss_gpu_support",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": {
        "annotated_type": "tuple[bool, str]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Check FAISS GPU support.",
      "doc_raw": "Check FAISS GPU support.\n\nReturns\n-------\ntuple[bool, str]\n    (is_available, status_message)",
      "docstyle": "google"
    },
    {
      "full_name": "app.gpu_warmup._check_cuda_availability",
      "short_name": "_check_cuda_availability",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": {
        "annotated_type": "tuple[bool, str]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Check CUDA availability via PyTorch.",
      "doc_raw": "Check CUDA availability via PyTorch.\n\nReturns\n-------\ntuple[bool, str]\n    (is_available, status_message)",
      "docstyle": "google"
    },
    {
      "full_name": "app.gpu_warmup._MIN_CHECKS_FOR_DEGRADED",
      "short_name": "_MIN_CHECKS_FOR_DEGRADED",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.gpu_warmup._TOTAL_GPU_CHECKS",
      "short_name": "_TOTAL_GPU_CHECKS",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.gpu_warmup.__all__",
      "short_name": "__all__",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.gpu_warmup.LOGGER",
      "short_name": "LOGGER",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.middleware",
      "short_name": "middleware",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Session management middleware for CodeIntel MCP.",
      "doc_raw": "Session management middleware for CodeIntel MCP.\n\nThis module provides FastAPI middleware for extracting or generating session IDs\nand storing them in thread-local context variables for access by MCP tool adapters.\n\nKey Components\n--------------\nSessionScopeMiddleware : class\n    Middleware that processes X-Session-ID header and populates ContextVar.\nsession_id_var : ContextVar[str | None]\n    Thread-local storage for current request's session ID.\nget_session_id : function\n    Helper to retrieve session ID from ContextVar (raises if not set).\n\nDesign Principles\n-----------------\n- **Thread-Local Isolation**: ContextVar ensures session IDs don't leak across threads\n- **Fail-Safe Defaults**: Auto-generates UUID if client doesn't provide session ID\n- **FastMCP Compatibility**: Works around FastMCP's lack of Request injection in tools\n- **Explicit Dependencies**: No global state; session ID accessed via explicit get_session_id()\n\nMiddleware Flow\n---------------\n1. Extract X-Session-ID header from request\n2. Generate UUID if header absent\n3. Store in request.state.session_id (FastAPI convention)\n4. Store in session_id_var (ContextVar for thread-local access)\n5. Invoke next middleware/handler\n6. Return response (no header modification\u2014FastMCP limitation)\n\nExample Usage\n-------------\nRegister middleware in FastAPI application:\n\n>>> from codeintel_rev.app.middleware import SessionScopeMiddleware\n>>> app.add_middleware(SessionScopeMiddleware)\n\nAccess session ID in adapter:\n\n>>> from codeintel_rev.app.middleware import get_session_id\n>>> async def my_adapter(context: ApplicationContext, ...) -> dict:\n...     session_id = get_session_id()\n...     scope = await context.scope_store.get(session_id)\n...     # ... use scope\n\nSee Also\n--------\ncodeintel_rev.app.scope_store : ScopeStore for storing session scopes\ncodeintel_rev.mcp_server.scope_utils : Utilities for retrieving and merging scopes",
      "docstyle": "google"
    },
    {
      "full_name": "app.middleware.__all__",
      "short_name": "__all__",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.middleware.SessionScopeMiddleware",
      "short_name": "SessionScopeMiddleware",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [
        "BaseHTTPMiddleware"
      ],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "app",
          "kind": "positional_or_keyword",
          "annotated_type": "ASGIApp",
          "default": null,
          "doc": null
        },
        {
          "name": "dispatch",
          "kind": "positional_or_keyword",
          "annotated_type": "DispatchFunction | None",
          "default": "None",
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Middleware for session ID extraction and context storage.",
      "doc_raw": "Middleware for session ID extraction and context storage.\n\nProcesses every request to extract or generate a session ID, then stores\nit in both request.state (FastAPI convention) and a ContextVar (for\nFastMCP tool access). Session IDs enable stateful scope management across\nmultiple MCP tool calls within the same session.\n\nThis middleware is stateless and does not maintain any instance attributes.\n\nParameters\n----------\napp : ASGIApp\n    ASGI application to wrap with middleware.\ndispatch : DispatchFunction | None, optional\n    Optional custom dispatch function for the middleware. If None, uses the\n    default dispatch from BaseHTTPMiddleware. Defaults to None.\n\nNotes\n-----\nMiddleware Order:\n- SessionScopeMiddleware should be registered early in the middleware stack\n  (before tool handlers) to ensure session ID is available.\n- If other middleware needs session ID, register it after SessionScope.\n\nSession ID Generation:\n- UUIDs are generated using uuid.uuid4() (random, 122 bits of entropy).\n- Collision probability is negligible for practical session counts (<2^61).\n\nWhy Not Response Header:\n- FastMCP doesn't provide a way to customize response headers from tool\n  handlers, so we return session_id in the response body instead.\n- Future: If FastMCP adds response customization, add X-Session-ID header.\n\nExamples\n--------\nRegister middleware in application:\n\n>>> from fastapi import FastAPI\n>>> from codeintel_rev.app.middleware import SessionScopeMiddleware\n>>> app = FastAPI()\n>>> app.add_middleware(SessionScopeMiddleware)\n\nSend request with session ID:\n\n>>> import httpx\n>>> headers = {\"X-Session-ID\": \"my-custom-session-123\"}\n>>> response = httpx.post(\"/mcp/tools/set_scope\", headers=headers, ...)\n\nSend request without session ID (auto-generated):\n\n>>> response = httpx.post(\"/mcp/tools/set_scope\", ...)\n>>> session_id = response.json()[\"session_id\"]  # Use for subsequent requests",
      "docstyle": "google"
    },
    {
      "full_name": "app.middleware.SessionScopeMiddleware.dispatch",
      "short_name": "dispatch",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "request",
          "kind": "positional_or_keyword",
          "annotated_type": "Request",
          "default": null,
          "doc": null
        },
        {
          "name": "call_next",
          "kind": "positional_or_keyword",
          "annotated_type": "Callable[[Request], Awaitable[Response]]",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "Response",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Process request and inject session ID.",
      "doc_raw": "Process request and inject session ID.\n\nExtracts X-Session-ID header or generates UUID, stores in request.state\nand ContextVar, then invokes next middleware/handler.\n\nParameters\n----------\nrequest : Request\n    Starlette Request object with headers and state.\ncall_next : Callable[[Request], Awaitable[Response]]\n    Next middleware or route handler in the chain. Must be an async\n    callable that accepts a Request and returns an awaitable Response.\n\nReturns\n-------\nResponse\n    Response from downstream handler (unmodified).\n\nNotes\n-----\nThe middleware is async to support FastAPI's async route handlers.\nEven if adapters are sync functions, FastAPI wraps them in asyncio.to_thread.",
      "docstyle": "google"
    },
    {
      "full_name": "app.middleware.SessionScopeMiddleware._logger",
      "short_name": "_logger",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.middleware.SessionScopeMiddleware.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "app",
          "kind": "positional_or_keyword",
          "annotated_type": "ASGIApp",
          "default": null,
          "doc": null
        },
        {
          "name": "dispatch",
          "kind": "positional_or_keyword",
          "annotated_type": "DispatchFunction | None",
          "default": "None",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.middleware.get_session_id",
      "short_name": "get_session_id",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": {
        "annotated_type": "str",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Retrieve session ID from thread-local context.",
      "doc_raw": "Retrieve session ID from thread-local context.\n\nThis helper is called by adapters to access the session ID set by\nSessionScopeMiddleware. It should only be called within request handlers\u2014\ncalling it outside a request context raises RuntimeError.\n\nReturns\n-------\nstr\n    Session ID for the current request (UUID format).\n\nRaises\n------\nRuntimeError\n    If called outside request context (session ID not set by middleware).\n    This indicates middleware is not registered or adapter is called\n    directly without going through FastAPI request handling.\n\nExamples\n--------\nIn an adapter function:\n\n>>> async def my_adapter(context: ApplicationContext) -> dict:\n...     session_id = get_session_id()  # Retrieves from ContextVar\n...     scope = await context.scope_store.get(session_id)\n...     # ... process with scope\n\nOutside request context (error case):\n\n>>> get_session_id()  # doctest: +SKIP\nTraceback (most recent call last):\n    ...\nRuntimeError: Session ID not initialized\u2014ensure SessionScopeMiddleware is registered\n\nNotes\n-----\nContextVar provides thread-local storage that is automatically copied to\nchild tasks in asyncio, ensuring session ID propagates correctly through\nawait calls and background tasks spawned from the request handler.",
      "docstyle": "google"
    },
    {
      "full_name": "app.middleware.session_id_var",
      "short_name": "session_id_var",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.middleware.LOGGER",
      "short_name": "LOGGER",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.scope_registry",
      "short_name": "scope_registry",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Session-scoped scope registry for CodeIntel MCP (legacy helper).",
      "doc_raw": "Session-scoped scope registry for CodeIntel MCP (legacy helper).\n\nThis helper predates the Redis-backed :mod:`codeintel_rev.app.scope_store` that\nApplicationContext wires up automatically today. The registry is still available\nfor standalone tooling, but production adapters should use ``context.scope_store``\ndirectly rather than mutating ``ApplicationContext``.\n\nKey Components\n--------------\nScopeRegistry : class\n    Thread-safe registry mapping session IDs to ScopeIn dictionaries.\n\nDesign Principles\n-----------------\n- **Thread Safety**: Uses threading.RLock for concurrent access protection\n- **LRU Behavior**: Updates timestamps on access for activity-based expiration\n- **Immutable Results**: Returns copies of stored scopes to prevent mutation\n- **Fail-Safe**: Missing sessions return None rather than raising exceptions\n\nExample Usage\n--------------\nInitialize registry manually (e.g., in a short-lived script). When running the\nfull FastAPI app, use ``ApplicationContext.scope_store`` instead\u2014application\ncontexts are frozen and cannot be reassigned after creation.\n\n>>> registry = ScopeRegistry()\n>>> registry.set_scope(\"session\", {\"languages\": [\"python\"]})\n\nStore scope for a session:\n\n>>> session_id = \"abc123...\"\n>>> scope = {\"languages\": [\"python\"], \"include_globs\": [\"src/**\"]}\n>>> registry.set_scope(session_id, scope)\n\nRetrieve scope in adapter:\n\n>>> scope = registry.get_scope(session_id)\n>>> if scope:\n...     # Apply scope filters\n...     include_globs = scope.get(\"include_globs\")\n\nPrune expired sessions (background task):\n\n>>> pruned = registry.prune_expired(max_age_seconds=3600)\n>>> logger.info(f\"Pruned {pruned} expired sessions\")\n\nSee Also\n--------\ncodeintel_rev.app.middleware : Session ID extraction and ContextVar management\ncodeintel_rev.mcp_server.scope_utils : Scope merging and filtering utilities",
      "docstyle": "google"
    },
    {
      "full_name": "app.scope_registry.__all__",
      "short_name": "__all__",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.scope_registry.ScopeRegistry",
      "short_name": "ScopeRegistry",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Thread-safe registry for session-scoped query scopes.",
      "doc_raw": "Thread-safe registry for session-scoped query scopes.\n\nMaintains an in-memory mapping of session IDs to ScopeIn dictionaries with\nlast-accessed timestamps for LRU expiration. Designed for concurrent access\nfrom FastAPI request handlers running in a threadpool.\n\nNotes\n-----\nThe registry is NOT persistent\u2014server restart clears all sessions. For\npersistent scope storage, consider Redis or database backing (Phase 3+).\n\nPerformance characteristics:\n- set_scope: O(1) with lock acquisition overhead (~1\u03bcs)\n- get_scope: O(1) with lock acquisition + dict copy (~2\u03bcs)\n- prune_expired: O(n) where n = active session count\n\nThread safety:\n- All public methods acquire _lock before dict access.\n- RLock prevents deadlocks when methods call each other.\n- ContextVar in middleware ensures session ID isolation across threads.\n\nInternal attributes (not part of public API):\n- ``_scopes``: Internal storage: {session_id: (scope, last_accessed_timestamp)}.\n  Timestamps are from time.monotonic() for monotonic clock guarantees.\n- ``_lock``: Reentrant lock protecting dict operations. RLock allows same thread\n  to acquire lock multiple times (e.g., set_scope calls _update_timestamp).\n\nExamples\n--------\nCreate registry and store scope:\n\n>>> registry = ScopeRegistry()\n>>> session_id = \"test-session-123\"\n>>> scope = {\"languages\": [\"python\"], \"include_globs\": [\"**/*.py\"]}\n>>> registry.set_scope(session_id, scope)\n>>> retrieved = registry.get_scope(session_id)\n>>> retrieved == scope\nTrue\n\nScope expiration:\n\n>>> import time\n>>> registry.set_scope(\"old-session\", {\"languages\": [\"python\"]})\n>>> time.sleep(2)\n>>> pruned = registry.prune_expired(max_age_seconds=1)\n>>> pruned\n1\n>>> registry.get_scope(\"old-session\") is None\nTrue",
      "docstyle": "google"
    },
    {
      "full_name": "app.scope_registry.ScopeRegistry.get_session_count",
      "short_name": "get_session_count",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "int",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Return number of active sessions.",
      "doc_raw": "Return number of active sessions.\n\nUseful for monitoring and health checks. If count exceeds threshold\n(e.g., 10,000), it may indicate pruning failure or attack (session\nexhaustion).\n\nReturns\n-------\nint\n    Number of sessions currently in registry.\n\nExamples\n--------\n>>> registry = ScopeRegistry()\n>>> registry.get_session_count()\n0\n>>> registry.set_scope(\"session1\", {})\n>>> registry.set_scope(\"session2\", {})\n>>> registry.get_session_count()\n2",
      "docstyle": "google"
    },
    {
      "full_name": "app.scope_registry.ScopeRegistry.prune_expired",
      "short_name": "prune_expired",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "max_age_seconds",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "int",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Remove sessions inactive for longer than max_age_seconds.",
      "doc_raw": "Remove sessions inactive for longer than max_age_seconds.\n\nIterates all sessions and removes those whose last-accessed timestamp\nis older than threshold. This prevents memory leaks from abandoned\nsessions (e.g., clients that crash without cleanup).\n\nThe method is designed to be called from a background task (e.g.,\nevery 10 minutes) rather than on every request for performance.\n\nParameters\n----------\nmax_age_seconds : int\n    Inactivity threshold in seconds. Sessions with (current_time -\n    last_accessed) > max_age_seconds are removed. Typical value: 3600\n    (1 hour).\n\nReturns\n-------\nint\n    Number of sessions pruned.\n\nExamples\n--------\n>>> registry = ScopeRegistry()\n>>> registry.set_scope(\"session1\", {\"languages\": [\"python\"]})\n>>> import time\n>>> time.sleep(2)\n>>> pruned = registry.prune_expired(max_age_seconds=1)\n>>> pruned\n1\n>>> registry.get_scope(\"session1\") is None\nTrue\n\nNotes\n-----\nTime measurement uses time.monotonic() to avoid issues with system\nclock adjustments (e.g., NTP corrections, daylight saving).\n\nFor large session counts (>10K), consider incremental pruning: remove\na fixed number of oldest sessions per invocation rather than iterating\nall sessions at once.",
      "docstyle": "google"
    },
    {
      "full_name": "app.scope_registry.ScopeRegistry.clear_scope",
      "short_name": "clear_scope",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "session_id",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Remove scope for session.",
      "doc_raw": "Remove scope for session.\n\nDeletes session entry from registry. Subsequent get_scope calls for\nthis session will return None. Clearing non-existent sessions is a\nno-op (does not raise exception).\n\nParameters\n----------\nsession_id : str\n    Session identifier to remove.\n\nExamples\n--------\n>>> registry = ScopeRegistry()\n>>> registry.set_scope(\"session1\", {\"languages\": [\"python\"]})\n>>> registry.clear_scope(\"session1\")\n>>> registry.get_scope(\"session1\") is None\nTrue\n>>> registry.clear_scope(\"nonexistent\")  # No error\n\nNotes\n-----\nThis method is useful for explicit session cleanup (e.g., user logout).\nFor automatic cleanup, use prune_expired() in a background task.",
      "docstyle": "google"
    },
    {
      "full_name": "app.scope_registry.ScopeRegistry.get_scope",
      "short_name": "get_scope",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "session_id",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "ScopeIn | None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Retrieve scope for session.",
      "doc_raw": "Retrieve scope for session.\n\nReturns a copy of the stored scope to prevent caller mutations from\naffecting registry state. Updates last-accessed timestamp for LRU\ntracking (accessed sessions are less likely to be pruned).\n\nParameters\n----------\nsession_id : str\n    Session identifier to look up.\n\nReturns\n-------\nScopeIn | None\n    Copy of stored scope if session exists, None otherwise.\n\nExamples\n--------\n>>> registry = ScopeRegistry()\n>>> registry.set_scope(\"session1\", {\"languages\": [\"python\"]})\n>>> scope = registry.get_scope(\"session1\")\n>>> scope\n{'languages': ['python']}\n>>> registry.get_scope(\"nonexistent\") is None\nTrue\n\nNotes\n-----\nReturning None for missing sessions allows adapters to gracefully\nfall back to \"no scope\" behavior without catching exceptions.",
      "docstyle": "google"
    },
    {
      "full_name": "app.scope_registry.ScopeRegistry.set_scope",
      "short_name": "set_scope",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "session_id",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "scope",
          "kind": "positional_or_keyword",
          "annotated_type": "ScopeIn",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Store scope for session.",
      "doc_raw": "Store scope for session.\n\nCreates or updates session entry with current timestamp. If session\nalready exists, overwrites previous scope (last-write-wins semantics).\n\nParameters\n----------\nsession_id : str\n    Unique session identifier (typically UUID from middleware).\nscope : ScopeIn\n    Scope configuration to store. May contain repos, branches, globs,\n    languages. Empty dict is valid (means \"no filters\").\n\nExamples\n--------\n>>> registry = ScopeRegistry()\n>>> registry.set_scope(\"session1\", {\"languages\": [\"python\"]})\n>>> registry.set_scope(\"session2\", {\"include_globs\": [\"src/**\"]})\n\nNotes\n-----\nThe method stores a deep copy of the scope dict, preventing subsequent\ncaller mutations from affecting the cached value. Callers may safely\nreuse or modify the original scope object after calling ``set_scope``.",
      "docstyle": "google"
    },
    {
      "full_name": "app.scope_registry.ScopeRegistry._lock",
      "short_name": "_lock",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.scope_registry.ScopeRegistry._scopes",
      "short_name": "_scopes",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.scope_registry.ScopeRegistry.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.scope_registry._scope_operations_total",
      "short_name": "_scope_operations_total",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.scope_registry._active_sessions_gauge",
      "short_name": "_active_sessions_gauge",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "app.scope_registry.LOGGER",
      "short_name": "LOGGER",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "bin",
      "short_name": "bin",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "CLI entry points for CodeIntel MCP indexing pipelines.",
      "doc_raw": "CLI entry points for CodeIntel MCP indexing pipelines.",
      "docstyle": "google"
    },
    {
      "full_name": "bin.index_all",
      "short_name": "index_all",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "One-shot indexing: SCIP \u2192 chunk \u2192 embed \u2192 Parquet \u2192 FAISS.",
      "doc_raw": "One-shot indexing: SCIP \u2192 chunk \u2192 embed \u2192 Parquet \u2192 FAISS.\n\nThis script orchestrates the full indexing pipeline:\n1. Parse SCIP index for symbol definitions\n2. Chunk files using cAST (SCIP-based)\n3. Embed chunks with vLLM\n4. Write to Parquet with embeddings\n5. Build FAISS index with adaptive type selection\n\nThe FAISS index type is automatically selected based on corpus size:\n- Small (<5K vectors): Flat index (exact search, fast training)\n- Medium (5K-50K vectors): IVFFlat (balanced training/recall)\n- Large (>50K vectors): IVF-PQ (memory efficient, fast search)",
      "docstyle": "google"
    },
    {
      "full_name": "bin.index_all._write_symbols",
      "short_name": "_write_symbols",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "paths",
          "kind": "positional_or_keyword",
          "annotated_type": "PipelinePaths",
          "default": null,
          "doc": null
        },
        {
          "name": "index",
          "kind": "positional_or_keyword",
          "annotated_type": "SCIPIndex",
          "default": null,
          "doc": null
        },
        {
          "name": "chunks",
          "kind": "positional_or_keyword",
          "annotated_type": "Sequence[Chunk]",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Derive symbol tables and persist them into DuckDB.",
      "doc_raw": "Derive symbol tables and persist them into DuckDB.",
      "docstyle": "google"
    },
    {
      "full_name": "bin.index_all._initialize_duckdb",
      "short_name": "_initialize_duckdb",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "paths",
          "kind": "positional_or_keyword",
          "annotated_type": "PipelinePaths",
          "default": null,
          "doc": null
        },
        {
          "name": "materialize",
          "kind": "keyword_only",
          "annotated_type": "bool",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "int",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Create or refresh the DuckDB catalog and return the chunk count.",
      "doc_raw": "Create or refresh the DuckDB catalog and return the chunk count.\n\nParameters\n----------\npaths : PipelinePaths\n    Pipeline paths configuration.\nmaterialize : bool\n    Whether to materialize Parquet data into a DuckDB table with indexes.\n\nReturns\n-------\nint\n    Number of chunk records registered in the catalog.",
      "docstyle": "google"
    },
    {
      "full_name": "bin.index_all._update_faiss_index_incremental",
      "short_name": "_update_faiss_index_incremental",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "chunks",
          "kind": "positional_or_keyword",
          "annotated_type": "Sequence[Chunk]",
          "default": null,
          "doc": null
        },
        {
          "name": "embeddings",
          "kind": "positional_or_keyword",
          "annotated_type": "NDArrayF32",
          "default": null,
          "doc": null
        },
        {
          "name": "paths",
          "kind": "positional_or_keyword",
          "annotated_type": "PipelinePaths",
          "default": null,
          "doc": null
        },
        {
          "name": "index_config",
          "kind": "positional_or_keyword",
          "annotated_type": "IndexConfig",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Update FAISS index incrementally by adding new chunks to secondary index.",
      "doc_raw": "Update FAISS index incrementally by adding new chunks to secondary index.\n\nLoads existing primary index and identifies new chunks that aren't already\nindexed. Adds new chunks to the secondary flat index for fast incremental\nupdates without rebuilding the primary index.\n\nParameters\n----------\nchunks : Sequence[Chunk]\n    All chunks from the current indexing run.\nembeddings : NDArrayF32\n    Embedding vectors aligned with chunks.\npaths : PipelinePaths\n    Pipeline paths configuration.\nindex_config : IndexConfig\n    FAISS index configuration.\n\nRaises\n------\nFileNotFoundError\n    If the primary index does not exist. Use full rebuild mode first.\nRuntimeError\n    If embeddings are empty or index loading fails.",
      "docstyle": "google"
    },
    {
      "full_name": "bin.index_all._build_faiss_index",
      "short_name": "_build_faiss_index",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "embeddings",
          "kind": "positional_or_keyword",
          "annotated_type": "NDArrayF32",
          "default": null,
          "doc": null
        },
        {
          "name": "paths",
          "kind": "positional_or_keyword",
          "annotated_type": "PipelinePaths",
          "default": null,
          "doc": null
        },
        {
          "name": "index_config",
          "kind": "positional_or_keyword",
          "annotated_type": "IndexConfig",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Train and persist the FAISS index with adaptive type selection.",
      "doc_raw": "Train and persist the FAISS index with adaptive type selection.\n\nThe index type is automatically selected based on corpus size for optimal\nperformance. Small corpora use flat indexes (fast training), medium corpora\nuse IVFFlat (balanced), and large corpora use IVF-PQ (memory efficient).\n\nParameters\n----------\nembeddings : NDArrayF32\n    Embedding vectors to index.\npaths : PipelinePaths\n    Pipeline paths configuration.\nindex_config : IndexConfig\n    FAISS index configuration.\n\nRaises\n------\nRuntimeError\n    If embeddings are empty and the index cannot be trained.",
      "docstyle": "google"
    },
    {
      "full_name": "bin.index_all._write_parquet",
      "short_name": "_write_parquet",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "chunks",
          "kind": "positional_or_keyword",
          "annotated_type": "Sequence[Chunk]",
          "default": null,
          "doc": null
        },
        {
          "name": "embeddings",
          "kind": "positional_or_keyword",
          "annotated_type": "NDArrayF32",
          "default": null,
          "doc": null
        },
        {
          "name": "paths",
          "kind": "positional_or_keyword",
          "annotated_type": "PipelinePaths",
          "default": null,
          "doc": null
        },
        {
          "name": "vec_dim",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "preview_max_chars",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "Path",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Persist chunk metadata and embeddings to Parquet.",
      "doc_raw": "Persist chunk metadata and embeddings to Parquet.\n\nParameters\n----------\nchunks : Sequence[Chunk]\n    Chunks to persist.\nembeddings : NDArrayF32\n    Embedding vectors aligned with chunks.\npaths : PipelinePaths\n    Pipeline paths configuration.\nvec_dim : int\n    Embedding vector dimension.\npreview_max_chars : int\n    Maximum number of characters to persist in chunk previews.\n\nReturns\n-------\nPath\n    Path to the written Parquet file containing chunk data.",
      "docstyle": "google"
    },
    {
      "full_name": "bin.index_all._embed_chunks",
      "short_name": "_embed_chunks",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "chunks",
          "kind": "positional_or_keyword",
          "annotated_type": "Sequence[Chunk]",
          "default": null,
          "doc": null
        },
        {
          "name": "config",
          "kind": "positional_or_keyword",
          "annotated_type": "VLLMConfig",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "NDArrayF32",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Generate embeddings for the supplied chunks using vLLM.",
      "doc_raw": "Generate embeddings for the supplied chunks using vLLM.\n\nParameters\n----------\nchunks : Sequence[Chunk]\n    Chunks to embed.\nconfig : VLLMConfig\n    vLLM client configuration.\n\nReturns\n-------\nNDArrayF32\n    Embedding matrix aligned with the chunk order.",
      "docstyle": "google"
    },
    {
      "full_name": "bin.index_all._chunk_repository",
      "short_name": "_chunk_repository",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "paths",
          "kind": "positional_or_keyword",
          "annotated_type": "PipelinePaths",
          "default": null,
          "doc": null
        },
        {
          "name": "definitions_by_file",
          "kind": "positional_or_keyword",
          "annotated_type": "Mapping[str, Sequence[SymbolDef]]",
          "default": null,
          "doc": null
        },
        {
          "name": "budget",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "list[Chunk]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Chunk all files referenced by the SCIP index.",
      "doc_raw": "Chunk all files referenced by the SCIP index.\n\nParameters\n----------\npaths : PipelinePaths\n    Pipeline paths configuration.\ndefinitions_by_file : Mapping[str, Sequence[SymbolDef]]\n    Symbol definitions grouped by file path.\nbudget : int\n    Character budget per chunk.\n\nReturns\n-------\nlist[Chunk]\n    Collection of generated chunks across the repository.",
      "docstyle": "google"
    },
    {
      "full_name": "bin.index_all._group_definitions_by_file",
      "short_name": "_group_definitions_by_file",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "index",
          "kind": "positional_or_keyword",
          "annotated_type": "SCIPIndex",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "Mapping[str, list[SymbolDef]]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Group symbol definitions by their relative file path.",
      "doc_raw": "Group symbol definitions by their relative file path.\n\nParameters\n----------\nindex : SCIPIndex\n    SCIP index containing symbol definitions.\n\nReturns\n-------\nMapping[str, list[SymbolDef]]\n    Definitions grouped by file path for downstream chunking.",
      "docstyle": "google"
    },
    {
      "full_name": "bin.index_all._load_scip_index",
      "short_name": "_load_scip_index",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "paths",
          "kind": "positional_or_keyword",
          "annotated_type": "PipelinePaths",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "SCIPIndex",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Load and parse the SCIP index from disk.",
      "doc_raw": "Load and parse the SCIP index from disk.\n\nParameters\n----------\npaths : PipelinePaths\n    Pipeline paths configuration containing SCIP index location.\n\nReturns\n-------\nSCIPIndex\n    Parsed SCIP index containing all documents and occurrences.\n\nRaises\n------\nFileNotFoundError\n    If the configured SCIP index file does not exist.",
      "docstyle": "google"
    },
    {
      "full_name": "bin.index_all._resolve_paths",
      "short_name": "_resolve_paths",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "settings",
          "kind": "positional_or_keyword",
          "annotated_type": "Settings",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "PipelinePaths",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Resolve and normalize key filesystem paths.",
      "doc_raw": "Resolve and normalize key filesystem paths.\n\nParameters\n----------\nsettings : Settings\n    Application settings containing path configuration.\n\nReturns\n-------\nPipelinePaths\n    Absolute paths for all filesystem locations used by the pipeline.",
      "docstyle": "google"
    },
    {
      "full_name": "bin.index_all.main",
      "short_name": "main",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Run the end-to-end indexing pipeline.",
      "doc_raw": "Run the end-to-end indexing pipeline.\n\nSupports both full rebuild (default) and incremental update modes.\nUse --incremental to add new chunks to an existing index instead of rebuilding.",
      "docstyle": "google"
    },
    {
      "full_name": "bin.index_all.PipelinePaths",
      "short_name": "PipelinePaths",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "dataclass(frozen=True)"
      ],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "repo_root",
          "kind": "positional_or_keyword",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        },
        {
          "name": "scip_index",
          "kind": "positional_or_keyword",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        },
        {
          "name": "vectors_dir",
          "kind": "positional_or_keyword",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        },
        {
          "name": "faiss_index",
          "kind": "positional_or_keyword",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        },
        {
          "name": "duckdb_path",
          "kind": "positional_or_keyword",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Resolved filesystem paths for the indexing pipeline.",
      "doc_raw": "Resolved filesystem paths for the indexing pipeline.",
      "docstyle": "google"
    },
    {
      "full_name": "bin.index_all.PipelinePaths.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "repo_root",
          "kind": "positional_or_keyword",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        },
        {
          "name": "scip_index",
          "kind": "positional_or_keyword",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        },
        {
          "name": "vectors_dir",
          "kind": "positional_or_keyword",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        },
        {
          "name": "faiss_index",
          "kind": "positional_or_keyword",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        },
        {
          "name": "duckdb_path",
          "kind": "positional_or_keyword",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "bin.index_all.PipelinePaths.duckdb_path",
      "short_name": "duckdb_path",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "bin.index_all.PipelinePaths.faiss_index",
      "short_name": "faiss_index",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "bin.index_all.PipelinePaths.vectors_dir",
      "short_name": "vectors_dir",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "bin.index_all.PipelinePaths.scip_index",
      "short_name": "scip_index",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "bin.index_all.PipelinePaths.repo_root",
      "short_name": "repo_root",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "bin.index_all.TRAINING_LIMIT",
      "short_name": "TRAINING_LIMIT",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "bin.index_all.EMBED_PREVIEW_CHARS",
      "short_name": "EMBED_PREVIEW_CHARS",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "bin.index_all.logger",
      "short_name": "logger",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "cache",
      "short_name": "cache",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Interfaces for caching results within the CodeIntel MCP stack.",
      "doc_raw": "Interfaces for caching results within the CodeIntel MCP stack.",
      "docstyle": "google"
    },
    {
      "full_name": "cli",
      "short_name": "cli",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Entry point aggregating CodeIntel CLI subcommands.",
      "doc_raw": "Entry point aggregating CodeIntel CLI subcommands.",
      "docstyle": "google"
    },
    {
      "full_name": "cli.main",
      "short_name": "main",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Run the aggregated CodeIntel CLI.",
      "doc_raw": "Run the aggregated CodeIntel CLI.",
      "docstyle": "google"
    },
    {
      "full_name": "cli.app",
      "short_name": "app",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "cli.xtr",
      "short_name": "xtr",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Backward-compatible entrypoint for the XTR Typer CLI.",
      "doc_raw": "Backward-compatible entrypoint for the XTR Typer CLI.",
      "docstyle": "google"
    },
    {
      "full_name": "cli.xtr.__all__",
      "short_name": "__all__",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "cli.splade",
      "short_name": "splade",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Command-line interface for SPLADE artifact management.",
      "doc_raw": "Command-line interface for SPLADE artifact management.",
      "docstyle": "google"
    },
    {
      "full_name": "cli.splade.main",
      "short_name": "main",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Run the SPLADE CLI directly.",
      "doc_raw": "Run the SPLADE CLI directly.",
      "docstyle": "google"
    },
    {
      "full_name": "cli.splade.bench",
      "short_name": "bench",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "app.command('bench')"
      ],
      "params": [
        {
          "name": "query",
          "kind": "keyword_only",
          "annotated_type": "str | None",
          "default": "QUERY_OPTION",
          "doc": null
        },
        {
          "name": "queries_file",
          "kind": "keyword_only",
          "annotated_type": "Path | None",
          "default": "QUERIES_FILE_OPTION",
          "doc": null
        },
        {
          "name": "warmup",
          "kind": "keyword_only",
          "annotated_type": "int",
          "default": "WARMUP_OPTION",
          "doc": null
        },
        {
          "name": "runs",
          "kind": "keyword_only",
          "annotated_type": "int",
          "default": "RUNS_OPTION",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Benchmark SPLADE query encoding latency.",
      "doc_raw": "Benchmark SPLADE query encoding latency.\n\nThis command measures the performance of SPLADE query encoding by running\nmultiple iterations of encoding operations and reporting statistical metrics\n(mean, p50, p95 latency). It supports benchmarking single queries or batches\nof queries from a file, with configurable warmup and measurement iterations\nto ensure accurate performance measurements.\n\nThe benchmark initializes the SPLADE encoder service, performs warmup runs\nto stabilize performance (accounting for JIT compilation, cache warming, etc.),\nthen executes measurement runs and calculates latency statistics. Results are\ndisplayed to stdout and logged with structured metadata.\n\nParameters\n----------\nquery : str | None, optional\n    Single query string to benchmark. If provided, this query is included in\n    the benchmark set. Can be combined with queries_file to benchmark multiple\n    queries. Defaults to None (no single query).\nqueries_file : Path | None, optional\n    Path to a text file containing one query per line. All non-empty lines\n    are read and included in the benchmark. Can be combined with query to\n    benchmark both. Defaults to None (no file queries).\nwarmup : int, optional\n    Number of warmup iterations to perform before measurement. Warmup runs\n    help stabilize performance by allowing JIT compilation, cache warming,\n    and other one-time optimizations to complete. Defaults to the value from\n    WARMUP_OPTION constant.\nruns : int, optional\n    Number of measurement iterations to perform after warmup. These runs\n    are used to calculate latency statistics (mean, p50, p95). More runs\n    provide more accurate statistics but take longer. Defaults to the value\n    from RUNS_OPTION constant.\n\nRaises\n------\ntyper.BadParameter\n    If no queries are provided (both query and queries_file are None/empty)\n    or if the queries_file path exists but is invalid/unreadable.",
      "docstyle": "google"
    },
    {
      "full_name": "cli.splade.build_index",
      "short_name": "build_index",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "app.command('build-index')"
      ],
      "params": [
        {
          "name": "vectors_dir",
          "kind": "keyword_only",
          "annotated_type": "Path | None",
          "default": "VECTORS_DIR_OPTION",
          "doc": null
        },
        {
          "name": "index_dir",
          "kind": "keyword_only",
          "annotated_type": "Path | None",
          "default": "INDEX_DIR_OPTION",
          "doc": null
        },
        {
          "name": "threads",
          "kind": "keyword_only",
          "annotated_type": "int | None",
          "default": "THREADS_OPTION",
          "doc": null
        },
        {
          "name": "max_clause_count",
          "kind": "keyword_only",
          "annotated_type": "int | None",
          "default": "MAX_CLAUSE_OPTION",
          "doc": null
        },
        {
          "name": "overwrite",
          "kind": "keyword_only",
          "annotated_type": "OverwriteFlag",
          "default": "True",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Build a SPLADE Lucene impact index from JsonVectorCollection shards.",
      "doc_raw": "Build a SPLADE Lucene impact index from JsonVectorCollection shards.",
      "docstyle": "google"
    },
    {
      "full_name": "cli.splade.RUNS_OPTION",
      "short_name": "RUNS_OPTION",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "cli.splade.WARMUP_OPTION",
      "short_name": "WARMUP_OPTION",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "cli.splade.QUERIES_FILE_OPTION",
      "short_name": "QUERIES_FILE_OPTION",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "cli.splade.QUERY_OPTION",
      "short_name": "QUERY_OPTION",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "cli.splade.MAX_CLAUSE_OPTION",
      "short_name": "MAX_CLAUSE_OPTION",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "cli.splade.THREADS_OPTION",
      "short_name": "THREADS_OPTION",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "cli.splade.INDEX_DIR_OPTION",
      "short_name": "INDEX_DIR_OPTION",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "cli.splade.VECTORS_DIR_OPTION",
      "short_name": "VECTORS_DIR_OPTION",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "cli.splade.encode",
      "short_name": "encode",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "app.command('encode')"
      ],
      "params": [
        {
          "name": "source",
          "kind": "keyword_only",
          "annotated_type": "Path",
          "default": "SOURCE_ARGUMENT",
          "doc": null
        },
        {
          "name": "output_dir",
          "kind": "keyword_only",
          "annotated_type": "Path | None",
          "default": "OUTPUT_DIR_OPTION",
          "doc": null
        },
        {
          "name": "batch_size",
          "kind": "keyword_only",
          "annotated_type": "int | None",
          "default": "BATCH_SIZE_OPTION",
          "doc": null
        },
        {
          "name": "quantization",
          "kind": "keyword_only",
          "annotated_type": "int | None",
          "default": "QUANTIZATION_OPTION_ENCODE",
          "doc": null
        },
        {
          "name": "shard_size",
          "kind": "keyword_only",
          "annotated_type": "int",
          "default": "SHARD_SIZE_OPTION",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Encode a corpus into SPLADE JsonVectorCollection shards.",
      "doc_raw": "Encode a corpus into SPLADE JsonVectorCollection shards.",
      "docstyle": "google"
    },
    {
      "full_name": "cli.splade.SHARD_SIZE_OPTION",
      "short_name": "SHARD_SIZE_OPTION",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "cli.splade.QUANTIZATION_OPTION_ENCODE",
      "short_name": "QUANTIZATION_OPTION_ENCODE",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "cli.splade.BATCH_SIZE_OPTION",
      "short_name": "BATCH_SIZE_OPTION",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "cli.splade.OUTPUT_DIR_OPTION",
      "short_name": "OUTPUT_DIR_OPTION",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "cli.splade.SOURCE_ARGUMENT",
      "short_name": "SOURCE_ARGUMENT",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "cli.splade.export_onnx",
      "short_name": "export_onnx",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "app.command('export-onnx')"
      ],
      "params": [
        {
          "name": "model_id",
          "kind": "keyword_only",
          "annotated_type": "str | None",
          "default": "MODEL_ID_OPTION",
          "doc": null
        },
        {
          "name": "optimize",
          "kind": "keyword_only",
          "annotated_type": "OptimizeFlag",
          "default": "True",
          "doc": null
        },
        {
          "name": "quantize",
          "kind": "keyword_only",
          "annotated_type": "QuantizeFlag",
          "default": "True",
          "doc": null
        },
        {
          "name": "quantization_config",
          "kind": "keyword_only",
          "annotated_type": "str",
          "default": "QUANTIZATION_OPTION",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Export SPLADE ONNX artifacts (optimized and quantized).",
      "doc_raw": "Export SPLADE ONNX artifacts (optimized and quantized).",
      "docstyle": "google"
    },
    {
      "full_name": "cli.splade.QUANTIZATION_OPTION",
      "short_name": "QUANTIZATION_OPTION",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "cli.splade.MODEL_ID_OPTION",
      "short_name": "MODEL_ID_OPTION",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "cli.splade._add_metadata_artifact",
      "short_name": "_add_metadata_artifact",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "env",
          "kind": "positional_or_keyword",
          "annotated_type": "EnvelopeBuilder",
          "default": null,
          "doc": null
        },
        {
          "name": "path",
          "kind": "positional_or_keyword",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Attach metadata artifacts to CLI envelopes when available.",
      "doc_raw": "Attach metadata artifacts to CLI envelopes when available.",
      "docstyle": "google"
    },
    {
      "full_name": "cli.splade._create_index_manager",
      "short_name": "_create_index_manager",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": {
        "annotated_type": "SpladeIndexManager",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Construct an index manager using the active settings.",
      "doc_raw": "Construct an index manager using the active settings.\n\nReturns\n-------\nSpladeIndexManager\n    Index manager initialized with the current environment configuration.",
      "docstyle": "google"
    },
    {
      "full_name": "cli.splade._create_encoder_service",
      "short_name": "_create_encoder_service",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": {
        "annotated_type": "SpladeEncoderService",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Construct an encoder service using the active settings.",
      "doc_raw": "Construct an encoder service using the active settings.\n\nReturns\n-------\nSpladeEncoderService\n    Encoder service initialized with the current environment configuration.",
      "docstyle": "google"
    },
    {
      "full_name": "cli.splade._create_artifacts_manager",
      "short_name": "_create_artifacts_manager",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": {
        "annotated_type": "SpladeArtifactsManager",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Construct an artifacts manager using the active settings.",
      "doc_raw": "Construct an artifacts manager using the active settings.\n\nReturns\n-------\nSpladeArtifactsManager\n    Manager initialized with the current environment configuration.",
      "docstyle": "google"
    },
    {
      "full_name": "cli.splade.app",
      "short_name": "app",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "cli.splade.OverwriteFlag",
      "short_name": "OverwriteFlag",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "cli.splade.QuantizeFlag",
      "short_name": "QuantizeFlag",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "cli.splade.OptimizeFlag",
      "short_name": "OptimizeFlag",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "cli.bm25",
      "short_name": "bm25",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Command-line interface for BM25 corpus preparation and index builds.",
      "doc_raw": "Command-line interface for BM25 corpus preparation and index builds.",
      "docstyle": "google"
    },
    {
      "full_name": "cli.bm25.main",
      "short_name": "main",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Run the BM25 CLI directly.",
      "doc_raw": "Run the BM25 CLI directly.",
      "docstyle": "google"
    },
    {
      "full_name": "cli.bm25.build_index",
      "short_name": "build_index",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "app.command('build-index')"
      ],
      "params": [
        {
          "name": "json_dir",
          "kind": "keyword_only",
          "annotated_type": "Path | None",
          "default": "JSON_DIR_OPTION",
          "doc": null
        },
        {
          "name": "index_dir",
          "kind": "keyword_only",
          "annotated_type": "Path | None",
          "default": "INDEX_DIR_OPTION",
          "doc": null
        },
        {
          "name": "threads",
          "kind": "keyword_only",
          "annotated_type": "int | None",
          "default": "THREADS_OPTION",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Build a Lucene BM25 index using Pyserini.",
      "doc_raw": "Build a Lucene BM25 index using Pyserini.",
      "docstyle": "google"
    },
    {
      "full_name": "cli.bm25.THREADS_OPTION",
      "short_name": "THREADS_OPTION",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "cli.bm25.INDEX_DIR_OPTION",
      "short_name": "INDEX_DIR_OPTION",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "cli.bm25.JSON_DIR_OPTION",
      "short_name": "JSON_DIR_OPTION",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "cli.bm25.prepare_corpus",
      "short_name": "prepare_corpus",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "app.command('prepare-corpus')"
      ],
      "params": [
        {
          "name": "source",
          "kind": "keyword_only",
          "annotated_type": "Path",
          "default": "SOURCE_ARGUMENT",
          "doc": null
        },
        {
          "name": "output_dir",
          "kind": "keyword_only",
          "annotated_type": "Path | None",
          "default": "OUTPUT_DIR_OPTION",
          "doc": null
        },
        {
          "name": "overwrite",
          "kind": "keyword_only",
          "annotated_type": "bool",
          "default": "OVERWRITE_OPTION",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Prepare a BM25 JsonCollection from a JSONL source.",
      "doc_raw": "Prepare a BM25 JsonCollection from a JSONL source.",
      "docstyle": "google"
    },
    {
      "full_name": "cli.bm25.OVERWRITE_OPTION",
      "short_name": "OVERWRITE_OPTION",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "cli.bm25.OUTPUT_DIR_OPTION",
      "short_name": "OUTPUT_DIR_OPTION",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "cli.bm25.OVERWRITE_DEFAULT",
      "short_name": "OVERWRITE_DEFAULT",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "cli.bm25.SOURCE_ARGUMENT",
      "short_name": "SOURCE_ARGUMENT",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "cli.bm25._add_metadata_artifact",
      "short_name": "_add_metadata_artifact",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "env",
          "kind": "positional_or_keyword",
          "annotated_type": "EnvelopeBuilder",
          "default": null,
          "doc": null
        },
        {
          "name": "path",
          "kind": "positional_or_keyword",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Attach metadata artifact information to the CLI envelope.",
      "doc_raw": "Attach metadata artifact information to the CLI envelope.",
      "docstyle": "google"
    },
    {
      "full_name": "cli.bm25._create_bm25_manager",
      "short_name": "_create_bm25_manager",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": {
        "annotated_type": "BM25IndexManager",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Return an index manager configured from environment settings.",
      "doc_raw": "Return an index manager configured from environment settings.\n\nReturns\n-------\nBM25IndexManager\n    Manager using the active environment configuration.",
      "docstyle": "google"
    },
    {
      "full_name": "cli.bm25.app",
      "short_name": "app",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config",
      "short_name": "config",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Configuration loading and environment settings for CodeIntel MCP.",
      "doc_raw": "Configuration loading and environment settings for CodeIntel MCP.",
      "docstyle": "google"
    },
    {
      "full_name": "config.utils",
      "short_name": "utils",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Helpers for working with msgspec-based settings structs.",
      "doc_raw": "Helpers for working with msgspec-based settings structs.",
      "docstyle": "google"
    },
    {
      "full_name": "config.utils.__all__",
      "short_name": "__all__",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.utils.replace_struct",
      "short_name": "replace_struct",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "instance",
          "kind": "positional_or_keyword",
          "annotated_type": "T",
          "default": null,
          "doc": null
        },
        {
          "name": "updates",
          "kind": "var_keyword",
          "annotated_type": "object",
          "default": "{}",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "T",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Clone a struct instance with the provided field overrides applied.",
      "doc_raw": "Clone a struct instance with the provided field overrides applied.\n\nExtended Summary\n----------------\nThis generic function creates a new struct instance by cloning the provided\ninstance and applying field overrides via keyword arguments. It uses msgspec's\nstructs.replace utility to perform immutable updates, ensuring the original\ninstance remains unchanged. This is a type-safe way to create modified struct\ninstances for any msgspec Struct type, useful for configuration overrides and\ntest fixtures.\n\nParameters\n----------\ninstance : T\n    Original struct instance to clone and modify. Must be an instance of a\n    class that inherits from msgspec.Struct. The instance is not modified.\n**updates : object\n    Keyword arguments mapping field names to new values. Only fields that exist\n    in the struct type T can be overridden. Invalid field names are ignored\n    by msgspec.\n\nReturns\n-------\nT\n    New struct instance of the same type as instance, with the provided fields\n    overridden. All other fields are copied from the original instance.\n\nNotes\n-----\nTime complexity O(1) for struct cloning. Space complexity O(1) aside from the\nnew struct object. The function performs no I/O and has no side effects.\nThread-safe as it operates on immutable structs. Type-safe via generic type\nparameter T constrained to Struct.",
      "docstyle": "google"
    },
    {
      "full_name": "config.utils.replace_settings",
      "short_name": "replace_settings",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "settings",
          "kind": "positional_or_keyword",
          "annotated_type": "Settings",
          "default": null,
          "doc": null
        },
        {
          "name": "updates",
          "kind": "var_keyword",
          "annotated_type": "object",
          "default": "{}",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "Settings",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Return a new Settings instance with updates applied.",
      "doc_raw": "Return a new Settings instance with updates applied.\n\nExtended Summary\n----------------\nThis function creates a new Settings instance by cloning the provided settings\nand applying field overrides via keyword arguments. It uses msgspec's structs.replace\nutility to perform immutable updates, ensuring the original settings object remains\nunchanged. This is useful for creating modified settings configurations for testing\nor specialized use cases without mutating the original.\n\nParameters\n----------\nsettings : Settings\n    Original Settings instance to clone and modify. The instance is not modified.\n**updates : object\n    Keyword arguments mapping field names to new values. Only fields that exist\n    in the Settings struct can be overridden. Invalid field names are ignored\n    by msgspec.\n\nReturns\n-------\nSettings\n    New Settings instance with the provided fields overridden. All other fields\n    are copied from the original settings instance.\n\nNotes\n-----\nTime complexity O(1) for struct cloning. Space complexity O(1) aside from the\nnew Settings object. The function performs no I/O and has no side effects.\nThread-safe as it operates on immutable structs.",
      "docstyle": "google"
    },
    {
      "full_name": "config.settings",
      "short_name": "settings",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Configuration settings using msgspec for fast, validated config.",
      "doc_raw": "Configuration settings using msgspec for fast, validated config.\n\nNO Pydantic - using msgspec.Struct for performance-critical settings.\nAll configuration loaded from environment variables with sensible defaults.",
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.__all__",
      "short_name": "__all__",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.load_settings",
      "short_name": "load_settings",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": {
        "annotated_type": "Settings",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Load settings from environment variables with sensible defaults.",
      "doc_raw": "Load settings from environment variables with sensible defaults.\n\nThis function reads configuration from environment variables and constructs\na Settings object with all subsystem configurations. Environment variables\nfollow a hierarchical naming scheme: subsystem name in uppercase, then\nthe parameter name.\n\nAll environment variables are optional - sensible defaults are provided for\ndevelopment and testing. For production deployments, you should set at minimum:\nREPO_ROOT, VLLM_URL, and any paths that differ from defaults.\n\nThe function validates types (converting strings to int/float/bool as needed)\nand ensures required fields (like repo_root) have values. If REPO_ROOT is\nnot set, it defaults to the current working directory.\n\nReturns\n-------\nSettings\n    Fully configured Settings instance with all subsystems initialized.\n    The Settings object is frozen (immutable) and can be safely shared across\n    threads.\n\nSee Also\n--------\nThe following environment variables can be used to configure the settings:\n---------------------\nVLLM_URL : str, optional\n    vLLM service base URL (default: \"http://127.0.0.1:8001/v1\").\nVLLM_MODEL : str, optional\n    Embedding model identifier (default: \"nomic-ai/nomic-embed-code\").\nVLLM_BATCH_SIZE : int, optional\n    Batch size for embedding requests (default: 64).\nVLLM_TIMEOUT_S : float, optional\n    HTTP timeout for vLLM requests in seconds (default: 120.0).\nVLLM_EMBED_DIM : int, optional\n    Embedding vector dimension for empty responses and validation\n    (default: 2560).\nREPO_ROOT : str, optional\n    Repository root directory path (default: current working directory).\nDATA_DIR : str, optional\n    Base data directory (default: \"data\").\nVECTORS_DIR : str, optional\n    Vector storage directory (default: \"data/vectors\").\nFAISS_INDEX : str, optional\n    FAISS index file path (default: \"data/faiss/code.ivfpq.faiss\").\nLUCENE_DIR : str, optional\n    Lucene index directory (default: \"data/lucene\").\nSPLADE_DIR : str, optional\n    SPLADE index directory (default: \"data/splade\").\nDUCKDB_PATH : str, optional\n    DuckDB catalog database path (default: \"data/catalog.duckdb\").\nSCIP_INDEX : str, optional\n    SCIP index file path (default: \"index.scip\").\nVEC_DIM : int, optional\n    Embedding vector dimension (default: 2560).\nCHUNK_BUDGET : int, optional\n    Target chunk size in characters (default: 2200).\nFAISS_NLIST : int, optional\n    Number of IVF centroids (default: 8192).\nFAISS_NPROBE : int, optional\n    Number of IVF cells to probe during search (default: 128).\nFAISS_COMPACTION_THRESHOLD : float, optional\n    Secondary-to-primary ratio that triggers compaction (default: 0.05).\nBM25_K1 : float, optional\n    BM25 k1 parameter (default: 0.9).\nBM25_B : float, optional\n    BM25 b parameter (default: 0.4).\nRRF_K : int, optional\n    RRF fusion K parameter (default: 60).\nHYBRID_ENABLE_BM25 : str, optional\n    Enable BM25 channel within hybrid retrieval fusion (\"1\"/\"true\" to enable, default enabled).\nHYBRID_ENABLE_SPLADE : str, optional\n    Enable SPLADE channel within hybrid retrieval fusion\n    (\"1\"/\"true\" to enable, default enabled).\nHYBRID_TOP_K_PER_CHANNEL : int, optional\n    Per-channel candidate fan-out gathered prior to RRF fusion (default: 50).\nUSE_CUVS : str, optional\n    Enable cuVS acceleration: \"1\", \"true\", or \"yes\" (default: \"1\").\nFAISS_PRELOAD : str, optional\n    Pre-load FAISS index at startup: \"1\", \"true\", or \"yes\" (default: \"0\").\n    When enabled, startup takes 2-10 seconds longer but first request is faster.\nMAX_RESULTS : int, optional\n    Maximum results per query (default: 1000).\nQUERY_TIMEOUT_S : float, optional\n    Query timeout in seconds (default: 30.0).\nRATE_LIMIT_QPS : float, optional\n    Rate limit queries per second (default: 10.0).\nRATE_LIMIT_BURST : int, optional\n    Rate limit burst capacity (default: 20).\nREDIS_URL : str, optional\n    Redis connection URL for Session scope storage (default: \"redis://127.0.0.1:6379/0\").\nREDIS_SCOPE_L1_SIZE : int, optional\n    Maximum number of entries for the in-process L1 cache (default: 256).\nREDIS_SCOPE_L1_TTL_SECONDS : float, optional\n    TTL in seconds for L1 cache entries (default: 300).\nREDIS_SCOPE_L2_TTL_SECONDS : int, optional\n    TTL in seconds for Redis entries (default: 3600).\nDUCKDB_THREADS : int, optional\n    Worker thread budget for DuckDB connections (default: 4).\nDUCKDB_OBJECT_CACHE : str, optional\n    Enable DuckDB object cache (\"1\"/\"true\" to enable, default enabled).\nDUCKDB_LOG_QUERIES : str, optional\n    Emit DuckDB SQL statements at debug level (\"1\"/\"true\" to enable).\nBM25_JSONL_DIR : str, optional\n    Directory containing BM25 JsonCollection documents (default: \"data/jsonl\").\nBM25_INDEX_DIR : str, optional\n    Directory for the Lucene BM25 index (default: \"indexes/bm25\").\nBM25_THREADS : int, optional\n    Worker thread budget for BM25 indexing (default: 8).\nSPLADE_MODEL_ID : str, optional\n    Hugging Face model identifier for SPLADE (default: \"naver/splade-v3\").\nSPLADE_MODEL_DIR : str, optional\n    Local directory for SPLADE model artifacts (default: \"models/splade-v3\").\nSPLADE_ONNX_DIR : str, optional\n    Directory that stores exported SPLADE ONNX artifacts (default: \"models/splade-v3/onnx\").\nSPLADE_ONNX_FILE : str, optional\n    Primary SPLADE ONNX file name (default: \"model_qint8.onnx\").\nSPLADE_VECTORS_DIR : str, optional\n    Directory containing SPLADE JsonVectorCollection shards (default: \"data/splade_vectors\").\nSPLADE_INDEX_DIR : str, optional\n    Directory for the SPLADE impact index (default: \"indexes/splade_v3_impact\").\nSPLADE_PROVIDER : str, optional\n    Default ONNX Runtime execution provider (default: \"CPUExecutionProvider\").\nSPLADE_QUANTIZATION : int, optional\n    Integer quantization factor applied during SPLADE encoding (default: 100).\nSPLADE_MAX_TERMS : int, optional\n    Maximum SPLADE query terms retained after expansion (default: 3000).\nSPLADE_MAX_CLAUSE : int, optional\n    Lucene Boolean clause limit used while indexing SPLADE vectors (default: 4096).\nSPLADE_BATCH_SIZE : int, optional\n    Default batch size for SPLADE encoding CLI commands (default: 32).\nCODERANK_MODEL_ID : str, optional\n    Hugging Face identifier for CodeRank embeddings (default: \"nomic-ai/CodeRankEmbed\").\nCODERANK_TRUST_REMOTE_CODE : str, optional\n    Allow custom code from the model repo (\"1\"/\"true\" to enable, default enabled).\nCODERANK_DEVICE : str, optional\n    Device string for CodeRank embeddings (default: \"cpu\").\nCODERANK_BATCH : int, optional\n    Batch size for CodeRank encoding (default: 128).\nCODERANK_NORMALIZE : str, optional\n    Enable L2 normalization for CodeRank embeddings (default enabled).\nCODERANK_QUERY_PREFIX : str, optional\n    Override the CodeRank instruction prefix when necessary.\nCODERANK_VECTORS_DIR : str, optional\n    Storage directory for CodeRank vectors (default: \"data/coderank_vectors\").\nCODERANK_FAISS_INDEX : str, optional\n    CodeRank FAISS index path (default: \"data/faiss/coderank.ivfpq.faiss\").\nWARP_INDEX_DIR : str, optional\n    Directory containing WARP/XTR index artifacts (default: \"indexes/warp_xtr\").\nWARP_MODEL_ID : str, optional\n    Identifier for WARP's multivector encoder (default: \"intfloat/e5-multivector-large\").\nWARP_DEVICE : str, optional\n    Device for the WARP executor (default: \"cpu\").\nWARP_TOP_K : int, optional\n    Candidate fan-out requested from WARP (default: 200).\nWARP_ENABLED : str, optional\n    Enable WARP channel (\"1\"/\"true\" to enable, default disabled).\nXTR_DIR : str, optional\n    Directory containing XTR token artifacts (default: \"data/xtr\").\nXTR_MODEL_ID : str, optional\n    Encoder checkpoint for XTR tokens (default: \"nomic-ai/CodeRankEmbed\").\nXTR_DEVICE : str, optional\n    Device for XTR query encoding (\"cuda\" default).\nXTR_MAX_QUERY_TOKENS : int, optional\n    Maximum number of query tokens processed (default: 256).\nXTR_CANDIDATE_K : int, optional\n    Number of Stage-A candidates to rescore (default: 200).\nXTR_DIM : int, optional\n    Token embedding dimensionality (default: 768).\nXTR_DTYPE : str, optional\n    Token storage dtype (\"float16\" default).\nXTR_ENABLE : str, optional\n    Enable XTR rescoring (\"1\"/\"true\" to enable, default disabled).\nCODERANK_LLM_MODEL_ID : str, optional\n    Identifier for the CodeRank listwise reranker (default: \"nomic-ai/CodeRankLLM\").\nCODERANK_LLM_DEVICE : str, optional\n    Device for the listwise reranker (default: \"cpu\").\nCODERANK_LLM_MAX_NEW_TOKENS : int, optional\n    Max tokens generated when reranking (default: 256).\nCODERANK_LLM_TEMPERATURE : float, optional\n    Sampling temperature for reranker generations (default: 0.0).\nCODERANK_LLM_TOP_P : float, optional\n    Top-p nucleus sampling parameter (default: 1.0).\nCODERANK_LLM_ENABLED : str, optional\n    Enable the CodeRank listwise reranker (\"1\"/\"true\" to enable, default disabled).",
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.Settings",
      "short_name": "Settings",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [
        "msgspec.Struct"
      ],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Global settings container for the entire code intelligence system.",
      "doc_raw": "Global settings container for the entire code intelligence system.\n\nThis is the root configuration object that aggregates all subsystem\nconfigurations. It's loaded once at application startup from environment\nvariables and remains immutable throughout the application lifetime.\n\nThe Settings object is frozen (immutable) to prevent accidental modification\nand ensure thread-safe access. All configuration is validated at load time\nthrough msgspec's type system.\n\nAttributes\n----------\nvllm : VLLMConfig\n    Configuration for the vLLM embedding service. Includes connection details,\n    model selection, and batching parameters for generating code embeddings.\npaths : PathsConfig\n    File system path configuration. Defines where indexes, vectors, databases,\n    and source code are stored. All paths are resolved relative to repo_root.\nindex : IndexConfig\n    Indexing and search algorithm configuration. Includes chunking parameters,\n    FAISS index structure, BM25 settings, and hybrid retrieval fusion parameters.\nlimits : ServerLimits\n    Server resource limits and rate limiting configuration. Protects against\n    resource exhaustion and provides basic API rate limiting.\nredis : RedisConfig\n    Redis configuration for session scope caching.\nduckdb : DuckDBConfig\n    DuckDB connection configuration (threading, object cache).\nbm25 : BM25Config\n    BM25 indexing configuration, including corpus preparation directories and\n    default thread settings.\nsplade : SpladeConfig\n    SPLADE v3 configuration covering model artifacts, ONNX execution defaults, and\n    Lucene impact index locations.\ncoderank : CodeRankConfig\n    Dense CodeRank retriever configuration.\nwarp : WarpConfig\n    WARP/XTR late-interaction configuration.\nxtr : XTRConfig\n    Token-level index and scoring configuration.\ncoderank_llm : CodeRankLLMConfig\n    CodeRank listwise reranker configuration.",
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.Settings.coderank_llm",
      "short_name": "coderank_llm",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.Settings.xtr",
      "short_name": "xtr",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.Settings.warp",
      "short_name": "warp",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.Settings.coderank",
      "short_name": "coderank",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.Settings.splade",
      "short_name": "splade",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.Settings.bm25",
      "short_name": "bm25",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.Settings.duckdb",
      "short_name": "duckdb",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.Settings.redis",
      "short_name": "redis",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.Settings.limits",
      "short_name": "limits",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.Settings.index",
      "short_name": "index",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.Settings.paths",
      "short_name": "paths",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.Settings.vllm",
      "short_name": "vllm",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.RedisConfig",
      "short_name": "RedisConfig",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [
        "msgspec.Struct"
      ],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Redis configuration for scope storage.",
      "doc_raw": "Redis configuration for scope storage.\n\nAttributes\n----------\nurl : str\n    Redis connection URL. Defaults to local Redis on standard port.\nscope_l1_size : int\n    Maximum number of entries to retain in the in-process L1 cache.\nscope_l1_ttl_seconds : float\n    Time-to-live in seconds for L1 cache entries.\nscope_l2_ttl_seconds : int\n    Time-to-live in seconds for Redis entries (L2 cache).",
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.RedisConfig.scope_l2_ttl_seconds",
      "short_name": "scope_l2_ttl_seconds",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.RedisConfig.scope_l1_ttl_seconds",
      "short_name": "scope_l1_ttl_seconds",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.RedisConfig.scope_l1_size",
      "short_name": "scope_l1_size",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.RedisConfig.url",
      "short_name": "url",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.ServerLimits",
      "short_name": "ServerLimits",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [
        "msgspec.Struct"
      ],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Server resource limits and rate limiting configuration.",
      "doc_raw": "Server resource limits and rate limiting configuration.\n\nConfiguration for protecting the server from resource exhaustion and ensuring\nfair usage. These limits prevent individual queries from consuming excessive\nresources and provide basic rate limiting for API access.\n\nThe defaults are conservative and suitable for production deployments. Adjust\nbased on your hardware capabilities and expected load patterns.\n\nAttributes\n----------\nmax_results : int\n    Maximum number of results to return per query. This prevents queries from\n    returning excessively large result sets that could cause memory issues or\n    slow response times. Defaults to 1000 results, which is typically more\n    than needed for most use cases. For interactive search, 50-100 is usually\n    sufficient.\nquery_timeout_s : float\n    Maximum time in seconds that a query is allowed to run before timing out.\n    This protects against slow queries (e.g., very large FAISS searches) that\n    could block the server. Defaults to 30 seconds, which should be sufficient\n    for most semantic searches even on large indexes. For very large indexes\n    (>10M vectors), consider increasing to 60 seconds.\nrate_limit_qps : float\n    Queries per second (QPS) rate limit. This is the sustained rate at which\n    queries are allowed. Defaults to 10 QPS, which is reasonable for a single\n    server instance. For production deployments behind a load balancer, this\n    should be set per-instance (total QPS = instances * rate_limit_qps).\nrate_limit_burst : int\n    Burst capacity for the rate limiter. This allows short bursts above the\n    QPS limit to handle traffic spikes. Defaults to 20 queries, which allows\n    a 2-second burst at 10 QPS. Set higher (40-60) if you expect more variable\n    traffic patterns.\nsemantic_overfetch_multiplier : int\n    Multiplier applied to FAISS search fan-out when scope filters are active.\n    Defaults to 2 (fetch twice the requested limit to compensate for filtering).",
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.ServerLimits.semantic_overfetch_multiplier",
      "short_name": "semantic_overfetch_multiplier",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.ServerLimits.rate_limit_burst",
      "short_name": "rate_limit_burst",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.ServerLimits.rate_limit_qps",
      "short_name": "rate_limit_qps",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.ServerLimits.query_timeout_s",
      "short_name": "query_timeout_s",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.ServerLimits.max_results",
      "short_name": "max_results",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.IndexConfig",
      "short_name": "IndexConfig",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [
        "msgspec.Struct"
      ],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Indexing and search configuration.",
      "doc_raw": "Indexing and search configuration.\n\nConfiguration parameters for the indexing pipeline and search algorithms.\nThis includes settings for chunking, vector dimensions, FAISS index structure,\nBM25 parameters, and hybrid retrieval fusion.\n\nThe configuration balances search quality (recall/precision) with performance\n(index size, search speed). The defaults are tuned for code search workloads\nwith typical repository sizes (thousands to millions of chunks).\n\nAttributes\n----------\nvec_dim : int\n    Dimensionality of embedding vectors. Must match the embedding model's\n    output dimension and stay aligned with :class:`VLLMConfig` ``embedding_dim``.\n    Defaults to 2560 for nomic-embed-code model. Changing this requires\n    re-indexing with a different model.\nchunk_budget : int\n    Target chunk size in characters. The cAST chunker tries to pack symbols\n    up to this size before splitting. Larger chunks provide more context but\n    may reduce precision. Defaults to 2200 characters, which is optimal for\n    code search (roughly 50-100 lines depending on code style).\nfaiss_nlist : int\n    Number of IVF (Inverted File) centroids/clusters. More centroids improve\n    recall but increase index size and training time. Defaults to 8192, which\n    provides good recall for millions of vectors. For smaller datasets (<100k),\n    consider 4096; for very large (>10M), consider 16384.\nfaiss_nprobe : int\n    Number of IVF cells to probe during live semantic search queries. Higher\n    values improve recall but increase response latency. Defaults to 128,\n    which probes ~1.5% of cells for nlist=8192. For higher recall, increase\n    to 256 or 512; for faster searches, decrease to 64.\nbm25_k1 : float\n    BM25 term frequency saturation parameter. Controls how quickly term\n    frequency saturates. Higher values (1.0-2.0) give more weight to\n    repeated terms. Defaults to 0.9, which is standard for code search.\nbm25_b : float\n    BM25 length normalization parameter. Controls how much document length\n    affects scoring (0 = no normalization, 1 = full normalization).\n    Defaults to 0.4, which provides moderate length normalization suitable\n    for code where length varies significantly.\nrrf_k : int\n    Reciprocal Rank Fusion (RRF) K parameter. Used to fuse results from\n    multiple retrieval systems (FAISS, BM25, SPLADE). Higher K values give\n    more weight to lower-ranked results. Defaults to 60, which is standard\n    for hybrid search. Lower values (30-40) favor top results; higher (80-100)\n    give more weight to consensus across systems.\nenable_bm25_channel : bool\n    Enable BM25 channel when performing hybrid retrieval. When disabled, BM25\n    results are excluded from fusion but the index can still be built for\n    other workflows. Defaults to ``True``.\nenable_splade_channel : bool\n    Enable SPLADE channel when performing hybrid retrieval. When disabled,\n    SPLADE results are excluded from fusion. Defaults to ``True``.\nhybrid_top_k_per_channel : int\n    Per-channel cutoff used when gathering candidates before RRF fusion.\n    Defaults to 50, which balances coverage with latency.\nuse_cuvs : bool\n    Enable cuVS (CUDA Vector Search) acceleration for FAISS GPU operations.\n    cuVS provides optimized GPU kernels that can be 2-3x faster than standard\n    FAISS GPU. Requires libcuvs-cu13 package. Defaults to True. Set to False\n    if cuVS is unavailable or causes issues.\nfaiss_preload : bool\n    Pre-load FAISS index during application startup (eager loading). When True,\n    the FAISS index is loaded immediately at startup, eliminating first-request\n    latency. When False (default), the index is loaded lazily on first semantic\n    search request. Set to True in production for consistent response times;\n    keep False in development for faster startup iteration.\nduckdb_materialize : bool\n    Persist chunk metadata into a DuckDB table (``chunks_materialized``) to\n    enable secondary indexes. When ``False`` (default), the catalog exposes\n    Parquet files via a view for zero-copy reads. Enable this for very large\n    catalogs when SQL filtering requires indexes. Defaults to ``False``.\npreview_max_chars : int\n    Maximum number of characters to persist in the Parquet ``preview`` column.\n    This controls indexing-time truncation. Defaults to 240 characters.\ncompaction_threshold : float\n    Fraction of primary index size that the secondary index can reach before a\n    compaction is recommended. Defaults to 0.05 (5%).\nrrf_weights : dict[str, float]\n    Default per-channel weights applied during weighted RRF fusion.",
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.IndexConfig.rrf_weights",
      "short_name": "rrf_weights",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.IndexConfig.compaction_threshold",
      "short_name": "compaction_threshold",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.IndexConfig.preview_max_chars",
      "short_name": "preview_max_chars",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.IndexConfig.duckdb_materialize",
      "short_name": "duckdb_materialize",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.IndexConfig.faiss_preload",
      "short_name": "faiss_preload",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.IndexConfig.use_cuvs",
      "short_name": "use_cuvs",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.IndexConfig.hybrid_top_k_per_channel",
      "short_name": "hybrid_top_k_per_channel",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.IndexConfig.enable_splade_channel",
      "short_name": "enable_splade_channel",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.IndexConfig.enable_bm25_channel",
      "short_name": "enable_bm25_channel",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.IndexConfig.rrf_k",
      "short_name": "rrf_k",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.IndexConfig.bm25_b",
      "short_name": "bm25_b",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.IndexConfig.bm25_k1",
      "short_name": "bm25_k1",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.IndexConfig.faiss_nprobe",
      "short_name": "faiss_nprobe",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.IndexConfig.faiss_nlist",
      "short_name": "faiss_nlist",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.IndexConfig.chunk_budget",
      "short_name": "chunk_budget",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.IndexConfig.vec_dim",
      "short_name": "vec_dim",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.PathsConfig",
      "short_name": "PathsConfig",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [
        "msgspec.Struct"
      ],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "File system paths configuration.",
      "doc_raw": "File system paths configuration.\n\nCentralized configuration for all file system paths used by the code intelligence\nsystem. This includes paths for data storage, indexes, and source code locations.\nAll paths can be relative (to repo_root) or absolute.\n\nThe paths are organized hierarchically: data_dir contains subdirectories for\ndifferent types of data (vectors, indexes, etc.). This structure makes it easy\nto manage and back up the entire index state.\n\nAttributes\n----------\nrepo_root : str\n    Absolute path to the repository root directory. This is the base directory\n    for all source code indexing and is used to resolve relative file paths\n    from SCIP indexes. Required - no default.\ndata_dir : str\n    Base directory for all data storage (indexes, vectors, databases). Defaults\n    to \"data\" relative to repo_root. This directory will contain subdirectories\n    for vectors, FAISS indexes, Lucene indexes, etc.\nvectors_dir : str\n    Directory containing Parquet files with vector embeddings. Each Parquet file\n    stores chunks with their embeddings in Arrow FixedSizeList format for\n    efficient zero-copy access. Defaults to \"data/vectors\".\nfaiss_index : str\n    Path to the FAISS IVF-PQ index file (CPU version). This is the persisted\n    index that can be loaded and cloned to GPU. Defaults to\n    \"data/faiss/code.ivfpq.faiss\".\nlucene_dir : str\n    Directory for Lucene/BM25 indexes. Used for sparse retrieval methods like\n    BM25 keyword search. Defaults to \"data/lucene\".\nsplade_dir : str\n    Directory for SPLADE (Sparse Lexical and Dense) impact indexes. SPLADE\n    provides learned sparse representations that combine benefits of keyword\n    and dense search. Defaults to \"data/splade\".\nduckdb_path : str\n    Path to the DuckDB catalog database file. DuckDB provides SQL views over\n    Parquet files, enabling fast queries for chunk metadata, filtering, and\n    joins. Defaults to \"data/catalog.duckdb\".\nscip_index : str\n    Path to the SCIP index file (either protobuf .scip or JSON .scip.json).\n    This is the source of truth for symbol definitions and is generated by\n    the SCIP Python indexer. Defaults to \"index.scip\" in repo_root.\ncoderank_vectors_dir : str\n    Directory that stores CodeRank chunk embeddings (parquet or npy shards).\ncoderank_faiss_index : str\n    Path to the CodeRank FAISS index file used for Stage-A retrieval.\nwarp_index_dir : str\n    Directory containing WARP/XTR index artifacts.\nxtr_dir : str\n    Directory containing XTR token-level artifacts (memmaps + metadata).",
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.PathsConfig.xtr_dir",
      "short_name": "xtr_dir",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.PathsConfig.warp_index_dir",
      "short_name": "warp_index_dir",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.PathsConfig.coderank_faiss_index",
      "short_name": "coderank_faiss_index",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.PathsConfig.coderank_vectors_dir",
      "short_name": "coderank_vectors_dir",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.PathsConfig.scip_index",
      "short_name": "scip_index",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.PathsConfig.duckdb_path",
      "short_name": "duckdb_path",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.PathsConfig.splade_dir",
      "short_name": "splade_dir",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.PathsConfig.lucene_dir",
      "short_name": "lucene_dir",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.PathsConfig.faiss_index",
      "short_name": "faiss_index",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.PathsConfig.vectors_dir",
      "short_name": "vectors_dir",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.PathsConfig.data_dir",
      "short_name": "data_dir",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.PathsConfig.repo_root",
      "short_name": "repo_root",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.SpladeConfig",
      "short_name": "SpladeConfig",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [
        "msgspec.Struct"
      ],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "SPLADE v3 configuration covering model artifacts and index directories.",
      "doc_raw": "SPLADE v3 configuration covering model artifacts and index directories.\n\nAttributes\n----------\nmodel_id : str\n    Hugging Face model identifier used for training or export. Defaults to\n    ``naver/splade-v3``.\nmodel_dir : str\n    Local directory that stores exported model artifacts. Defaults to\n    ``models/splade-v3``.\nonnx_dir : str\n    Directory containing exported ONNX models. Defaults to ``models/splade-v3/onnx``.\nonnx_file : str\n    Primary ONNX file name (relative to ``onnx_dir``). Defaults to ``model_qint8.onnx``.\nvectors_dir : str\n    Directory that stores SPLADE JsonVectorCollection shards. Defaults to\n    ``data/splade_vectors``.\nindex_dir : str\n    Output directory for the Lucene impact index. Defaults to ``indexes/splade_v3_impact``.\nprovider : str\n    Default ONNX Runtime execution provider. Defaults to ``CPUExecutionProvider``.\nquantization : int\n    Integer quantization factor applied during encoding. Defaults to ``100``.\nmax_terms : int\n    Maximum number of query terms to retain when expanding SPLADE queries. Defaults to ``3000``.\nmax_clause_count : int\n    Lucene Boolean clause limit applied during indexing. Defaults to ``4096``.\nbatch_size : int\n    Default encoding batch size for CLI utilities. Defaults to ``32``.\nthreads : int\n    Default thread count used for Lucene impact index builds. Defaults to ``8``.",
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.SpladeConfig.threads",
      "short_name": "threads",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.SpladeConfig.batch_size",
      "short_name": "batch_size",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.SpladeConfig.max_clause_count",
      "short_name": "max_clause_count",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.SpladeConfig.max_terms",
      "short_name": "max_terms",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.SpladeConfig.quantization",
      "short_name": "quantization",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.SpladeConfig.provider",
      "short_name": "provider",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.SpladeConfig.index_dir",
      "short_name": "index_dir",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.SpladeConfig.vectors_dir",
      "short_name": "vectors_dir",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.SpladeConfig.onnx_file",
      "short_name": "onnx_file",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.SpladeConfig.onnx_dir",
      "short_name": "onnx_dir",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.SpladeConfig.model_dir",
      "short_name": "model_dir",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.SpladeConfig.model_id",
      "short_name": "model_id",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.BM25Config",
      "short_name": "BM25Config",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [
        "msgspec.Struct"
      ],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "BM25 indexing and search configuration.",
      "doc_raw": "BM25 indexing and search configuration.\n\nAttributes\n----------\ncorpus_json_dir : str\n    Directory containing per-document JSON files used to build the BM25 index.\n    Defaults to ``data/jsonl`` (relative to ``paths.repo_root``).\nindex_dir : str\n    Output directory for the Lucene index. Defaults to ``indexes/bm25``.\nthreads : int\n    Number of worker threads to use while building the index. Defaults to 8.",
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.BM25Config.threads",
      "short_name": "threads",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.BM25Config.index_dir",
      "short_name": "index_dir",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.BM25Config.corpus_json_dir",
      "short_name": "corpus_json_dir",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.VLLMConfig",
      "short_name": "VLLMConfig",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [
        "msgspec.Struct"
      ],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "vLLM embedding service configuration.",
      "doc_raw": "vLLM embedding service configuration.\n\nConfiguration for connecting to a vLLM embedding service that provides\nOpenAI-compatible embeddings API. This is used for generating vector embeddings\nof code chunks during indexing and for query embeddings during semantic search.\n\nThe vLLM service runs separately (typically on a GPU-enabled machine) and\nprovides fast batch embedding generation. The configuration includes connection\ndetails, model selection, and performance tuning parameters.\n\nAttributes\n----------\nbase_url : str\n    Base URL for the vLLM embeddings API endpoint. Should point to the /v1\n    endpoint of a running vLLM server. Defaults to localhost:8001.\nmodel : str\n    Model identifier for embeddings. This should match a model that the\n    vLLM server has loaded. Defaults to \"nomic-ai/nomic-embed-code\" which\n    is a code-specific embedding model with 2560 dimensions.\nbatch_size : int\n    Number of texts to embed in a single batch request. Larger batches improve\n    throughput but increase memory usage. Defaults to 64, which is a good\n    balance for most GPU setups.\nembedding_dim : int\n    Dimensionality of embeddings returned by the configured model. Defaults to\n    2560 to match the deployed nomic-embed-code checkpoint. Consumers should\n    keep this aligned with :class:`IndexConfig` ``vec_dim``.\ntimeout_s : float\n    HTTP request timeout in seconds. Embedding requests can take time for\n    large batches, so this should be set appropriately. Defaults to 120 seconds.\nrun : VLLMRunMode\n    Runtime execution mode for vLLM. Controls whether embeddings are generated\n    via HTTP requests to a remote service (\"http\") or using an in-process vLLM\n    engine (\"inprocess\"). Defaults to \"inprocess\" for local development.\ngpu_memory_utilization : float\n    Fraction of GPU memory to allocate for vLLM model and KV cache. Range [0.0, 1.0].\n    Higher values improve throughput but reduce available memory for other operations.\n    Defaults to 0.92 (92% of GPU memory).\nmax_num_batched_tokens : int\n    Maximum number of tokens to process in a single batch. Larger values improve\n    throughput but increase memory usage and latency. Defaults to 65536 tokens.\nnormalize : bool\n    Whether to L2-normalize embeddings after generation. Normalized embeddings\n    enable cosine similarity computation via dot product. Defaults to True.\npooling_type : Literal[\"lasttoken\", \"cls\", \"mean\"]\n    Token pooling strategy for generating embeddings from token-level outputs.\n    \"lasttoken\" uses the final token embedding, \"cls\" uses a special CLS token,\n    \"mean\" averages all token embeddings. Defaults to \"lasttoken\".\nmax_concurrent_requests : int\n    Maximum number of concurrent embedding requests allowed when using HTTP mode.\n    Higher values improve throughput but increase memory usage. Defaults to 4.",
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.VLLMConfig.max_concurrent_requests",
      "short_name": "max_concurrent_requests",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.VLLMConfig.pooling_type",
      "short_name": "pooling_type",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.VLLMConfig.normalize",
      "short_name": "normalize",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.VLLMConfig.max_num_batched_tokens",
      "short_name": "max_num_batched_tokens",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.VLLMConfig.gpu_memory_utilization",
      "short_name": "gpu_memory_utilization",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.VLLMConfig.run",
      "short_name": "run",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.VLLMConfig.timeout_s",
      "short_name": "timeout_s",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.VLLMConfig.embedding_dim",
      "short_name": "embedding_dim",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.VLLMConfig.batch_size",
      "short_name": "batch_size",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.VLLMConfig.model",
      "short_name": "model",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.VLLMConfig.base_url",
      "short_name": "base_url",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.VLLMRunMode",
      "short_name": "VLLMRunMode",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [
        "msgspec.Struct"
      ],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Execution mode for the vLLM embedder.",
      "doc_raw": "Execution mode for the vLLM embedder.",
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.VLLMRunMode.mode",
      "short_name": "mode",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.CodeRankLLMConfig",
      "short_name": "CodeRankLLMConfig",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [
        "msgspec.Struct"
      ],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Configuration for the CodeRank listwise reranker.",
      "doc_raw": "Configuration for the CodeRank listwise reranker.",
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.CodeRankLLMConfig.budget_ms",
      "short_name": "budget_ms",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.CodeRankLLMConfig.enabled",
      "short_name": "enabled",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.CodeRankLLMConfig.top_p",
      "short_name": "top_p",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.CodeRankLLMConfig.temperature",
      "short_name": "temperature",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.CodeRankLLMConfig.max_new_tokens",
      "short_name": "max_new_tokens",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.CodeRankLLMConfig.device",
      "short_name": "device",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.CodeRankLLMConfig.model_id",
      "short_name": "model_id",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.XTRConfig",
      "short_name": "XTRConfig",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [
        "msgspec.Struct"
      ],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Configuration for XTR token storage and scoring.",
      "doc_raw": "Configuration for XTR token storage and scoring.",
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.XTRConfig.mode",
      "short_name": "mode",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.XTRConfig.enable",
      "short_name": "enable",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.XTRConfig.dtype",
      "short_name": "dtype",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.XTRConfig.dim",
      "short_name": "dim",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.XTRConfig.candidate_k",
      "short_name": "candidate_k",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.XTRConfig.max_query_tokens",
      "short_name": "max_query_tokens",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.XTRConfig.device",
      "short_name": "device",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.XTRConfig.model_id",
      "short_name": "model_id",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.WarpConfig",
      "short_name": "WarpConfig",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [
        "msgspec.Struct"
      ],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Configuration for the WARP/XTR late-interaction reranker.",
      "doc_raw": "Configuration for the WARP/XTR late-interaction reranker.\n\nAttributes\n----------\nindex_dir : str\n    Directory containing the compiled WARP/XTR index artifacts.\nmodel_id : str\n    Identifier for the multivector encoder used by WARP (for reference).\ndevice : str\n    Target device for the WARP executor (\"cpu\" or \"cuda\").\ntop_k : int\n    Candidate fan-out requested from the WARP executor.\nenabled : bool\n    Gate to enable/disable WARP at runtime (defaults to ``False``).\nbudget_ms : int\n    Soft latency budget for the WARP reranking stage.",
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.WarpConfig.budget_ms",
      "short_name": "budget_ms",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.WarpConfig.enabled",
      "short_name": "enabled",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.WarpConfig.top_k",
      "short_name": "top_k",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.WarpConfig.device",
      "short_name": "device",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.WarpConfig.model_id",
      "short_name": "model_id",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.WarpConfig.index_dir",
      "short_name": "index_dir",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.CodeRankConfig",
      "short_name": "CodeRankConfig",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [
        "msgspec.Struct"
      ],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Configuration for the CodeRank dense retriever.",
      "doc_raw": "Configuration for the CodeRank dense retriever.\n\nAttributes\n----------\nmodel_id : str\n    Hugging Face model identifier for CodeRank embeddings (bi-encoder).\ntrust_remote_code : bool\n    Whether to allow custom modules provided by the model repository.\ndevice : str\n    Device identifier (\"cpu\", \"cuda\", or \"auto\") used for inference.\nbatch_size : int\n    Batch size used while encoding queries or code chunks.\nnormalize : bool\n    When ``True`` (default), normalize embeddings for cosine similarity.\nquery_prefix : str\n    Instruction prefix required by the CodeRank model card for queries.\ntop_k : int\n    Maximum number of candidates to retrieve during Stage-A.\nbudget_ms : int\n    Soft latency budget for CodeRank embedding + ANN search.\nmin_stage2_margin : float\n    Score margin threshold that skips Stage-B when confidence is high.\nmin_stage2_candidates : int\n    Minimum candidate count required to invoke Stage-B.",
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.CodeRankConfig.min_stage2_candidates",
      "short_name": "min_stage2_candidates",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.CodeRankConfig.min_stage2_margin",
      "short_name": "min_stage2_margin",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.CodeRankConfig.budget_ms",
      "short_name": "budget_ms",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.CodeRankConfig.top_k",
      "short_name": "top_k",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.CodeRankConfig.query_prefix",
      "short_name": "query_prefix",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.CodeRankConfig.normalize",
      "short_name": "normalize",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.CodeRankConfig.batch_size",
      "short_name": "batch_size",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.CodeRankConfig.device",
      "short_name": "device",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.CodeRankConfig.trust_remote_code",
      "short_name": "trust_remote_code",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.CodeRankConfig.model_id",
      "short_name": "model_id",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings._build_xtr_config",
      "short_name": "_build_xtr_config",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": {
        "annotated_type": "XTRConfig",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings._build_vllm_config",
      "short_name": "_build_vllm_config",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": {
        "annotated_type": "VLLMConfig",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings._parse_int_with_suffix",
      "short_name": "_parse_int_with_suffix",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "value",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "default",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "int",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "config.settings.DEFAULT_RRF_WEIGHTS",
      "short_name": "DEFAULT_RRF_WEIGHTS",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "errors",
      "short_name": "errors",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "CodeIntel-specific exception hierarchy with Problem Details support.",
      "doc_raw": "CodeIntel-specific exception hierarchy with Problem Details support.\n\nThis module defines domain-specific exceptions for CodeIntel MCP server operations.\nAll exceptions inherit from ``KgFoundryError`` and include automatic RFC 9457\nProblem Details mapping with appropriate HTTP status codes and structured context.\n\nThe exception hierarchy is organized by operation category:\n\n- **File Operations**: ``FileOperationError``, ``FileReadError``, ``InvalidLineRangeError``\n- **Git Operations**: ``GitOperationError``\n- **Search Operations**: Use ``VectorSearchError``, ``EmbeddingError`` from kgfoundry_common\n\nExamples\n--------\nRaising file operation error:\n\n>>> raise FileReadError(\"Binary file or encoding error\", path=\"binary_file.png\")\n\nRaising invalid line range error with context:\n\n>>> raise InvalidLineRangeError(\n...     \"start_line must be positive\", path=\"src/main.py\", line_range=(0, 10)\n... )\n\nRaising Git operation error:\n\n>>> try:\n...     git_client.blame_range(path, start, end)\n... except git.exc.GitCommandError as exc:\n...     raise GitOperationError(\"Git blame failed\", path=path, git_command=\"blame\") from exc",
      "docstyle": "google"
    },
    {
      "full_name": "errors.__all__",
      "short_name": "__all__",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "errors.RuntimeUnavailableError",
      "short_name": "RuntimeUnavailableError",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [
        "KgFoundryError"
      ],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "message",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "runtime",
          "kind": "keyword_only",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "detail",
          "kind": "keyword_only",
          "annotated_type": "str | None",
          "default": "None",
          "doc": null
        },
        {
          "name": "cause",
          "kind": "keyword_only",
          "annotated_type": "Exception | None",
          "default": "None",
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Raised when a runtime dependency is missing or disabled.",
      "doc_raw": "Raised when a runtime dependency is missing or disabled.",
      "docstyle": "google"
    },
    {
      "full_name": "errors.RuntimeUnavailableError.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "message",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "runtime",
          "kind": "keyword_only",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "detail",
          "kind": "keyword_only",
          "annotated_type": "str | None",
          "default": "None",
          "doc": null
        },
        {
          "name": "cause",
          "kind": "keyword_only",
          "annotated_type": "Exception | None",
          "default": "None",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "errors.RuntimeLifecycleError",
      "short_name": "RuntimeLifecycleError",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [
        "KgFoundryError"
      ],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "message",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "runtime",
          "kind": "keyword_only",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "cause",
          "kind": "keyword_only",
          "annotated_type": "Exception | None",
          "default": "None",
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Raised when a runtime fails to initialize or shut down.",
      "doc_raw": "Raised when a runtime fails to initialize or shut down.",
      "docstyle": "google"
    },
    {
      "full_name": "errors.RuntimeLifecycleError.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "message",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "runtime",
          "kind": "keyword_only",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "cause",
          "kind": "keyword_only",
          "annotated_type": "Exception | None",
          "default": "None",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "errors.GitOperationError",
      "short_name": "GitOperationError",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [
        "KgFoundryError"
      ],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "message",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "path",
          "kind": "positional_or_keyword",
          "annotated_type": "str | None",
          "default": "None",
          "doc": null
        },
        {
          "name": "git_command",
          "kind": "positional_or_keyword",
          "annotated_type": "str | None",
          "default": "None",
          "doc": null
        },
        {
          "name": "cause",
          "kind": "positional_or_keyword",
          "annotated_type": "Exception | None",
          "default": "None",
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Base exception for Git operation errors.",
      "doc_raw": "Base exception for Git operation errors.\n\nRaised when Git operations fail (blame, history, log, etc.). This is\nappropriate for **system errors** (Git command failed, repository corrupted,\nGit binary not found) and maps to 500 Internal Server Error.\n\nThe exception includes optional path and Git command context for debugging.\n\nParameters\n----------\nmessage : str\n    Human-readable error message explaining what went wrong.\npath : str | None, optional\n    File path that was being operated on. Include this when the error is\n    related to a specific file. Defaults to None.\ngit_command : str | None, optional\n    Git command that failed (e.g., \"blame\", \"log\", \"show\"). Helps identify\n    which Git operation failed. Defaults to None.\ncause : Exception | None, optional\n    Underlying exception (typically ``git.exc.GitCommandError``). Use\n    ``raise ... from cause`` to preserve exception chain. Defaults to None.\n\nExamples\n--------\nWrap GitCommandError from blame:\n\n>>> try:\n...     git_client.blame_range(path, 1, 10)\n... except git.exc.GitCommandError as exc:\n...     raise GitOperationError(\n...         \"Git blame failed\", path=\"src/main.py\", git_command=\"blame\"\n...     ) from exc\n\nWrap GitCommandError from log:\n\n>>> try:\n...     git_client.file_history(path, limit=50)\n... except git.exc.GitCommandError as exc:\n...     raise GitOperationError(\n...         \"Git log failed\", path=\"src/main.py\", git_command=\"log\"\n...     ) from exc\n\nRepository-level error (no specific file):\n\n>>> if not repo_path.exists():\n...     raise GitOperationError(\"Repository not found\", path=None, git_command=None)\n\nNotes\n-----\nHTTP Status: 500 Internal Server Error (system error)\nError Code: \"git-operation-error\"\nContext: ``{\"path\": \"<file_path>\", \"git_command\": \"blame\"}``\n\nBoth path and git_command are optional in context (only included if provided).",
      "docstyle": "google"
    },
    {
      "full_name": "errors.GitOperationError.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "message",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "path",
          "kind": "positional_or_keyword",
          "annotated_type": "str | None",
          "default": "None",
          "doc": null
        },
        {
          "name": "git_command",
          "kind": "positional_or_keyword",
          "annotated_type": "str | None",
          "default": "None",
          "doc": null
        },
        {
          "name": "cause",
          "kind": "positional_or_keyword",
          "annotated_type": "Exception | None",
          "default": "None",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "errors.PathNotDirectoryError",
      "short_name": "PathNotDirectoryError",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [
        "KgFoundryError"
      ],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "message",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "path",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "cause",
          "kind": "keyword_only",
          "annotated_type": "Exception | None",
          "default": "None",
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Raised when a repository path is expected to be a directory but is not.",
      "doc_raw": "Raised when a repository path is expected to be a directory but is not.",
      "docstyle": "google"
    },
    {
      "full_name": "errors.PathNotDirectoryError.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "message",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "path",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "cause",
          "kind": "keyword_only",
          "annotated_type": "Exception | None",
          "default": "None",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "errors.PathNotFoundError",
      "short_name": "PathNotFoundError",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [
        "KgFoundryError"
      ],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "message",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "path",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "cause",
          "kind": "keyword_only",
          "annotated_type": "Exception | None",
          "default": "None",
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Raised when a requested repository path does not exist.",
      "doc_raw": "Raised when a requested repository path does not exist.",
      "docstyle": "google"
    },
    {
      "full_name": "errors.PathNotFoundError.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "message",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "path",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "cause",
          "kind": "keyword_only",
          "annotated_type": "Exception | None",
          "default": "None",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "errors.InvalidLineRangeError",
      "short_name": "InvalidLineRangeError",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [
        "FileOperationError"
      ],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "message",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "path",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "line_range",
          "kind": "positional_or_keyword",
          "annotated_type": "tuple[int | None, int | None] | None",
          "default": "None",
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Raised when line range parameters are invalid.",
      "doc_raw": "Raised when line range parameters are invalid.\n\nThis exception is raised when line range validation fails (negative line\nnumbers, start > end, etc.). It provides structured context including the\ninvalid line range for debugging.\n\nParameters\n----------\nmessage : str\n    Human-readable error message explaining constraint violation.\n    Examples: \"start_line must be a positive integer\",\n    \"end_line must be a positive integer\",\n    \"start_line must be less than or equal to end_line\".\npath : str\n    File path being accessed.\nline_range : tuple[int | None, int | None] | None, optional\n    Requested line range (start_line, end_line) for error context. Either\n    or both values may be None if not provided. Defaults to None.\n\nExamples\n--------\nNegative start_line:\n\n>>> if start_line is not None and start_line <= 0:\n...     raise InvalidLineRangeError(\n...         \"start_line must be a positive integer\",\n...         path=\"src/main.py\",\n...         line_range=(start_line, end_line),\n...     )\n\nStart > end:\n\n>>> if start_line > end_line:\n...     raise InvalidLineRangeError(\n...         \"start_line must be less than or equal to end_line\",\n...         path=\"src/main.py\",\n...         line_range=(start_line, end_line),\n...     )\n\nNotes\n-----\nHTTP Status: 400 Bad Request (user error)\nError Code: \"invalid-parameter\"\nContext: ``{\"path\": \"<file_path>\", \"start_line\": 0, \"end_line\": 10}``\n\nThe line_range context is included in Problem Details extensions for\ndebugging and client error messages.",
      "docstyle": "google"
    },
    {
      "full_name": "errors.InvalidLineRangeError.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "message",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "path",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "line_range",
          "kind": "positional_or_keyword",
          "annotated_type": "tuple[int | None, int | None] | None",
          "default": "None",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "errors.FileReadError",
      "short_name": "FileReadError",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [
        "FileOperationError"
      ],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Raised when file cannot be read due to encoding or binary content.",
      "doc_raw": "Raised when file cannot be read due to encoding or binary content.\n\nThis exception is raised when attempting to read a file that is binary\n(non-text) or has an unsupported encoding. It's appropriate for files that\nexist and are accessible, but cannot be decoded as UTF-8 text.\n\nCommon causes:\n\n- Binary files (images, executables, archives)\n- Files with non-UTF-8 encoding (e.g., Latin-1, UTF-16)\n- Corrupted text files with invalid byte sequences\n\nParameters\n----------\nmessage : str\n    Human-readable error message (e.g., \"Binary file or encoding error\").\npath : str\n    File path that couldn't be read.\ncause : Exception | None, optional\n    Underlying exception (typically ``UnicodeDecodeError``). Defaults to None.\n\nExamples\n--------\nWrap UnicodeDecodeError:\n\n>>> try:\n...     content = path.read_text(encoding=\"utf-8\")\n... except UnicodeDecodeError as exc:\n...     raise FileReadError(\"Binary file or encoding error\", path=str(path)) from exc\n\nDirect raise:\n\n>>> if path.suffix in {\".png\", \".jpg\", \".pdf\"}:\n...     raise FileReadError(\"Binary file type not supported\", path=str(path))\n\nNotes\n-----\nHTTP Status: 400 Bad Request (inherited from FileOperationError)\nError Code: \"file-operation-error\" (inherited)\nContext: ``{\"path\": \"<file_path>\"}``\n\nThe error handling decorator will map this to Problem Details with\nappropriate status and error code.",
      "docstyle": "google"
    },
    {
      "full_name": "errors.FileOperationError",
      "short_name": "FileOperationError",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [
        "KgFoundryError"
      ],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "message",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "path",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "cause",
          "kind": "positional_or_keyword",
          "annotated_type": "Exception | None",
          "default": "None",
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Base exception for file operation errors.",
      "doc_raw": "Base exception for file operation errors.\n\nRaised when file operations fail (read, validation, path resolution, etc.).\nSubclass this for specific file operation error types.\n\nThis exception is appropriate for **user errors** (bad input, file not found,\ninvalid parameters) and maps to 400 Bad Request.\n\nParameters\n----------\nmessage : str\n    Human-readable error message explaining what went wrong.\npath : str\n    File path that caused the error. Included in context for debugging.\ncause : Exception | None, optional\n    Underlying exception that caused the file operation failure. Use\n    ``raise ... from cause`` to preserve exception chain. Defaults to None.\n\nExamples\n--------\n>>> raise FileOperationError(\"Invalid file path\", path=\"/etc/passwd\")\nTraceback (most recent call last):\n    ...\nFileOperationError[file-operation-error]: Invalid file path\n\nWith cause chain:\n\n>>> try:\n...     path.resolve(strict=True)\n... except FileNotFoundError as exc:\n...     raise FileOperationError(\"Path resolution failed\", path=str(path)) from exc\n\nNotes\n-----\nHTTP Status: 400 Bad Request (user error)\nError Code: \"file-operation-error\"\nContext: ``{\"path\": \"<file_path>\"}``",
      "docstyle": "google"
    },
    {
      "full_name": "errors.FileOperationError.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "message",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "path",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "cause",
          "kind": "positional_or_keyword",
          "annotated_type": "Exception | None",
          "default": "None",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "indexing",
      "short_name": "indexing",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "SCIP parsing and chunking utilities for repository indexing.",
      "doc_raw": "SCIP parsing and chunking utilities for repository indexing.",
      "docstyle": "google"
    },
    {
      "full_name": "indexing.cast_chunker",
      "short_name": "cast_chunker",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "cAST chunking using SCIP symbol ranges.",
      "doc_raw": "cAST chunking using SCIP symbol ranges.\n\nImplements structure-aware chunking using symbol boundaries from SCIP\nrather than tree-sitter parsing. Greedily packs top-level symbols up to\nthe character budget, splitting large symbols on blank lines.",
      "docstyle": "google"
    },
    {
      "full_name": "indexing.cast_chunker.__all__",
      "short_name": "__all__",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "indexing.cast_chunker._apply_call_site_overlap",
      "short_name": "_apply_call_site_overlap",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "chunks",
          "kind": "keyword_only",
          "annotated_type": "list[Chunk]",
          "default": null,
          "doc": null
        },
        {
          "name": "encoded",
          "kind": "keyword_only",
          "annotated_type": "bytes",
          "default": null,
          "doc": null
        },
        {
          "name": "byte_starts",
          "kind": "keyword_only",
          "annotated_type": "list[int]",
          "default": null,
          "doc": null
        },
        {
          "name": "options",
          "kind": "keyword_only",
          "annotated_type": "ChunkOverlapOptions",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "list[Chunk]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Add call-site overlap snippets to chunks.",
      "doc_raw": "Add call-site overlap snippets to chunks.\n\nParameters\n----------\nchunks : list[Chunk]\n    Initial chunks to enhance with overlap snippets.\nencoded : bytes\n    UTF-8 encoded file content.\nbyte_starts : list[int]\n    Byte offsets for each line start.\noptions : ChunkOverlapOptions\n    Overlap configuration including file occurrences and chunk lookup.\n\nReturns\n-------\nlist[Chunk]\n    Modified chunks with call-site overlap snippets added.",
      "docstyle": "google"
    },
    {
      "full_name": "indexing.cast_chunker.ChunkOptions",
      "short_name": "ChunkOptions",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "dataclass(frozen=True)"
      ],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "budget",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": "2200",
          "doc": null
        },
        {
          "name": "language",
          "kind": "positional_or_keyword",
          "annotated_type": "str | None",
          "default": "None",
          "doc": null
        },
        {
          "name": "overlap",
          "kind": "positional_or_keyword",
          "annotated_type": "ChunkOverlapOptions | None",
          "default": "None",
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Chunk generation configuration.",
      "doc_raw": "Chunk generation configuration.",
      "docstyle": "google"
    },
    {
      "full_name": "indexing.cast_chunker.ChunkOptions.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "budget",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": "2200",
          "doc": null
        },
        {
          "name": "language",
          "kind": "positional_or_keyword",
          "annotated_type": "str | None",
          "default": "None",
          "doc": null
        },
        {
          "name": "overlap",
          "kind": "positional_or_keyword",
          "annotated_type": "ChunkOverlapOptions | None",
          "default": "None",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "indexing.cast_chunker.ChunkOptions.overlap",
      "short_name": "overlap",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "indexing.cast_chunker.ChunkOptions.language",
      "short_name": "language",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "indexing.cast_chunker.ChunkOptions.budget",
      "short_name": "budget",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "indexing.cast_chunker.ChunkOverlapOptions",
      "short_name": "ChunkOverlapOptions",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "dataclass(frozen=True)"
      ],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "file_occurrences",
          "kind": "positional_or_keyword",
          "annotated_type": "list[tuple[str, int, int, int, int]]",
          "default": null,
          "doc": null
        },
        {
          "name": "def_chunk_lookup",
          "kind": "positional_or_keyword",
          "annotated_type": "dict[str, int]",
          "default": null,
          "doc": null
        },
        {
          "name": "max_related",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": "8",
          "doc": null
        },
        {
          "name": "overlap_lines",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": "8",
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Configuration for adding call-site overlap snippets.",
      "doc_raw": "Configuration for adding call-site overlap snippets.",
      "docstyle": "google"
    },
    {
      "full_name": "indexing.cast_chunker.ChunkOverlapOptions.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "file_occurrences",
          "kind": "positional_or_keyword",
          "annotated_type": "list[tuple[str, int, int, int, int]]",
          "default": null,
          "doc": null
        },
        {
          "name": "def_chunk_lookup",
          "kind": "positional_or_keyword",
          "annotated_type": "dict[str, int]",
          "default": null,
          "doc": null
        },
        {
          "name": "max_related",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": "8",
          "doc": null
        },
        {
          "name": "overlap_lines",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": "8",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "indexing.cast_chunker.ChunkOverlapOptions.overlap_lines",
      "short_name": "overlap_lines",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "indexing.cast_chunker.ChunkOverlapOptions.max_related",
      "short_name": "max_related",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "indexing.cast_chunker.ChunkOverlapOptions.def_chunk_lookup",
      "short_name": "def_chunk_lookup",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "indexing.cast_chunker.ChunkOverlapOptions.file_occurrences",
      "short_name": "file_occurrences",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "indexing.cast_chunker.chunk_file",
      "short_name": "chunk_file",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "path",
          "kind": "positional_or_keyword",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        },
        {
          "name": "text",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "definitions",
          "kind": "positional_or_keyword",
          "annotated_type": "list[SymbolDef]",
          "default": null,
          "doc": null
        },
        {
          "name": "options",
          "kind": "keyword_only",
          "annotated_type": "ChunkOptions | None",
          "default": "None",
          "doc": null
        },
        {
          "name": "budget",
          "kind": "keyword_only",
          "annotated_type": "int | None",
          "default": "None",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "list[Chunk]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Chunk file using SCIP symbol boundaries.",
      "doc_raw": "Chunk file using SCIP symbol boundaries.\n\nGreedily packs top-level symbols up to a budget while optionally adding\nrelated-symbol overlap snippets for better context.\n\nParameters\n----------\npath : Path\n    File path for the source code being chunked.\ntext : str\n    Complete file content as a string.\ndefinitions : list[SymbolDef]\n    List of SCIP symbol definitions extracted from the file.\noptions : ChunkOptions | None, optional\n    Chunk generation configuration. If None, uses default options.\nbudget : int | None, optional\n    Override for the character budget applied during chunk assembly.\n\nReturns\n-------\nlist[Chunk]\n    List of generated chunks in source order.",
      "docstyle": "google"
    },
    {
      "full_name": "indexing.cast_chunker._ChunkBuilder",
      "short_name": "_ChunkBuilder",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "config",
          "kind": "positional_or_keyword",
          "annotated_type": "_ChunkAccumulator",
          "default": null,
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Mutable helper that performs chunk assembly for a fixed configuration.",
      "doc_raw": "Mutable helper that performs chunk assembly for a fixed configuration.",
      "docstyle": "google"
    },
    {
      "full_name": "indexing.cast_chunker._ChunkBuilder._reset",
      "short_name": "_reset",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "indexing.cast_chunker._ChunkBuilder._split_large_symbol",
      "short_name": "_split_large_symbol",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "symbol",
          "kind": "positional_or_keyword",
          "annotated_type": "SymbolDef",
          "default": null,
          "doc": null
        },
        {
          "name": "start",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "end",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "indexing.cast_chunker._ChunkBuilder._append_chunk",
      "short_name": "_append_chunk",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "start",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "end",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "symbols",
          "kind": "positional_or_keyword",
          "annotated_type": "tuple[str, ...]",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "indexing.cast_chunker._ChunkBuilder._flush_current",
      "short_name": "_flush_current",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "indexing.cast_chunker._ChunkBuilder._start_chunk",
      "short_name": "_start_chunk",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "start",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "end",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "symbol",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "indexing.cast_chunker._ChunkBuilder.finalize",
      "short_name": "finalize",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "list[Chunk]",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "indexing.cast_chunker._ChunkBuilder.add_symbol",
      "short_name": "add_symbol",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "symbol",
          "kind": "positional_or_keyword",
          "annotated_type": "SymbolDef",
          "default": null,
          "doc": null
        },
        {
          "name": "start",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "end",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "indexing.cast_chunker._ChunkBuilder._current_symbols",
      "short_name": "_current_symbols",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "indexing.cast_chunker._ChunkBuilder._current_end_char",
      "short_name": "_current_end_char",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "indexing.cast_chunker._ChunkBuilder._current_start_char",
      "short_name": "_current_start_char",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "indexing.cast_chunker._ChunkBuilder._chunks",
      "short_name": "_chunks",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "indexing.cast_chunker._ChunkBuilder._config",
      "short_name": "_config",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "indexing.cast_chunker._ChunkBuilder.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "config",
          "kind": "positional_or_keyword",
          "annotated_type": "_ChunkAccumulator",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "indexing.cast_chunker._ChunkBuilder.__slots__",
      "short_name": "__slots__",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "indexing.cast_chunker._ChunkAccumulator",
      "short_name": "_ChunkAccumulator",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "dataclass(slots=True, frozen=True)"
      ],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "uri",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "text",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "encoded",
          "kind": "positional_or_keyword",
          "annotated_type": "bytes",
          "default": null,
          "doc": null
        },
        {
          "name": "line_index",
          "kind": "positional_or_keyword",
          "annotated_type": "LineIndex",
          "default": null,
          "doc": null
        },
        {
          "name": "budget",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "language",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Immutable accumulator configuration; delegates mutation to a builder.",
      "doc_raw": "Immutable accumulator configuration; delegates mutation to a builder.",
      "docstyle": "google"
    },
    {
      "full_name": "indexing.cast_chunker._ChunkAccumulator.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "uri",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "text",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "encoded",
          "kind": "positional_or_keyword",
          "annotated_type": "bytes",
          "default": null,
          "doc": null
        },
        {
          "name": "line_index",
          "kind": "positional_or_keyword",
          "annotated_type": "LineIndex",
          "default": null,
          "doc": null
        },
        {
          "name": "budget",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "language",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "indexing.cast_chunker._ChunkAccumulator.build_chunks",
      "short_name": "build_chunks",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "symbols_with_positions",
          "kind": "positional_or_keyword",
          "annotated_type": "Sequence[tuple[SymbolDef, int, int]]",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "list[Chunk]",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "indexing.cast_chunker._ChunkAccumulator.language",
      "short_name": "language",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "indexing.cast_chunker._ChunkAccumulator.budget",
      "short_name": "budget",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "indexing.cast_chunker._ChunkAccumulator.line_index",
      "short_name": "line_index",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "indexing.cast_chunker._ChunkAccumulator.encoded",
      "short_name": "encoded",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "indexing.cast_chunker._ChunkAccumulator.text",
      "short_name": "text",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "indexing.cast_chunker._ChunkAccumulator.uri",
      "short_name": "uri",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "indexing.cast_chunker.range_to_bytes",
      "short_name": "range_to_bytes",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "text",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "line_index",
          "kind": "positional_or_keyword",
          "annotated_type": "LineIndex",
          "default": null,
          "doc": null
        },
        {
          "name": "rng",
          "kind": "positional_or_keyword",
          "annotated_type": "Range",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "tuple[int, int]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Convert line/character range to byte offsets.",
      "doc_raw": "Convert line/character range to byte offsets.\n\nParameters\n----------\ntext : str\n    Source text (unused, retained for backward compatibility).\nline_index : LineIndex\n    Line index for character-to-byte conversion.\nrng : Range\n    Range with start and end line/character positions.\n\nReturns\n-------\ntuple[int, int]\n    Tuple of (start_byte, end_byte) offsets.",
      "docstyle": "google"
    },
    {
      "full_name": "indexing.cast_chunker._char_index_for_line",
      "short_name": "_char_index_for_line",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "line_index",
          "kind": "positional_or_keyword",
          "annotated_type": "LineIndex",
          "default": null,
          "doc": null
        },
        {
          "name": "line",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "character",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "int",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Map a line/character pair to an absolute character index.",
      "doc_raw": "Map a line/character pair to an absolute character index.\n\nParameters\n----------\nline_index : LineIndex\n    Line index containing character start positions.\nline : int\n    Zero-based line number.\ncharacter : int\n    Zero-based character offset within the line.\n\nReturns\n-------\nint\n    Absolute character index in the text, clamped to valid range.",
      "docstyle": "google"
    },
    {
      "full_name": "indexing.cast_chunker._line_index_from_byte",
      "short_name": "_line_index_from_byte",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "starts",
          "kind": "positional_or_keyword",
          "annotated_type": "Sequence[int]",
          "default": null,
          "doc": null
        },
        {
          "name": "byte_offset",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "int",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Return the zero-based line index containing ``byte_offset``.",
      "doc_raw": "Return the zero-based line index containing ``byte_offset``.\n\nParameters\n----------\nstarts : Sequence[int]\n    Offsets for the beginning of each line.\nbyte_offset : int\n    Absolute byte offset within the text.\n\nReturns\n-------\nint\n    Zero-based line index best matching the offset.",
      "docstyle": "google"
    },
    {
      "full_name": "indexing.cast_chunker.line_starts",
      "short_name": "line_starts",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "text",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "LineIndex",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Compute character and byte offsets for each line start.",
      "doc_raw": "Compute character and byte offsets for each line start.\n\nParameters\n----------\ntext : str\n    Input text to index.\n\nReturns\n-------\nLineIndex\n    Index containing character starts, byte starts, and character-to-byte mapping.",
      "docstyle": "google"
    },
    {
      "full_name": "indexing.cast_chunker._utf8_length",
      "short_name": "_utf8_length",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "ch",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "int",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Return the UTF-8 encoded length for ``ch``.",
      "doc_raw": "Return the UTF-8 encoded length for ``ch``.\n\nParameters\n----------\nch : str\n    Single character to measure.\n\nReturns\n-------\nint\n    Number of bytes required to encode the character in UTF-8 (1-4).",
      "docstyle": "google"
    },
    {
      "full_name": "indexing.cast_chunker._THREE_BYTE_MAX",
      "short_name": "_THREE_BYTE_MAX",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "indexing.cast_chunker._TWO_BYTE_MAX",
      "short_name": "_TWO_BYTE_MAX",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "indexing.cast_chunker._ONE_BYTE_MAX",
      "short_name": "_ONE_BYTE_MAX",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "indexing.cast_chunker.LineIndex",
      "short_name": "LineIndex",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "dataclass(frozen=True)"
      ],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "char_starts",
          "kind": "positional_or_keyword",
          "annotated_type": "list[int]",
          "default": null,
          "doc": null
        },
        {
          "name": "byte_starts",
          "kind": "positional_or_keyword",
          "annotated_type": "list[int]",
          "default": null,
          "doc": null
        },
        {
          "name": "char_to_byte",
          "kind": "positional_or_keyword",
          "annotated_type": "list[int]",
          "default": null,
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Line start bookkeeping for both character and byte positions.",
      "doc_raw": "Line start bookkeeping for both character and byte positions.",
      "docstyle": "google"
    },
    {
      "full_name": "indexing.cast_chunker.LineIndex.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "char_starts",
          "kind": "positional_or_keyword",
          "annotated_type": "list[int]",
          "default": null,
          "doc": null
        },
        {
          "name": "byte_starts",
          "kind": "positional_or_keyword",
          "annotated_type": "list[int]",
          "default": null,
          "doc": null
        },
        {
          "name": "char_to_byte",
          "kind": "positional_or_keyword",
          "annotated_type": "list[int]",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "indexing.cast_chunker.LineIndex.text_length",
      "short_name": "text_length",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Return the decoded text length in characters.",
      "doc_raw": "Return the decoded text length in characters.",
      "docstyle": "google"
    },
    {
      "full_name": "indexing.cast_chunker.LineIndex.char_to_byte",
      "short_name": "char_to_byte",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "indexing.cast_chunker.LineIndex.byte_starts",
      "short_name": "byte_starts",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "indexing.cast_chunker.LineIndex.char_starts",
      "short_name": "char_starts",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "indexing.cast_chunker.Chunk",
      "short_name": "Chunk",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "dataclass(frozen=True)"
      ],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "uri",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "start_byte",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "end_byte",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "start_line",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "end_line",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "text",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "symbols",
          "kind": "positional_or_keyword",
          "annotated_type": "tuple[str, ...]",
          "default": null,
          "doc": null
        },
        {
          "name": "language",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Code chunk with precise byte and line bounds.",
      "doc_raw": "Code chunk with precise byte and line bounds.\n\nA Chunk represents a contiguous region of source code that has been extracted\nfor indexing. Chunks are created by the cAST chunker using SCIP symbol boundaries\nto ensure that chunks respect semantic structure (functions, classes, etc.) rather\nthan arbitrary text splits.\n\nEach chunk includes precise byte offsets (for exact text extraction) and line\nnumbers (for human-readable display). The chunk also tracks which SCIP symbols\nit contains, enabling symbol-aware search and navigation.\n\nChunks are immutable (frozen dataclass) to ensure thread safety and prevent\naccidental modification. They are designed to be stored in Parquet files with\ntheir embeddings for efficient retrieval.\n\nAttributes\n----------\nuri : str\n    File path or URI identifying the source file. This is typically a relative\n    path from the repository root, matching the SCIP index format. Used for\n    filtering and grouping chunks by file.\nstart_byte : int\n    Starting byte offset (0-indexed) of the chunk within the source file.\n    Used for precise text extraction without re-parsing the file. Byte offsets\n    are more reliable than character offsets for multi-byte encodings.\nend_byte : int\n    Ending byte offset (exclusive, 0-indexed) of the chunk. The chunk text\n    spans from start_byte to end_byte (exclusive).\nstart_line : int\n    Starting line number (0-indexed) for human-readable display. Used in search\n    results and code navigation. Line numbers are computed from byte offsets\n    using line start positions.\nend_line : int\n    Ending line number (0-indexed, inclusive). The chunk spans from start_line\n    to end_line (inclusive). Used for displaying code ranges in search results.\ntext : str\n    The actual source code text of the chunk. This is the substring of the\n    source file from start_byte to end_byte. Stored explicitly for fast\n    retrieval without re-reading files.\nsymbols : tuple[str, ...]\n    Tuple of SCIP symbol strings that are defined or referenced within this\n    chunk. Symbols are in SCIP format (e.g., \"python kgfoundry.core#Function.main\").\n    Used for symbol-aware search and filtering. Empty tuple if no symbols.\nlanguage : str\n    Programming language of the source file containing this chunk. Used for\n    filtering results by language scope and derived from SCIP metadata.",
      "docstyle": "google"
    },
    {
      "full_name": "indexing.cast_chunker.Chunk.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "uri",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "start_byte",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "end_byte",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "start_line",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "end_line",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "text",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "symbols",
          "kind": "positional_or_keyword",
          "annotated_type": "tuple[str, ...]",
          "default": null,
          "doc": null
        },
        {
          "name": "language",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "indexing.cast_chunker.Chunk.language",
      "short_name": "language",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "indexing.cast_chunker.Chunk.symbols",
      "short_name": "symbols",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "indexing.cast_chunker.Chunk.text",
      "short_name": "text",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "indexing.cast_chunker.Chunk.end_line",
      "short_name": "end_line",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "indexing.cast_chunker.Chunk.start_line",
      "short_name": "start_line",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "indexing.cast_chunker.Chunk.end_byte",
      "short_name": "end_byte",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "indexing.cast_chunker.Chunk.start_byte",
      "short_name": "start_byte",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "indexing.cast_chunker.Chunk.uri",
      "short_name": "uri",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "indexing.xtr_build",
      "short_name": "xtr_build",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Utilities for building and verifying XTR token indexes.",
      "doc_raw": "Utilities for building and verifying XTR token indexes.",
      "docstyle": "google"
    },
    {
      "full_name": "indexing.xtr_build.main",
      "short_name": "main",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Entry point allowing ``python -m codeintel_rev.indexing.xtr_build``.",
      "doc_raw": "Entry point allowing ``python -m codeintel_rev.indexing.xtr_build``.",
      "docstyle": "google"
    },
    {
      "full_name": "indexing.xtr_build.build_xtr_index",
      "short_name": "build_xtr_index",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "settings",
          "kind": "positional_or_keyword",
          "annotated_type": "Settings | None",
          "default": "None",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "XTRBuildSummary",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Build XTR token artifacts from DuckDB chunks.",
      "doc_raw": "Build XTR token artifacts from DuckDB chunks.\n\nExtended Summary\n----------------\nThis function orchestrates the complete XTR index building process, reading chunks\nfrom the DuckDB catalog, encoding them into token-level embeddings, and persisting\nthe results as memory-mapped files. It creates the XTR index directory structure,\nencodes all chunks using the configured XTR model, writes token embeddings and\nmetadata, and returns a summary of the generated artifacts. This is the primary\nentry point for building XTR indexes from existing chunk data.\n\nParameters\n----------\nsettings : Settings | None, optional\n    Application settings containing XTR configuration, paths, and model settings.\n    If None, settings are loaded from the default location. Defaults to None.\n\nReturns\n-------\nXTRBuildSummary\n    Summary describing the generated artifacts, including chunk count, token count,\n    embedding dimension, dtype, and file paths for the token matrix and metadata.\n\nRaises\n------\nRuntimeError\n    If no chunks are available to encode in the catalog. This indicates the\n    catalog is empty or chunks table is missing, and index building cannot proceed.\n\nNotes\n-----\nTime complexity O(N * T * D) where N is chunk count, T is average tokens per\nchunk, and D is embedding dimension. Space complexity O(N * T * D) for buffers\nand memmap files. The function performs database I/O, GPU/CPU encoding computation,\nand file I/O. Not thread-safe due to catalog and file system operations.\nThe function creates the XTR directory if it doesn't exist.",
      "docstyle": "google"
    },
    {
      "full_name": "indexing.xtr_build._write_token_matrix",
      "short_name": "_write_token_matrix",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "buffers",
          "kind": "positional_or_keyword",
          "annotated_type": "Sequence[NDArrayAny]",
          "default": null,
          "doc": null
        },
        {
          "name": "dtype",
          "kind": "keyword_only",
          "annotated_type": "np.dtype[Any]",
          "default": null,
          "doc": null
        },
        {
          "name": "dim",
          "kind": "keyword_only",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "root",
          "kind": "keyword_only",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        },
        {
          "name": "total_tokens",
          "kind": "keyword_only",
          "annotated_type": "int",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "Path",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Persist buffered token vectors to memmap storage.",
      "doc_raw": "Persist buffered token vectors to memmap storage.\n\nExtended Summary\n----------------\nThis function writes token embedding vectors to a memory-mapped NumPy array file\nfor efficient random access during XTR search. It creates a memmap file with the\nspecified shape and dtype, then copies vectors from the input buffers into the\nmemmap in order. Vectors are truncated or zero-padded to match the target dimension.\nThe resulting file can be memory-mapped read-only for fast access during search\noperations without loading the entire index into RAM.\n\nParameters\n----------\nbuffers : Sequence[NDArrayAny]\n    Sequence of token embedding arrays, one per chunk. Each array has shape\n    (tokens_per_chunk, embedding_dim). Arrays are concatenated in order.\ndtype : np.dtype[Any]\n    NumPy dtype for the memmap file (typically float32 or float16). Determines\n    file size and precision trade-off.\ndim : int\n    Target embedding dimension for the memmap. Vectors are truncated or\n    zero-padded to this dimension. Must match the XTR index configuration.\nroot : Path\n    Directory path where the token matrix file will be written. The directory\n    must exist or be creatable.\ntotal_tokens : int\n    Total number of tokens across all buffers. Used to allocate the memmap\n    shape as (total_tokens, dim).\n\nReturns\n-------\nPath\n    Path to the persisted token matrix file. Filename is \"tokens.f32\" for\n    float32 or \"tokens.f16\" for float16, based on dtype.\n\nNotes\n-----\nTime complexity O(N * D) where N is total_tokens and D is dim, due to memmap\nwrites. Space complexity O(N * D) for the memmap file on disk. The function\nperforms file I/O and flushes the memmap to ensure data is persisted. Thread-safe\nif buffers are not modified concurrently. Vectors shorter than dim are zero-padded;\nvectors longer than dim are truncated.",
      "docstyle": "google"
    },
    {
      "full_name": "indexing.xtr_build._gather_chunk_vectors",
      "short_name": "_gather_chunk_vectors",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "index",
          "kind": "positional_or_keyword",
          "annotated_type": "XTRIndex",
          "default": null,
          "doc": null
        },
        {
          "name": "catalog",
          "kind": "positional_or_keyword",
          "annotated_type": "DuckDBCatalog",
          "default": null,
          "doc": null
        },
        {
          "name": "dtype",
          "kind": "positional_or_keyword",
          "annotated_type": "np.dtype[Any]",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "tuple[list[NDArrayAny], list[int], list[int], list[int], int]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Collect encoded vectors and offsets for all chunks.",
      "doc_raw": "Collect encoded vectors and offsets for all chunks.\n\nExtended Summary\n----------------\nThis function processes all chunks from the catalog, encodes their text content\ninto token-level embeddings using the XTR index encoder, and collects the\nresulting vectors along with metadata (chunk IDs, offsets, lengths). The vectors\nare converted to the specified dtype for memory efficiency. This is a core step\nin XTR index building, transforming raw chunk text into the token embeddings\nthat will be stored in the memory-mapped index.\n\nParameters\n----------\nindex : XTRIndex\n    XTR index instance used for encoding chunk text into token embeddings.\n    The index's encode_query_tokens method is called for each chunk.\ncatalog : DuckDBCatalog\n    DuckDB catalog containing chunks to encode. Chunks are iterated via\n    _iter_chunk_text helper.\ndtype : np.dtype[Any]\n    NumPy dtype for the encoded vectors (typically float32 or float16).\n    Vectors are cast to this dtype after encoding to reduce memory usage.\n\nReturns\n-------\ntuple[list[NDArrayAny], list[int], list[int], list[int], int]\n    Five-element tuple containing:\n    - List of token embedding arrays, one per chunk\n    - List of chunk IDs corresponding to each buffer\n    - List of token offsets (cumulative token count before each chunk)\n    - List of token lengths (number of tokens per chunk)\n    - Total token count across all chunks\n\nNotes\n-----\nTime complexity O(N * T * D) where N is chunk count, T is average tokens per\nchunk, and D is embedding dimension. Space complexity O(N * T * D) for all\nbuffers. The function performs I/O to read chunks from catalog and GPU/CPU\ncomputation for encoding. Thread-safe if index encoder is thread-safe.\nDimension mismatches are logged as warnings but processing continues.",
      "docstyle": "google"
    },
    {
      "full_name": "indexing.xtr_build._iter_chunk_text",
      "short_name": "_iter_chunk_text",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "catalog",
          "kind": "positional_or_keyword",
          "annotated_type": "DuckDBCatalog",
          "default": null,
          "doc": null
        },
        {
          "name": "batch_size",
          "kind": "keyword_only",
          "annotated_type": "int",
          "default": "1024",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "Iterable[tuple[int, str]]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Yield (chunk_id, content) pairs from the DuckDB catalog.",
      "doc_raw": "Yield (chunk_id, content) pairs from the DuckDB catalog.\n\nExtended Summary\n----------------\nThis generator function efficiently streams chunk data from the DuckDB catalog\nin batches to minimize memory usage. It queries the chunks table ordered by ID,\nfetches rows in configurable batch sizes, and yields (chunk_id, content) tuples.\nThis is used during XTR index building to process chunks incrementally without\nloading the entire catalog into memory.\n\nParameters\n----------\ncatalog : DuckDBCatalog\n    DuckDB catalog instance containing the chunks table. The catalog connection\n    is opened within this function and closed when iteration completes.\nbatch_size : int, optional\n    Number of rows to fetch per database query. Larger batches reduce query\n    overhead but increase memory usage. Defaults to 1024.\n\nYields\n------\ntuple[int, str]\n    Chunk identifier and raw content string. Chunks with None IDs are skipped.\n    Empty content strings are converted to empty strings.\n\nNotes\n-----\nTime complexity O(N) where N is total chunk count, amortized across batch queries.\nSpace complexity O(batch_size) for temporary row storage. The function performs\ndatabase I/O and manages catalog connection lifecycle. Thread-safe if catalog\nconnection is thread-safe. Chunks are yielded in ID order.",
      "docstyle": "google"
    },
    {
      "full_name": "indexing.xtr_build.XTRBuildSummary",
      "short_name": "XTRBuildSummary",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "dataclass(slots=True, frozen=True)"
      ],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "chunk_count",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "token_count",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "dim",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "dtype",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "token_path",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "meta_path",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Metadata describing a freshly built XTR token index.",
      "doc_raw": "Metadata describing a freshly built XTR token index.",
      "docstyle": "google"
    },
    {
      "full_name": "indexing.xtr_build.XTRBuildSummary.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "chunk_count",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "token_count",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "dim",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "dtype",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "token_path",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "meta_path",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "indexing.xtr_build.XTRBuildSummary.meta_path",
      "short_name": "meta_path",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "indexing.xtr_build.XTRBuildSummary.token_path",
      "short_name": "token_path",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "indexing.xtr_build.XTRBuildSummary.dtype",
      "short_name": "dtype",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "indexing.xtr_build.XTRBuildSummary.dim",
      "short_name": "dim",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "indexing.xtr_build.XTRBuildSummary.token_count",
      "short_name": "token_count",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "indexing.xtr_build.XTRBuildSummary.chunk_count",
      "short_name": "chunk_count",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "indexing.xtr_build.LOGGER",
      "short_name": "LOGGER",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "indexing.scip_reader",
      "short_name": "scip_reader",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "SCIP index reader for extracting symbol definitions and ranges.",
      "doc_raw": "SCIP index reader for extracting symbol definitions and ranges.\n\nParses index.scip (protobuf) or index.scip.json and extracts symbol definitions\nwith precise ranges for chunking and code intelligence.",
      "docstyle": "google"
    },
    {
      "full_name": "indexing.scip_reader.__all__",
      "short_name": "__all__",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "indexing.scip_reader.get_top_level_definitions",
      "short_name": "get_top_level_definitions",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "definitions",
          "kind": "positional_or_keyword",
          "annotated_type": "list[SymbolDef]",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "list[SymbolDef]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Filter to top-level definitions (not nested inside others).",
      "doc_raw": "Filter to top-level definitions (not nested inside others).\n\nParameters\n----------\ndefinitions : list[SymbolDef]\n    All symbol definitions for a file.\n\nReturns\n-------\nlist[SymbolDef]\n    Top-level definitions only.",
      "docstyle": "google"
    },
    {
      "full_name": "indexing.scip_reader.extract_definitions",
      "short_name": "extract_definitions",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "index",
          "kind": "positional_or_keyword",
          "annotated_type": "SCIPIndex",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "Iterable[SymbolDef]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Extract symbol definitions from SCIP index.",
      "doc_raw": "Extract symbol definitions from SCIP index.\n\nYields definition occurrences (roles & 1 != 0) or first occurrence per symbol\nas fallback.\n\nParameters\n----------\nindex : SCIPIndex\n    Parsed SCIP index.\n\nYields\n------\nSymbolDef\n    Symbol definition with range.",
      "docstyle": "google"
    },
    {
      "full_name": "indexing.scip_reader.parse_scip_json",
      "short_name": "parse_scip_json",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "json_path",
          "kind": "positional_or_keyword",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "SCIPIndex",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Parse SCIP index from JSON export.",
      "doc_raw": "Parse SCIP index from JSON export.\n\nReads and parses a SCIP index that has been exported to JSON format.\nThe JSON format is more convenient than the binary protobuf format for\nPython processing and debugging.\n\nThe function handles various SCIP JSON formats (different versions may have\nslightly different field names) and converts them to the canonical SCIPIndex\nstructure. It extracts documents and their occurrences, converting range\nformats (array vs object) to the standard tuple format.\n\nParameters\n----------\njson_path : Path\n    Path to the index.scip.json file. This is typically generated by\n    exporting a binary SCIP index using the SCIP CLI tool.\n\nReturns\n-------\nSCIPIndex\n    Parsed SCIP index containing all documents and their symbol occurrences.\n    The index is ready for use with extract_definitions() and other processing\n    functions.\n\nNotes\n-----\nThe function gracefully handles missing or malformed data:\n- Documents without relative_path are skipped\n- Occurrences without symbols are skipped\n- Invalid range formats are skipped\n- Missing fields use empty defaults\n\nThe function does not raise exceptions for parsing errors - it silently\nskips invalid entries to ensure robust processing of partial indexes.",
      "docstyle": "google"
    },
    {
      "full_name": "indexing.scip_reader.SymbolDef",
      "short_name": "SymbolDef",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "dataclass(frozen=True)"
      ],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "symbol",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "path",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "range",
          "kind": "positional_or_keyword",
          "annotated_type": "Range",
          "default": null,
          "doc": null
        },
        {
          "name": "language",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Extracted symbol definition with location information.",
      "doc_raw": "Extracted symbol definition with location information.\n\nRepresents a single symbol definition extracted from a SCIP index. This is\nthe processed form of an Occurrence with role=Definition, converted to\na more convenient format for chunking and indexing.\n\nSymbolDef objects are used by the cAST chunker to create structure-aware\nchunks that respect symbol boundaries. They're also used for symbol search\nand \"go to definition\" functionality.\n\nAttributes\n----------\nsymbol : str\n    SCIP symbol identifier string (e.g., \"python kgfoundry.core#Function.main\").\n    Uniquely identifies the symbol across the entire codebase. Used for\n    cross-references and symbol search.\npath : str\n    File path where this symbol is defined. Typically a relative path from\n    the repository root, matching the Document.relative_path format.\nrange : Range\n    Precise source code range where the symbol is defined. Includes start\n    and end line/character positions. Used for exact location navigation\n    and text extraction.\nlanguage : str\n    Programming language of the file containing this symbol (e.g., \"python\").\n    Used for language-specific processing and filtering. Matches the\n    Document.language value.",
      "docstyle": "google"
    },
    {
      "full_name": "indexing.scip_reader.SymbolDef.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "symbol",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "path",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "range",
          "kind": "positional_or_keyword",
          "annotated_type": "Range",
          "default": null,
          "doc": null
        },
        {
          "name": "language",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "indexing.scip_reader.SymbolDef.language",
      "short_name": "language",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "indexing.scip_reader.SymbolDef.range",
      "short_name": "range",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "indexing.scip_reader.SymbolDef.path",
      "short_name": "path",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "indexing.scip_reader.SymbolDef.symbol",
      "short_name": "symbol",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "indexing.scip_reader.SCIPIndex",
      "short_name": "SCIPIndex",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [
        "msgspec.Struct"
      ],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "SCIP index containing all indexed documents.",
      "doc_raw": "SCIP index containing all indexed documents.\n\nThe root structure of a SCIP index, containing all documents (source files)\nthat have been indexed. This is the top-level object returned by parse_scip_json()\nand is used to extract symbol definitions and build the code intelligence index.\n\nThe index is immutable and can be safely shared across threads. It's designed\nfor efficient serialization to/from JSON format.\n\nAttributes\n----------\ndocuments : tuple[Document, ...]\n    All indexed documents (source files) in the repository. Each document\n    contains symbol occurrences for one file. Empty tuple if no documents\n    indexed. Documents are typically sorted by relative_path for consistent\n    ordering.",
      "docstyle": "google"
    },
    {
      "full_name": "indexing.scip_reader.SCIPIndex.documents",
      "short_name": "documents",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "indexing.scip_reader.Document",
      "short_name": "Document",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [
        "msgspec.Struct"
      ],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "SCIP document representing a source file.",
      "doc_raw": "SCIP document representing a source file.\n\nA Document represents a single source file that has been indexed by SCIP.\nIt contains all symbol occurrences (definitions and references) found in\nthat file, along with metadata about the file's language and path.\n\nDocuments are immutable and designed for efficient serialization to/from\nJSON. They are the building blocks of a SCIPIndex.\n\nAttributes\n----------\nrelative_path : str\n    File path relative to the repository root. This matches the path format\n    used in SCIP indexes and is used to locate files during indexing and\n    search. Should use forward slashes even on Windows.\nlanguage : str\n    Programming language identifier (e.g., \"python\", \"typescript\", \"go\").\n    Used to filter files by language and apply language-specific processing.\n    Matches SCIP language identifiers.\noccurrences : tuple[Occurrence, ...]\n    All symbol occurrences found in this document. Includes both definitions\n    (where symbols are defined) and references (where symbols are used).\n    Empty tuple if no symbols found. Stored as tuple for immutability and\n    efficient serialization.",
      "docstyle": "google"
    },
    {
      "full_name": "indexing.scip_reader.Document.occurrences",
      "short_name": "occurrences",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "indexing.scip_reader.Document.language",
      "short_name": "language",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "indexing.scip_reader.Document.relative_path",
      "short_name": "relative_path",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "indexing.scip_reader.Occurrence",
      "short_name": "Occurrence",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [
        "msgspec.Struct"
      ],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Symbol occurrence in source code.",
      "doc_raw": "Symbol occurrence in source code.\n\nRepresents a single occurrence of a symbol (definition, reference, etc.)\nwithin a source file. Occurrences are extracted from SCIP indexes and\nused to build symbol-to-location mappings.\n\nThe range is stored as a tuple for efficient serialization, matching the\nSCIP JSON format. The roles field uses bit flags to indicate the type\nof occurrence (definition, reference, etc.).\n\nAttributes\n----------\nsymbol : str\n    SCIP symbol identifier string. Format depends on language (e.g.,\n    \"python kgfoundry.core#Function.main\" for Python). Used to link\n    occurrences to symbol definitions.\nrange : tuple[int, int, int, int]\n    Source code range as (start_line, start_character, end_line, end_character).\n    All values are 0-indexed. The range is inclusive at start, exclusive\n    at end (matching LSP convention). Stored as tuple for JSON compatibility.\nroles : int\n    Role bitmask indicating the type of occurrence. Bit 0 (LSB) = Definition,\n    other bits indicate references, implementations, etc. Defaults to 0\n    (unknown/unspecified role). Use bitwise AND to check roles:\n    `(occ.roles & 1) != 0` checks for definition.",
      "docstyle": "google"
    },
    {
      "full_name": "indexing.scip_reader.Occurrence.roles",
      "short_name": "roles",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "indexing.scip_reader.Occurrence.range",
      "short_name": "range",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "indexing.scip_reader.Occurrence.symbol",
      "short_name": "symbol",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "indexing.scip_reader.Range",
      "short_name": "Range",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "dataclass(frozen=True)"
      ],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "start_line",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "start_character",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "end_line",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "end_character",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Source code range with line and character positions.",
      "doc_raw": "Source code range with line and character positions.\n\nRepresents a contiguous region of source code using line and character\ncoordinates. This matches the SCIP/LSP range format, which uses 0-indexed\nlines and characters (columns).\n\nRanges are used to precisely identify symbol definitions and occurrences\nin source files. They can be converted to byte offsets for text extraction\nusing the line_starts() helper function.\n\nAttributes\n----------\nstart_line : int\n    Starting line number (0-indexed). The first line of a file is line 0.\n    Used with start_character to identify the start position.\nstart_character : int\n    Starting character/column position (0-indexed) within start_line.\n    Character 0 is the first character on the line. Used for precise\n    positioning within a line.\nend_line : int\n    Ending line number (0-indexed, inclusive). The range spans from\n    start_line to end_line (inclusive).\nend_character : int\n    Ending character/column position (0-indexed, exclusive) within end_line.\n    The range includes characters from start_character up to (but not\n    including) end_character. This matches LSP/SCIP convention.",
      "docstyle": "google"
    },
    {
      "full_name": "indexing.scip_reader.Range.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "start_line",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "start_character",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "end_line",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "end_character",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "indexing.scip_reader.Range.end_character",
      "short_name": "end_character",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "indexing.scip_reader.Range.end_line",
      "short_name": "end_line",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "indexing.scip_reader.Range.start_character",
      "short_name": "start_character",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "indexing.scip_reader.Range.start_line",
      "short_name": "start_line",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "indexing.scip_reader.RANGE_TUPLE_LENGTH",
      "short_name": "RANGE_TUPLE_LENGTH",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io",
      "short_name": "io",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Storage and external service adapters for CodeIntel MCP.",
      "doc_raw": "Storage and external service adapters for CodeIntel MCP.",
      "docstyle": "google"
    },
    {
      "full_name": "io.rerank_coderankllm",
      "short_name": "rerank_coderankllm",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Listwise reranking using the CodeRankLLM checkpoint.",
      "doc_raw": "Listwise reranking using the CodeRankLLM checkpoint.",
      "docstyle": "google"
    },
    {
      "full_name": "io.rerank_coderankllm.CodeRankListwiseReranker",
      "short_name": "CodeRankListwiseReranker",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "model_id",
          "kind": "keyword_only",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "device",
          "kind": "keyword_only",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "max_new_tokens",
          "kind": "keyword_only",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "temperature",
          "kind": "keyword_only",
          "annotated_type": "float",
          "default": null,
          "doc": null
        },
        {
          "name": "top_p",
          "kind": "keyword_only",
          "annotated_type": "float",
          "default": null,
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Listwise reranking helper built on CodeRankLLM.",
      "doc_raw": "Listwise reranking helper built on CodeRankLLM.",
      "docstyle": "google"
    },
    {
      "full_name": "io.rerank_coderankllm.CodeRankListwiseReranker._parse_rankings",
      "short_name": "_parse_rankings",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "staticmethod"
      ],
      "params": [
        {
          "name": "text",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "valid_ids",
          "kind": "positional_or_keyword",
          "annotated_type": "set[int]",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "list[int]",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.rerank_coderankllm.CodeRankListwiseReranker._build_prompt",
      "short_name": "_build_prompt",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "staticmethod"
      ],
      "params": [
        {
          "name": "query",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "candidates",
          "kind": "positional_or_keyword",
          "annotated_type": "Sequence[tuple[int, str]]",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "str",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.rerank_coderankllm.CodeRankListwiseReranker._ensure_model",
      "short_name": "_ensure_model",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "tuple[PreTrainedTokenizerBase, AutoModelForCausalLM]",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.rerank_coderankllm.CodeRankListwiseReranker.rerank",
      "short_name": "rerank",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "query",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "candidates",
          "kind": "positional_or_keyword",
          "annotated_type": "Sequence[tuple[int, str]]",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "list[int]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Return ordered chunk IDs ranked by CodeRankLLM.",
      "doc_raw": "Return ordered chunk IDs ranked by CodeRankLLM.\n\nParameters\n----------\nquery : str\n    Natural language search query string.\ncandidates : Sequence[tuple[int, str]]\n    Sequence of (chunk_id, code_snippet) tuples to rerank. The code\n    snippets are used as context for the LLM to determine relevance.\n\nReturns\n-------\nlist[int]\n    Ordered list of chunk IDs ranked by CodeRankLLM, highest score first.\n    Length matches len(candidates).\n\nRaises\n------\nRuntimeError\n    If model generation fails or the model cannot produce output.",
      "docstyle": "google"
    },
    {
      "full_name": "io.rerank_coderankllm.CodeRankListwiseReranker.top_p",
      "short_name": "top_p",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.rerank_coderankllm.CodeRankListwiseReranker.temperature",
      "short_name": "temperature",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.rerank_coderankllm.CodeRankListwiseReranker.max_new_tokens",
      "short_name": "max_new_tokens",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.rerank_coderankllm.CodeRankListwiseReranker.device",
      "short_name": "device",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.rerank_coderankllm.CodeRankListwiseReranker.model_id",
      "short_name": "model_id",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.rerank_coderankllm.CodeRankListwiseReranker.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "model_id",
          "kind": "keyword_only",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "device",
          "kind": "keyword_only",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "max_new_tokens",
          "kind": "keyword_only",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "temperature",
          "kind": "keyword_only",
          "annotated_type": "float",
          "default": null,
          "doc": null
        },
        {
          "name": "top_p",
          "kind": "keyword_only",
          "annotated_type": "float",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.rerank_coderankllm.CodeRankListwiseReranker._CACHE",
      "short_name": "_CACHE",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.rerank_coderankllm.CodeRankListwiseReranker._CACHE_LOCK",
      "short_name": "_CACHE_LOCK",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.rerank_coderankllm._MAX_PREVIEW_CHARS",
      "short_name": "_MAX_PREVIEW_CHARS",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.rerank_coderankllm._PROMPT_TEMPLATE",
      "short_name": "_PROMPT_TEMPLATE",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.rerank_coderankllm.LOGGER",
      "short_name": "LOGGER",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.git_client",
      "short_name": "git_client",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Typed Git operations wrapper using GitPython.",
      "doc_raw": "Typed Git operations wrapper using GitPython.\n\nThis module provides typed Python APIs for Git operations (blame, history) using\nGitPython instead of subprocess calls. Benefits include:\n- 50-80ms latency reduction (no subprocess overhead)\n- Structured data returns (no text parsing)\n- Automatic Unicode/locale handling\n- Specific typed exceptions\n- Unit testable (mock git.Repo)\n\nExample Usage\n-------------\nInitialize client with repository path:\n\n>>> from pathlib import Path\n>>> git_client = GitClient(repo_path=Path(\"/path/to/repo\"))\n\nGet blame for line range:\n\n>>> entries = git_client.blame_range(\"src/main.py\", start_line=10, end_line=20)\n>>> for entry in entries:\n...     print(f\"Line {entry['line']}: {entry['author']} - {entry['message']}\")\n\nGet commit history:\n\n>>> commits = git_client.file_history(\"README.md\", limit=10)\n>>> for commit in commits:\n...     print(f\"{commit['sha']}: {commit['message']}\")\n\nAsync wrapper for non-blocking operations:\n\n>>> async_client = AsyncGitClient(git_client)\n>>> entries = await async_client.blame_range(\"src/main.py\", 10, 20)\n\nSee Also\n--------\ncodeintel_rev.mcp_server.adapters.history : Adapters using GitClient\nGitPython documentation : https://gitpython.readthedocs.io/",
      "docstyle": "google"
    },
    {
      "full_name": "io.git_client.__all__",
      "short_name": "__all__",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.git_client.AsyncGitClient",
      "short_name": "AsyncGitClient",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "git_client",
          "kind": "positional_or_keyword",
          "annotated_type": "GitClient",
          "default": null,
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Async wrapper around GitClient using asyncio.to_thread.",
      "doc_raw": "Async wrapper around GitClient using asyncio.to_thread.\n\nProvides async versions of GitClient methods by running synchronous\nGitPython operations in a threadpool. This prevents blocking the event\nloop while allowing concurrent Git operations.\n\nGitPython is synchronous internally (it calls subprocess), so we use\nasyncio.to_thread to offload operations to a threadpool. This enables\nconcurrent Git operations without thread exhaustion.\n\nParameters\n----------\ngit_client : GitClient\n    Synchronous GitClient instance to wrap. The same instance can be\n    shared across multiple AsyncGitClient instances safely.\n\nExamples\n--------\nCreate async client and get blame:\n\n>>> from pathlib import Path\n>>> sync_client = GitClient(repo_path=Path(\".\"))\n>>> async_client = AsyncGitClient(sync_client)\n>>> blame = await async_client.blame_range(\"src/main.py\", 1, 10)\n>>> blame[0][\"author\"]\n'John Doe'\n\nGet commit history:\n\n>>> history = await async_client.file_history(\"README.md\", limit=5)\n>>> len(history)\n5\n\nNotes\n-----\nThe async methods run the synchronous GitClient methods in a threadpool\nvia asyncio.to_thread. This is safe because GitPython operations are\nthread-safe (each operation uses its own subprocess).\n\nFor best performance, use AsyncGitClient when you need to perform multiple\nGit operations concurrently (e.g., blaming multiple files in parallel).\n\nInternal attributes (not part of public API):\n- ``_sync_client``: Synchronous GitClient instance wrapped by this async client",
      "docstyle": "google"
    },
    {
      "full_name": "io.git_client.AsyncGitClient.file_history",
      "short_name": "file_history",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "path",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "limit",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": "50",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "list[dict]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Async version of GitClient.file_history.",
      "doc_raw": "Async version of GitClient.file_history.\n\nRuns synchronous file_history in threadpool to avoid blocking event loop.\nExceptions are propagated from the sync client (see GitClient.file_history).\n\nParameters\n----------\npath : str\n    File path relative to repository root.\nlimit : int, optional\n    Maximum number of commits to return (default: 50).\n\nReturns\n-------\nlist[dict]\n    List of commit dictionaries ordered by date (newest first).\n\nExamples\n--------\n>>> async_client = AsyncGitClient(GitClient(repo_path=Path(\".\")))\n>>> history = await async_client.file_history(\"README.md\", limit=5)\n>>> len(history)\n5",
      "docstyle": "google"
    },
    {
      "full_name": "io.git_client.AsyncGitClient.blame_range",
      "short_name": "blame_range",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "path",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "start_line",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "end_line",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "list[GitBlameEntry]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Async version of GitClient.blame_range.",
      "doc_raw": "Async version of GitClient.blame_range.\n\nRuns synchronous blame_range in threadpool to avoid blocking event loop.\nExceptions are propagated from the sync client (see GitClient.blame_range).\n\nParameters\n----------\npath : str\n    File path relative to repository root.\nstart_line : int\n    Start line number (1-indexed, inclusive).\nend_line : int\n    End line number (1-indexed, inclusive).\n\nReturns\n-------\nlist[GitBlameEntry]\n    List of blame entries for the line range.\n\nExamples\n--------\n>>> async_client = AsyncGitClient(GitClient(repo_path=Path(\".\")))\n>>> blame = await async_client.blame_range(\"README.md\", 1, 10)\n>>> len(blame)\n10",
      "docstyle": "google"
    },
    {
      "full_name": "io.git_client.AsyncGitClient._sync_client",
      "short_name": "_sync_client",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.git_client.AsyncGitClient.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "git_client",
          "kind": "positional_or_keyword",
          "annotated_type": "GitClient",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.git_client.GitClient",
      "short_name": "GitClient",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "dataclass(slots=True, frozen=True)"
      ],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "repo_path",
          "kind": "positional_or_keyword",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Typed wrapper around GitPython for blame and history operations.",
      "doc_raw": "Typed wrapper around GitPython for blame and history operations.\n\nProvides structured APIs that return typed dictionaries instead of parsing\nsubprocess text output. Handles encoding/locale issues automatically via\nGitPython's built-in Unicode support.\n\nThe Git repository is lazy-loaded on first access to avoid startup overhead\nfor applications that may not use Git operations immediately.\n\nAttributes\n----------\nrepo_path : Path\n    Path to repository root directory. GitPython will search parent\n    directories for .git if repo_path is a subdirectory.\n\nExamples\n--------\nCreate client and get blame:\n\n>>> from pathlib import Path\n>>> client = GitClient(repo_path=Path(\"/home/user/myrepo\"))\n>>> blame = client.blame_range(\"src/main.py\", 1, 10)\n>>> blame[0][\"author\"]\n'John Doe'\n\nGet commit history:\n\n>>> history = client.file_history(\"README.md\", limit=5)\n>>> len(history)\n5\n>>> history[0][\"message\"]\n'Update documentation'\n\nNotes\n-----\nThe GitPython Repo object is cached after first access. This is safe because\nGit repositories are generally not modified during server runtime (except for\nindexing operations which run separately).\n\nFor async operations, use AsyncGitClient wrapper which runs operations in\na threadpool via asyncio.to_thread.\n\nInternal attributes (not part of public API):\n- ``_repo``: Cached GitPython Repo instance (lazy-initialized on first property access)",
      "docstyle": "google"
    },
    {
      "full_name": "io.git_client.GitClient.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "repo_path",
          "kind": "positional_or_keyword",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.git_client.GitClient.file_history",
      "short_name": "file_history",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "path",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "limit",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": "50",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "list[dict]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Get commit history for file.",
      "doc_raw": "Get commit history for file.\n\nReturns list of commits that modified the specified file, ordered by\ncommit date (newest first). Includes commit metadata: SHA, author,\ndate, message.\n\nUses GitPython's iter_commits() for efficient history traversal. This\nis faster than `git log` subprocess because it avoids process overhead\nand text parsing.\n\nParameters\n----------\npath : str\n    File path relative to repository root. Path separators should be\n    forward slashes (/) even on Windows.\nlimit : int, optional\n    Maximum number of commits to return (default: 50). Set to a large\n    value (e.g., 1000) to get full history, but be aware of performance\n    impact for files with many commits.\n\nReturns\n-------\nlist[dict]\n    List of commit dictionaries ordered by date (newest first). Each\n    dict contains: sha (8 chars), full_sha (40 chars), author, email,\n    date (ISO 8601), message (summary line).\n\nRaises\n------\nFileNotFoundError\n    If the specified file does not exist in the repository history.\n    This includes files that were deleted in HEAD but existed in\n    past commits.\ngit.exc.GitCommandError\n    If Git operation fails for other reasons.\n\nExamples\n--------\nGet recent commits:\n\n>>> client = GitClient(repo_path=Path(\".\"))\n>>> history = client.file_history(\"README.md\", limit=5)\n>>> for commit in history:\n...     print(f\"{commit['sha']}: {commit['message']}\")\na1b2c3d4: Update documentation\ne5f6g7h8: Fix typo\n...\n\nGet full author info:\n\n>>> commit = history[0]\n>>> print(f\"{commit['author']} <{commit['email']}>\")\nJohn Doe <john@example.com>\n\nNotes\n-----\nThe function returns commits in reverse chronological order (newest\nfirst), matching `git log` default behavior. Dates are in ISO 8601\nformat with timezone info.\n\nFor files with rename history, GitPython's --follow equivalent may\nnot work perfectly. Consider using Git's --follow flag via subprocess\nif rename tracking is critical.",
      "docstyle": "google"
    },
    {
      "full_name": "io.git_client.GitClient.blame_range",
      "short_name": "blame_range",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "path",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "start_line",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "end_line",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "list[GitBlameEntry]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Get Git blame for line range.",
      "doc_raw": "Get Git blame for line range.\n\nReturns blame information for each line in the specified range, showing\nwhich commit last modified the line, who authored it, when, and why.\n\nUses GitPython's blame_incremental() for efficient line-by-line blame.\nThis is faster than running `git blame` subprocess because it uses\nGitPython's internal optimizations and avoids text parsing.\n\nParameters\n----------\npath : str\n    File path relative to repository root. Path separators should be\n    forward slashes (/) even on Windows. GitPython normalizes paths.\nstart_line : int\n    Start line number (1-indexed, inclusive). Must be positive and\n    less than or equal to end_line.\nend_line : int\n    End line number (1-indexed, inclusive). Must be positive and\n    greater than or equal to start_line.\n\nReturns\n-------\nlist[GitBlameEntry]\n    List of blame entries, one per line in range. Each entry is a\n    typed dictionary with fields: line, commit, author, date, message.\n    Lines are ordered by line number (ascending).\n\nRaises\n------\nFileNotFoundError\n    If the specified file does not exist in the repository at HEAD.\n    This is raised instead of git.exc.GitCommandError for clearer\n    error handling in adapters.\ngit.exc.GitCommandError\n    If Git operation fails for other reasons (not a valid commit,\n    permission denied, etc.). The exception message contains details\n    from Git.\n\nExamples\n--------\nGet blame for first 10 lines:\n\n>>> client = GitClient(repo_path=Path(\".\"))\n>>> blame = client.blame_range(\"README.md\", 1, 10)\n>>> for entry in blame:\n...     print(f\"Line {entry['line']}: {entry['author']}\")\nLine 1: John Doe\nLine 2: Jane Smith\n...\n\nHandle file not found:\n\n>>> try:\n...     blame = client.blame_range(\"nonexistent.txt\", 1, 10)\n... except FileNotFoundError as exc:\n...     print(f\"File not found: {exc}\")\nFile not found: File not found: nonexistent.txt\n\nNotes\n-----\nGitPython's blame_incremental returns blame info for entire file, but\nwe filter to requested line range for efficiency. The function handles\nUnicode filenames and author names automatically.\n\nLine numbers are 1-indexed to match editor conventions and Git's\noutput format. Internally, GitPython uses 0-indexed lines.",
      "docstyle": "google"
    },
    {
      "full_name": "io.git_client.GitClient.with_cached_repo",
      "short_name": "with_cached_repo",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "repo",
          "kind": "positional_or_keyword",
          "annotated_type": "git.Repo",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "GitClient",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Return a clone of this client with a cached repository.",
      "doc_raw": "Return a clone of this client with a cached repository.\n\nParameters\n----------\nrepo : git.Repo\n    Repository instance to seed the cache with.\n\nReturns\n-------\nGitClient\n    Clone of this client with ``repo`` cached.",
      "docstyle": "google"
    },
    {
      "full_name": "io.git_client.GitClient.repo",
      "short_name": "repo",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Lazy-load Git repository.",
      "doc_raw": "Lazy-load Git repository.\n\nCreates GitPython Repo instance on first access and caches it for\nsubsequent calls. This avoids repository initialization overhead at\nclient creation time.\n\nReturns\n-------\ngit.Repo\n    GitPython repository object for performing Git operations.\n\nRaises\n------\ngit.exc.InvalidGitRepositoryError\n    If repo_path is not a valid Git repository or .git cannot be found\n    in parent directories.\n\nExamples\n--------\n>>> client = GitClient(repo_path=Path(\".\"))\n>>> repo = client.repo  # Lazy initialization happens here\n>>> repo.head.commit.hexsha\n'a1b2c3d4...'",
      "docstyle": "google"
    },
    {
      "full_name": "io.git_client.GitClient._repo",
      "short_name": "_repo",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.git_client.GitClient.repo_path",
      "short_name": "repo_path",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.git_client._SET_GITCLIENT_ATTR",
      "short_name": "_SET_GITCLIENT_ATTR",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.git_client.LOGGER",
      "short_name": "LOGGER",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.bm25_manager",
      "short_name": "bm25_manager",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "BM25 indexing workflow helpers.",
      "doc_raw": "BM25 indexing workflow helpers.",
      "docstyle": "google"
    },
    {
      "full_name": "io.bm25_manager.__all__",
      "short_name": "__all__",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.bm25_manager._directory_size",
      "short_name": "_directory_size",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "path",
          "kind": "positional_or_keyword",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "int",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Compute total size in bytes for all files beneath a directory.",
      "doc_raw": "Compute total size in bytes for all files beneath a directory.\n\nThis utility function recursively traverses a directory tree and sums the\nsizes of all regular files found. It's used to calculate index sizes for\nmetadata purposes. Symbolic links are followed, but directories themselves\ndon't contribute to the size.\n\nParameters\n----------\npath : Path\n    Root directory path to measure. The function recursively traverses all\n    subdirectories and sums file sizes. The path must exist and be a directory.\n\nReturns\n-------\nint\n    Total size in bytes for all regular files contained within the directory\n    tree. Returns 0 if the directory is empty or contains no files. The\n    size is calculated using file system stat information (st_size).",
      "docstyle": "google"
    },
    {
      "full_name": "io.bm25_manager._detect_pyserini_version",
      "short_name": "_detect_pyserini_version",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": {
        "annotated_type": "str",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Return the installed Pyserini version or ``'unknown'`` if unavailable.",
      "doc_raw": "Return the installed Pyserini version or ``'unknown'`` if unavailable.\n\nReturns\n-------\nstr\n    The Pyserini version string, or ``'unknown'`` if the package is not installed.",
      "docstyle": "google"
    },
    {
      "full_name": "io.bm25_manager._run_pyserini_index",
      "short_name": "_run_pyserini_index",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "cmd",
          "kind": "positional_or_keyword",
          "annotated_type": "list[str]",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Execute the Pyserini index command and raise for failures.",
      "doc_raw": "Execute the Pyserini index command and raise for failures.",
      "docstyle": "google"
    },
    {
      "full_name": "io.bm25_manager._parse_corpus_line",
      "short_name": "_parse_corpus_line",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "raw_line",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "line_number",
          "kind": "keyword_only",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "seen_ids",
          "kind": "keyword_only",
          "annotated_type": "set[str]",
          "default": null,
          "doc": null
        },
        {
          "name": "source_path",
          "kind": "keyword_only",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "tuple[str, str] | None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Parse and validate a JSONL line from the corpus source.",
      "doc_raw": "Parse and validate a JSONL line from the corpus source.\n\nThis function parses a single line from a JSONL corpus file, validates that\nit contains required fields (id and contents/text), checks for duplicate\ndocument IDs, and returns the parsed document identifier and content. Empty\nlines are skipped by returning None.\n\nThe function maintains a set of seen document IDs to detect duplicates within\nthe corpus, which is important for ensuring corpus integrity and preventing\nindexing errors.\n\nParameters\n----------\nraw_line : str\n    Raw line from the JSONL file, including any trailing whitespace or\n    newline characters. Will be stripped before parsing.\nline_number : int\n    One-based line number in the source file. Used for error messages to\n    help identify problematic lines during corpus preparation.\nseen_ids : set[str]\n    Set of document IDs that have been encountered in previous lines. This\n    set is mutated by adding the current document ID if parsing succeeds.\n    Used to detect duplicate document IDs within the corpus.\nsource_path : Path\n    Path to the source JSONL file. Used in error messages to provide context\n    about which file contains the problematic line.\n\nReturns\n-------\ntuple[str, str] | None\n    Tuple of (doc_id, contents) if the line was successfully parsed and\n    validated. Returns None if the line is empty (after stripping) or should\n    be skipped for any reason.\n\nRaises\n------\nValueError\n    Raised in the following cases:\n    - Line contains invalid JSON (JSONDecodeError)\n    - Document object is missing the 'id' field\n    - Document ID has already been seen (duplicate)\n    - Document is missing both 'contents' and 'text' fields, or the content\n      field is empty or not a string",
      "docstyle": "google"
    },
    {
      "full_name": "io.bm25_manager._read_corpus_metadata",
      "short_name": "_read_corpus_metadata",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "path",
          "kind": "positional_or_keyword",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "BM25CorpusMetadata",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Read corpus metadata from JSON file.",
      "doc_raw": "Read corpus metadata from JSON file.\n\nThis helper function deserializes BM25 corpus metadata from a JSON file\ncreated during corpus preparation. The metadata contains information about\ndocument count, source path, content digest, preparation timestamp, and\ngenerator identifier.\n\nParameters\n----------\npath : Path\n    File path to the JSON metadata file. The file must exist and contain\n    valid BM25CorpusMetadata JSON serialized data.\n\nReturns\n-------\nBM25CorpusMetadata\n    Decoded metadata structure containing corpus statistics and provenance\n    information. Includes document count, source path, SHA-256 digest of\n    corpus content, ISO 8601 timestamp, and generator name.\n\nNotes\n-----\nException Propagation:\n    This function may propagate exceptions from underlying operations:\n    - FileNotFoundError: If the metadata file does not exist (from path.read_bytes())\n    - msgspec.DecodeError: If the file contains invalid JSON or data that doesn't\n      match the BM25CorpusMetadata schema (from msgspec.json.decode())",
      "docstyle": "google"
    },
    {
      "full_name": "io.bm25_manager._write_struct",
      "short_name": "_write_struct",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "path",
          "kind": "positional_or_keyword",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        },
        {
          "name": "data",
          "kind": "positional_or_keyword",
          "annotated_type": "msgspec.Struct",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Write a msgspec struct to JSON with UTF-8 encoding.",
      "doc_raw": "Write a msgspec struct to JSON with UTF-8 encoding.",
      "docstyle": "google"
    },
    {
      "full_name": "io.bm25_manager.BM25IndexManager",
      "short_name": "BM25IndexManager",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "settings",
          "kind": "positional_or_keyword",
          "annotated_type": "Settings",
          "default": null,
          "doc": null
        },
        {
          "name": "logger_",
          "kind": "keyword_only",
          "annotated_type": "logging.Logger | None",
          "default": "None",
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Manage BM25 corpus preparation and Lucene index builds.",
      "doc_raw": "Manage BM25 corpus preparation and Lucene index builds.",
      "docstyle": "google"
    },
    {
      "full_name": "io.bm25_manager.BM25IndexManager.build_index",
      "short_name": "build_index",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "options",
          "kind": "positional_or_keyword",
          "annotated_type": "BM25BuildOptions | None",
          "default": "None",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "BM25IndexMetadata",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Invoke Pyserini to build a Lucene BM25 index.",
      "doc_raw": "Invoke Pyserini to build a Lucene BM25 index.\n\nParameters\n----------\noptions : BM25BuildOptions | None, optional\n    Build options. When omitted, defaults from configuration are used.\n\nReturns\n-------\nBM25IndexMetadata\n    Structured metadata describing the resulting Lucene index.\n\nRaises\n------\nFileNotFoundError\n    If the JsonCollection directory does not exist.\nFileExistsError\n    If ``overwrite`` is ``False`` and the index directory already contains data.",
      "docstyle": "google"
    },
    {
      "full_name": "io.bm25_manager.BM25IndexManager.prepare_corpus",
      "short_name": "prepare_corpus",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "source",
          "kind": "positional_or_keyword",
          "annotated_type": "str | Path",
          "default": null,
          "doc": null
        },
        {
          "name": "output_dir",
          "kind": "keyword_only",
          "annotated_type": "str | Path | None",
          "default": "None",
          "doc": null
        },
        {
          "name": "overwrite",
          "kind": "keyword_only",
          "annotated_type": "bool",
          "default": "True",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "BM25CorpusSummary",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Materialize a Pyserini JsonCollection directory from a JSONL source.",
      "doc_raw": "Materialize a Pyserini JsonCollection directory from a JSONL source.\n\nParameters\n----------\nsource : str | Path\n    Path to the JSONL corpus containing ``{\"id\": \"...\", \"contents\": ...}`` rows.\noutput_dir : str | Path | None, optional\n    Override the configured JsonCollection directory. If None, uses the\n    default corpus directory from configuration. The directory will be\n    created if it doesn't exist. Defaults to None.\noverwrite : bool, optional\n    When ``True`` (default) existing documents in the output directory are removed.\n\nReturns\n-------\nBM25CorpusSummary\n    Summary describing the prepared corpus and metadata location.\n\nRaises\n------\nFileNotFoundError\n    If ``source`` does not exist.\nValueError\n    If a document is missing required fields or duplicated.\nFileExistsError\n    If ``overwrite`` is ``False`` and the output directory already contains documents.",
      "docstyle": "google"
    },
    {
      "full_name": "io.bm25_manager.BM25IndexManager.index_dir",
      "short_name": "index_dir",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Return the resolved Lucene index directory.",
      "doc_raw": "Return the resolved Lucene index directory.",
      "docstyle": "google"
    },
    {
      "full_name": "io.bm25_manager.BM25IndexManager.corpus_dir",
      "short_name": "corpus_dir",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Return the resolved corpus JsonCollection directory.",
      "doc_raw": "Return the resolved corpus JsonCollection directory.",
      "docstyle": "google"
    },
    {
      "full_name": "io.bm25_manager.BM25IndexManager._config",
      "short_name": "_config",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.bm25_manager.BM25IndexManager._repo_root",
      "short_name": "_repo_root",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.bm25_manager.BM25IndexManager._logger",
      "short_name": "_logger",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.bm25_manager.BM25IndexManager._settings",
      "short_name": "_settings",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.bm25_manager.BM25IndexManager.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "settings",
          "kind": "positional_or_keyword",
          "annotated_type": "Settings",
          "default": null,
          "doc": null
        },
        {
          "name": "logger_",
          "kind": "keyword_only",
          "annotated_type": "logging.Logger | None",
          "default": "None",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.bm25_manager.BM25BuildOptions",
      "short_name": "BM25BuildOptions",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [
        "msgspec.Struct"
      ],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Options controlling BM25 index builds.",
      "doc_raw": "Options controlling BM25 index builds.",
      "docstyle": "google"
    },
    {
      "full_name": "io.bm25_manager.BM25BuildOptions.store_raw",
      "short_name": "store_raw",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.bm25_manager.BM25BuildOptions.store_docvectors",
      "short_name": "store_docvectors",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.bm25_manager.BM25BuildOptions.store_positions",
      "short_name": "store_positions",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.bm25_manager.BM25BuildOptions.overwrite",
      "short_name": "overwrite",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.bm25_manager.BM25BuildOptions.threads",
      "short_name": "threads",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.bm25_manager.BM25BuildOptions.index_dir",
      "short_name": "index_dir",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.bm25_manager.BM25BuildOptions.json_dir",
      "short_name": "json_dir",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.bm25_manager.BM25IndexMetadata",
      "short_name": "BM25IndexMetadata",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [
        "msgspec.Struct"
      ],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Metadata describing a built BM25 index.",
      "doc_raw": "Metadata describing a built BM25 index.",
      "docstyle": "google"
    },
    {
      "full_name": "io.bm25_manager.BM25IndexMetadata.generator",
      "short_name": "generator",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.bm25_manager.BM25IndexMetadata.index_size_bytes",
      "short_name": "index_size_bytes",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.bm25_manager.BM25IndexMetadata.index_dir",
      "short_name": "index_dir",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.bm25_manager.BM25IndexMetadata.threads",
      "short_name": "threads",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.bm25_manager.BM25IndexMetadata.pyserini_version",
      "short_name": "pyserini_version",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.bm25_manager.BM25IndexMetadata.corpus_source",
      "short_name": "corpus_source",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.bm25_manager.BM25IndexMetadata.corpus_digest",
      "short_name": "corpus_digest",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.bm25_manager.BM25IndexMetadata.built_at",
      "short_name": "built_at",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.bm25_manager.BM25IndexMetadata.doc_count",
      "short_name": "doc_count",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.bm25_manager.BM25CorpusSummary",
      "short_name": "BM25CorpusSummary",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [
        "msgspec.Struct"
      ],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Summary information returned after preparing a corpus.",
      "doc_raw": "Summary information returned after preparing a corpus.",
      "docstyle": "google"
    },
    {
      "full_name": "io.bm25_manager.BM25CorpusSummary.corpus_metadata_path",
      "short_name": "corpus_metadata_path",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.bm25_manager.BM25CorpusSummary.digest",
      "short_name": "digest",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.bm25_manager.BM25CorpusSummary.output_dir",
      "short_name": "output_dir",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.bm25_manager.BM25CorpusSummary.doc_count",
      "short_name": "doc_count",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.bm25_manager.BM25CorpusMetadata",
      "short_name": "BM25CorpusMetadata",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [
        "msgspec.Struct"
      ],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Metadata describing a prepared BM25 corpus.",
      "doc_raw": "Metadata describing a prepared BM25 corpus.",
      "docstyle": "google"
    },
    {
      "full_name": "io.bm25_manager.BM25CorpusMetadata.generator",
      "short_name": "generator",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.bm25_manager.BM25CorpusMetadata.prepared_at",
      "short_name": "prepared_at",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.bm25_manager.BM25CorpusMetadata.digest",
      "short_name": "digest",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.bm25_manager.BM25CorpusMetadata.source_path",
      "short_name": "source_path",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.bm25_manager.BM25CorpusMetadata.doc_count",
      "short_name": "doc_count",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.bm25_manager.logger",
      "short_name": "logger",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.bm25_manager.INDEX_METADATA_FILENAME",
      "short_name": "INDEX_METADATA_FILENAME",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.bm25_manager.CORPUS_METADATA_FILENAME",
      "short_name": "CORPUS_METADATA_FILENAME",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.bm25_manager.GENERATOR_NAME",
      "short_name": "GENERATOR_NAME",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_catalog",
      "short_name": "duckdb_catalog",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "DuckDB catalog for querying Parquet chunks.",
      "doc_raw": "DuckDB catalog for querying Parquet chunks.\n\nProvides SQL views over Parquet directories and query helpers for fast\nchunk retrieval and joins.",
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_catalog.__all__",
      "short_name": "__all__",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_catalog.DuckDBCatalog",
      "short_name": "DuckDBCatalog",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "db_path",
          "kind": "positional_or_keyword",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        },
        {
          "name": "vectors_dir",
          "kind": "positional_or_keyword",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        },
        {
          "name": "materialize",
          "kind": "keyword_only",
          "annotated_type": "bool",
          "default": "False",
          "doc": null
        },
        {
          "name": "manager",
          "kind": "keyword_only",
          "annotated_type": "DuckDBManager | None",
          "default": "None",
          "doc": null
        },
        {
          "name": "log_queries",
          "kind": "keyword_only",
          "annotated_type": "bool | None",
          "default": "None",
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "DuckDB catalog for querying chunks.",
      "doc_raw": "DuckDB catalog for querying chunks.\n\nParameters\n----------\ndb_path : Path\n    DuckDB database path.\nvectors_dir : Path\n    Directory containing Parquet files.\nmaterialize : bool, optional\n    When ``True``, chunk metadata is materialized into a persisted DuckDB\n    table (``chunks_materialized``) with a secondary index on ``uri``. When\n    ``False`` (default), the catalog exposes Parquet files through a view for\n    zero-copy queries.\nmanager : DuckDBManager | None, optional\n    DuckDB connection manager instance. If ``None``, creates a new manager\n    with default configuration. Defaults to ``None``.\nlog_queries : bool | None, optional\n    Enable debug logging of executed SQL statements when ``True``. Defaults to\n    ``None`` which inherits the global logging configuration.",
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_catalog.DuckDBCatalog._embedding_dim",
      "short_name": "_embedding_dim",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "int",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Return the embedding dimension, caching when possible.",
      "doc_raw": "Return the embedding dimension, caching when possible.\n\nReturns\n-------\nint\n    Embedding dimension for the chunks table, or ``0`` when no rows exist.",
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_catalog.DuckDBCatalog.count_chunks",
      "short_name": "count_chunks",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "int",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Count total number of chunks in the index.",
      "doc_raw": "Count total number of chunks in the index.\n\nReturns the total number of chunks across all files. Useful for monitoring\nindex size and validating that indexing completed successfully.\n\nThe count is computed efficiently using DuckDB's COUNT aggregation over\nthe chunks view, which reads directly from Parquet files.\n\nReturns\n-------\nint\n    Total number of chunks in the index. Returns 0 if the chunks view\n    is empty or no Parquet files exist.",
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_catalog.DuckDBCatalog.get_embeddings_by_ids",
      "short_name": "get_embeddings_by_ids",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "ids",
          "kind": "positional_or_keyword",
          "annotated_type": "Sequence[int]",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "NDArrayF32",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Extract embedding vectors for given chunk IDs.",
      "doc_raw": "Extract embedding vectors for given chunk IDs.\n\nRetrieves the pre-computed embedding vectors for chunks, typically used\nafter a FAISS search to get the actual vectors for re-ranking or analysis.\nThe embeddings are stored in Parquet as FixedSizeList arrays and are\nconverted to NumPy arrays for efficient computation.\n\nThe function preserves the order of input IDs in the output array. If\nan ID is not found, it's silently skipped (the output will have fewer\nrows than input IDs).\n\nParameters\n----------\nids : Sequence[int]\n    Sequence of chunk IDs to retrieve embeddings for. IDs must exist\n    in the chunks table. Empty sequence returns empty array.\n\nReturns\n-------\nNDArrayF32\n    Embedding vectors as a 2D NumPy array of shape (n_found, vec_dim)\n    where n_found <= len(ids). Dtype is float32 for memory efficiency.\n    Returns empty array (shape (0, vec_dim)) if no IDs provided or no\n    matches found. The array is ordered by the input ID sequence.",
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_catalog.DuckDBCatalog.query_by_uri",
      "short_name": "query_by_uri",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "uri",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "limit",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": "100",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "list[dict]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Query chunks by file URI/path.",
      "doc_raw": "Query chunks by file URI/path.\n\nRetrieves all chunks from a specific file. Useful for file-level operations\nlike displaying all chunks in a file or filtering search results by file.\n\nThe query uses parameterized SQL to prevent injection and efficiently\nfilters by URI. Results are limited to prevent excessive memory usage\nfor large files. Pass ``limit <= 0`` to disable the limit entirely\nwhile still preserving deterministic ordering by chunk ID.\n\nParameters\n----------\nuri : str\n    File URI or path to query. Should match the uri field in the chunks\n    table (typically a relative path from repo root).\nlimit : int, optional\n    Maximum number of chunks to return. Defaults to 100. Set higher for\n    large files, but be aware of memory usage. Pass 0 or a negative value\n    to disable the limit (not recommended for production).\n\nReturns\n-------\nlist[dict]\n    List of chunk records from the specified file. Each dict contains\n    all chunk columns. Results are ordered by chunk ID (which typically\n    corresponds to file order). Returns empty list if file not found or\n    no chunks in file.",
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_catalog.DuckDBCatalog.get_symbols_for_chunk",
      "short_name": "get_symbols_for_chunk",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "chunk_id",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "list[str]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Return all symbols associated with a chunk.",
      "doc_raw": "Return all symbols associated with a chunk.\n\nParameters\n----------\nchunk_id : int\n    Chunk ID to query symbols for.\n\nReturns\n-------\nlist[str]\n    List of symbol identifiers associated with the chunk. Returns empty\n    list if chunk has no symbols or chunk_id doesn't exist.",
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_catalog.DuckDBCatalog.get_chunk_by_id",
      "short_name": "get_chunk_by_id",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "chunk_id",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "dict | None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Return a single chunk record by ID.",
      "doc_raw": "Return a single chunk record by ID.\n\nParameters\n----------\nchunk_id : int\n    Chunk identifier to retrieve from the catalog.\n\nReturns\n-------\ndict | None\n    Chunk metadata dictionary when the ID exists, otherwise ``None``.",
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_catalog.DuckDBCatalog._is_simple_glob",
      "short_name": "_is_simple_glob",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "staticmethod"
      ],
      "params": [
        {
          "name": "pattern",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "bool",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Check if glob pattern can be converted to SQL LIKE.",
      "doc_raw": "Check if glob pattern can be converted to SQL LIKE.\n\nSimple patterns:\n- `*.py` (suffix match)\n- `**/*.py` (suffix match, equivalent to `*.py`)\n- `src/**` (prefix match)\n- `src/*.py` (prefix + suffix)\n\nComplex patterns (require Python filtering):\n- `src/**/test_*.py` (recursive in middle)\n- `src/[abc]/*.py` (bracket expressions)\n- `src/{a,b}/*.py` (brace expansion)\n\nParameters\n----------\npattern : str\n    Glob pattern to check.\n\nReturns\n-------\nbool\n    True if pattern can be converted to SQL LIKE, False otherwise.",
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_catalog.DuckDBCatalog._determine_filter_type",
      "short_name": "_determine_filter_type",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "staticmethod"
      ],
      "params": [
        {
          "name": "include_globs",
          "kind": "positional_or_keyword",
          "annotated_type": "list[str] | None",
          "default": null,
          "doc": null
        },
        {
          "name": "exclude_globs",
          "kind": "positional_or_keyword",
          "annotated_type": "list[str] | None",
          "default": null,
          "doc": null
        },
        {
          "name": "languages",
          "kind": "positional_or_keyword",
          "annotated_type": "list[str] | None",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "str",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Format the filter type label used for Prometheus metrics.",
      "doc_raw": "Format the filter type label used for Prometheus metrics.\n\nDetermines the type of scope filtering being applied based on the\npresence of glob patterns and language filters. Used to label metrics\nfor observability.\n\nParameters\n----------\ninclude_globs : list[str] | None\n    List of include glob patterns, or None if not specified.\nexclude_globs : list[str] | None\n    List of exclude glob patterns, or None if not specified.\nlanguages : list[str] | None\n    List of language filters, or None if not specified.\n\nReturns\n-------\nstr\n    Filter type label: \"combined\" (both globs and languages),\n    \"glob\" (only glob patterns), \"language\" (only language filters),\n    or \"none\" (no filters).",
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_catalog.DuckDBCatalog._observe_scope_filter_duration",
      "short_name": "_observe_scope_filter_duration",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "start_time",
          "kind": "positional_or_keyword",
          "annotated_type": "float",
          "default": null,
          "doc": null
        },
        {
          "name": "include_globs",
          "kind": "positional_or_keyword",
          "annotated_type": "list[str] | None",
          "default": null,
          "doc": null
        },
        {
          "name": "exclude_globs",
          "kind": "positional_or_keyword",
          "annotated_type": "list[str] | None",
          "default": null,
          "doc": null
        },
        {
          "name": "languages",
          "kind": "positional_or_keyword",
          "annotated_type": "list[str] | None",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Record how long scope filtering took for observability.",
      "doc_raw": "Record how long scope filtering took for observability.",
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_catalog.DuckDBCatalog._apply_language_filters",
      "short_name": "_apply_language_filters",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "staticmethod"
      ],
      "params": [
        {
          "name": "results",
          "kind": "positional_or_keyword",
          "annotated_type": "list[dict]",
          "default": null,
          "doc": null
        },
        {
          "name": "language_extensions",
          "kind": "positional_or_keyword",
          "annotated_type": "frozenset[str]",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "list[dict]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Filter results by normalized file extensions.",
      "doc_raw": "Filter results by normalized file extensions.\n\nThis method filters results to include only those whose URI ends with\none of the specified language extensions. Extensions are matched\ncase-insensitively against the lowercase URI.\n\nParameters\n----------\nresults : list[dict]\n    List of result dictionaries, each containing at least a \"uri\" key.\nlanguage_extensions : frozenset[str]\n    Set of normalized file extensions (e.g., {\".py\", \".js\", \".ts\"}).\n    Extensions should include the leading dot. Empty set means no\n    language filter is applied.\n\nReturns\n-------\nlist[dict]\n    Filtered results matching language extensions. Only results whose\n    URI ends with one of the specified extensions are included.",
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_catalog.DuckDBCatalog._apply_complex_glob_filters",
      "short_name": "_apply_complex_glob_filters",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "staticmethod"
      ],
      "params": [
        {
          "name": "results",
          "kind": "positional_or_keyword",
          "annotated_type": "list[dict]",
          "default": null,
          "doc": null
        },
        {
          "name": "include_patterns",
          "kind": "positional_or_keyword",
          "annotated_type": "tuple[str, ...]",
          "default": null,
          "doc": null
        },
        {
          "name": "exclude_patterns",
          "kind": "positional_or_keyword",
          "annotated_type": "tuple[str, ...]",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "list[dict]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Run Python filtering for complex glob patterns not expressible in SQL.",
      "doc_raw": "Run Python filtering for complex glob patterns not expressible in SQL.\n\nThis method filters results by applying include and exclude glob patterns\nto the URI field of each result dictionary. Patterns that cannot be\nefficiently expressed in SQL (e.g., complex wildcards, multiple patterns)\nare handled here using Python's path matching logic.\n\nParameters\n----------\nresults : list[dict]\n    List of result dictionaries, each containing at least a \"uri\" key.\ninclude_patterns : tuple[str, ...]\n    Glob patterns that URIs must match to be included. Empty tuple means\n    no inclusion filter is applied.\nexclude_patterns : tuple[str, ...]\n    Glob patterns that URIs must not match to be included. Empty tuple\n    means no exclusion filter is applied.\n\nReturns\n-------\nlist[dict]\n    Filtered results matching include/exclude glob patterns. Results\n    matching exclude patterns or not matching include patterns are removed.",
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_catalog.DuckDBCatalog._build_scope_filter_spec",
      "short_name": "_build_scope_filter_spec",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "ids",
          "kind": "positional_or_keyword",
          "annotated_type": "Sequence[int]",
          "default": null,
          "doc": null
        },
        {
          "name": "include_globs",
          "kind": "keyword_only",
          "annotated_type": "list[str] | None",
          "default": null,
          "doc": null
        },
        {
          "name": "exclude_globs",
          "kind": "keyword_only",
          "annotated_type": "list[str] | None",
          "default": null,
          "doc": null
        },
        {
          "name": "languages",
          "kind": "keyword_only",
          "annotated_type": "list[str] | None",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "_ScopeFilterSpec",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Categorize scope filters and language extensions for later processing.",
      "doc_raw": "Categorize scope filters and language extensions for later processing.\n\nParameters\n----------\nids : Sequence[int]\n    Chunk identifiers provided by FAISS.\ninclude_globs : list[str] | None\n    Glob patterns to include via SQL LIKE.\nexclude_globs : list[str] | None\n    Glob patterns to exclude via SQL LIKE.\nlanguages : list[str] | None\n    Language names for extension-based filtering.\n\nReturns\n-------\n_ScopeFilterSpec\n    Structured metadata describing how to materialize the query.",
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_catalog.DuckDBCatalog.query_by_filters",
      "short_name": "query_by_filters",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "ids",
          "kind": "positional_or_keyword",
          "annotated_type": "Sequence[int]",
          "default": null,
          "doc": null
        },
        {
          "name": "include_globs",
          "kind": "keyword_only",
          "annotated_type": "list[str] | None",
          "default": "None",
          "doc": null
        },
        {
          "name": "exclude_globs",
          "kind": "keyword_only",
          "annotated_type": "list[str] | None",
          "default": "None",
          "doc": null
        },
        {
          "name": "languages",
          "kind": "keyword_only",
          "annotated_type": "list[str] | None",
          "default": "None",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "list[dict]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Query chunks by IDs with path and language filtering.",
      "doc_raw": "Query chunks by IDs with path and language filtering.\n\nRetrieves chunk metadata for a list of chunk IDs, applying optional filters\nfor path patterns (include/exclude globs) and programming languages. This\nmethod is used after FAISS search to filter results by scope constraints.\n\nFiltering Strategy:\n- Simple globs (e.g., `*.py`, `src/**`) are converted to SQL `LIKE` patterns\n  for efficient database-side filtering.\n- Complex globs (e.g., `src/**/test_*.py`) fall back to Python `fnmatch`\n  post-filtering after SQL query execution.\n- Language filtering uses file extension mapping (e.g., `python` \u2192 `.py`, `.pyi`).\n\nParameters\n----------\nids : Sequence[int]\n    Sequence of chunk IDs to retrieve. Empty sequence returns empty list.\ninclude_globs : list[str] | None, optional\n    Glob patterns to include. Chunks must match at least one pattern.\n    Empty list means \"include all\" (no filtering). Defaults to None.\nexclude_globs : list[str] | None, optional\n    Glob patterns to exclude. Chunks matching any pattern are removed.\n    Empty list means \"exclude none\". Defaults to None.\nlanguages : list[str] | None, optional\n    Programming language names (e.g., [\"python\", \"typescript\"]).\n    Filters chunks by file extension. Defaults to None.\n\nReturns\n-------\nlist[dict]\n    List of filtered chunk records as dictionaries. Each dict contains all\n    columns from the chunks Parquet file. Results preserve input ID order\n    (via JOIN with UNNEST ordinality). Returns empty list if no IDs provided\n    or all chunks filtered out.\n\nExamples\n--------\nFilter by language:\n\n>>> catalog.query_by_filters([1, 2, 3], languages=[\"python\"])\n[{'id': 1, 'uri': 'src/main.py', ...}, {'id': 2, 'uri': 'src/utils.py', ...}]\n\nFilter by include globs:\n\n>>> catalog.query_by_filters([1, 2, 3], include_globs=[\"src/**/*.py\"])\n[{'id': 1, 'uri': 'src/main.py', ...}]\n\nCombined filters:\n\n>>> catalog.query_by_filters(\n...     [1, 2, 3],\n...     include_globs=[\"**/*.py\"],\n...     exclude_globs=[\"**/test_*.py\"],\n...     languages=[\"python\"],\n... )\n[{'id': 1, 'uri': 'src/main.py', ...}]\n\nNotes\n-----\nSQL LIKE Pattern Conversion:\n- `**/*.py` \u2192 `%.py` (matches any path ending in .py)\n- `src/**` \u2192 `src/%` (matches paths starting with src/)\n- `*.py` \u2192 `%.py` (same as **/*.py in our implementation)\n\nComplex Glob Detection:\n- Patterns with `**` in the middle (e.g., `src/**/test_*.py`) are detected\n  as complex and use Python post-filtering.\n- Patterns with bracket expressions `[...]` or `[!...]` use Python filtering.\n- Simple prefix/suffix patterns use SQL LIKE for performance.\n\nLanguage Extension Mapping:\n- Uses `LANGUAGE_EXTENSIONS` from `scope_utils` module.\n- Unknown languages are silently ignored (no error raised).\n- Extension matching is case-insensitive (normalizes to lowercase).\n\nPerformance:\n- SQL filtering is preferred for large result sets (avoids transferring\n  filtered-out chunks from database).\n- Python post-filtering adds ~1-2ms overhead per 1000 chunks.\n- Consider adding index on `uri` column for faster LIKE queries (see Task 14).",
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_catalog.DuckDBCatalog.query_by_ids",
      "short_name": "query_by_ids",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "ids",
          "kind": "positional_or_keyword",
          "annotated_type": "Sequence[int]",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "list[dict]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Query chunks by their unique IDs.",
      "doc_raw": "Query chunks by their unique IDs.\n\nRetrieves chunk metadata (text, URI, line numbers, etc.) for a list of\nchunk IDs. This is typically used after a FAISS search returns chunk IDs\nto hydrate the results with full chunk information.\n\nThe function constructs a SQL IN clause to efficiently fetch multiple\nchunks in a single query. Results are returned as dictionaries with column\nnames as keys, matching the Parquet schema.\n\nParameters\n----------\nids : Sequence[int]\n    Sequence of chunk IDs to retrieve. IDs must exist in the chunks table.\n    Empty sequence returns empty list.\n\nReturns\n-------\nlist[dict]\n    List of chunk records as dictionaries. Each dict contains all columns\n    from the chunks Parquet file (id, uri, text, start_line, end_line,\n    symbols, etc.). Returns empty list if no IDs provided or no matches.",
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_catalog.DuckDBCatalog.relation_exists",
      "short_name": "relation_exists",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "staticmethod"
      ],
      "params": [
        {
          "name": "conn",
          "kind": "positional_or_keyword",
          "annotated_type": "duckdb.DuckDBPyConnection",
          "default": null,
          "doc": null
        },
        {
          "name": "name",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "bool",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Return True when a table or view exists (public wrapper).",
      "doc_raw": "Return True when a table or view exists (public wrapper).\n\nParameters\n----------\nconn : duckdb.DuckDBPyConnection\n    DuckDB connection to inspect.\nname : str\n    Table or view name to look up.\n\nReturns\n-------\nbool\n    ``True`` when the relation exists in schema ``main``.",
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_catalog.DuckDBCatalog._relation_exists",
      "short_name": "_relation_exists",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "staticmethod"
      ],
      "params": [
        {
          "name": "conn",
          "kind": "positional_or_keyword",
          "annotated_type": "duckdb.DuckDBPyConnection",
          "default": null,
          "doc": null
        },
        {
          "name": "name",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "bool",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Return True when a table or view with ``name`` exists in the main schema.",
      "doc_raw": "Return True when a table or view with ``name`` exists in the main schema.\n\nParameters\n----------\nconn : duckdb.DuckDBPyConnection\n    DuckDB connection used to inspect the catalog.\nname : str\n    Table or view name to look up within the ``main`` schema.\n\nReturns\n-------\nbool\n    ``True`` when the relation exists, otherwise ``False``.",
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_catalog.DuckDBCatalog._ensure_views",
      "short_name": "_ensure_views",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "conn",
          "kind": "positional_or_keyword",
          "annotated_type": "duckdb.DuckDBPyConnection",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Create views over Parquet directories if they do not already exist.",
      "doc_raw": "Create views over Parquet directories if they do not already exist.",
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_catalog.DuckDBCatalog._log_query",
      "short_name": "_log_query",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "sql",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "params",
          "kind": "positional_or_keyword",
          "annotated_type": "object | None",
          "default": "None",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Emit debug log for executed DuckDB statement when enabled.",
      "doc_raw": "Emit debug log for executed DuckDB statement when enabled.",
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_catalog.DuckDBCatalog.connection",
      "short_name": "connection",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "contextmanager"
      ],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "Iterator[duckdb.DuckDBPyConnection]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Yield a configured DuckDB connection.",
      "doc_raw": "Yield a configured DuckDB connection.\n\nYields\n------\nduckdb.DuckDBPyConnection\n    Connection configured with catalog pragmas and ready for queries.",
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_catalog.DuckDBCatalog._ensure_ready",
      "short_name": "_ensure_ready",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Initialize catalog views once in a threadsafe manner.",
      "doc_raw": "Initialize catalog views once in a threadsafe manner.",
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_catalog.DuckDBCatalog.manager",
      "short_name": "manager",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Return the underlying DuckDB manager.",
      "doc_raw": "Return the underlying DuckDB manager.",
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_catalog.DuckDBCatalog.__exit__",
      "short_name": "__exit__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "exc",
          "kind": "var_positional",
          "annotated_type": "object",
          "default": "()",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Exit context manager.",
      "doc_raw": "Exit context manager.",
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_catalog.DuckDBCatalog.__enter__",
      "short_name": "__enter__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "Self",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Enter context manager.",
      "doc_raw": "Enter context manager.\n\nReturns\n-------\nSelf\n    The catalog instance with an active DuckDB connection.",
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_catalog.DuckDBCatalog.close",
      "short_name": "close",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "No-op for compatibility; connections are per-use via the manager.",
      "doc_raw": "No-op for compatibility; connections are per-use via the manager.",
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_catalog.DuckDBCatalog.open",
      "short_name": "open",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Ensure catalog views are initialized.",
      "doc_raw": "Ensure catalog views are initialized.",
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_catalog.DuckDBCatalog._log_queries",
      "short_name": "_log_queries",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_catalog.DuckDBCatalog._views_ready",
      "short_name": "_views_ready",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_catalog.DuckDBCatalog._init_lock",
      "short_name": "_init_lock",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_catalog.DuckDBCatalog._embedding_dim_cache",
      "short_name": "_embedding_dim_cache",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_catalog.DuckDBCatalog._query_builder",
      "short_name": "_query_builder",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_catalog.DuckDBCatalog._manager",
      "short_name": "_manager",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_catalog.DuckDBCatalog.materialize",
      "short_name": "materialize",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_catalog.DuckDBCatalog.vectors_dir",
      "short_name": "vectors_dir",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_catalog.DuckDBCatalog.db_path",
      "short_name": "db_path",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_catalog.DuckDBCatalog.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "db_path",
          "kind": "positional_or_keyword",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        },
        {
          "name": "vectors_dir",
          "kind": "positional_or_keyword",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        },
        {
          "name": "materialize",
          "kind": "keyword_only",
          "annotated_type": "bool",
          "default": "False",
          "doc": null
        },
        {
          "name": "manager",
          "kind": "keyword_only",
          "annotated_type": "DuckDBManager | None",
          "default": "None",
          "doc": null
        },
        {
          "name": "log_queries",
          "kind": "keyword_only",
          "annotated_type": "bool | None",
          "default": "None",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_catalog._ScopeFilterSpec",
      "short_name": "_ScopeFilterSpec",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "dataclass(frozen=True)"
      ],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "chunk_ids",
          "kind": "positional_or_keyword",
          "annotated_type": "tuple[int, ...]",
          "default": null,
          "doc": null
        },
        {
          "name": "simple_include_globs",
          "kind": "positional_or_keyword",
          "annotated_type": "tuple[str, ...] | None",
          "default": null,
          "doc": null
        },
        {
          "name": "simple_exclude_globs",
          "kind": "positional_or_keyword",
          "annotated_type": "tuple[str, ...] | None",
          "default": null,
          "doc": null
        },
        {
          "name": "complex_include_patterns",
          "kind": "positional_or_keyword",
          "annotated_type": "tuple[str, ...]",
          "default": null,
          "doc": null
        },
        {
          "name": "complex_exclude_patterns",
          "kind": "positional_or_keyword",
          "annotated_type": "tuple[str, ...]",
          "default": null,
          "doc": null
        },
        {
          "name": "language_extensions",
          "kind": "positional_or_keyword",
          "annotated_type": "frozenset[str]",
          "default": null,
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Structured scope filter metadata used during scoped queries.",
      "doc_raw": "Structured scope filter metadata used during scoped queries.",
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_catalog._ScopeFilterSpec.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "chunk_ids",
          "kind": "positional_or_keyword",
          "annotated_type": "tuple[int, ...]",
          "default": null,
          "doc": null
        },
        {
          "name": "simple_include_globs",
          "kind": "positional_or_keyword",
          "annotated_type": "tuple[str, ...] | None",
          "default": null,
          "doc": null
        },
        {
          "name": "simple_exclude_globs",
          "kind": "positional_or_keyword",
          "annotated_type": "tuple[str, ...] | None",
          "default": null,
          "doc": null
        },
        {
          "name": "complex_include_patterns",
          "kind": "positional_or_keyword",
          "annotated_type": "tuple[str, ...]",
          "default": null,
          "doc": null
        },
        {
          "name": "complex_exclude_patterns",
          "kind": "positional_or_keyword",
          "annotated_type": "tuple[str, ...]",
          "default": null,
          "doc": null
        },
        {
          "name": "language_extensions",
          "kind": "positional_or_keyword",
          "annotated_type": "frozenset[str]",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_catalog._ScopeFilterSpec.has_complex_globs",
      "short_name": "has_complex_globs",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Return ``True`` when complex include/exclude patterns exist.",
      "doc_raw": "Return ``True`` when complex include/exclude patterns exist.",
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_catalog._ScopeFilterSpec.language_extensions",
      "short_name": "language_extensions",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_catalog._ScopeFilterSpec.complex_exclude_patterns",
      "short_name": "complex_exclude_patterns",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_catalog._ScopeFilterSpec.complex_include_patterns",
      "short_name": "complex_include_patterns",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_catalog._ScopeFilterSpec.simple_exclude_globs",
      "short_name": "simple_exclude_globs",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_catalog._ScopeFilterSpec.simple_include_globs",
      "short_name": "simple_include_globs",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_catalog._ScopeFilterSpec.chunk_ids",
      "short_name": "chunk_ids",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_catalog._EMPTY_CHUNKS_SELECT",
      "short_name": "_EMPTY_CHUNKS_SELECT",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_catalog._scope_filter_duration_seconds",
      "short_name": "_scope_filter_duration_seconds",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_catalog.LOGGER",
      "short_name": "LOGGER",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_dual_index",
      "short_name": "faiss_dual_index",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "FAISS dual-index utilities and metadata helpers.",
      "doc_raw": "FAISS dual-index utilities and metadata helpers.",
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_dual_index.FAISSDualIndexManager",
      "short_name": "FAISSDualIndexManager",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "index_dir",
          "kind": "positional_or_keyword",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        },
        {
          "name": "settings",
          "kind": "positional_or_keyword",
          "annotated_type": "IndexConfig",
          "default": null,
          "doc": null
        },
        {
          "name": "vec_dim",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Manage dual FAISS indexes with CPU/GPU coordination.",
      "doc_raw": "Manage dual FAISS indexes with CPU/GPU coordination.",
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_dual_index.FAISSDualIndexManager._select_secondary_index",
      "short_name": "_select_secondary_index",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "faiss.Index | None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_dual_index.FAISSDualIndexManager._select_primary_index",
      "short_name": "_select_primary_index",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "faiss.Index",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_dual_index.FAISSDualIndexManager._clone_index_to_gpu",
      "short_name": "_clone_index_to_gpu",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "faiss_module",
          "kind": "positional_or_keyword",
          "annotated_type": "ModuleType",
          "default": null,
          "doc": null
        },
        {
          "name": "gpu_resources",
          "kind": "positional_or_keyword",
          "annotated_type": "faiss.StandardGpuResources",
          "default": null,
          "doc": null
        },
        {
          "name": "cpu_index",
          "kind": "positional_or_keyword",
          "annotated_type": "faiss.Index",
          "default": null,
          "doc": null
        },
        {
          "name": "cloner_options",
          "kind": "positional_or_keyword",
          "annotated_type": "faiss.GpuClonerOptions",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "faiss.Index",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_dual_index.FAISSDualIndexManager._build_gpu_cloner_options",
      "short_name": "_build_gpu_cloner_options",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "faiss_module",
          "kind": "positional_or_keyword",
          "annotated_type": "ModuleType",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "faiss.GpuClonerOptions",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_dual_index.FAISSDualIndexManager.try_gpu_clone",
      "short_name": "try_gpu_clone",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "faiss_module",
          "kind": "positional_or_keyword",
          "annotated_type": "ModuleType",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Attempt to clone CPU indexes to GPU for acceleration.",
      "doc_raw": "Attempt to clone CPU indexes to GPU for acceleration.\n\nThis method is public for testing purposes. It attempts to clone\nboth primary and secondary CPU indexes to GPU if CUDA is available.\n\nParameters\n----------\nfaiss_module : ModuleType\n    FAISS module instance to use for GPU operations.",
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_dual_index.FAISSDualIndexManager._load_manifest",
      "short_name": "_load_manifest",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_dual_index.FAISSDualIndexManager._configure_direct_map",
      "short_name": "_configure_direct_map",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "staticmethod"
      ],
      "params": [
        {
          "name": "index",
          "kind": "positional_or_keyword",
          "annotated_type": "faiss.Index",
          "default": null,
          "doc": null
        },
        {
          "name": "faiss_module",
          "kind": "positional_or_keyword",
          "annotated_type": "ModuleType",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_dual_index.FAISSDualIndexManager._wrap_with_idmap",
      "short_name": "_wrap_with_idmap",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "index",
          "kind": "positional_or_keyword",
          "annotated_type": "faiss.Index",
          "default": null,
          "doc": null
        },
        {
          "name": "faiss_module",
          "kind": "positional_or_keyword",
          "annotated_type": "ModuleType",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "faiss.Index",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_dual_index.FAISSDualIndexManager._load_secondary_index",
      "short_name": "_load_secondary_index",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "faiss_module",
          "kind": "positional_or_keyword",
          "annotated_type": "ModuleType",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "faiss.Index",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_dual_index.FAISSDualIndexManager._load_primary_index",
      "short_name": "_load_primary_index",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "faiss_module",
          "kind": "positional_or_keyword",
          "annotated_type": "ModuleType",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "tuple[faiss.Index | None, str | None]",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_dual_index.FAISSDualIndexManager._import_faiss",
      "short_name": "_import_faiss",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "tuple[ModuleType | None, str | None]",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_dual_index.FAISSDualIndexManager._reset_gpu_state",
      "short_name": "_reset_gpu_state",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_dual_index.FAISSDualIndexManager.needs_compaction",
      "short_name": "needs_compaction",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "bool",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Return ``True`` when the secondary index exceeds the compaction threshold.",
      "doc_raw": "Return ``True`` when the secondary index exceeds the compaction threshold.\n\nReturns\n-------\nbool\n    ``True`` when ``secondary.ntotal / primary.ntotal`` is greater than the\n    configured compaction threshold; otherwise ``False``.",
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_dual_index.FAISSDualIndexManager.add_incremental",
      "short_name": "add_incremental",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "vectors",
          "kind": "positional_or_keyword",
          "annotated_type": "NDArrayF32",
          "default": null,
          "doc": null
        },
        {
          "name": "chunk_ids",
          "kind": "positional_or_keyword",
          "annotated_type": "NDArrayI64",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Append vectors to the secondary index and persist them to disk.",
      "doc_raw": "Append vectors to the secondary index and persist them to disk.\n\nParameters\n----------\nvectors : NDArrayF32\n    2-D array of shape ``(n, vec_dim)`` containing the vectors to add. The\n    vectors are L2-normalized before insertion.\nchunk_ids : NDArrayI64\n    1-D array of shape ``(n,)`` containing the chunk identifiers to bind to\n    the provided vectors. IDs are coerced to ``int64``.\n\nRaises\n------\nRuntimeError\n    If :meth:`ensure_ready` has not been called yet.\nValueError\n    If the vectors do not match the configured embedding dimension or if\n    the number of vectors differs from the number of chunk IDs.",
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_dual_index.FAISSDualIndexManager.search",
      "short_name": "search",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "query_vec",
          "kind": "positional_or_keyword",
          "annotated_type": "NDArrayF32",
          "default": null,
          "doc": null
        },
        {
          "name": "k",
          "kind": "keyword_only",
          "annotated_type": "int",
          "default": "10",
          "doc": null
        },
        {
          "name": "nprobe",
          "kind": "keyword_only",
          "annotated_type": "int | None",
          "default": "None",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "list[tuple[int, float]]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Search primary and secondary indexes and merge results.",
      "doc_raw": "Search primary and secondary indexes and merge results.\n\nParameters\n----------\nquery_vec : NDArrayF32\n    Query vector with shape ``(vec_dim,)`` or ``(1, vec_dim)``.\nk : int, optional\n    Number of results to return. Defaults to ``10``.\nnprobe : int | None, optional\n    IVF probe count for the primary index. When ``None`` uses the\n    configured ``IndexConfig.faiss_nprobe`` value.\n\nReturns\n-------\nlist[tuple[int, float]]\n    Top-``k`` ``(chunk_id, score)`` pairs sorted by decreasing score.\n\nRaises\n------\nRuntimeError\n    If the primary index has not been loaded via :meth:`ensure_ready`.\nValueError\n    If the query contains multiple vectors. Batch search support will be\n    added in a future task.",
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_dual_index.FAISSDualIndexManager.close",
      "short_name": "close",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Release FAISS handles and GPU resources.",
      "doc_raw": "Release FAISS handles and GPU resources.",
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_dual_index.FAISSDualIndexManager.ensure_ready",
      "short_name": "ensure_ready",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "tuple[bool, str | None]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Load FAISS artifacts from disk and prepare GPU state.",
      "doc_raw": "Load FAISS artifacts from disk and prepare GPU state.\n\nReturns\n-------\ntuple[bool, str | None]\n    ``(ready, reason)`` where ``ready`` indicates whether CPU indexes are\n    available. ``reason`` carries a degradation message when GPU cloning\n    fails or prerequisites are missing.",
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_dual_index.FAISSDualIndexManager.manifest",
      "short_name": "manifest",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Return the cached index manifest metadata, if one was loaded.",
      "doc_raw": "Return the cached index manifest metadata, if one was loaded.",
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_dual_index.FAISSDualIndexManager.secondary_index",
      "short_name": "secondary_index",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Return the loaded secondary FAISS index, if available.",
      "doc_raw": "Return the loaded secondary FAISS index, if available.",
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_dual_index.FAISSDualIndexManager.primary_index",
      "short_name": "primary_index",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Return the loaded primary FAISS index, if available.",
      "doc_raw": "Return the loaded primary FAISS index, if available.",
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_dual_index.FAISSDualIndexManager.gpu_disabled_reason",
      "short_name": "gpu_disabled_reason",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Explain why GPU acceleration is disabled, if applicable.",
      "doc_raw": "Explain why GPU acceleration is disabled, if applicable.",
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_dual_index.FAISSDualIndexManager.gpu_enabled",
      "short_name": "gpu_enabled",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Return ``True`` when GPU acceleration is enabled.",
      "doc_raw": "Return ``True`` when GPU acceleration is enabled.",
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_dual_index.FAISSDualIndexManager.set_test_indexes",
      "short_name": "set_test_indexes",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "primary",
          "kind": "positional_or_keyword",
          "annotated_type": "faiss.Index | None",
          "default": null,
          "doc": null
        },
        {
          "name": "secondary",
          "kind": "positional_or_keyword",
          "annotated_type": "faiss.Index | None",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Set CPU indexes for testing purposes.",
      "doc_raw": "Set CPU indexes for testing purposes.\n\nThis method allows tests to inject CPU indexes directly, bypassing\nthe normal loading mechanism. It is public for testing purposes only.\n\nParameters\n----------\nprimary : faiss.Index | None\n    Primary CPU index to set.\nsecondary : faiss.Index | None\n    Secondary CPU index to set.",
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_dual_index.FAISSDualIndexManager._gpu_disabled_reason",
      "short_name": "_gpu_disabled_reason",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_dual_index.FAISSDualIndexManager._gpu_enabled",
      "short_name": "_gpu_enabled",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_dual_index.FAISSDualIndexManager._gpu_resources",
      "short_name": "_gpu_resources",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_dual_index.FAISSDualIndexManager._faiss_module",
      "short_name": "_faiss_module",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_dual_index.FAISSDualIndexManager._manifest",
      "short_name": "_manifest",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_dual_index.FAISSDualIndexManager._secondary_gpu",
      "short_name": "_secondary_gpu",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_dual_index.FAISSDualIndexManager._secondary_cpu",
      "short_name": "_secondary_cpu",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_dual_index.FAISSDualIndexManager._primary_gpu",
      "short_name": "_primary_gpu",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_dual_index.FAISSDualIndexManager._primary_cpu",
      "short_name": "_primary_cpu",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_dual_index.FAISSDualIndexManager._vec_dim",
      "short_name": "_vec_dim",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_dual_index.FAISSDualIndexManager._settings",
      "short_name": "_settings",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_dual_index.FAISSDualIndexManager._index_dir",
      "short_name": "_index_dir",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_dual_index.FAISSDualIndexManager.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "index_dir",
          "kind": "positional_or_keyword",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        },
        {
          "name": "settings",
          "kind": "positional_or_keyword",
          "annotated_type": "IndexConfig",
          "default": null,
          "doc": null
        },
        {
          "name": "vec_dim",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_dual_index.IndexManifest",
      "short_name": "IndexManifest",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "dataclass(slots=True, frozen=True)"
      ],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "version",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "vec_dim",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "index_type",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "metric",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "trained_on",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "built_at",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "gpu_enabled",
          "kind": "positional_or_keyword",
          "annotated_type": "bool",
          "default": null,
          "doc": null
        },
        {
          "name": "primary_count",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "secondary_count",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "nlist",
          "kind": "positional_or_keyword",
          "annotated_type": "int | None",
          "default": "None",
          "doc": null
        },
        {
          "name": "pq_m",
          "kind": "positional_or_keyword",
          "annotated_type": "int | None",
          "default": "None",
          "doc": null
        },
        {
          "name": "cuvs_version",
          "kind": "positional_or_keyword",
          "annotated_type": "str | None",
          "default": "None",
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Persisted metadata for FAISS dual-index deployments.",
      "doc_raw": "Persisted metadata for FAISS dual-index deployments.",
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_dual_index.IndexManifest.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "version",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "vec_dim",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "index_type",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "metric",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "trained_on",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "built_at",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "gpu_enabled",
          "kind": "positional_or_keyword",
          "annotated_type": "bool",
          "default": null,
          "doc": null
        },
        {
          "name": "primary_count",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "secondary_count",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "nlist",
          "kind": "positional_or_keyword",
          "annotated_type": "int | None",
          "default": "None",
          "doc": null
        },
        {
          "name": "pq_m",
          "kind": "positional_or_keyword",
          "annotated_type": "int | None",
          "default": "None",
          "doc": null
        },
        {
          "name": "cuvs_version",
          "kind": "positional_or_keyword",
          "annotated_type": "str | None",
          "default": "None",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_dual_index.IndexManifest.to_file",
      "short_name": "to_file",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "path",
          "kind": "positional_or_keyword",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Serialize the manifest to ``path`` as formatted JSON.",
      "doc_raw": "Serialize the manifest to ``path`` as formatted JSON.",
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_dual_index.IndexManifest.from_file",
      "short_name": "from_file",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "classmethod"
      ],
      "params": [
        {
          "name": "cls",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "path",
          "kind": "positional_or_keyword",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "IndexManifest",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Load manifest metadata from a JSON document.",
      "doc_raw": "Load manifest metadata from a JSON document.\n\nParameters\n----------\npath : Path\n    Filesystem path to the manifest JSON file.\n\nReturns\n-------\nIndexManifest\n    Parsed manifest instance populated with the JSON payload.\n\nRaises\n------\nTypeError\n    If the JSON payload is not a mapping object.\nValueError\n    If required fields are missing or have incompatible types.",
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_dual_index.IndexManifest.cuvs_version",
      "short_name": "cuvs_version",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_dual_index.IndexManifest.pq_m",
      "short_name": "pq_m",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_dual_index.IndexManifest.nlist",
      "short_name": "nlist",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_dual_index.IndexManifest.secondary_count",
      "short_name": "secondary_count",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_dual_index.IndexManifest.primary_count",
      "short_name": "primary_count",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_dual_index.IndexManifest.gpu_enabled",
      "short_name": "gpu_enabled",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_dual_index.IndexManifest.built_at",
      "short_name": "built_at",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_dual_index.IndexManifest.trained_on",
      "short_name": "trained_on",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_dual_index.IndexManifest.metric",
      "short_name": "metric",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_dual_index.IndexManifest.index_type",
      "short_name": "index_type",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_dual_index.IndexManifest.vec_dim",
      "short_name": "vec_dim",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_dual_index.IndexManifest.version",
      "short_name": "version",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_dual_index.__all__",
      "short_name": "__all__",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_dual_index.LOGGER",
      "short_name": "LOGGER",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_manager",
      "short_name": "faiss_manager",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "FAISS manager for GPU-accelerated vector search.",
      "doc_raw": "FAISS manager for GPU-accelerated vector search.\n\nManages adaptive FAISS indexes (Flat, IVFFlat, or IVF-PQ) with cuVS acceleration,\nCPU persistence, and GPU cloning. Index type is automatically selected based on\ncorpus size for optimal performance.",
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_manager.__all__",
      "short_name": "__all__",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_manager._coerce_to_int",
      "short_name": "_coerce_to_int",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "value",
          "kind": "positional_or_keyword",
          "annotated_type": "object",
          "default": null,
          "doc": null
        },
        {
          "name": "default",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": "-1",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "int",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Safely round arbitrary objects to integers for index comparisons.",
      "doc_raw": "Safely round arbitrary objects to integers for index comparisons.\n\nParameters\n----------\nvalue : object\n    Candidate value that might be converted to an integer.\ndefault : int\n    Fallback value when conversion is not possible.\n\nReturns\n-------\nint\n    Converted integer or the provided default.",
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_manager.FAISSManager",
      "short_name": "FAISSManager",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "index_path",
          "kind": "positional_or_keyword",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        },
        {
          "name": "vec_dim",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": "2560",
          "doc": null
        },
        {
          "name": "nlist",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": "8192",
          "doc": null
        },
        {
          "name": "use_cuvs",
          "kind": "keyword_only",
          "annotated_type": "bool",
          "default": "True",
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "FAISS index manager with adaptive indexing, GPU support, and incremental updates.",
      "doc_raw": "FAISS index manager with adaptive indexing, GPU support, and incremental updates.\n\nUses a dual-index architecture for fast incremental updates.\n\n**Primary Index** (built via `build_index()`):\n- Adaptive type selection based on corpus size\n- Small (<5K vectors): Flat index for exact search\n- Medium (5K-50K vectors): IVFFlat with dynamic nlist\n- Large (>50K vectors): IVF-PQ with dynamic nlist\n- Trained on initial corpus, expensive to rebuild\n\n**Secondary Index** (updated via `update_index()`):\n- Flat index (IndexFlatIP) for fast incremental additions\n- No training required - instant updates (seconds)\n- Used for new vectors added after initial build\n- Automatically searched alongside primary index\n\n**Architecture Diagram**:\n```\nSearch Query\n    |\n    \u251c\u2500> Primary Index (IVF-PQ/IVFFlat/Flat)\n    |       \u2514\u2500> Returns top-k results\n    |\n    \u2514\u2500> Secondary Index (Flat) [if exists]\n            \u2514\u2500> Returns top-k results\n    |\n    \u2514\u2500> Merge Results by Score\n            \u2514\u2500> Return top-k combined results\n```\n\nThe secondary index is optional and controlled by usage of `update_index()`.\nWhen `update_index()` is called, the secondary index is automatically created\nif it doesn't exist. Use `merge_indexes()` periodically to merge secondary\ninto primary and rebuild for optimal performance.\n\nParameters\n----------\nindex_path : Path\n    Path to CPU index file.\nvec_dim : int\n    Vector dimension.\nnlist : int\n    Number of IVF centroids (used as fallback for large corpora if dynamic\n    calculation yields smaller value). For adaptive indexing, this parameter\n    is typically overridden by dynamic nlist calculation.\nuse_cuvs : bool\n    Enable cuVS acceleration.",
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_manager.FAISSManager._active_index",
      "short_name": "_active_index",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "_faiss.Index",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Return the best available search index.",
      "doc_raw": "Return the best available search index.\n\nReturns\n-------\n_faiss.Index\n    GPU-backed index when available, otherwise the CPU index.\n\nRaises\n------\nRuntimeError\n    If neither CPU nor GPU indexes are available.",
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_manager.FAISSManager._downcast_index",
      "short_name": "_downcast_index",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "staticmethod"
      ],
      "params": [
        {
          "name": "index",
          "kind": "positional_or_keyword",
          "annotated_type": "_faiss.Index",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "_faiss.Index",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Return a concrete FAISS index implementation when possible.",
      "doc_raw": "Return a concrete FAISS index implementation when possible.\n\nReturns\n-------\n_faiss.Index\n    Downcast index when supported, otherwise the provided handle.",
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_manager.FAISSManager._require_cpu_index",
      "short_name": "_require_cpu_index",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "_faiss.Index",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Return the CPU index if initialized.",
      "doc_raw": "Return the CPU index if initialized.\n\nReturns\n-------\n_faiss.Index\n    Initialized CPU FAISS index.\n\nRaises\n------\nRuntimeError\n    If the index has not been built or loaded yet.",
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_manager.FAISSManager._try_load_cuvs",
      "short_name": "_try_load_cuvs",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "staticmethod"
      ],
      "params": [],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Load cuVS acceleration library if available.",
      "doc_raw": "Load cuVS acceleration library if available.\n\nRaises\n------\nImportError\n    If the optional pylibcuvs package is not installed.\nRuntimeError\n    If the cuVS shared library cannot be loaded.",
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_manager.FAISSManager._extract_all_vectors",
      "short_name": "_extract_all_vectors",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "index",
          "kind": "positional_or_keyword",
          "annotated_type": "_faiss.Index",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "tuple[NDArrayF32, NDArrayI64]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Extract all vectors and IDs from a FAISS index.",
      "doc_raw": "Extract all vectors and IDs from a FAISS index.\n\nReconstructs vectors from the index and retrieves their associated IDs.\nFor quantized indexes (e.g., IVF-PQ), reconstruction returns approximate\nvectors (dequantized from the codebook).\n\nParameters\n----------\nindex : _faiss.Index\n    FAISS index to extract vectors from. Must support `reconstruct()` and\n    have an `id_map` attribute (IndexIDMap2 wrapper).\n\nReturns\n-------\ntuple[NDArrayF32, NDArrayI64]\n    Tuple of (vectors, ids):\n    - vectors: shape (n_vectors, vec_dim), dtype float32\n    - ids: shape (n_vectors,), dtype int64\n\nRaises\n------\nRuntimeError\n    If the index does not support vector reconstruction or ID mapping.\n    This can occur with certain index types or if the index is not wrapped\n    with IndexIDMap2.\nTypeError\n    If the index's ``id_map`` interface is invalid (missing ``at`` or not callable),\n    or if the id_map interface is missing required methods.",
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_manager.FAISSManager.merge_indexes",
      "short_name": "merge_indexes",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Merge secondary index into primary index (periodic rebuild).",
      "doc_raw": "Merge secondary index into primary index (periodic rebuild).\n\nRebuilds the primary index to include all vectors from both the primary\nand secondary indexes. After merging, the secondary index is cleared,\nallowing for a fresh start for future incremental updates.\n\nThis operation is expensive (requires rebuilding the primary index) but\nshould be performed periodically to maintain optimal search performance.\nAfter merging, search operations will only query the primary index,\nwhich is faster than dual-index search.\n\nThe merge process:\n1. Extracts all vectors and IDs from both primary and secondary indexes\n2. Combines them into a single dataset\n3. Rebuilds the primary index with adaptive type selection\n4. Adds all vectors to the rebuilt primary index\n5. Clears the secondary index and incremental IDs\n\nNotes\n-----\nThis method requires that vectors can be reconstructed from the indexes.\nFor IVF-PQ indexes, reconstruction may be approximate (quantized).\nThe method will raise RuntimeError if reconstruction is not supported.\n\nExamples\n--------\n>>> manager = FAISSManager(index_path=Path(\"index.faiss\"), vec_dim=2560)\n>>> manager.build_index(initial_vectors)\n>>> manager.update_index(new_vectors, new_ids)  # Add incrementally\n>>> # Periodically merge to optimize performance\n>>> manager.merge_indexes()  # Rebuilds primary with all vectors\n\nRaises\n------\nRuntimeError\n    If the primary index is not available, or if vector extraction fails\n    (e.g., index does not support reconstruction or ID mapping).",
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_manager.FAISSManager._merge_results",
      "short_name": "_merge_results",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "staticmethod"
      ],
      "params": [
        {
          "name": "dists1",
          "kind": "positional_or_keyword",
          "annotated_type": "NDArrayF32",
          "default": null,
          "doc": null
        },
        {
          "name": "ids1",
          "kind": "positional_or_keyword",
          "annotated_type": "NDArrayI64",
          "default": null,
          "doc": null
        },
        {
          "name": "dists2",
          "kind": "positional_or_keyword",
          "annotated_type": "NDArrayF32",
          "default": null,
          "doc": null
        },
        {
          "name": "ids2",
          "kind": "positional_or_keyword",
          "annotated_type": "NDArrayI64",
          "default": null,
          "doc": null
        },
        {
          "name": "k",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "tuple[NDArrayF32, NDArrayI64]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Merge search results from two indexes by score.",
      "doc_raw": "Merge search results from two indexes by score.\n\nCombines results from primary and secondary indexes, sorts by distance\n(inner product, higher is better), and returns the top-k combined results.\n\nParameters\n----------\ndists1 : NDArrayF32\n    Distances from first index, shape (n_queries, k1).\nids1 : NDArrayI64\n    IDs from first index, shape (n_queries, k1).\ndists2 : NDArrayF32\n    Distances from second index, shape (n_queries, k2).\nids2 : NDArrayI64\n    IDs from second index, shape (n_queries, k2).\nk : int\n    Number of top results to return after merging.\n\nReturns\n-------\ntuple[NDArrayF32, NDArrayI64]\n    Tuple of (merged_distances, merged_ids), both shape (n_queries, k).\n    Results are sorted by distance (descending for inner product).\n\nNotes\n-----\nUses inner product distance (cosine similarity after normalization),\nwhere higher values indicate better matches. Results are sorted in\ndescending order and top-k is selected.",
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_manager.FAISSManager.primary_index_impl",
      "short_name": "primary_index_impl",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "_faiss.Index",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Return the underlying FAISS index implementation for primary CPU index.",
      "doc_raw": "Return the underlying FAISS index implementation for primary CPU index.\n\nReturns\n-------\n_faiss.Index\n    Downcast FAISS index representing the current primary structure.",
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_manager.FAISSManager.search_secondary",
      "short_name": "search_secondary",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "query",
          "kind": "positional_or_keyword",
          "annotated_type": "NDArrayF32",
          "default": null,
          "doc": null
        },
        {
          "name": "k",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "tuple[NDArrayF32, NDArrayI64]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Search the secondary index (flat, no training required).",
      "doc_raw": "Search the secondary index (flat, no training required).\n\nThis method is public for testing and advanced use cases where\nseparate primary/secondary search results are needed.\n\nParameters\n----------\nquery : NDArrayF32\n    Query vector(s), shape (n_queries, vec_dim) or (vec_dim,).\nk : int\n    Number of nearest neighbors to return.\n\nReturns\n-------\ntuple[NDArrayF32, NDArrayI64]\n    Tuple of (distances, ids) from secondary index search.\n\nRaises\n------\nRuntimeError\n    If secondary index is not available (should not happen if called\n    from search() after checking existence).",
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_manager.FAISSManager.search_primary",
      "short_name": "search_primary",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "query",
          "kind": "positional_or_keyword",
          "annotated_type": "NDArrayF32",
          "default": null,
          "doc": null
        },
        {
          "name": "k",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "nprobe",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "tuple[NDArrayF32, NDArrayI64]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Search the primary index (adaptive type: Flat/IVFFlat/IVF-PQ).",
      "doc_raw": "Search the primary index (adaptive type: Flat/IVFFlat/IVF-PQ).\n\nThis method is public for testing and advanced use cases where\nseparate primary/secondary search results are needed.\n\nParameters\n----------\nquery : NDArrayF32\n    Query vector(s), shape (n_queries, vec_dim) or (vec_dim,).\nk : int\n    Number of nearest neighbors to return.\nnprobe : int\n    Number of IVF cells to probe (for IVF indexes).\n\nReturns\n-------\ntuple[NDArrayF32, NDArrayI64]\n    Tuple of (distances, ids) from primary index search.\n\nNotes\n-----\nFlat indexes (``IndexFlat*``) do not expose the ``nprobe`` attribute.\nThe method checks for attribute support before assigning so that flat\nindexes skip the IVF-only parameter while IVF indexes continue to use\n``nprobe`` for recall control.\n\nRaises\n------\nRuntimeError\n    If primary index is not available.",
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_manager.FAISSManager.search",
      "short_name": "search",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "query",
          "kind": "positional_or_keyword",
          "annotated_type": "NDArrayF32",
          "default": null,
          "doc": null
        },
        {
          "name": "k",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": "50",
          "doc": null
        },
        {
          "name": "nprobe",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": "128",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "tuple[NDArrayF32, NDArrayI64]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Search for nearest neighbors using cosine similarity with dual-index support.",
      "doc_raw": "Search for nearest neighbors using cosine similarity with dual-index support.\n\nPerforms approximate nearest neighbor search using the FAISS index(es).\nWhen a secondary index exists (from incremental updates), searches both\nthe primary and secondary indexes, then merges results by score to return\nthe top-k most similar vectors overall.\n\nThe function automatically uses the GPU index if available (faster),\notherwise falls back to CPU. The nprobe parameter controls the trade-off\nbetween search speed and recall - higher values search more cells and\nimprove recall but slow down search.\n\nParameters\n----------\nquery : NDArrayF32\n    Query vector(s) of shape (n_queries, vec_dim) or (vec_dim,) for\n    single query. Dtype should be float32. Vectors are automatically\n    normalized for cosine similarity.\nk : int, optional\n    Number of nearest neighbors to return per query (default: 50).\n    Higher k improves recall but increases computation and memory usage.\nnprobe : int, optional\n    Number of IVF cells to probe during search (default: 128). Higher\n    values improve recall but slow down search. Should match or be less\n    than the nlist parameter used during index construction. Only applies\n    to primary index (secondary index is flat, no nprobe).\n\nReturns\n-------\ntuple[NDArrayF32, NDArrayI64]\n    Tuple of (distances, ids) arrays:\n    - distances: shape (n_queries, k), cosine similarity scores (higher\n      is more similar, range typically 0-1 after normalization)\n    - ids: shape (n_queries, k), chunk IDs of the nearest neighbors.\n      IDs correspond to the ids passed to add_vectors() or update_index().\n\nNotes\n-----\nWhen both primary and secondary indexes exist, the method:\n1. Searches primary index with nprobe parameter\n2. Searches secondary index (flat, no nprobe)\n3. Merges results by score (inner product distance)\n4. Returns top-k combined results\n\nThis ensures incremental updates are immediately searchable without\nrebuilding the primary index.\n\nRaises RuntimeError (propagated from `search_primary()` and\n`search_secondary()`) if no index is available or if search fails\n(e.g., dimension mismatch, invalid nprobe value).",
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_manager.FAISSManager.clone_to_gpu",
      "short_name": "clone_to_gpu",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "device",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": "0",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "bool",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Clone CPU index to GPU for accelerated search.",
      "doc_raw": "Clone CPU index to GPU for accelerated search.\n\nCreates a GPU-resident copy of the CPU index for faster search operations.\nThe GPU index uses the same structure (IVF-PQ) but runs on GPU hardware\nfor 10-100x speedup on large indexes.\n\nIf cuVS acceleration is enabled (use_cuvs=True), the function attempts to\nuse optimized cuVS kernels. If cuVS is unavailable, it falls back to\nstandard FAISS GPU operations.\n\nThe GPU index is kept in memory alongside the CPU index. Both can be\nused for search, but GPU is preferred when available.\n\nParameters\n----------\ndevice : int, optional\n    CUDA device ID to use (default: 0). Use device 0 for single-GPU systems.\n    For multi-GPU, specify the device ID (0, 1, 2, etc.).\n\nReturns\n-------\nbool\n    ``True`` when GPU acceleration is available. ``False`` when GPU\n    initialization fails and the manager falls back to the CPU index.\n\nRaises\n------\nRuntimeError\n    If the CPU index has not been loaded yet. Call load_cpu_index() or\n    build_index() first.",
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_manager.FAISSManager.load_secondary_index",
      "short_name": "load_secondary_index",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Load secondary index from disk.",
      "doc_raw": "Load secondary index from disk.\n\nReads a previously saved secondary FAISS index from disk and loads it\ninto memory. This restores incremental updates that were made in a\nprevious session.\n\nAfter loading, the secondary index will be automatically searched\nalongside the primary index when using search(). The incremental_ids\nset is restored from the index contents.\n\nRaises\n------\nFileNotFoundError\n    If the secondary index file does not exist. This is normal if no\n    incremental updates have been made yet.",
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_manager.FAISSManager.save_secondary_index",
      "short_name": "save_secondary_index",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Save secondary index to disk.",
      "doc_raw": "Save secondary index to disk.\n\nWrites the current secondary index (if it exists) to a separate file\nalongside the primary index. The secondary index file uses the same\nname as the primary index with a `.secondary` suffix.\n\nThis allows persisting incremental updates so they can be restored\nafter restart. The secondary index is saved independently from the\nprimary index.\n\nRaises\n------\nRuntimeError\n    If the secondary index has not been created yet. Call update_index()\n    first to create the secondary index.",
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_manager.FAISSManager.load_cpu_index",
      "short_name": "load_cpu_index",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Load CPU index from disk.",
      "doc_raw": "Load CPU index from disk.\n\nReads a previously saved FAISS index from index_path and loads it into\nmemory. This allows reusing an index without rebuilding it, which is much\nfaster for large indexes.\n\nAfter loading, you can call clone_to_gpu() to create a GPU version for\nfaster search, or use search() directly with the CPU index.\n\nRaises\n------\nFileNotFoundError\n    If the index file does not exist at index_path. Ensure the index was\n    saved with save_cpu_index() or that the path is correct.",
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_manager.FAISSManager.save_cpu_index",
      "short_name": "save_cpu_index",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Save CPU index to disk for persistence.",
      "doc_raw": "Save CPU index to disk for persistence.\n\nWrites the current CPU index to the file specified by index_path. The\nindex can be loaded later with load_cpu_index() to avoid rebuilding.\nThe parent directory is created if it doesn't exist.\n\nThe saved index includes all vectors and IDs that have been added. This\nis the CPU version - GPU indexes are cloned on-demand and not persisted.\n\nRaises\n------\nRuntimeError\n    If the index has not been built yet. Call build_index() first.",
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_manager.FAISSManager._set_direct_map_type",
      "short_name": "_set_direct_map_type",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "staticmethod"
      ],
      "params": [
        {
          "name": "index",
          "kind": "positional_or_keyword",
          "annotated_type": "_faiss.Index",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_manager.FAISSManager._configure_direct_map",
      "short_name": "_configure_direct_map",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "staticmethod"
      ],
      "params": [
        {
          "name": "index",
          "kind": "positional_or_keyword",
          "annotated_type": "_faiss.Index",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Ensure FAISS direct maps are array-backed for reconstruction.",
      "doc_raw": "Ensure FAISS direct maps are array-backed for reconstruction.",
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_manager.FAISSManager._log_secondary_added",
      "short_name": "_log_secondary_added",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "staticmethod"
      ],
      "params": [
        {
          "name": "added",
          "kind": "keyword_only",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "total_secondary_vectors",
          "kind": "keyword_only",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "skipped_duplicates",
          "kind": "keyword_only",
          "annotated_type": "int",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_manager.FAISSManager._collect_unique_indices",
      "short_name": "_collect_unique_indices",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "new_ids",
          "kind": "positional_or_keyword",
          "annotated_type": "NDArrayI64",
          "default": null,
          "doc": null
        },
        {
          "name": "primary_contains",
          "kind": "positional_or_keyword",
          "annotated_type": "Callable[[int], bool]",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "list[int]",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_manager.FAISSManager._build_existing_ids_set",
      "short_name": "_build_existing_ids_set",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "staticmethod"
      ],
      "params": [
        {
          "name": "cpu_index",
          "kind": "positional_or_keyword",
          "annotated_type": "_faiss.Index",
          "default": null,
          "doc": null
        },
        {
          "name": "id_map_obj",
          "kind": "positional_or_keyword",
          "annotated_type": "object",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "set[int]",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_manager.FAISSManager._wrap_index_contains",
      "short_name": "_wrap_index_contains",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "staticmethod"
      ],
      "params": [
        {
          "name": "raw",
          "kind": "positional_or_keyword",
          "annotated_type": "Callable[[int], object]",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "Callable[[int], bool]",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_manager.FAISSManager._wrap_bool_contains",
      "short_name": "_wrap_bool_contains",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "staticmethod"
      ],
      "params": [
        {
          "name": "raw",
          "kind": "positional_or_keyword",
          "annotated_type": "Callable[[int], object]",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "Callable[[int], bool]",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_manager.FAISSManager._build_primary_contains",
      "short_name": "_build_primary_contains",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "Callable[[int], bool]",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_manager.FAISSManager._ensure_secondary_index",
      "short_name": "_ensure_secondary_index",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_manager.FAISSManager.update_index",
      "short_name": "update_index",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "new_vectors",
          "kind": "positional_or_keyword",
          "annotated_type": "NDArrayF32",
          "default": null,
          "doc": null
        },
        {
          "name": "new_ids",
          "kind": "positional_or_keyword",
          "annotated_type": "NDArrayI64",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Add new vectors to secondary index for fast incremental updates.",
      "doc_raw": "Add new vectors to secondary index for fast incremental updates.\n\nExtended Summary\n----------------\nThis method adds new vectors to a secondary flat index (IndexFlatIP) which\nrequires no training and provides instant updates. This enables fast incremental\nindexing without rebuilding the primary index. The method filters out vectors\nthat already exist in the primary index to avoid duplicates, then adds only\nunique vectors to the secondary index. This is used for real-time index updates\nduring active codebase indexing workflows.\n\nParameters\n----------\nnew_vectors : NDArrayF32\n    Array of new embedding vectors to add, shape (N, dim) where N is the number\n    of vectors and dim matches the index dimensionality. Must be float32 and\n    normalized if the index uses cosine similarity.\nnew_ids : NDArrayI64\n    Array of document/chunk IDs corresponding to new_vectors, shape (N,).\n    Must be integer type. IDs that already exist in the primary index will be\n    filtered out before adding to the secondary index.\n\nRaises\n------\nRuntimeError\n    If the secondary index is unexpectedly missing during the update. This\n    indicates a configuration or initialization error that should be resolved\n    before attempting updates.\n\nNotes\n-----\nTime complexity O(N * log(M)) where N is new_vectors count and M is existing\nindex size, due to duplicate checking. Space complexity O(N) for temporary\nstorage. The method performs I/O to update the FAISS index on disk. Thread-safe\nif called sequentially; concurrent updates may cause race conditions.",
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_manager.FAISSManager.add_vectors",
      "short_name": "add_vectors",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "vectors",
          "kind": "positional_or_keyword",
          "annotated_type": "NDArrayF32",
          "default": null,
          "doc": null
        },
        {
          "name": "ids",
          "kind": "positional_or_keyword",
          "annotated_type": "NDArrayI64",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Add vectors with IDs to the index.",
      "doc_raw": "Add vectors with IDs to the index.\n\nAdds a batch of vectors to the FAISS index with their associated IDs.\nThe vectors are normalized for cosine similarity (L2 normalization) before\nbeing added. IDs are used for retrieval - they should match the chunk IDs\nstored in DuckDB.\n\nThis method requires that build_index() has been called first to create\nand train the index structure.\n\nParameters\n----------\nvectors : NDArrayF32\n    Vectors to add, shape (n, vec_dim) where n is the number of vectors\n    and vec_dim matches the index dimension. Dtype should be float32.\nids : NDArrayI64\n    Unique IDs for each vector, shape (n,). IDs are stored as int64 in\n    FAISS. These should correspond to chunk IDs from the indexing pipeline.\n\nRaises\n------\nRuntimeError\n    If the index has not been built yet. Call build_index() first.",
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_manager.FAISSManager.estimate_memory_usage",
      "short_name": "estimate_memory_usage",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "n_vectors",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "dict[str, int]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Estimate memory usage in bytes for a given number of vectors.",
      "doc_raw": "Estimate memory usage in bytes for a given number of vectors.\n\nProvides memory estimates for CPU and GPU indexes based on the adaptive\nindex type that would be selected for the given corpus size. This is useful\nfor capacity planning and resource allocation.\n\nParameters\n----------\nn_vectors : int\n    Number of vectors to estimate memory for.\n\nReturns\n-------\ndict[str, int]\n    Dictionary with memory estimates in bytes:\n    - ``cpu_index_bytes``: Estimated CPU index memory usage\n    - ``gpu_index_bytes``: Estimated GPU index memory usage (includes ~20% overhead)\n    - ``total_bytes``: Total estimated memory (CPU + GPU)\n\nExamples\n--------\n>>> manager = FAISSManager(index_path=Path(\"index.faiss\"), vec_dim=2560)\n>>> estimates = manager.estimate_memory_usage(10000)\n>>> print(f\"CPU index: {estimates['cpu_index_bytes'] / 1e9:.2f} GB\")\nCPU index: 0.26 GB\n>>> print(f\"Total: {estimates['total_bytes'] / 1e9:.2f} GB\")\nTotal: 0.57 GB\n\nNotes\n-----\nMemory estimates are approximate and may vary based on:\n- Actual index type selected (flat vs IVFFlat vs IVF-PQ)\n- FAISS internal overhead\n- GPU memory fragmentation\n- Operating system memory management\n\nEstimates are typically within \u00b120% of actual usage for most workloads.",
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_manager.FAISSManager.build_index",
      "short_name": "build_index",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "vectors",
          "kind": "positional_or_keyword",
          "annotated_type": "NDArrayF32",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Build and train FAISS index with adaptive type selection.",
      "doc_raw": "Build and train FAISS index with adaptive type selection.\n\nChooses the optimal index type based on corpus size:\n- Small corpus (<5K vectors): IndexFlatIP (exact search, no training)\n- Medium corpus (5K-50K vectors): IVFFlat with dynamic nlist\n- Large corpus (>50K vectors): IVF-PQ with dynamic nlist\n\nThis adaptive selection provides 10-100x faster training for small/medium\ncorpora while maintaining high recall (>95%) and search performance.\n\nParameters\n----------\nvectors : NDArrayF32\n    Training vectors of shape (n, vec_dim). Vectors are automatically\n    L2-normalized for cosine similarity.\n\nNotes\n-----\nThe index type is selected automatically based on the number of vectors.\nSmall corpora use flat indexes (exact search) for simplicity and speed.\nMedium corpora use IVFFlat for balanced training time and recall.\nLarge corpora use IVF-PQ for memory efficiency and fast search.\n\nExamples\n--------\n>>> manager = FAISSManager(index_path=Path(\"index.faiss\"), vec_dim=2560)\n>>> vectors = np.random.randn(1000, 2560).astype(np.float32)\n>>> manager.build_index(vectors)\n>>> # Uses IndexFlatIP for 1000 vectors (small corpus)",
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_manager.FAISSManager.secondary_index_path",
      "short_name": "secondary_index_path",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_manager.FAISSManager.incremental_ids",
      "short_name": "incremental_ids",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_manager.FAISSManager.secondary_gpu_index",
      "short_name": "secondary_gpu_index",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_manager.FAISSManager.secondary_index",
      "short_name": "secondary_index",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_manager.FAISSManager.gpu_disabled_reason",
      "short_name": "gpu_disabled_reason",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_manager.FAISSManager.gpu_resources",
      "short_name": "gpu_resources",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_manager.FAISSManager.gpu_index",
      "short_name": "gpu_index",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_manager.FAISSManager.cpu_index",
      "short_name": "cpu_index",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_manager.FAISSManager.use_cuvs",
      "short_name": "use_cuvs",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_manager.FAISSManager.nlist",
      "short_name": "nlist",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_manager.FAISSManager.vec_dim",
      "short_name": "vec_dim",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_manager.FAISSManager.index_path",
      "short_name": "index_path",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_manager.FAISSManager.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "index_path",
          "kind": "positional_or_keyword",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        },
        {
          "name": "vec_dim",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": "2560",
          "doc": null
        },
        {
          "name": "nlist",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": "8192",
          "doc": null
        },
        {
          "name": "use_cuvs",
          "kind": "keyword_only",
          "annotated_type": "bool",
          "default": "True",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_manager._log_extra",
      "short_name": "_log_extra",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "kwargs",
          "kind": "var_keyword",
          "annotated_type": "object",
          "default": "{}",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "dict[str, object]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Build structured logging extras for FAISS manager events.",
      "doc_raw": "Build structured logging extras for FAISS manager events.\n\nParameters\n----------\n**kwargs : object\n    Additional key-value pairs to include in logging extras. These are\n    merged with the base component name.\n\nReturns\n-------\ndict[str, object]\n    Merged dictionary with component name and provided kwargs.",
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_manager._LOG_EXTRA_BASE",
      "short_name": "_LOG_EXTRA_BASE",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_manager._MEDIUM_CORPUS_THRESHOLD",
      "short_name": "_MEDIUM_CORPUS_THRESHOLD",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_manager._SMALL_CORPUS_THRESHOLD",
      "short_name": "_SMALL_CORPUS_THRESHOLD",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_manager._has_faiss_gpu_support",
      "short_name": "_has_faiss_gpu_support",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": {
        "annotated_type": "bool",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Return ``True`` when FAISS exposes GPU bindings, otherwise ``False``.",
      "doc_raw": "Return ``True`` when FAISS exposes GPU bindings, otherwise ``False``.\n\nReturns\n-------\nbool\n    ``True`` when GPU capabilities are available, otherwise ``False``.",
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_manager._faiss_module",
      "short_name": "_faiss_module",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": {
        "annotated_type": "ModuleType",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Return the lazily imported FAISS module.",
      "doc_raw": "Return the lazily imported FAISS module.\n\nReturns\n-------\nModuleType\n    Cached FAISS module instance.",
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_manager.faiss",
      "short_name": "faiss",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_manager._FAISS_PROXY",
      "short_name": "_FAISS_PROXY",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_manager._LazyFaissProxy",
      "short_name": "_LazyFaissProxy",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Deferred FAISS module loader to avoid import-time side effects.",
      "doc_raw": "Deferred FAISS module loader to avoid import-time side effects.",
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_manager._LazyFaissProxy.__getattr__",
      "short_name": "__getattr__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "name",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "object",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Proxy attribute access to the underlying FAISS module.",
      "doc_raw": "Proxy attribute access to the underlying FAISS module.\n\nReturns\n-------\nobject\n    Attribute resolved from the proxied FAISS module.",
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_manager._LazyFaissProxy.module",
      "short_name": "module",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "ModuleType",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Return the cached FAISS module, importing it on demand.",
      "doc_raw": "Return the cached FAISS module, importing it on demand.\n\nReturns\n-------\nModuleType\n    Materialized FAISS module.",
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_manager._LazyFaissProxy._module",
      "short_name": "_module",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_manager._LazyFaissProxy.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_manager._LazyFaissProxy.__slots__",
      "short_name": "__slots__",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_manager.logger",
      "short_name": "logger",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.faiss_manager.LOGGER",
      "short_name": "LOGGER",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.warp_engine",
      "short_name": "warp_engine",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Adapter for the optional WARP/XTR late interaction executor.",
      "doc_raw": "Adapter for the optional WARP/XTR late interaction executor.",
      "docstyle": "google"
    },
    {
      "full_name": "io.warp_engine._safe_float",
      "short_name": "_safe_float",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "value",
          "kind": "positional_or_keyword",
          "annotated_type": "object | None",
          "default": null,
          "doc": null
        },
        {
          "name": "default",
          "kind": "positional_or_keyword",
          "annotated_type": "float",
          "default": "0.0",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "float",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Convert an object to float safely, falling back to the provided default.",
      "doc_raw": "Convert an object to float safely, falling back to the provided default.\n\nParameters\n----------\nvalue : object | None\n    Value to convert to float. Can be int, float, or str. If None or\n    conversion fails, returns default.\ndefault : float, optional\n    Fallback value returned if conversion fails. Defaults to 0.0.\n\nReturns\n-------\nfloat\n    Float representation of value or the fallback default.",
      "docstyle": "google"
    },
    {
      "full_name": "io.warp_engine._safe_int",
      "short_name": "_safe_int",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "value",
          "kind": "positional_or_keyword",
          "annotated_type": "object | None",
          "default": null,
          "doc": null
        },
        {
          "name": "default",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": "0",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "int",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Convert an object to int safely, falling back to the provided default.",
      "doc_raw": "Convert an object to int safely, falling back to the provided default.\n\nParameters\n----------\nvalue : object | None\n    Value to convert to int. Can be int, float, or str. If None or\n    conversion fails, returns default.\ndefault : int, optional\n    Fallback value returned if conversion fails. Defaults to 0.\n\nReturns\n-------\nint\n    Integer representation of value or the fallback default.",
      "docstyle": "google"
    },
    {
      "full_name": "io.warp_engine.WarpEngine",
      "short_name": "WarpEngine",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "index_dir",
          "kind": "keyword_only",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        },
        {
          "name": "device",
          "kind": "keyword_only",
          "annotated_type": "str",
          "default": null,
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Encapsulates interactions with the optional ``xtr-warp`` executor.",
      "doc_raw": "Encapsulates interactions with the optional ``xtr-warp`` executor.",
      "docstyle": "google"
    },
    {
      "full_name": "io.warp_engine.WarpEngine._ensure_executor",
      "short_name": "_ensure_executor",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "object",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Ensure the WARP executor is initialized and return it.",
      "doc_raw": "Ensure the WARP executor is initialized and return it.\n\nReturns\n-------\nobject\n    The initialized WARP executor instance.\n\nRaises\n------\nWarpUnavailableError\n    If executor initialization fails.",
      "docstyle": "google"
    },
    {
      "full_name": "io.warp_engine.WarpEngine._import_warp_executor_module",
      "short_name": "_import_warp_executor_module",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "staticmethod"
      ],
      "params": [],
      "returns": {
        "annotated_type": "ModuleType",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.warp_engine.WarpEngine._load_executor_cls",
      "short_name": "_load_executor_cls",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "WarpExecutorFactory",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Import the WARP executor class via ``gate_import``.",
      "doc_raw": "Import the WARP executor class via ``gate_import``.\n\nReturns\n-------\nWarpExecutorFactory\n    The WarpExecutor factory class from xtr_warp.executor module.\n\nRaises\n------\nWarpUnavailableError\n    If the WarpExecutor class is not found in the module.",
      "docstyle": "google"
    },
    {
      "full_name": "io.warp_engine.WarpEngine.rerank",
      "short_name": "rerank",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "query",
          "kind": "keyword_only",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "candidate_ids",
          "kind": "keyword_only",
          "annotated_type": "Sequence[int]",
          "default": null,
          "doc": null
        },
        {
          "name": "top_k",
          "kind": "keyword_only",
          "annotated_type": "int",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "list[tuple[int, float]]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Return WARP scores for candidate document IDs.",
      "doc_raw": "Return WARP scores for candidate document IDs.\n\nParameters\n----------\nquery : str\n    Natural language search query string.\ncandidate_ids : Sequence[int]\n    Sequence of document/chunk IDs to rerank using WARP late-interaction\n    scoring. These are typically top-k results from an initial retrieval stage.\ntop_k : int\n    Maximum number of results to return. Must be positive.\n\nReturns\n-------\nlist[tuple[int, float]]\n    List of (doc_id, score) tuples ranked by WARP scores in descending order.\n    Length is min(len(candidate_ids), top_k).\n\nRaises\n------\nWarpUnavailableError\n    If WARP executor is unavailable or search fails.",
      "docstyle": "google"
    },
    {
      "full_name": "io.warp_engine.WarpEngine._executor",
      "short_name": "_executor",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.warp_engine.WarpEngine._executor_cls",
      "short_name": "_executor_cls",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.warp_engine.WarpEngine.device",
      "short_name": "device",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.warp_engine.WarpEngine.index_dir",
      "short_name": "index_dir",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.warp_engine.WarpEngine.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "index_dir",
          "kind": "keyword_only",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        },
        {
          "name": "device",
          "kind": "keyword_only",
          "annotated_type": "str",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.warp_engine.WarpUnavailableError",
      "short_name": "WarpUnavailableError",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [
        "RuntimeError"
      ],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Raised when the WARP executor or index artifacts are missing.",
      "doc_raw": "Raised when the WARP executor or index artifacts are missing.",
      "docstyle": "google"
    },
    {
      "full_name": "io.warp_engine.WarpExecutorFactory",
      "short_name": "WarpExecutorFactory",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.warp_engine.LOGGER",
      "short_name": "LOGGER",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.hybrid_search",
      "short_name": "hybrid_search",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Hybrid retrieval utilities combining FAISS, BM25, and SPLADE.",
      "doc_raw": "Hybrid retrieval utilities combining FAISS, BM25, and SPLADE.",
      "docstyle": "google"
    },
    {
      "full_name": "io.hybrid_search.__all__",
      "short_name": "__all__",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.hybrid_search._rrf_fuse",
      "short_name": "_rrf_fuse",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "runs",
          "kind": "positional_or_keyword",
          "annotated_type": "Mapping[str, Sequence[ChannelHit]]",
          "default": null,
          "doc": null
        },
        {
          "name": "k",
          "kind": "keyword_only",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "limit",
          "kind": "keyword_only",
          "annotated_type": "int",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "tuple[list[HybridResultDoc], dict[str, list[tuple[str, int, float]]]]",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.hybrid_search.HybridSearchEngine",
      "short_name": "HybridSearchEngine",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "settings",
          "kind": "positional_or_keyword",
          "annotated_type": "Settings",
          "default": null,
          "doc": null
        },
        {
          "name": "paths",
          "kind": "positional_or_keyword",
          "annotated_type": "ResolvedPaths",
          "default": null,
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Combine dense (FAISS) and sparse channels (BM25, SPLADE) via RRF.",
      "doc_raw": "Combine dense (FAISS) and sparse channels (BM25, SPLADE) via RRF.",
      "docstyle": "google"
    },
    {
      "full_name": "io.hybrid_search.HybridSearchEngine._build_semantic_channel_hits",
      "short_name": "_build_semantic_channel_hits",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "hits",
          "kind": "positional_or_keyword",
          "annotated_type": "Sequence[tuple[int, float]]",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "list[ChannelHit]",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.hybrid_search.HybridSearchEngine.resolve_path",
      "short_name": "resolve_path",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "value",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "Path",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Resolve a path string to an absolute Path.",
      "doc_raw": "Resolve a path string to an absolute Path.\n\nParameters\n----------\nvalue : str\n    Path string that may be absolute, relative, or use ~ expansion.\n\nReturns\n-------\nPath\n    Absolute resolved path. If input is absolute, returns as-is.\n    If relative, resolves relative to repository root.",
      "docstyle": "google"
    },
    {
      "full_name": "io.hybrid_search.HybridSearchEngine._create_splade_provider",
      "short_name": "_create_splade_provider",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "SpladeSearchProvider",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.hybrid_search.HybridSearchEngine._create_bm25_provider",
      "short_name": "_create_bm25_provider",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "BM25SearchProvider",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.hybrid_search.HybridSearchEngine._ensure_splade_provider",
      "short_name": "_ensure_splade_provider",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "SpladeSearchProvider | None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.hybrid_search.HybridSearchEngine._ensure_bm25_provider",
      "short_name": "_ensure_bm25_provider",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "BM25SearchProvider | None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.hybrid_search.HybridSearchEngine._maybe_add_splade_hits",
      "short_name": "_maybe_add_splade_hits",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "query",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "runs",
          "kind": "positional_or_keyword",
          "annotated_type": "dict[str, list[ChannelHit]]",
          "default": null,
          "doc": null
        },
        {
          "name": "warnings",
          "kind": "positional_or_keyword",
          "annotated_type": "list[str]",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Populate SPLADE hits when the channel is available.",
      "doc_raw": "Populate SPLADE hits when the channel is available.",
      "docstyle": "google"
    },
    {
      "full_name": "io.hybrid_search.HybridSearchEngine._maybe_add_bm25_hits",
      "short_name": "_maybe_add_bm25_hits",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "query",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "runs",
          "kind": "positional_or_keyword",
          "annotated_type": "dict[str, list[ChannelHit]]",
          "default": null,
          "doc": null
        },
        {
          "name": "warnings",
          "kind": "positional_or_keyword",
          "annotated_type": "list[str]",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Populate BM25 hits when the channel is available.",
      "doc_raw": "Populate BM25 hits when the channel is available.",
      "docstyle": "google"
    },
    {
      "full_name": "io.hybrid_search.HybridSearchEngine._gather_channel_hits",
      "short_name": "_gather_channel_hits",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "query",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "semantic_hits",
          "kind": "positional_or_keyword",
          "annotated_type": "Sequence[tuple[int, float]]",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "tuple[dict[str, list[ChannelHit]], list[str]]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Collect per-channel search hits and warnings for ``query``.",
      "doc_raw": "Collect per-channel search hits and warnings for ``query``.\n\nThis internal method coordinates retrieval across all enabled channels,\ncollecting results from semantic (FAISS), BM25, and SPLADE channels.\nEach channel is queried independently, and errors are captured as warnings\nrather than exceptions to ensure robust multi-channel retrieval.\n\nThe semantic channel is always included (converting IDs and scores to\nChannelHit objects). BM25 and SPLADE channels are conditionally enabled\nbased on settings and availability. Channel initialization errors are\ncaptured as warnings and included in the return value.\n\nParameters\n----------\nquery : str\n    Search query string. Used for sparse retrieval channels (BM25, SPLADE).\n    The semantic channel uses pre-computed results, so query is only\n    relevant for sparse channels.\nsemantic_hits : Sequence[tuple[int, float]]\n    Dense retrieval hits expressed as ``(doc_id, score)`` pairs.\n\nReturns\n-------\ntuple[dict[str, list[ChannelHit]], list[str]]\n    Tuple containing:\n    - Dictionary mapping channel identifiers (\"semantic\", \"bm25\", \"splade\")\n      to lists of ChannelHit objects. Only channels that successfully\n      returned results are included.\n    - List of warning messages accumulated during channel retrieval. Includes\n      initialization errors, search failures, and availability issues.",
      "docstyle": "google"
    },
    {
      "full_name": "io.hybrid_search.HybridSearchEngine.search",
      "short_name": "search",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "query",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "semantic_hits",
          "kind": "keyword_only",
          "annotated_type": "Sequence[tuple[int, float]]",
          "default": null,
          "doc": null
        },
        {
          "name": "limit",
          "kind": "keyword_only",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "extra_channels",
          "kind": "keyword_only",
          "annotated_type": "Mapping[str, Sequence[ChannelHit]] | None",
          "default": "None",
          "doc": null
        },
        {
          "name": "weights",
          "kind": "keyword_only",
          "annotated_type": "Mapping[str, float] | None",
          "default": "None",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "HybridSearchResult",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Fuse dense and sparse retrieval results for ``query``.",
      "doc_raw": "Fuse dense and sparse retrieval results for ``query``.\n\nThis method combines results from multiple retrieval channels (semantic/FAISS,\nBM25, SPLADE) using Reciprocal Rank Fusion (RRF) to produce a unified ranked\nlist. RRF is a rank aggregation technique that combines multiple ranked lists\nwithout requiring score normalization, making it ideal for fusing different\nretrieval modalities with incompatible score ranges.\n\nThe method gathers hits from all enabled channels (semantic is always included,\nBM25 and SPLADE are optional based on settings), then applies RRF fusion to\nproduce the final ranked results. Channel contributions are tracked for\ntransparency and debugging.\n\nParameters\n----------\nquery : str\n    Search query string. Used for sparse retrieval channels (BM25, SPLADE)\n    which perform keyword-based or learned sparse matching. The semantic\n    channel uses pre-computed embeddings, so the query text is only used\n    for sparse channels.\nsemantic_hits : Sequence[tuple[int, float]]\n    Ordered dense results expressed as ``(doc_id, score)`` pairs.\nlimit : int\n    Maximum number of final results to return after RRF fusion. The fusion\n    process ranks all documents from all channels, then returns the top\n    'limit' documents. Must be a positive integer.\nextra_channels : Mapping[str, Sequence[ChannelHit]] | None\n    Optional externally supplied channels (e.g., WARP). Each entry is\n    merged into the RRF runs prior to fusion.\nweights : Mapping[str, float] | None\n    Optional per-channel weights applied during fusion. Defaults to\n    equal weighting.\n\nReturns\n-------\nHybridSearchResult\n    Fused retrieval output containing:\n    - docs: Final ranked list of documents (top 'limit' after RRF fusion)\n    - contributions: Per-document breakdown of which channels contributed\n      each document (useful for understanding fusion behavior)\n    - channels: List of active channel identifiers that contributed results\n    - warnings: Any warnings generated during channel retrieval (e.g., index\n      unavailable, encoding failures)",
      "docstyle": "google"
    },
    {
      "full_name": "io.hybrid_search.HybridSearchEngine._splade_lock",
      "short_name": "_splade_lock",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.hybrid_search.HybridSearchEngine._bm25_lock",
      "short_name": "_bm25_lock",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.hybrid_search.HybridSearchEngine._splade_error",
      "short_name": "_splade_error",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.hybrid_search.HybridSearchEngine._bm25_error",
      "short_name": "_bm25_error",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.hybrid_search.HybridSearchEngine._splade_provider",
      "short_name": "_splade_provider",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.hybrid_search.HybridSearchEngine._bm25_provider",
      "short_name": "_bm25_provider",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.hybrid_search.HybridSearchEngine._paths",
      "short_name": "_paths",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.hybrid_search.HybridSearchEngine._settings",
      "short_name": "_settings",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.hybrid_search.HybridSearchEngine.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "settings",
          "kind": "positional_or_keyword",
          "annotated_type": "Settings",
          "default": null,
          "doc": null
        },
        {
          "name": "paths",
          "kind": "positional_or_keyword",
          "annotated_type": "ResolvedPaths",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.hybrid_search.SpladeSearchProvider",
      "short_name": "SpladeSearchProvider",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "config",
          "kind": "positional_or_keyword",
          "annotated_type": "SpladeConfig",
          "default": null,
          "doc": null
        },
        {
          "name": "model_dir",
          "kind": "keyword_only",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        },
        {
          "name": "onnx_dir",
          "kind": "keyword_only",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        },
        {
          "name": "index_dir",
          "kind": "keyword_only",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "SPLADE query encoder and Lucene impact searcher for learned sparse retrieval.",
      "doc_raw": "SPLADE query encoder and Lucene impact searcher for learned sparse retrieval.\n\nThis class combines a SPLADE (Sparse Lexical and Expansion) query encoder\nwith a Lucene impact searcher to perform learned sparse retrieval. SPLADE\nlearns to expand queries with relevant terms and assign importance weights,\ncreating sparse representations that are more effective than traditional\nkeyword matching while maintaining the efficiency of sparse retrieval.\n\nThe provider initializes a SPLADE encoder model (typically loaded from ONNX\nformat for efficiency) and a Lucene impact searcher that uses learned term\nweights for ranking. The encoder expands queries into weighted term vectors,\nwhich are then converted to bag-of-words representations for Lucene search.\n\nParameters\n----------\nconfig : SpladeConfig\n    SPLADE configuration containing model settings, quantization parameters,\n    and maximum term limits. Used to configure encoder behavior and search\n    parameters.\nmodel_dir : Path\n    Directory containing the SPLADE model files. The model directory should\n    contain the encoder weights and tokenizer configuration.\nonnx_dir : Path\n    Directory containing ONNX-exported model files. If an ONNX file exists\n    (specified in config.onnx_file), it will be used instead of the PyTorch\n    model for faster inference. Falls back to PyTorch model if ONNX not found.\nindex_dir : Path\n    Directory path containing the Lucene impact index. The index must be\n    created using Pyserini's indexing tools with SPLADE-encoded document\n    vectors. Each document should have term weights matching the SPLADE\n    encoding scheme.\n\nRaises\n------\nFileNotFoundError\n    If the SPLADE impact index directory does not exist or is not accessible.",
      "docstyle": "google"
    },
    {
      "full_name": "io.hybrid_search.SpladeSearchProvider._build_bow",
      "short_name": "_build_bow",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "pairs",
          "kind": "positional_or_keyword",
          "annotated_type": "Sequence[tuple[str, float]]",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "str",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.hybrid_search.SpladeSearchProvider.search",
      "short_name": "search",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "query",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "top_k",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "list[ChannelHit]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Return SPLADE impact hits for ``query``.",
      "doc_raw": "Return SPLADE impact hits for ``query``.\n\nEncodes the query using the SPLADE encoder to generate a sparse term\nvector with learned importance weights. The vector is decoded into a\nbag-of-words representation with term repetitions based on quantized\nweights, then searched against the Lucene impact index. Results are\nranked by learned relevance scores.\n\nParameters\n----------\nquery : str\n    Search query string to encode and search. The SPLADE encoder will\n    expand this query with relevant terms and assign importance weights\n    based on learned patterns from training data.\ntop_k : int\n    Maximum number of results to return. The searcher returns the top-k\n    highest-scoring documents based on learned SPLADE relevance. Must be\n    a positive integer.\n\nReturns\n-------\nlist[ChannelHit]\n    List of ranked SPLADE results, ordered by learned relevance score\n    (highest first). Each ChannelHit contains a document ID and SPLADE\n    impact score. Returns empty list if encoding fails, no terms are\n    generated, or top_k is 0.",
      "docstyle": "google"
    },
    {
      "full_name": "io.hybrid_search.SpladeSearchProvider._max_terms",
      "short_name": "_max_terms",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.hybrid_search.SpladeSearchProvider._quantization",
      "short_name": "_quantization",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.hybrid_search.SpladeSearchProvider._searcher",
      "short_name": "_searcher",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.hybrid_search.SpladeSearchProvider._encoder",
      "short_name": "_encoder",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.hybrid_search.SpladeSearchProvider.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "config",
          "kind": "positional_or_keyword",
          "annotated_type": "SpladeConfig",
          "default": null,
          "doc": null
        },
        {
          "name": "model_dir",
          "kind": "keyword_only",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        },
        {
          "name": "onnx_dir",
          "kind": "keyword_only",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        },
        {
          "name": "index_dir",
          "kind": "keyword_only",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.hybrid_search.BM25SearchProvider",
      "short_name": "BM25SearchProvider",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "index_dir",
          "kind": "positional_or_keyword",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        },
        {
          "name": "k1",
          "kind": "keyword_only",
          "annotated_type": "float",
          "default": null,
          "doc": null
        },
        {
          "name": "b",
          "kind": "keyword_only",
          "annotated_type": "float",
          "default": null,
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Thin wrapper around Pyserini's LuceneSearcher for BM25 retrieval.",
      "doc_raw": "Thin wrapper around Pyserini's LuceneSearcher for BM25 retrieval.\n\nThis class provides a simple interface to Pyserini's Lucene-based BM25 search\nimplementation. BM25 (Best Matching 25) is a probabilistic ranking function\nthat scores documents based on term frequency, inverse document frequency,\nand document length normalization. It's particularly effective for keyword\nand exact-match queries in code search scenarios.\n\nThe provider initializes a Lucene searcher with the specified BM25 parameters\n(k1 and b) which control term frequency saturation and length normalization\nrespectively. The searcher is thread-safe and can be reused for multiple\nqueries.\n\nParameters\n----------\nindex_dir : Path\n    Directory path containing the Lucene BM25 index. The index must be created\n    using Pyserini's indexing tools and contain document vectors suitable for\n    BM25 retrieval.\nk1 : float\n    BM25 term frequency saturation parameter. Controls how quickly term\n    frequency saturates. Typical values range from 1.2 to 2.0. Higher values\n    give more weight to term frequency.\nb : float\n    BM25 length normalization parameter. Controls the degree of document length\n    normalization. Values range from 0.0 (no normalization) to 1.0 (full\n    normalization). Typical value is 0.75.\n\nRaises\n------\nFileNotFoundError\n    If the BM25 index directory does not exist or is not accessible.",
      "docstyle": "google"
    },
    {
      "full_name": "io.hybrid_search.BM25SearchProvider.search",
      "short_name": "search",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "query",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "top_k",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "list[ChannelHit]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Return top-k BM25 hits for ``query``.",
      "doc_raw": "Return top-k BM25 hits for ``query``.\n\nExecutes a BM25 search query against the Lucene index and returns the\ntop-k most relevant documents. The search uses the configured BM25\nparameters (k1, b) set during initialization. Results are ranked by\nBM25 relevance score in descending order.\n\nParameters\n----------\nquery : str\n    Search query string. Can contain multiple terms separated by spaces.\n    BM25 will score documents based on term frequency and inverse document\n    frequency for each term in the query.\ntop_k : int\n    Maximum number of results to return. The searcher will return the\n    top-k highest-scoring documents. Must be a positive integer.\n\nReturns\n-------\nlist[ChannelHit]\n    List of ranked BM25 results, ordered by relevance score (highest first).\n    Each ChannelHit contains a document ID and BM25 score. Returns empty\n    list if no documents match the query or if top_k is 0.",
      "docstyle": "google"
    },
    {
      "full_name": "io.hybrid_search.BM25SearchProvider._searcher",
      "short_name": "_searcher",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.hybrid_search.BM25SearchProvider._index_dir",
      "short_name": "_index_dir",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.hybrid_search.BM25SearchProvider.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "index_dir",
          "kind": "positional_or_keyword",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        },
        {
          "name": "k1",
          "kind": "keyword_only",
          "annotated_type": "float",
          "default": null,
          "doc": null
        },
        {
          "name": "b",
          "kind": "keyword_only",
          "annotated_type": "float",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.hybrid_search.LOGGER",
      "short_name": "LOGGER",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.xtr_manager",
      "short_name": "xtr_manager",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Token-level XTR index manager with late-interaction scoring utilities.",
      "doc_raw": "Token-level XTR index manager with late-interaction scoring utilities.",
      "docstyle": "google"
    },
    {
      "full_name": "io.xtr_manager.TorchDeviceModule",
      "short_name": "TorchDeviceModule",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [
        "Protocol"
      ],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Subset of torch API required for device resolution.",
      "doc_raw": "Subset of torch API required for device resolution.",
      "docstyle": "google"
    },
    {
      "full_name": "io.xtr_manager.TorchDeviceModule.device",
      "short_name": "device",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "name",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "object",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Return a torch.device handle.",
      "doc_raw": "Return a torch.device handle.",
      "docstyle": "google"
    },
    {
      "full_name": "io.xtr_manager.TorchDeviceModule.cuda",
      "short_name": "cuda",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.xtr_manager.TorchDeviceModule._CudaAPI",
      "short_name": "_CudaAPI",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [
        "Protocol"
      ],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.xtr_manager.TorchDeviceModule._CudaAPI.device_count",
      "short_name": "device_count",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "int",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.xtr_manager.TorchDeviceModule._CudaAPI.is_available",
      "short_name": "is_available",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "bool",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.xtr_manager.XTRIndex",
      "short_name": "XTRIndex",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "dataclass(slots=True, frozen=True)"
      ],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "root",
          "kind": "positional_or_keyword",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        },
        {
          "name": "config",
          "kind": "positional_or_keyword",
          "annotated_type": "XTRConfig",
          "default": null,
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Memory-mapped XTR token index with query encoding + scoring helpers.",
      "doc_raw": "Memory-mapped XTR token index with query encoding + scoring helpers.",
      "docstyle": "google"
    },
    {
      "full_name": "io.xtr_manager.XTRIndex.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "root",
          "kind": "positional_or_keyword",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        },
        {
          "name": "config",
          "kind": "positional_or_keyword",
          "annotated_type": "XTRConfig",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.xtr_manager.XTRIndex._current_state",
      "short_name": "_current_state",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "_XTRIndexRuntime | None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.xtr_manager.XTRIndex._ensure_state",
      "short_name": "_ensure_state",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "_XTRIndexRuntime",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.xtr_manager.XTRIndex.close",
      "short_name": "close",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Release runtime resources such as memmaps and tokenizer.",
      "doc_raw": "Release runtime resources such as memmaps and tokenizer.",
      "docstyle": "google"
    },
    {
      "full_name": "io.xtr_manager.XTRIndex._build_chunk_lookup",
      "short_name": "_build_chunk_lookup",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "staticmethod"
      ],
      "params": [
        {
          "name": "meta",
          "kind": "positional_or_keyword",
          "annotated_type": "XTRMetadata",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "dict[int, tuple[int, int]]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Build fast chunk metadata for offset lookups.",
      "doc_raw": "Build fast chunk metadata for offset lookups.\n\nParameters\n----------\nmeta : XTRMetadata\n    Metadata containing chunk dimensions for the index.\n\nReturns\n-------\ndict[int, tuple[int, int]]\n    Mapping from chunk ID to (offset, length).",
      "docstyle": "google"
    },
    {
      "full_name": "io.xtr_manager.XTRIndex._slice_chunk",
      "short_name": "_slice_chunk",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "chunk_id",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "NDArrayF32",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Return token matrix slice for chunk_id.",
      "doc_raw": "Return token matrix slice for chunk_id.\n\nParameters\n----------\nchunk_id : int\n    Chunk ID to extract embeddings for. Must exist in the index metadata.\n\nReturns\n-------\nNDArrayF32\n    View over the token matrix for the requested chunk. Array shaped\n    [tokens, dim] with token embeddings.\n\nRaises\n------\nRuntimeError\n    If the index has not been opened.\nKeyError\n    If the chunk identifier is not present in metadata.",
      "docstyle": "google"
    },
    {
      "full_name": "io.xtr_manager.XTRIndex._parse_cuda_ordinal",
      "short_name": "_parse_cuda_ordinal",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "staticmethod"
      ],
      "params": [
        {
          "name": "value",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "int | None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Extract CUDA device ordinal from a device string.",
      "doc_raw": "Extract CUDA device ordinal from a device string.\n\nExtended Summary\n----------------\nThis method parses a CUDA device string (e.g., \"cuda:0\", \"cuda:1\") to extract\nthe device ordinal. It handles malformed input gracefully by returning None\nwhen the format is invalid or when no ordinal is specified. This is used\ninternally by the XTR index to resolve device assignments from configuration\nstrings and ensure proper GPU device selection for tensor operations.\n\nParameters\n----------\nvalue : str\n    Device string that may contain a CUDA ordinal in the format \"cuda:<ordinal>\".\n    If the string doesn't contain a colon or the part after the colon is not\n    a valid integer, the function returns None.\n\nReturns\n-------\nint | None\n    Parsed ordinal as an integer (e.g., 0, 1, 2) when ``value`` contains\n    ``cuda:<ordinal>``, or ``None`` when unspecified, invalid, or not in\n    the expected format.\n\nNotes\n-----\nTime complexity O(1) - simple string split and int conversion. Space\ncomplexity O(1). No I/O or side effects. Handles ValueError exceptions\nfrom int() conversion by returning None, making it safe for malformed input.",
      "docstyle": "google"
    },
    {
      "full_name": "io.xtr_manager.XTRIndex._resolve_device",
      "short_name": "_resolve_device",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "torch_module",
          "kind": "positional_or_keyword",
          "annotated_type": "TorchDeviceModule",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "object",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Resolve the runtime torch.device honoring config preferences.",
      "doc_raw": "Resolve the runtime torch.device honoring config preferences.\n\nParameters\n----------\ntorch_module : TorchDeviceModule\n    Torch module instance used to check CUDA availability and create\n    device objects.\n\nReturns\n-------\nobject\n    Device reference (torch.device) pointing to cpu or cuda based on\n    config and availability.",
      "docstyle": "google"
    },
    {
      "full_name": "io.xtr_manager.XTRIndex._ensure_encoder",
      "short_name": "_ensure_encoder",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "tuple[Any, Any]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Instantiate and cache tokenizer/model pair.",
      "doc_raw": "Instantiate and cache tokenizer/model pair.\n\nReturns\n-------\ntuple[Any, Any]\n    Tokenizer/model pair loaded from Hugging Face.",
      "docstyle": "google"
    },
    {
      "full_name": "io.xtr_manager.XTRIndex.score_candidates",
      "short_name": "score_candidates",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "query_vecs",
          "kind": "positional_or_keyword",
          "annotated_type": "NDArrayF32",
          "default": null,
          "doc": null
        },
        {
          "name": "candidate_chunk_ids",
          "kind": "positional_or_keyword",
          "annotated_type": "Iterable[int]",
          "default": null,
          "doc": null
        },
        {
          "name": "explain",
          "kind": "keyword_only",
          "annotated_type": "bool",
          "default": "False",
          "doc": null
        },
        {
          "name": "topk_explanations",
          "kind": "keyword_only",
          "annotated_type": "int",
          "default": "5",
          "doc": null
        },
        {
          "name": "limit",
          "kind": "keyword_only",
          "annotated_type": "int | None",
          "default": "None",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "list[tuple[int, float, dict[str, Any] | None]]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Compute MaxSim scores for candidate chunk IDs.",
      "doc_raw": "Compute MaxSim scores for candidate chunk IDs.\n\nParameters\n----------\nquery_vecs : NDArrayF32\n    Query token embeddings array shaped [query_tokens, dim]. Used to compute\n    MaxSim scores against document token embeddings.\ncandidate_chunk_ids : Iterable[int]\n    Iterable of chunk IDs to score. Duplicates are automatically deduplicated.\nexplain : bool, optional\n    If True, include explainability payload with token-level alignments.\n    Defaults to False.\ntopk_explanations : int, optional\n    Maximum number of token matches to include in explainability payload.\n    Defaults to 5.\nlimit : int | None, optional\n    Optional cap on the number of rescored results returned. ``None`` retains\n    every candidate.\n\nReturns\n-------\nlist[tuple[int, float, dict[str, Any] | None]]\n    Ranked list containing (chunk_id, score, explainability_payload) tuples.\n    Scores are MaxSim sums across query tokens. Explainability payload is None\n    if explain=False or no matches found.",
      "docstyle": "google"
    },
    {
      "full_name": "io.xtr_manager.XTRIndex.rescore",
      "short_name": "rescore",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "query",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "candidate_chunk_ids",
          "kind": "positional_or_keyword",
          "annotated_type": "Iterable[int]",
          "default": null,
          "doc": null
        },
        {
          "name": "explain",
          "kind": "keyword_only",
          "annotated_type": "bool",
          "default": "False",
          "doc": null
        },
        {
          "name": "topk_explanations",
          "kind": "keyword_only",
          "annotated_type": "int",
          "default": "5",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "list[tuple[int, float, dict[str, Any] | None]]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Rescore a Stage-0 candidate set using MaxSim (narrow mode).",
      "doc_raw": "Rescore a Stage-0 candidate set using MaxSim (narrow mode).\n\nExtended Summary\n----------------\nThis method performs focused MaxSim rescoring on a pre-filtered set of\ncandidate chunks, typically from an initial retrieval stage (e.g., CodeRank\nFAISS search). It encodes the query, computes MaxSim scores only for the\nprovided candidates, and returns ranked results. This narrow-mode operation\nis more efficient than full index search when a high-quality candidate set\nis available. The method is used in two-stage retrieval pipelines where\nStage-0 provides candidates and XTR provides late-interaction reranking.\n\nParameters\n----------\nquery : str\n    Natural language search query string. Will be tokenized and encoded\n    into query token embeddings for MaxSim computation.\ncandidate_chunk_ids : Iterable[int]\n    Iterable of chunk IDs from Stage-0 retrieval to rescore. Duplicates\n    are automatically deduplicated. Empty iterables result in empty results.\nexplain : bool, optional\n    If True, include explainability payload with token-level alignment\n    information for each result. Defaults to False.\ntopk_explanations : int, optional\n    Maximum number of token matches to include in explainability payload\n    when explain=True. Defaults to 5.\n\nReturns\n-------\nlist[tuple[int, float, dict[str, Any] | None]]\n    Ranked list of (chunk_id, score, explainability_payload) tuples,\n    restricted to the provided candidate chunk IDs. Scores are MaxSim sums\n    across query tokens. Explainability payload is None if explain=False\n    or no matches found. Results are sorted by score descending.\n\nNotes\n-----\nTime complexity O(n * m * d) where n is query tokens, m is total document\ntokens across candidate chunks, and d is embedding dimension. Space complexity\nO(n * d + c * m * d) where c is candidate count. More efficient than search()\nwhen candidate set is small relative to total chunks. The method performs\nI/O to read token embeddings from memory-mapped files. Thread-safe if index\nis read-only. Returns empty list if index is not ready or candidates is empty.\n\nExamples\n--------\n>>> # Requires XTRIndex instance with opened index\n>>> # index = XTRIndex(root=Path(\"...\"), config=...)\n>>> # index.open()\n>>> # candidates = [1, 2, 3, 4, 5]\n>>> # results = index.rescore(\"vector store\", candidates, explain=True)\n>>> # len(results) <= len(candidates)\n>>> # all(r[0] in candidates for r in results)\n>>> # True",
      "docstyle": "google"
    },
    {
      "full_name": "io.xtr_manager.XTRIndex.search",
      "short_name": "search",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "query",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "k",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "explain",
          "kind": "keyword_only",
          "annotated_type": "bool",
          "default": "False",
          "doc": null
        },
        {
          "name": "topk_explanations",
          "kind": "keyword_only",
          "annotated_type": "int",
          "default": "5",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "list[tuple[int, float, dict[str, Any] | None]]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Perform index-wide MaxSim search across all chunks (wide mode).",
      "doc_raw": "Perform index-wide MaxSim search across all chunks (wide mode).\n\nExtended Summary\n----------------\nThis method performs exhaustive MaxSim search across the entire XTR index,\nscoring all chunks against the query and returning the top-k results. It is\nused for wide-mode retrieval when no initial candidate set is available. The\nmethod encodes the query into token embeddings, computes MaxSim scores against\nall document chunks, and returns ranked results with optional explainability\ndata. This is the primary entry point for XTR-based search when operating\nwithout a Stage-0 retrieval system.\n\nParameters\n----------\nquery : str\n    Natural language search query string. Will be tokenized and encoded\n    into query token embeddings for MaxSim computation.\nk : int\n    Maximum number of results to return. Must be positive. Results are\n    ranked by MaxSim score in descending order.\nexplain : bool, optional\n    If True, include explainability payload with token-level alignment\n    information for each result. Defaults to False.\ntopk_explanations : int, optional\n    Maximum number of token matches to include in explainability payload\n    when explain=True. Defaults to 5.\n\nReturns\n-------\nlist[tuple[int, float, dict[str, Any] | None]]\n    Ranked list of (chunk_id, score, explainability_payload) tuples.\n    Scores are MaxSim sums across query tokens. Explainability payload is\n    None if explain=False or no matches found. Length is min(k, total_chunks).\n\nNotes\n-----\nTime complexity O(n * m * d) where n is query tokens, m is total document\ntokens across all chunks, and d is embedding dimension. Space complexity\nO(n * d + m * d) for query and document embeddings. The method performs\nI/O to read token embeddings from memory-mapped files. Thread-safe if\nindex is read-only. Returns empty list if index is not ready or k <= 0.\n\nExamples\n--------\n>>> # Requires XTRIndex instance with opened index\n>>> # index = XTRIndex(root=Path(\"...\"), config=...)\n>>> # index.open()\n>>> # results = index.search(\"vector store\", k=10)\n>>> # len(results) <= 10\n>>> # all(isinstance(r[0], int) and isinstance(r[1], float) for r in results)\n>>> # True",
      "docstyle": "google"
    },
    {
      "full_name": "io.xtr_manager.XTRIndex.encode_query_tokens",
      "short_name": "encode_query_tokens",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "text",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "NDArrayF32",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Encode text into normalized token embeddings.",
      "doc_raw": "Encode text into normalized token embeddings.\n\nParameters\n----------\ntext : str\n    Query text string to encode. Will be tokenized and truncated to\n    max_query_tokens if necessary.\n\nReturns\n-------\nNDArrayF32\n    Array shaped [tokens, dim] with L2-normalized token vectors.\n    Each row is a token embedding normalized to unit length.",
      "docstyle": "google"
    },
    {
      "full_name": "io.xtr_manager.XTRIndex.metadata",
      "short_name": "metadata",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "XTRMetadata | None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Return a shallow copy of index metadata when loaded.",
      "doc_raw": "Return a shallow copy of index metadata when loaded.\n\nReturns\n-------\nXTRMetadata | None\n    Metadata dictionary or ``None`` when index not opened.",
      "docstyle": "google"
    },
    {
      "full_name": "io.xtr_manager.XTRIndex.ready",
      "short_name": "ready",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Return ``True`` when both metadata and token memmap are available.",
      "doc_raw": "Return ``True`` when both metadata and token memmap are available.\n\nReturns\n-------\nbool\n    ``True`` if the index is ready for scoring.",
      "docstyle": "google"
    },
    {
      "full_name": "io.xtr_manager.XTRIndex.open",
      "short_name": "open",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Open metadata and memory-map the token matrix if artifacts exist.",
      "doc_raw": "Open metadata and memory-map the token matrix if artifacts exist.\n\nRaises\n------\nValueError\n    If the stored metadata does not match the token matrix shape.",
      "docstyle": "google"
    },
    {
      "full_name": "io.xtr_manager.XTRIndex._cell",
      "short_name": "_cell",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.xtr_manager.XTRIndex.config",
      "short_name": "config",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.xtr_manager.XTRIndex.root",
      "short_name": "root",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.xtr_manager._XTRIndexRuntime",
      "short_name": "_XTRIndexRuntime",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Mutable runtime artifacts for XTRIndex.",
      "doc_raw": "Mutable runtime artifacts for XTRIndex.",
      "docstyle": "google"
    },
    {
      "full_name": "io.xtr_manager._XTRIndexRuntime.close",
      "short_name": "close",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Release loaded tokenizer/model/memmaps.",
      "doc_raw": "Release loaded tokenizer/model/memmaps.",
      "docstyle": "google"
    },
    {
      "full_name": "io.xtr_manager._XTRIndexRuntime.chunk_lookup",
      "short_name": "chunk_lookup",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.xtr_manager._XTRIndexRuntime.device",
      "short_name": "device",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.xtr_manager._XTRIndexRuntime.model",
      "short_name": "model",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.xtr_manager._XTRIndexRuntime.tokenizer",
      "short_name": "tokenizer",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.xtr_manager._XTRIndexRuntime.tokens",
      "short_name": "tokens",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.xtr_manager._XTRIndexRuntime.meta",
      "short_name": "meta",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.xtr_manager._XTRIndexRuntime.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.xtr_manager._XTRIndexRuntime.__slots__",
      "short_name": "__slots__",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.xtr_manager.XTRMetadata",
      "short_name": "XTRMetadata",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [
        "TypedDict"
      ],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Metadata persisted alongside the token memmap.",
      "doc_raw": "Metadata persisted alongside the token memmap.",
      "docstyle": "google"
    },
    {
      "full_name": "io.xtr_manager.XTRMetadata.lengths",
      "short_name": "lengths",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.xtr_manager.XTRMetadata.offsets",
      "short_name": "offsets",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.xtr_manager.XTRMetadata.chunk_ids",
      "short_name": "chunk_ids",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.xtr_manager.XTRMetadata.doc_count",
      "short_name": "doc_count",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.xtr_manager.XTRMetadata.total_tokens",
      "short_name": "total_tokens",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.xtr_manager.XTRMetadata.dtype",
      "short_name": "dtype",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.xtr_manager.XTRMetadata.dim",
      "short_name": "dim",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.xtr_manager.LOGGER",
      "short_name": "LOGGER",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_manager",
      "short_name": "duckdb_manager",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Thread-safe DuckDB connection manager.",
      "doc_raw": "Thread-safe DuckDB connection manager.",
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_manager.DuckDBQueryBuilder",
      "short_name": "DuckDBQueryBuilder",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Helper for building parameterized DuckDB queries with scope filters.",
      "doc_raw": "Helper for building parameterized DuckDB queries with scope filters.",
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_manager.DuckDBQueryBuilder._escape_like_wildcards",
      "short_name": "_escape_like_wildcards",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "staticmethod"
      ],
      "params": [
        {
          "name": "pattern",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "str",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_manager.DuckDBQueryBuilder._glob_to_like",
      "short_name": "_glob_to_like",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "classmethod"
      ],
      "params": [
        {
          "name": "cls",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "pattern",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "str",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_manager.DuckDBQueryBuilder._build_where_clauses",
      "short_name": "_build_where_clauses",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "params",
          "kind": "keyword_only",
          "annotated_type": "dict[str, list[int] | list[str] | str]",
          "default": null,
          "doc": null
        },
        {
          "name": "include_globs",
          "kind": "keyword_only",
          "annotated_type": "Sequence[str]",
          "default": null,
          "doc": null
        },
        {
          "name": "exclude_globs",
          "kind": "keyword_only",
          "annotated_type": "Sequence[str]",
          "default": null,
          "doc": null
        },
        {
          "name": "languages",
          "kind": "keyword_only",
          "annotated_type": "Sequence[str]",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "list[str]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Build WHERE clauses and populate params based on filters.",
      "doc_raw": "Build WHERE clauses and populate params based on filters.\n\nParameters\n----------\nparams : dict[str, list[int] | list[str] | str]\n    Dictionary to populate with parameter values for SQL placeholders.\ninclude_globs : Sequence[str]\n    Glob patterns for paths to include in the query.\nexclude_globs : Sequence[str]\n    Glob patterns for paths to exclude from the query.\nlanguages : Sequence[str]\n    Language codes to filter by.\n\nReturns\n-------\nlist[str]\n    SQL fragments that should be combined with ``AND`` in the final query.",
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_manager.DuckDBQueryBuilder.build_filter_query",
      "short_name": "build_filter_query",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "chunk_ids",
          "kind": "keyword_only",
          "annotated_type": "Sequence[int]",
          "default": null,
          "doc": null
        },
        {
          "name": "options",
          "kind": "keyword_only",
          "annotated_type": "DuckDBQueryOptions | None",
          "default": "None",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "tuple[str, dict[str, list[int] | list[str] | str]]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Return SQL and parameters for scoped chunk retrieval.",
      "doc_raw": "Return SQL and parameters for scoped chunk retrieval.\n\nParameters\n----------\nchunk_ids : Sequence[int]\n    Chunk identifiers to hydrate. Must not be empty.\noptions : DuckDBQueryOptions | None, optional\n    Query generation options including include/exclude globs, language\n    filters, select columns, and ordering behavior.\n\nReturns\n-------\ntuple[str, dict[str, list[int] | list[str] | str]]\n    SQL query string and mapping of named parameters to values.\n\nRaises\n------\nValueError\n    If ``chunk_ids`` is empty.",
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_manager.DuckDBQueryOptions",
      "short_name": "DuckDBQueryOptions",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "dataclass(slots=True, frozen=True)"
      ],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "include_globs",
          "kind": "positional_or_keyword",
          "annotated_type": "Sequence[str] | None",
          "default": "None",
          "doc": null
        },
        {
          "name": "exclude_globs",
          "kind": "positional_or_keyword",
          "annotated_type": "Sequence[str] | None",
          "default": "None",
          "doc": null
        },
        {
          "name": "languages",
          "kind": "positional_or_keyword",
          "annotated_type": "Sequence[str] | None",
          "default": "None",
          "doc": null
        },
        {
          "name": "select_columns",
          "kind": "positional_or_keyword",
          "annotated_type": "Sequence[str] | None",
          "default": "None",
          "doc": null
        },
        {
          "name": "preserve_order",
          "kind": "positional_or_keyword",
          "annotated_type": "bool",
          "default": "False",
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Options controlling DuckDB query generation.",
      "doc_raw": "Options controlling DuckDB query generation.",
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_manager.DuckDBQueryOptions.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "include_globs",
          "kind": "positional_or_keyword",
          "annotated_type": "Sequence[str] | None",
          "default": "None",
          "doc": null
        },
        {
          "name": "exclude_globs",
          "kind": "positional_or_keyword",
          "annotated_type": "Sequence[str] | None",
          "default": "None",
          "doc": null
        },
        {
          "name": "languages",
          "kind": "positional_or_keyword",
          "annotated_type": "Sequence[str] | None",
          "default": "None",
          "doc": null
        },
        {
          "name": "select_columns",
          "kind": "positional_or_keyword",
          "annotated_type": "Sequence[str] | None",
          "default": "None",
          "doc": null
        },
        {
          "name": "preserve_order",
          "kind": "positional_or_keyword",
          "annotated_type": "bool",
          "default": "False",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_manager.DuckDBQueryOptions.preserve_order",
      "short_name": "preserve_order",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_manager.DuckDBQueryOptions.select_columns",
      "short_name": "select_columns",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_manager.DuckDBQueryOptions.languages",
      "short_name": "languages",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_manager.DuckDBQueryOptions.exclude_globs",
      "short_name": "exclude_globs",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_manager.DuckDBQueryOptions.include_globs",
      "short_name": "include_globs",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_manager.DuckDBManager",
      "short_name": "DuckDBManager",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "db_path",
          "kind": "positional_or_keyword",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        },
        {
          "name": "config",
          "kind": "positional_or_keyword",
          "annotated_type": "DuckDBConfig | None",
          "default": "None",
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Factory for DuckDB connections with consistent pragmas.",
      "doc_raw": "Factory for DuckDB connections with consistent pragmas.\n\nParameters\n----------\ndb_path : Path\n    Path to the DuckDB catalog database file.\nconfig : DuckDBConfig | None, optional\n    Connection configuration controlling threading and caching pragmas.\n    If ``None``, uses default configuration. Defaults to ``None``.",
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_manager.DuckDBManager._release_connection",
      "short_name": "_release_connection",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "conn",
          "kind": "positional_or_keyword",
          "annotated_type": "duckdb.DuckDBPyConnection",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_manager.DuckDBManager._acquire_connection",
      "short_name": "_acquire_connection",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "duckdb.DuckDBPyConnection",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_manager.DuckDBManager._create_connection",
      "short_name": "_create_connection",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "duckdb.DuckDBPyConnection",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_manager.DuckDBManager.__del__",
      "short_name": "__del__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Ensure pooled connections are released during garbage collection.",
      "doc_raw": "Ensure pooled connections are released during garbage collection.",
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_manager.DuckDBManager.close",
      "short_name": "close",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Close all pooled connections and reset pool counters.",
      "doc_raw": "Close all pooled connections and reset pool counters.",
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_manager.DuckDBManager.connections_created",
      "short_name": "connections_created",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Return the number of pooled connections created.",
      "doc_raw": "Return the number of pooled connections created.",
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_manager.DuckDBManager.config",
      "short_name": "config",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Return the active DuckDB configuration.",
      "doc_raw": "Return the active DuckDB configuration.",
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_manager.DuckDBManager.connection",
      "short_name": "connection",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "contextmanager"
      ],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "Iterator[duckdb.DuckDBPyConnection]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Yield a configured DuckDB connection.",
      "doc_raw": "Yield a configured DuckDB connection.\n\nYields\n------\nduckdb.DuckDBPyConnection\n    Connection configured with the requested pragmas. The connection is\n    automatically closed when the context manager exits.\n\nNotes\n-----\nWhen ``DuckDBConfig.pool_size`` is greater than zero, connections are\ntaken from and returned to an in-process pool, ensuring bounded\nconcurrency without reopening the database file for every request.",
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_manager.DuckDBManager._connections_created",
      "short_name": "_connections_created",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_manager.DuckDBManager._pool_lock",
      "short_name": "_pool_lock",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_manager.DuckDBManager._pool",
      "short_name": "_pool",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_manager.DuckDBManager._pool_size",
      "short_name": "_pool_size",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_manager.DuckDBManager._config",
      "short_name": "_config",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_manager.DuckDBManager._db_path",
      "short_name": "_db_path",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_manager.DuckDBManager.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "db_path",
          "kind": "positional_or_keyword",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        },
        {
          "name": "config",
          "kind": "positional_or_keyword",
          "annotated_type": "DuckDBConfig | None",
          "default": "None",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_manager.DuckDBConfig",
      "short_name": "DuckDBConfig",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "dataclass(slots=True, frozen=True)"
      ],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "threads",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": "4",
          "doc": null
        },
        {
          "name": "enable_object_cache",
          "kind": "positional_or_keyword",
          "annotated_type": "bool",
          "default": "True",
          "doc": null
        },
        {
          "name": "log_queries",
          "kind": "positional_or_keyword",
          "annotated_type": "bool",
          "default": "False",
          "doc": null
        },
        {
          "name": "pool_size",
          "kind": "positional_or_keyword",
          "annotated_type": "int | None",
          "default": "None",
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Configuration parameters controlling DuckDB connections.",
      "doc_raw": "Configuration parameters controlling DuckDB connections.\n\nAttributes\n----------\nthreads : int\n    Number of DuckDB worker threads to use for queries executed on the\n    returned connection. Defaults to ``4`` which offers good parallelism for\n    local development while remaining conservative for CI environments.\nenable_object_cache : bool\n    Enable DuckDB's object cache to reuse parsed query plans and cached\n    Parquet metadata across connections. Enabled by default for repeated\n    catalog queries.\nlog_queries : bool\n    Emit debug-level logs for every executed SQL statement. Disabled by\n    default to avoid noise in production environments.\npool_size : int | None\n    Maximum number of DuckDB connections to keep in the optional connection\n    pool. ``None`` or ``0`` disables pooling (default). When enabled,\n    connections are reused across requests up to the configured limit.",
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_manager.DuckDBConfig.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "threads",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": "4",
          "doc": null
        },
        {
          "name": "enable_object_cache",
          "kind": "positional_or_keyword",
          "annotated_type": "bool",
          "default": "True",
          "doc": null
        },
        {
          "name": "log_queries",
          "kind": "positional_or_keyword",
          "annotated_type": "bool",
          "default": "False",
          "doc": null
        },
        {
          "name": "pool_size",
          "kind": "positional_or_keyword",
          "annotated_type": "int | None",
          "default": "None",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_manager.DuckDBConfig.pool_size",
      "short_name": "pool_size",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_manager.DuckDBConfig.log_queries",
      "short_name": "log_queries",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_manager.DuckDBConfig.enable_object_cache",
      "short_name": "enable_object_cache",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_manager.DuckDBConfig.threads",
      "short_name": "threads",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.duckdb_manager.__all__",
      "short_name": "__all__",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.parquet_store",
      "short_name": "parquet_store",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Parquet storage for chunks and vectors using Arrow.",
      "doc_raw": "Parquet storage for chunks and vectors using Arrow.\n\nStores chunks and embeddings in columnar Parquet format with FixedSizeList\nfor efficient vector storage and querying via DuckDB.",
      "docstyle": "google"
    },
    {
      "full_name": "io.parquet_store.__all__",
      "short_name": "__all__",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.parquet_store.extract_embeddings",
      "short_name": "extract_embeddings",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "table",
          "kind": "positional_or_keyword",
          "annotated_type": "pa.Table",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "NDArrayF32",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Extract embeddings from chunks table.",
      "doc_raw": "Extract embeddings from chunks table.\n\nParameters\n----------\ntable : pa.Table\n    Chunks table with embedding column.\n\nReturns\n-------\nNDArrayF32\n    Embeddings array of shape (num_rows, vec_dim).\n\nRaises\n------\nTypeError\n    If the embedding column is not stored as a FixedSizeListArray.",
      "docstyle": "google"
    },
    {
      "full_name": "io.parquet_store.read_chunks_parquet",
      "short_name": "read_chunks_parquet",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "parquet_path",
          "kind": "positional_or_keyword",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "pa.Table",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Read chunks from Parquet file.",
      "doc_raw": "Read chunks from Parquet file.\n\nParameters\n----------\nparquet_path : Path\n    Parquet file path.\n\nReturns\n-------\npa.Table\n    Chunks table.",
      "docstyle": "google"
    },
    {
      "full_name": "io.parquet_store.write_chunks_parquet",
      "short_name": "write_chunks_parquet",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "output_path",
          "kind": "positional_or_keyword",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        },
        {
          "name": "chunks",
          "kind": "positional_or_keyword",
          "annotated_type": "Sequence[Chunk]",
          "default": null,
          "doc": null
        },
        {
          "name": "embeddings",
          "kind": "positional_or_keyword",
          "annotated_type": "NDArrayF32",
          "default": null,
          "doc": null
        },
        {
          "name": "options",
          "kind": "keyword_only",
          "annotated_type": "ParquetWriteOptions | None",
          "default": "None",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Write chunks and embeddings to Parquet.",
      "doc_raw": "Write chunks and embeddings to Parquet.\n\nParameters\n----------\noutput_path : Path\n    Output Parquet file path.\nchunks : Sequence[Chunk]\n    Chunk metadata.\nembeddings : NDArrayF32\n    Embeddings array of shape (len(chunks), vec_dim).\noptions : ParquetWriteOptions | None, optional\n    Configuration for chunk identifiers, embedding dimension, and preview\n    truncation length. Defaults to :class:`ParquetWriteOptions`.\n\nRaises\n------\nValueError\n    If chunks and embeddings length mismatch.",
      "docstyle": "google"
    },
    {
      "full_name": "io.parquet_store.ParquetWriteOptions",
      "short_name": "ParquetWriteOptions",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "dataclass(slots=True, frozen=True)"
      ],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "start_id",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": "0",
          "doc": null
        },
        {
          "name": "vec_dim",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": "2560",
          "doc": null
        },
        {
          "name": "preview_max_chars",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": "240",
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Configuration for Parquet persistence.",
      "doc_raw": "Configuration for Parquet persistence.",
      "docstyle": "google"
    },
    {
      "full_name": "io.parquet_store.ParquetWriteOptions.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "start_id",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": "0",
          "doc": null
        },
        {
          "name": "vec_dim",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": "2560",
          "doc": null
        },
        {
          "name": "preview_max_chars",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": "240",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.parquet_store.ParquetWriteOptions.preview_max_chars",
      "short_name": "preview_max_chars",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.parquet_store.ParquetWriteOptions.vec_dim",
      "short_name": "vec_dim",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.parquet_store.ParquetWriteOptions.start_id",
      "short_name": "start_id",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.parquet_store.get_chunks_schema",
      "short_name": "get_chunks_schema",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "vec_dim",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "pa.Schema",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Get Arrow schema for chunks table.",
      "doc_raw": "Get Arrow schema for chunks table.\n\nParameters\n----------\nvec_dim : int\n    Embedding dimension.\n\nReturns\n-------\npa.Schema\n    Arrow schema for chunks with embeddings.",
      "docstyle": "google"
    },
    {
      "full_name": "io.vllm_client",
      "short_name": "vllm_client",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "vLLM embedding client using msgspec for fast serialization.",
      "doc_raw": "vLLM embedding client using msgspec for fast serialization.\n\nOpenAI-compatible /v1/embeddings endpoint with batching support.",
      "docstyle": "google"
    },
    {
      "full_name": "io.vllm_client.__all__",
      "short_name": "__all__",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.vllm_client.VLLMClient",
      "short_name": "VLLMClient",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "config",
          "kind": "positional_or_keyword",
          "annotated_type": "VLLMConfig",
          "default": null,
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "vLLM embedding client supporting HTTP or in-process execution.",
      "doc_raw": "vLLM embedding client supporting HTTP or in-process execution.\n\nMaintains a persistent HTTP client for connection reuse across embedding\nbatches. This reduces latency by eliminating TCP handshake overhead and\nenables HTTP/1.1 keep-alive for better performance.\n\nThe client is created during initialization and reused for all embed_batch\ncalls. Connection pooling is configured with limits to prevent server\noverload. The client must be closed during application shutdown via the\nclose() method to avoid resource leaks.\n\nParameters\n----------\nconfig : VLLMConfig\n    vLLM configuration including base URL, timeout, and model name.\n\nExamples\n--------\nCreate client and embed batch:\n\n>>> from codeintel_rev.config.settings import VLLMConfig\n>>> config = VLLMConfig(base_url=\"http://localhost:8000\", model=\"test-model\")\n>>> client = VLLMClient(config)\n>>> vectors = client.embed_batch([\"def hello(): pass\", \"def world(): pass\"])\n>>> vectors.shape\n(2, 2560)\n\nCleanup during shutdown:\n\n>>> client.close()  # Must be called to close HTTP connections\n\nNotes\n-----\nConnection pool limits:\n- max_connections=100: Maximum total connections in pool\n- max_keepalive_connections=20: Maximum connections kept alive for reuse\n\nThese limits prevent overwhelming the vLLM server while allowing efficient\nconnection reuse for high-throughput embedding workloads.\n\nInternal attributes (not part of public API):\n- ``config``: vLLM configuration\n- ``_client``: Persistent HTTP client with connection pooling. Created during\n  initialization and reused across all requests\n- ``_async_client``: Optional async HTTP client for concurrent embedding generation.\n  Lazy-initialized on first call to embed_batch_async\n- ``_encoder``: Fast JSON encoder for request serialization\n- ``_decoder``: Fast JSON decoder for response deserialization",
      "docstyle": "google"
    },
    {
      "full_name": "io.vllm_client.VLLMClient._require_http_client",
      "short_name": "_require_http_client",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "httpx.Client",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.vllm_client.VLLMClient._ensure_async_http_client",
      "short_name": "_ensure_async_http_client",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "httpx.AsyncClient",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.vllm_client.VLLMClient._embed_batch_async_local",
      "short_name": "_embed_batch_async_local",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "texts",
          "kind": "positional_or_keyword",
          "annotated_type": "Sequence[str]",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "NDArrayF32",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.vllm_client.VLLMClient.aclose",
      "short_name": "aclose",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Asynchronously release all clients/engines.",
      "doc_raw": "Asynchronously release all clients/engines.",
      "docstyle": "google"
    },
    {
      "full_name": "io.vllm_client.VLLMClient.close",
      "short_name": "close",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Close HTTP clients, async clients, and the local engine.",
      "doc_raw": "Close HTTP clients, async clients, and the local engine.",
      "docstyle": "google"
    },
    {
      "full_name": "io.vllm_client.VLLMClient.embed_batch_async",
      "short_name": "embed_batch_async",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "texts",
          "kind": "positional_or_keyword",
          "annotated_type": "Sequence[str]",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "NDArrayF32",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Asynchronous variant of embed_batch for async/await workflows.",
      "doc_raw": "Asynchronous variant of embed_batch for async/await workflows.\n\nExtended Summary\n----------------\nThis method provides an asynchronous interface for generating dense vector\nembeddings, enabling non-blocking embedding generation in async contexts.\nIt supports both HTTP-based remote embedding (via async HTTP client) and\nin-process embedding (via async local engine wrapper). The method handles\nempty input batches gracefully and provides the same functionality as\nembed_batch but with async/await semantics for use in async event loops.\n\nParameters\n----------\ntexts : Sequence[str]\n    Ordered sequence of text strings to embed. Empty sequences result in an\n    empty embedding matrix. Each text will be tokenized and encoded by the\n    vLLM model to produce a dense vector representation.\n\nReturns\n-------\nNDArrayF32\n    Embedding matrix with shape (N, embedding_dim) where N is len(texts) and\n    embedding_dim matches the configured model's output dimensionality. Dtype is\n    float32. Each row corresponds to the embedding of the corresponding input text.\n\nNotes\n-----\nTime complexity O(N * T) where N is batch size and T is average token count per\ntext, plus network latency for HTTP mode. Space complexity O(N * embedding_dim)\nfor the result matrix. The method performs async network I/O in HTTP mode or\nasync GPU computation in local mode. Thread-safe if the underlying async HTTP\nclient or local engine is thread-safe. Empty batches return shape (0, embedding_dim).",
      "docstyle": "google"
    },
    {
      "full_name": "io.vllm_client.VLLMClient.embed_chunks",
      "short_name": "embed_chunks",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "texts",
          "kind": "positional_or_keyword",
          "annotated_type": "Sequence[str]",
          "default": null,
          "doc": null
        },
        {
          "name": "batch_size",
          "kind": "positional_or_keyword",
          "annotated_type": "int | None",
          "default": "None",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "NDArrayF32",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Embed texts in batches.",
      "doc_raw": "Embed texts in batches.\n\nThis method processes multiple texts efficiently by splitting them into\nbatches and sending each batch to the vLLM embedding service. Batching\nimproves throughput by amortizing HTTP request overhead and allowing\nthe service to process multiple texts in parallel.\n\nThe method handles empty input gracefully, returning an empty array with\nthe correct shape. Batch size can be customized per call or defaults to\nthe client's configured batch size. Results are concatenated into a single\narray maintaining the input order.\n\nParameters\n----------\ntexts : Sequence[str]\n    Sequence of texts to embed. Can be any sequence type (list, tuple, etc.).\n    Each text should be a code chunk or query string suitable for the\n    embedding model. Empty sequence returns empty array.\nbatch_size : int | None, optional\n    Number of texts to process per batch. If None, uses the client's\n    configured batch_size from config. Larger batches improve throughput\n    but increase memory usage. Defaults to None (use config.batch_size).\n\nReturns\n-------\nNDArrayF32\n    Embeddings array of shape (len(texts), vec_dim) where vec_dim is the\n    model's embedding dimension (e.g., 2560). Dtype is float32 for memory\n    efficiency. Returns an empty array of shape (0, self.config.embedding_dim)\n    when texts is empty. The order matches the input texts.",
      "docstyle": "google"
    },
    {
      "full_name": "io.vllm_client.VLLMClient.embed_single",
      "short_name": "embed_single",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "text",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "NDArrayF32",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Embed a single string and return its vector.",
      "doc_raw": "Embed a single string and return its vector.\n\nParameters\n----------\ntext : str\n    Text to embed.\n\nReturns\n-------\nNDArrayF32\n    One-dimensional embedding vector for the supplied text.\n\nRaises\n------\nRuntimeError\n    If the embedding service returns an empty response.",
      "docstyle": "google"
    },
    {
      "full_name": "io.vllm_client.VLLMClient._embed_batch_http",
      "short_name": "_embed_batch_http",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "texts",
          "kind": "positional_or_keyword",
          "annotated_type": "Sequence[str]",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "NDArrayF32",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.vllm_client.VLLMClient.embed_batch",
      "short_name": "embed_batch",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "texts",
          "kind": "positional_or_keyword",
          "annotated_type": "Sequence[str]",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "NDArrayF32",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Embed texts using the configured transport (HTTP or local).",
      "doc_raw": "Embed texts using the configured transport (HTTP or local).\n\nExtended Summary\n----------------\nThis method generates dense vector embeddings for a batch of text strings using\nthe configured vLLM service. It supports both HTTP-based remote embedding (when\nvLLM runs as a separate service) and in-process embedding (when vLLM is loaded\nlocally). The method automatically selects the appropriate transport based on\nthe client configuration and handles empty input batches gracefully. This is the\nprimary entry point for generating embeddings in Stage-0 retrieval pipelines.\n\nParameters\n----------\ntexts : Sequence[str]\n    Ordered sequence of text strings to embed. Empty sequences result in an\n    empty embedding matrix. Each text will be tokenized and encoded by the\n    vLLM model to produce a dense vector representation.\n\nReturns\n-------\nNDArrayF32\n    Embedding matrix with shape (N, embedding_dim) where N is len(texts) and\n    embedding_dim matches the configured model's output dimensionality. Dtype is\n    float32. Each row corresponds to the embedding of the corresponding input text.\n\nNotes\n-----\nTime complexity O(N * T) where N is batch size and T is average token count per\ntext, plus network latency for HTTP mode. Space complexity O(N * embedding_dim)\nfor the result matrix. The method performs network I/O in HTTP mode or GPU\ncomputation in local mode. Thread-safe if the underlying HTTP client or local\nengine is thread-safe. Empty batches return shape (0, embedding_dim).",
      "docstyle": "google"
    },
    {
      "full_name": "io.vllm_client.VLLMClient._initialize_http_client",
      "short_name": "_initialize_http_client",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.vllm_client.VLLMClient._initialize_local_engine",
      "short_name": "_initialize_local_engine",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.vllm_client.VLLMClient._local_semaphore",
      "short_name": "_local_semaphore",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.vllm_client.VLLMClient._local_engine",
      "short_name": "_local_engine",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.vllm_client.VLLMClient._async_client",
      "short_name": "_async_client",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.vllm_client.VLLMClient._client",
      "short_name": "_client",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.vllm_client.VLLMClient._mode",
      "short_name": "_mode",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.vllm_client.VLLMClient._decoder",
      "short_name": "_decoder",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.vllm_client.VLLMClient._encoder",
      "short_name": "_encoder",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.vllm_client.VLLMClient.config",
      "short_name": "config",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.vllm_client.VLLMClient.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "config",
          "kind": "positional_or_keyword",
          "annotated_type": "VLLMConfig",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.vllm_client.EmbeddingResponse",
      "short_name": "EmbeddingResponse",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [
        "msgspec.Struct"
      ],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "OpenAI-compatible embedding response payload.",
      "doc_raw": "OpenAI-compatible embedding response payload.\n\nResponse structure from the vLLM /v1/embeddings endpoint, matching the OpenAI\nAPI format. Contains the embedding vectors along with metadata about the\nrequest and model usage.\n\nThe data field contains one EmbeddingData per input text. Results may be\nreturned in a different order than the input, so use the index field to\nmatch embeddings to their original texts.\n\nAttributes\n----------\ndata : list[EmbeddingData]\n    List of embedding results, one per input text. The list length matches\n    the number of texts in the request. Each EmbeddingData contains the\n    vector and its index in the original batch.\nmodel : str\n    Model identifier that was used to generate the embeddings. Should match\n    the model field from the request. Useful for verification and logging.\nusage : dict\n    Token usage statistics dictionary. Typically contains keys like \"prompt_tokens\"\n    and \"total_tokens\" indicating how many tokens were processed. Useful for\n    monitoring and cost tracking.",
      "docstyle": "google"
    },
    {
      "full_name": "io.vllm_client.EmbeddingResponse.usage",
      "short_name": "usage",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.vllm_client.EmbeddingResponse.model",
      "short_name": "model",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.vllm_client.EmbeddingResponse.data",
      "short_name": "data",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.vllm_client.EmbeddingData",
      "short_name": "EmbeddingData",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [
        "msgspec.Struct"
      ],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Single embedding result from a batch request.",
      "doc_raw": "Single embedding result from a batch request.\n\nRepresents one embedding vector from a batch embedding request. Each text\nin the input batch produces one EmbeddingData object. The index field\nindicates the position in the original batch, which is important because\nvLLM may return results in a different order than the input.\n\nAttributes\n----------\nembedding : list[float]\n    Embedding vector as a list of floats. The length matches the model's\n    dimension (e.g., 2560 for nomic-embed-code). Values are typically\n    normalized for cosine similarity. The expected size is available as\n    ``VLLMConfig.embedding_dim``.\nindex : int\n    Zero-based index indicating the position of this embedding in the\n    original input batch. Used to match embeddings back to their input\n    texts when results may be reordered.",
      "docstyle": "google"
    },
    {
      "full_name": "io.vllm_client.EmbeddingData.index",
      "short_name": "index",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.vllm_client.EmbeddingData.embedding",
      "short_name": "embedding",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.vllm_client.EmbeddingRequest",
      "short_name": "EmbeddingRequest",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [
        "msgspec.Struct"
      ],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "OpenAI-compatible embedding request payload.",
      "doc_raw": "OpenAI-compatible embedding request payload.\n\nRequest structure for the vLLM /v1/embeddings endpoint, matching the OpenAI\nAPI format. This allows vLLM to be used as a drop-in replacement for OpenAI's\nembedding API.\n\nThe request can embed a single text (str) or a batch of texts (list[str]).\nBatch requests are more efficient as they're processed in parallel by the\nmodel.\n\nAttributes\n----------\ninput : str | list[str]\n    Text(s) to embed. Can be a single string for one embedding, or a list\n    of strings for batch embedding. Batch processing is more efficient.\n    Each text should be a code chunk or query string.\nmodel : str\n    Model identifier string. Must match a model loaded by the vLLM server.\n    Defaults to \"nomic-ai/nomic-embed-code\" which is a code-specific\n    embedding model with 2560 dimensions. The embedding dimensionality is\n    surfaced via :class:`codeintel_rev.config.settings.VLLMConfig` ``embedding_dim``.",
      "docstyle": "google"
    },
    {
      "full_name": "io.vllm_client.EmbeddingRequest.model",
      "short_name": "model",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.vllm_client.EmbeddingRequest.input",
      "short_name": "input",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.vllm_client._get_numpy",
      "short_name": "_get_numpy",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "lru_cache(maxsize=1)"
      ],
      "params": [],
      "returns": {
        "annotated_type": "ModuleType",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Load numpy lazily when embeddings are computed.",
      "doc_raw": "Load numpy lazily when embeddings are computed.\n\nExtended Summary\n----------------\nThis function provides lazy import of the NumPy module for embedding operations\nin VLLMClient. It uses LRU caching to ensure the module is imported only once\nper process, reducing import overhead. The function gates the import using\n``gate_import`` to prevent eager loading of NumPy when it's not needed, which\nis important for keeping the codebase lightweight and avoiding unnecessary\ndependencies in environments where NumPy may not be available.\n\nReturns\n-------\nModuleType\n    The lazily imported NumPy module. The return type is ``ModuleType`` to\n    match the runtime type, but the actual value is the ``numpy`` module\n    (cast from the gate_import result).\n\nNotes\n-----\nTime complexity O(1) after first call (cached); O(n) on first call where n\nis import overhead. Space complexity O(1) - single module reference cached.\nThe function performs module import I/O on first call only. Thread-safe due\nto lru_cache implementation. Uses ``gate_import`` to ensure proper typing\nfacade compliance and prevent eager NumPy loading.",
      "docstyle": "google"
    },
    {
      "full_name": "io.vllm_client.LOGGER",
      "short_name": "LOGGER",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager",
      "short_name": "splade_manager",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "SPLADE artifact management, encoding, and Lucene impact index builders.",
      "doc_raw": "SPLADE artifact management, encoding, and Lucene impact index builders.",
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.__all__",
      "short_name": "__all__",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeIndexManager",
      "short_name": "SpladeIndexManager",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "settings",
          "kind": "positional_or_keyword",
          "annotated_type": "Settings",
          "default": null,
          "doc": null
        },
        {
          "name": "logger_",
          "kind": "keyword_only",
          "annotated_type": "logging.Logger | None",
          "default": "None",
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Build SPLADE Lucene impact indexes from vector collections.",
      "doc_raw": "Build SPLADE Lucene impact indexes from vector collections.",
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeIndexManager.build_index",
      "short_name": "build_index",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "options",
          "kind": "positional_or_keyword",
          "annotated_type": "SpladeBuildOptions | None",
          "default": "None",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "SpladeIndexMetadata",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Invoke Pyserini to build a SPLADE Lucene impact index.",
      "doc_raw": "Invoke Pyserini to build a SPLADE Lucene impact index.\n\nParameters\n----------\noptions : SpladeBuildOptions | None, optional\n    Overrides for vectors/index directories, thread count, clause limit, and overwrite.\n\nReturns\n-------\nSpladeIndexMetadata\n    Metadata describing the resulting Lucene impact index.\n\nRaises\n------\nFileExistsError\n    If the index directory already exists and ``overwrite`` is ``False``.",
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeIndexManager.index_dir",
      "short_name": "index_dir",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Return the configured Lucene impact index directory.",
      "doc_raw": "Return the configured Lucene impact index directory.\n\nReturns\n-------\nPath\n    Absolute path to the Lucene impact index output directory.",
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeIndexManager.vectors_dir",
      "short_name": "vectors_dir",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Return the configured JsonVectorCollection directory.",
      "doc_raw": "Return the configured JsonVectorCollection directory.\n\nReturns\n-------\nPath\n    Absolute path to the JsonVectorCollection directory used for indexing.",
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeIndexManager._config",
      "short_name": "_config",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeIndexManager._repo_root",
      "short_name": "_repo_root",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeIndexManager._logger",
      "short_name": "_logger",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeIndexManager._settings",
      "short_name": "_settings",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeIndexManager.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "settings",
          "kind": "positional_or_keyword",
          "annotated_type": "Settings",
          "default": null,
          "doc": null
        },
        {
          "name": "logger_",
          "kind": "keyword_only",
          "annotated_type": "logging.Logger | None",
          "default": "None",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeEncoderService",
      "short_name": "SpladeEncoderService",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "settings",
          "kind": "positional_or_keyword",
          "annotated_type": "Settings",
          "default": null,
          "doc": null
        },
        {
          "name": "logger_",
          "kind": "keyword_only",
          "annotated_type": "logging.Logger | None",
          "default": "None",
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Encode corpora into SPLADE JsonVectorCollection shards.",
      "doc_raw": "Encode corpora into SPLADE JsonVectorCollection shards.",
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeEncoderService.benchmark_queries",
      "short_name": "benchmark_queries",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "queries",
          "kind": "positional_or_keyword",
          "annotated_type": "Sequence[str]",
          "default": null,
          "doc": null
        },
        {
          "name": "options",
          "kind": "positional_or_keyword",
          "annotated_type": "SpladeBenchmarkOptions | None",
          "default": "None",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "SpladeBenchmarkSummary",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Benchmark SPLADE query encoding latency.",
      "doc_raw": "Benchmark SPLADE query encoding latency.\n\nParameters\n----------\nqueries : Sequence[str]\n    One or more query strings to encode during the benchmark.\noptions : SpladeBenchmarkOptions | None, optional\n    Benchmark configuration overrides. Defaults to :class:`SpladeBenchmarkOptions`.\n\nReturns\n-------\nSpladeBenchmarkSummary\n    Latency statistics captured across the measured iterations.\n\nRaises\n------\nValueError\n    Raised when the query list is empty or the benchmark configuration is invalid.",
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeEncoderService.encode_corpus",
      "short_name": "encode_corpus",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "source",
          "kind": "positional_or_keyword",
          "annotated_type": "str | Path",
          "default": null,
          "doc": null
        },
        {
          "name": "options",
          "kind": "positional_or_keyword",
          "annotated_type": "SpladeEncodeOptions | None",
          "default": "None",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "SpladeEncodingSummary",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Encode ``source`` JSONL into SPLADE JsonVectorCollection shards.",
      "doc_raw": "Encode ``source`` JSONL into SPLADE JsonVectorCollection shards.\n\nParameters\n----------\nsource : str | Path\n    Path to the JSONL corpus containing ``id`` and ``contents``/``text`` fields.\noptions : SpladeEncodeOptions | None, optional\n    Overrides for output directory, batch size, quantization, provider, and ONNX file.\n\nReturns\n-------\nSpladeEncodingSummary\n    Summary including document count, vectors directory, metadata path, and shard count.\n\nRaises\n------\nTypeError\n    If corpus entries are missing identifiers or textual content.",
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeEncoderService._build_encoder",
      "short_name": "_build_encoder",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "provider",
          "kind": "keyword_only",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "onnx_file",
          "kind": "keyword_only",
          "annotated_type": "str | None",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "_SparseEncoderProtocol",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeEncoderService._initialise_encoder",
      "short_name": "_initialise_encoder",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "provider",
          "kind": "keyword_only",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "onnx_file",
          "kind": "keyword_only",
          "annotated_type": "str | None",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "tuple[_SparseEncoderProtocol, str | None]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Instantiate a SparseEncoder and return the resolved ONNX artifact (if any).",
      "doc_raw": "Instantiate a SparseEncoder and return the resolved ONNX artifact (if any).\n\nThis method initializes a SPLADE sparse encoder instance, searching for\nONNX model files in a priority order: explicit onnx_file parameter,\nconfigured default ONNX file, or falls back to PyTorch model if no ONNX\nfile is found. The encoder is configured with the specified provider\n(CPU, CUDA, etc.) for inference.\n\nThe method searches multiple candidate paths to find an available ONNX\nmodel, preferring explicitly specified files over defaults. If an ONNX\nfile is found, it's used for faster inference. Otherwise, the encoder\nfalls back to the PyTorch model.\n\nParameters\n----------\nprovider : str\n    ONNX runtime provider to use for inference (e.g., \"cpu\", \"cuda\",\n    \"tensorrt\"). The provider determines which hardware/backend is used\n    for model execution. Must be a valid provider name supported by the\n    ONNX runtime.\nonnx_file : str | None, optional\n    Optional explicit ONNX filename to use. If provided, this file is\n    searched first in the ONNX directory. If not found or None, falls\n    back to the configured default ONNX filename. Defaults to None.\n\nReturns\n-------\ntuple[_SparseEncoderProtocol, str | None]\n    Tuple containing:\n    - Encoder instance ready for encoding operations. The encoder is\n      configured with the found ONNX model (if available) or PyTorch\n      model, using the specified provider.\n    - Relative path to the ONNX file used (relative to model_dir), or\n      None if no ONNX file was found and PyTorch model was used instead.\n      This path can be stored in metadata for reproducibility.",
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeEncoderService._resolve_vectors_dir",
      "short_name": "_resolve_vectors_dir",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "override",
          "kind": "positional_or_keyword",
          "annotated_type": "str | Path | None",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "Path",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Resolve the vectors directory override or fall back to the configured path.",
      "doc_raw": "Resolve the vectors directory override or fall back to the configured path.\n\nThis method resolves the output directory for encoded vectors, either\nusing an explicit override path or falling back to the configured default.\nThe directory is created if it doesn't exist, ensuring it's ready for\nwriting shard files.\n\nParameters\n----------\noverride : str | Path | None, optional\n    Optional override path for the vectors directory. If provided, this\n    path is resolved relative to the repository root and used instead of\n    the configured default. If None, uses the configured vectors_dir\n    from settings. Defaults to None.\n\nReturns\n-------\nPath\n    Absolute path to the directory where encoded vectors will be written.\n    The directory is guaranteed to exist (created if necessary). The path\n    is resolved relative to the repository root and normalized.",
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeEncoderService.vectors_dir",
      "short_name": "vectors_dir",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Return the directory that stores SPLADE JsonVectorCollection shards.",
      "doc_raw": "Return the directory that stores SPLADE JsonVectorCollection shards.\n\nReturns\n-------\nPath\n    Absolute path to the configured vectors directory.",
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeEncoderService._config",
      "short_name": "_config",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeEncoderService._repo_root",
      "short_name": "_repo_root",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeEncoderService._logger",
      "short_name": "_logger",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeEncoderService._settings",
      "short_name": "_settings",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeEncoderService.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "settings",
          "kind": "positional_or_keyword",
          "annotated_type": "Settings",
          "default": null,
          "doc": null
        },
        {
          "name": "logger_",
          "kind": "keyword_only",
          "annotated_type": "logging.Logger | None",
          "default": "None",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeArtifactsManager",
      "short_name": "SpladeArtifactsManager",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "settings",
          "kind": "positional_or_keyword",
          "annotated_type": "Settings",
          "default": null,
          "doc": null
        },
        {
          "name": "logger_",
          "kind": "keyword_only",
          "annotated_type": "logging.Logger | None",
          "default": "None",
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Manage SPLADE model exports and ONNX artifacts.",
      "doc_raw": "Manage SPLADE model exports and ONNX artifacts.",
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeArtifactsManager.export_onnx",
      "short_name": "export_onnx",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "options",
          "kind": "positional_or_keyword",
          "annotated_type": "SpladeExportOptions | None",
          "default": "None",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "SpladeExportSummary",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Export SPLADE ONNX artifacts and record metadata.",
      "doc_raw": "Export SPLADE ONNX artifacts and record metadata.\n\nParameters\n----------\noptions : SpladeExportOptions | None, optional\n    Overrides for model identifier, provider, and export behaviour.\n\nReturns\n-------\nSpladeExportSummary\n    Summary describing the exported artifact and metadata path.",
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeArtifactsManager.onnx_dir",
      "short_name": "onnx_dir",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Return the directory where exported ONNX artifacts are stored.",
      "doc_raw": "Return the directory where exported ONNX artifacts are stored.\n\nReturns\n-------\nPath\n    Absolute path to the configured ONNX artifacts directory.",
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeArtifactsManager.model_dir",
      "short_name": "model_dir",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Return the repository-relative directory containing saved SPLADE weights.",
      "doc_raw": "Return the repository-relative directory containing saved SPLADE weights.\n\nReturns\n-------\nPath\n    Absolute path to the configured SPLADE model directory.",
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeArtifactsManager._config",
      "short_name": "_config",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeArtifactsManager._repo_root",
      "short_name": "_repo_root",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeArtifactsManager._logger",
      "short_name": "_logger",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeArtifactsManager._settings",
      "short_name": "_settings",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeArtifactsManager.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "settings",
          "kind": "positional_or_keyword",
          "annotated_type": "Settings",
          "default": null,
          "doc": null
        },
        {
          "name": "logger_",
          "kind": "keyword_only",
          "annotated_type": "logging.Logger | None",
          "default": "None",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager._persist_export_metadata",
      "short_name": "_persist_export_metadata",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "ctx",
          "kind": "keyword_only",
          "annotated_type": "_ExportContext",
          "default": null,
          "doc": null
        },
        {
          "name": "quantized",
          "kind": "keyword_only",
          "annotated_type": "bool",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "SpladeExportSummary",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Write export metadata and return the resulting summary.",
      "doc_raw": "Write export metadata and return the resulting summary.\n\nThis function creates and persists metadata about a SPLADE ONNX export\noperation, including model identifier, export paths, provider information,\noptimization and quantization status, and export timestamp. The metadata\nis written as JSON to a standard location and can be used to verify exports\nand understand export configuration.\n\nParameters\n----------\nctx : _ExportContext\n    Export context containing all export information: model identifier,\n    directory paths, provider, target file path, and export options\n    (optimization, quantization settings). Used to populate metadata fields.\nquantized : bool\n    Flag indicating whether the exported model is quantized. Determines\n    which quantization configuration (if any) is stored in metadata. True\n    if dynamic quantization was successfully applied, False otherwise.\n\nReturns\n-------\nSpladeExportSummary\n    Summary object containing:\n    - onnx_file: Path to the exported ONNX model file (relative or absolute)\n    - metadata_path: Path to the written metadata JSON file\n    The summary can be used to locate the exported artifacts and verify\n    export completion.",
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager._quantize_export",
      "short_name": "_quantize_export",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "encoder",
          "kind": "keyword_only",
          "annotated_type": "_SparseEncoderProtocol",
          "default": null,
          "doc": null
        },
        {
          "name": "ctx",
          "kind": "keyword_only",
          "annotated_type": "_ExportContext",
          "default": null,
          "doc": null
        },
        {
          "name": "base_onnx",
          "kind": "keyword_only",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "bool",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Apply dynamic quantization and ensure the target ONNX exists.",
      "doc_raw": "Apply dynamic quantization and ensure the target ONNX exists.\n\nThis function conditionally applies dynamic quantization to the ONNX model\nto reduce model size and potentially improve inference speed. If quantization\nis enabled, it uses the configured quantization settings to produce a\nquantized model. If quantization is disabled or fails, it ensures the target\npath exists by copying the base model if needed.\n\nDynamic quantization converts floating-point weights to lower precision\n(typically INT8) while maintaining model accuracy. This reduces model size\nand can improve inference speed on certain hardware, but may slightly\ndegrade accuracy.\n\nParameters\n----------\nencoder : _SparseEncoderProtocol\n    SPLADE encoder model to quantize. The encoder must support the quantization\n    interface provided by sentence-transformers export helpers.\nctx : _ExportContext\n    Export context containing quantization options, target path, model\n    directories, and provider information. The ctx.options.quantize flag\n    determines whether quantization is performed, and ctx.options.quantization_config\n    specifies quantization parameters.\nbase_onnx : Path\n    Path to the base ONNX model file (optimized or original). This is the\n    input for quantization. If quantization is disabled, this file is copied\n    to the target path.\n\nReturns\n-------\nbool\n    True if a quantized artifact was successfully produced and exists at\n    the target path. False if quantization was disabled, failed, or the\n    base model was copied instead. Used by callers to determine which model\n    file was actually created.",
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager._optimize_export",
      "short_name": "_optimize_export",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "encoder",
          "kind": "positional_or_keyword",
          "annotated_type": "_SparseEncoderProtocol",
          "default": null,
          "doc": null
        },
        {
          "name": "ctx",
          "kind": "positional_or_keyword",
          "annotated_type": "_ExportContext",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "Path",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Run graph optimization if requested and return the base ONNX path.",
      "doc_raw": "Run graph optimization if requested and return the base ONNX path.\n\nThis function conditionally applies ONNX graph optimizations to improve\ninference performance. If optimization is enabled in the export context,\nit runs the optimizer with O3 optimization level (aggressive optimizations)\nand returns the path to the optimized model. Otherwise, returns the path\nto the original unoptimized model.\n\nGraph optimization can significantly improve inference latency and reduce\nmodel size by applying transformations like constant folding, operator fusion,\nand dead code elimination. However, optimization may increase export time.\n\nParameters\n----------\nencoder : _SparseEncoderProtocol\n    SPLADE encoder model to optimize. The encoder must support the optimization\n    interface provided by sentence-transformers export helpers.\nctx : _ExportContext\n    Export context containing export options, directory paths, model\n    identifier, and provider information. The ctx.options.optimize flag\n    determines whether optimization is performed.\n\nReturns\n-------\nPath\n    Path to the ONNX model file to use as the base for further processing\n    (quantization, etc.). If optimization was performed and successful,\n    returns the optimized model path (model_O3.onnx). Otherwise, returns\n    the original model path (model.onnx).",
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager._encode_records",
      "short_name": "_encode_records",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "encoder",
          "kind": "keyword_only",
          "annotated_type": "_SparseEncoderProtocol",
          "default": null,
          "doc": null
        },
        {
          "name": "state",
          "kind": "keyword_only",
          "annotated_type": "_ShardState",
          "default": null,
          "doc": null
        },
        {
          "name": "batch",
          "kind": "keyword_only",
          "annotated_type": "list[tuple[str, str]]",
          "default": null,
          "doc": null
        },
        {
          "name": "batch_size",
          "kind": "keyword_only",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "source_path",
          "kind": "keyword_only",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Stream records from disk, validate them, and flush in batches.",
      "doc_raw": "Stream records from disk, validate them, and flush in batches.\n\nThis function orchestrates the encoding process by reading JSONL records from\na corpus file, validating that each record has required fields (id and\ncontents/text), accumulating records into batches, and flushing batches when\nthey reach the configured size. The final batch is flushed even if it's\nsmaller than the batch size.\n\nThe function handles streaming large corpora efficiently by processing records\none at a time and batching encoding operations. This minimizes memory usage\nwhile maintaining good throughput through batch encoding.\n\nParameters\n----------\nencoder : _SparseEncoderProtocol\n    SPLADE encoder instance used to encode document texts. The encoder\n    processes batches of texts and returns sparse vector representations.\nstate : _ShardState\n    Mutable encoding state tracking shard files, document counts, and encoding\n    parameters. Updated as batches are flushed and documents are written.\nbatch : list[tuple[str, str]]\n    Accumulator list for batching documents. Documents are added to this list\n    until it reaches batch_size, then the batch is flushed. The list is\n    cleared after each flush. Must be empty initially.\nbatch_size : int\n    Maximum number of documents to accumulate before flushing. Larger batches\n    improve encoding throughput but increase memory usage. Must be positive.\nsource_path : Path\n    Path to the JSONL corpus file to encode. The file is read line-by-line\n    and each line is parsed as JSON. The file must exist and be readable.\n\nRaises\n------\nTypeError\n    Raised when corpus entries violate type requirements:\n    - Document 'id' field is missing or not a string\n    - Document is missing both 'contents' and 'text' fields, or the content\n      field is not a string\n\nNotes\n-----\nException Propagation:\n    This function may propagate exceptions from underlying operations:\n    - FileNotFoundError: If the source_path does not exist (from file operations\n      in _iter_corpus)\n    - json.JSONDecodeError: If a line in the corpus file contains invalid JSON\n      (from json.loads() in _iter_corpus)",
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager._persist_encoding_metadata",
      "short_name": "_persist_encoding_metadata",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "state",
          "kind": "keyword_only",
          "annotated_type": "_ShardState",
          "default": null,
          "doc": null
        },
        {
          "name": "vectors_dir",
          "kind": "keyword_only",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        },
        {
          "name": "source_path",
          "kind": "keyword_only",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        },
        {
          "name": "batch_size",
          "kind": "keyword_only",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "provider",
          "kind": "keyword_only",
          "annotated_type": "str",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "SpladeEncodingSummary",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Write metadata for an encoding run and return the summary.",
      "doc_raw": "Write metadata for an encoding run and return the summary.\n\nThis function creates and persists metadata about a SPLADE encoding operation,\nincluding document counts, shard information, encoding parameters, and\nprovenance data. The metadata is written as JSON to a standard location\nwithin the vectors directory and can be used later to verify corpus integrity\nand understand encoding configuration.\n\nParameters\n----------\nstate : _ShardState\n    Encoding state object containing accumulated statistics: document count,\n    shard count, quantization parameter, and other encoding metadata. The\n    state reflects the final state after all documents have been encoded.\nvectors_dir : Path\n    Directory where encoded vector shards are stored. The metadata file will\n    be written to this directory with a standard filename.\nsource_path : Path\n    Path to the original JSONL corpus file that was encoded. Stored in\n    metadata for provenance tracking and corpus identification.\nbatch_size : int\n    Batch size used during encoding. This parameter affects encoding\n    throughput and memory usage. Stored in metadata for reproducibility.\nprovider : str\n    ONNX runtime provider used for encoding (e.g., \"cpu\", \"cuda\", \"tensorrt\").\n    Affects encoding performance and hardware requirements. Stored for\n    reproducibility and performance analysis.\n\nReturns\n-------\nSpladeEncodingSummary\n    Summary object containing:\n    - doc_count: Total number of documents encoded\n    - vectors_dir: Directory path where shards are stored\n    - metadata_path: Path to the written metadata JSON file\n    - shard_count: Number of shard files created",
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager._flush_batch",
      "short_name": "_flush_batch",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "encoder",
          "kind": "positional_or_keyword",
          "annotated_type": "_SparseEncoderProtocol",
          "default": null,
          "doc": null
        },
        {
          "name": "batch",
          "kind": "positional_or_keyword",
          "annotated_type": "list[tuple[str, str]]",
          "default": null,
          "doc": null
        },
        {
          "name": "state",
          "kind": "positional_or_keyword",
          "annotated_type": "_ShardState",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Encode and persist the current batch of documents.",
      "doc_raw": "Encode and persist the current batch of documents.\n\nThis function processes a batch of documents by encoding them using the\nSPLADE encoder, decoding the sparse vectors into token-weight pairs, quantizing\nthe weights, and writing the results to JSONL shard files. The batch is\ncleared after processing.\n\nThe function handles shard file management automatically, creating new shard\nfiles when needed based on the configured shard size. Documents are written\nin JSONL format with document ID, empty contents (for compatibility), and\nthe quantized sparse vector.\n\nParameters\n----------\nencoder : _SparseEncoderProtocol\n    SPLADE encoder instance used to encode document texts into sparse vectors.\n    The encoder must support encode_document() and decode() methods.\nbatch : list[tuple[str, str]]\n    List of (document_id, text) tuples to encode. Each tuple represents one\n    document from the corpus. The batch is cleared after processing.\nstate : _ShardState\n    Mutable state object tracking shard file handles, document counts, shard\n    indices, and encoding parameters. The state is updated as documents are\n    written and shard files are rotated.\n\nRaises\n------\nRuntimeError\n    If a shard file handle unexpectedly becomes None during writing. This\n    should not occur in normal operation and indicates a programming error\n    or resource management issue.",
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager._open_writer",
      "short_name": "_open_writer",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "vectors_dir",
          "kind": "positional_or_keyword",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        },
        {
          "name": "index",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "tuple[Path, TextIO]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Create a shard writer for the given shard index.",
      "doc_raw": "Create a shard writer for the given shard index.\n\nThis helper function creates a new JSONL shard file for writing encoded\nvectors. Shard files are named with zero-padded indices (e.g., part-00000.jsonl,\npart-00001.jsonl) to ensure proper ordering and easy identification. The file\nis opened in write mode with UTF-8 encoding.\n\nParameters\n----------\nvectors_dir : Path\n    Directory where shard files are stored. The directory should already\n    exist (created by the caller). Shard files are written directly to this\n    directory.\nindex : int\n    Zero-based shard index. Used to generate the shard filename with zero\n    padding (5 digits). Must be non-negative.\n\nReturns\n-------\ntuple[Path, TextIO]\n    Tuple containing:\n    - Path to the created shard file (e.g., vectors_dir/part-00000.jsonl)\n    - Open text file handle in write mode, UTF-8 encoded, ready for writing\n      JSONL records. The caller is responsible for closing the handle.",
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager._iter_corpus",
      "short_name": "_iter_corpus",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "path",
          "kind": "positional_or_keyword",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "Iterable[dict[str, object]]",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager._quantize_tokens",
      "short_name": "_quantize_tokens",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "pairs",
          "kind": "positional_or_keyword",
          "annotated_type": "Sequence[tuple[str, float]]",
          "default": null,
          "doc": null
        },
        {
          "name": "quantization",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "dict[str, int]",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager._percentile_value",
      "short_name": "_percentile_value",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "sorted_values",
          "kind": "positional_or_keyword",
          "annotated_type": "Sequence[float]",
          "default": null,
          "doc": null
        },
        {
          "name": "percentile",
          "kind": "positional_or_keyword",
          "annotated_type": "float",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "float",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Return the percentile value using linear interpolation.",
      "doc_raw": "Return the percentile value using linear interpolation.\n\nParameters\n----------\nsorted_values : Sequence[float]\n    Non-empty sorted sequence of latency values.\npercentile : float\n    Desired percentile in the inclusive range [0, 100].\n\nReturns\n-------\nfloat\n    Interpolated percentile value.\n\nRaises\n------\nValueError\n    If :paramref:`sorted_values` is empty.",
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager._serialize_relative",
      "short_name": "_serialize_relative",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "path",
          "kind": "positional_or_keyword",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        },
        {
          "name": "base",
          "kind": "positional_or_keyword",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "str",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager._detect_pyserini_version",
      "short_name": "_detect_pyserini_version",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": {
        "annotated_type": "str",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager._directory_size",
      "short_name": "_directory_size",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "path",
          "kind": "positional_or_keyword",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "int",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Compute total size in bytes for all files beneath a directory.",
      "doc_raw": "Compute total size in bytes for all files beneath a directory.\n\nThis utility function recursively traverses a directory tree and sums the\nsizes of all regular files found. It's used to calculate index sizes for\nmetadata purposes. Symbolic links are followed, but directories themselves\ndon't contribute to the size.\n\nParameters\n----------\npath : Path\n    Root directory path to measure. The function recursively traverses all\n    subdirectories and sums file sizes. The path must exist and be a directory.\n\nReturns\n-------\nint\n    Total size in bytes for all regular files contained within the directory\n    tree. Returns 0 if the directory is empty or contains no files. The\n    size is calculated using file system stat information (st_size).",
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager._write_struct",
      "short_name": "_write_struct",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "target",
          "kind": "positional_or_keyword",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        },
        {
          "name": "payload",
          "kind": "positional_or_keyword",
          "annotated_type": "msgspec.Struct",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager._require_export_helpers",
      "short_name": "_require_export_helpers",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": {
        "annotated_type": "tuple[_OptimizerFunction, _QuantizerFunction]",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager._require_sparse_encoder",
      "short_name": "_require_sparse_encoder",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": {
        "annotated_type": "type",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager._ExportContext",
      "short_name": "_ExportContext",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "dataclass(frozen=True)"
      ],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "model_id",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "model_dir",
          "kind": "positional_or_keyword",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        },
        {
          "name": "onnx_dir",
          "kind": "positional_or_keyword",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        },
        {
          "name": "provider",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "target_path",
          "kind": "positional_or_keyword",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        },
        {
          "name": "options",
          "kind": "positional_or_keyword",
          "annotated_type": "SpladeExportOptions",
          "default": null,
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Context for SPLADE export operations.",
      "doc_raw": "Context for SPLADE export operations.",
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager._ExportContext.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "model_id",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "model_dir",
          "kind": "positional_or_keyword",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        },
        {
          "name": "onnx_dir",
          "kind": "positional_or_keyword",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        },
        {
          "name": "provider",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "target_path",
          "kind": "positional_or_keyword",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        },
        {
          "name": "options",
          "kind": "positional_or_keyword",
          "annotated_type": "SpladeExportOptions",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager._ExportContext.options",
      "short_name": "options",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager._ExportContext.target_path",
      "short_name": "target_path",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager._ExportContext.provider",
      "short_name": "provider",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager._ExportContext.onnx_dir",
      "short_name": "onnx_dir",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager._ExportContext.model_dir",
      "short_name": "model_dir",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager._ExportContext.model_id",
      "short_name": "model_id",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager._SET_SHARD_STATE_ATTR",
      "short_name": "_SET_SHARD_STATE_ATTR",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager._ShardState",
      "short_name": "_ShardState",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "dataclass(frozen=True)"
      ],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "vectors_dir",
          "kind": "positional_or_keyword",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        },
        {
          "name": "quantization",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "shard_size",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "doc_count",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": "0",
          "doc": null
        },
        {
          "name": "shard_index",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": "0",
          "doc": null
        },
        {
          "name": "shard_handle",
          "kind": "positional_or_keyword",
          "annotated_type": "TextIO | None",
          "default": "None",
          "doc": null
        },
        {
          "name": "shard_count",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": "0",
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Mutable encoding state for shard rotation.",
      "doc_raw": "Mutable encoding state for shard rotation.",
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager._ShardState.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "vectors_dir",
          "kind": "positional_or_keyword",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        },
        {
          "name": "quantization",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "shard_size",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "doc_count",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": "0",
          "doc": null
        },
        {
          "name": "shard_index",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": "0",
          "doc": null
        },
        {
          "name": "shard_handle",
          "kind": "positional_or_keyword",
          "annotated_type": "TextIO | None",
          "default": "None",
          "doc": null
        },
        {
          "name": "shard_count",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": "0",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager._ShardState.shard_count",
      "short_name": "shard_count",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager._ShardState.shard_handle",
      "short_name": "shard_handle",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager._ShardState.shard_index",
      "short_name": "shard_index",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager._ShardState.doc_count",
      "short_name": "doc_count",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager._ShardState.shard_size",
      "short_name": "shard_size",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager._ShardState.quantization",
      "short_name": "quantization",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager._ShardState.vectors_dir",
      "short_name": "vectors_dir",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeIndexMetadata",
      "short_name": "SpladeIndexMetadata",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [
        "msgspec.Struct"
      ],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Metadata describing a SPLADE Lucene impact index.",
      "doc_raw": "Metadata describing a SPLADE Lucene impact index.",
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeIndexMetadata.generator",
      "short_name": "generator",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeIndexMetadata.index_size_bytes",
      "short_name": "index_size_bytes",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeIndexMetadata.index_dir",
      "short_name": "index_dir",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeIndexMetadata.threads",
      "short_name": "threads",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeIndexMetadata.pyserini_version",
      "short_name": "pyserini_version",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeIndexMetadata.corpus_digest",
      "short_name": "corpus_digest",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeIndexMetadata.vectors_dir",
      "short_name": "vectors_dir",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeIndexMetadata.built_at",
      "short_name": "built_at",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeIndexMetadata.doc_count",
      "short_name": "doc_count",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeBuildOptions",
      "short_name": "SpladeBuildOptions",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [
        "msgspec.Struct"
      ],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Options controlling SPLADE Lucene impact index builds.",
      "doc_raw": "Options controlling SPLADE Lucene impact index builds.",
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeBuildOptions.overwrite",
      "short_name": "overwrite",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeBuildOptions.max_clause_count",
      "short_name": "max_clause_count",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeBuildOptions.threads",
      "short_name": "threads",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeBuildOptions.index_dir",
      "short_name": "index_dir",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeBuildOptions.vectors_dir",
      "short_name": "vectors_dir",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeEncodeOptions",
      "short_name": "SpladeEncodeOptions",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [
        "msgspec.Struct"
      ],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Options controlling SPLADE corpus encoding.",
      "doc_raw": "Options controlling SPLADE corpus encoding.",
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeEncodeOptions.onnx_file",
      "short_name": "onnx_file",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeEncodeOptions.provider",
      "short_name": "provider",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeEncodeOptions.shard_size",
      "short_name": "shard_size",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeEncodeOptions.quantization",
      "short_name": "quantization",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeEncodeOptions.batch_size",
      "short_name": "batch_size",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeEncodeOptions.output_dir",
      "short_name": "output_dir",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeExportOptions",
      "short_name": "SpladeExportOptions",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [
        "msgspec.Struct"
      ],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Options controlling SPLADE ONNX export behaviour.",
      "doc_raw": "Options controlling SPLADE ONNX export behaviour.",
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeExportOptions.quantization_config",
      "short_name": "quantization_config",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeExportOptions.quantize",
      "short_name": "quantize",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeExportOptions.optimize",
      "short_name": "optimize",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeExportOptions.file_name",
      "short_name": "file_name",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeExportOptions.provider",
      "short_name": "provider",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeExportOptions.model_id",
      "short_name": "model_id",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeBenchmarkSummary",
      "short_name": "SpladeBenchmarkSummary",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [
        "msgspec.Struct"
      ],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Summary describing SPLADE encoder latency benchmarks.",
      "doc_raw": "Summary describing SPLADE encoder latency benchmarks.",
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeBenchmarkSummary.onnx_file",
      "short_name": "onnx_file",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeBenchmarkSummary.provider",
      "short_name": "provider",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeBenchmarkSummary.p99_latency_ms",
      "short_name": "p99_latency_ms",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeBenchmarkSummary.p95_latency_ms",
      "short_name": "p95_latency_ms",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeBenchmarkSummary.p50_latency_ms",
      "short_name": "p50_latency_ms",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeBenchmarkSummary.mean_latency_ms",
      "short_name": "mean_latency_ms",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeBenchmarkSummary.max_latency_ms",
      "short_name": "max_latency_ms",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeBenchmarkSummary.min_latency_ms",
      "short_name": "min_latency_ms",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeBenchmarkSummary.measure_iterations",
      "short_name": "measure_iterations",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeBenchmarkSummary.warmup_iterations",
      "short_name": "warmup_iterations",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeBenchmarkSummary.query_count",
      "short_name": "query_count",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeBenchmarkOptions",
      "short_name": "SpladeBenchmarkOptions",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [
        "msgspec.Struct"
      ],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Options controlling SPLADE encoder latency benchmarks.",
      "doc_raw": "Options controlling SPLADE encoder latency benchmarks.",
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeBenchmarkOptions.onnx_file",
      "short_name": "onnx_file",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeBenchmarkOptions.provider",
      "short_name": "provider",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeBenchmarkOptions.measure_iterations",
      "short_name": "measure_iterations",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeBenchmarkOptions.warmup_iterations",
      "short_name": "warmup_iterations",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeEncodingSummary",
      "short_name": "SpladeEncodingSummary",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [
        "msgspec.Struct"
      ],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Summary describing SPLADE encoding output.",
      "doc_raw": "Summary describing SPLADE encoding output.",
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeEncodingSummary.shard_count",
      "short_name": "shard_count",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeEncodingSummary.metadata_path",
      "short_name": "metadata_path",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeEncodingSummary.vectors_dir",
      "short_name": "vectors_dir",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeEncodingSummary.doc_count",
      "short_name": "doc_count",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeEncodingMetadata",
      "short_name": "SpladeEncodingMetadata",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [
        "msgspec.Struct"
      ],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Metadata describing SPLADE vector encoding runs.",
      "doc_raw": "Metadata describing SPLADE vector encoding runs.",
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeEncodingMetadata.generator",
      "short_name": "generator",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeEncodingMetadata.prepared_at",
      "short_name": "prepared_at",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeEncodingMetadata.source_path",
      "short_name": "source_path",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeEncodingMetadata.vectors_dir",
      "short_name": "vectors_dir",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeEncodingMetadata.provider",
      "short_name": "provider",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeEncodingMetadata.batch_size",
      "short_name": "batch_size",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeEncodingMetadata.quantization",
      "short_name": "quantization",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeEncodingMetadata.shard_count",
      "short_name": "shard_count",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeEncodingMetadata.doc_count",
      "short_name": "doc_count",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeExportSummary",
      "short_name": "SpladeExportSummary",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [
        "msgspec.Struct"
      ],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Summary returned after exporting SPLADE artifacts.",
      "doc_raw": "Summary returned after exporting SPLADE artifacts.",
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeExportSummary.metadata_path",
      "short_name": "metadata_path",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeExportSummary.onnx_file",
      "short_name": "onnx_file",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeArtifactMetadata",
      "short_name": "SpladeArtifactMetadata",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [
        "msgspec.Struct"
      ],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Metadata describing exported SPLADE ONNX artifacts.",
      "doc_raw": "Metadata describing exported SPLADE ONNX artifacts.",
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeArtifactMetadata.generator",
      "short_name": "generator",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeArtifactMetadata.exported_at",
      "short_name": "exported_at",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeArtifactMetadata.quantization_config",
      "short_name": "quantization_config",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeArtifactMetadata.quantized",
      "short_name": "quantized",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeArtifactMetadata.optimized",
      "short_name": "optimized",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeArtifactMetadata.provider",
      "short_name": "provider",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeArtifactMetadata.onnx_file",
      "short_name": "onnx_file",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeArtifactMetadata.onnx_dir",
      "short_name": "onnx_dir",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeArtifactMetadata.model_dir",
      "short_name": "model_dir",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.SpladeArtifactMetadata.model_id",
      "short_name": "model_id",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.logger",
      "short_name": "logger",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager._PERCENTILE_MAX",
      "short_name": "_PERCENTILE_MAX",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager._PERCENTILE_MIN",
      "short_name": "_PERCENTILE_MIN",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.INDEX_METADATA_FILENAME",
      "short_name": "INDEX_METADATA_FILENAME",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.ENCODING_METADATA_FILENAME",
      "short_name": "ENCODING_METADATA_FILENAME",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.ARTIFACT_METADATA_FILENAME",
      "short_name": "ARTIFACT_METADATA_FILENAME",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager.GENERATOR_NAME",
      "short_name": "GENERATOR_NAME",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager._QuantizerFunction",
      "short_name": "_QuantizerFunction",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [
        "Protocol"
      ],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager._QuantizerFunction.__call__",
      "short_name": "__call__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "model",
          "kind": "positional_or_keyword",
          "annotated_type": "_SparseEncoderProtocol",
          "default": null,
          "doc": null
        },
        {
          "name": "quantization_config",
          "kind": "keyword_only",
          "annotated_type": "str | None",
          "default": null,
          "doc": null
        },
        {
          "name": "model_name_or_path",
          "kind": "keyword_only",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "push_to_hub",
          "kind": "keyword_only",
          "annotated_type": "bool",
          "default": null,
          "doc": null
        },
        {
          "name": "create_pr",
          "kind": "keyword_only",
          "annotated_type": "bool",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager._OptimizerFunction",
      "short_name": "_OptimizerFunction",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [
        "Protocol"
      ],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager._OptimizerFunction.__call__",
      "short_name": "__call__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "model",
          "kind": "positional_or_keyword",
          "annotated_type": "_SparseEncoderProtocol",
          "default": null,
          "doc": null
        },
        {
          "name": "optimization_config",
          "kind": "keyword_only",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "model_name_or_path",
          "kind": "keyword_only",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "push_to_hub",
          "kind": "keyword_only",
          "annotated_type": "bool",
          "default": null,
          "doc": null
        },
        {
          "name": "create_pr",
          "kind": "keyword_only",
          "annotated_type": "bool",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager._SparseEncoderProtocol",
      "short_name": "_SparseEncoderProtocol",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [
        "Protocol"
      ],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager._SparseEncoderProtocol.decode",
      "short_name": "decode",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "embeddings",
          "kind": "positional_or_keyword",
          "annotated_type": "object",
          "default": null,
          "doc": null
        },
        {
          "name": "top_k",
          "kind": "positional_or_keyword",
          "annotated_type": "int | None",
          "default": "None",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "Sequence[Sequence[tuple[str, float]]]",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager._SparseEncoderProtocol.encode_query",
      "short_name": "encode_query",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "queries",
          "kind": "positional_or_keyword",
          "annotated_type": "Sequence[str]",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "Sequence[object]",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.splade_manager._SparseEncoderProtocol.encode_document",
      "short_name": "encode_document",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "sentences",
          "kind": "positional_or_keyword",
          "annotated_type": "Sequence[str]",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "Sequence[object]",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.symbol_catalog",
      "short_name": "symbol_catalog",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "DuckDB symbol catalog writer.",
      "doc_raw": "DuckDB symbol catalog writer.",
      "docstyle": "google"
    },
    {
      "full_name": "io.symbol_catalog.SymbolCatalog",
      "short_name": "SymbolCatalog",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "manager",
          "kind": "positional_or_keyword",
          "annotated_type": "DuckDBManager",
          "default": null,
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Writer for symbol metadata tables alongside `chunks`.",
      "doc_raw": "Writer for symbol metadata tables alongside `chunks`.",
      "docstyle": "google"
    },
    {
      "full_name": "io.symbol_catalog.SymbolCatalog.bulk_insert_chunk_symbols",
      "short_name": "bulk_insert_chunk_symbols",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "pairs",
          "kind": "positional_or_keyword",
          "annotated_type": "Iterable[tuple[int, str]]",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Associate chunks with the symbols they contain.",
      "doc_raw": "Associate chunks with the symbols they contain.",
      "docstyle": "google"
    },
    {
      "full_name": "io.symbol_catalog.SymbolCatalog.bulk_insert_occurrences",
      "short_name": "bulk_insert_occurrences",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "rows",
          "kind": "positional_or_keyword",
          "annotated_type": "Sequence[SymbolOccurrenceRow]",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Bulk load symbol occurrences.",
      "doc_raw": "Bulk load symbol occurrences.",
      "docstyle": "google"
    },
    {
      "full_name": "io.symbol_catalog.SymbolCatalog.upsert_symbol_defs",
      "short_name": "upsert_symbol_defs",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "rows",
          "kind": "positional_or_keyword",
          "annotated_type": "Sequence[SymbolDefRow]",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Insert or replace symbol definitions in bulk.",
      "doc_raw": "Insert or replace symbol definitions in bulk.",
      "docstyle": "google"
    },
    {
      "full_name": "io.symbol_catalog.SymbolCatalog.ensure_schema",
      "short_name": "ensure_schema",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Ensure symbol tables and indexes exist in DuckDB.",
      "doc_raw": "Ensure symbol tables and indexes exist in DuckDB.",
      "docstyle": "google"
    },
    {
      "full_name": "io.symbol_catalog.SymbolCatalog._manager",
      "short_name": "_manager",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.symbol_catalog.SymbolCatalog.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "manager",
          "kind": "positional_or_keyword",
          "annotated_type": "DuckDBManager",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.symbol_catalog.SymbolOccurrenceRow",
      "short_name": "SymbolOccurrenceRow",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "dataclass(frozen=True)"
      ],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "symbol",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "uri",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "start_line",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "start_col",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "end_line",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "end_col",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "roles",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "kind",
          "kind": "positional_or_keyword",
          "annotated_type": "str | None",
          "default": null,
          "doc": null
        },
        {
          "name": "language",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "chunk_id",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Service row for individual symbol occurrences.",
      "doc_raw": "Service row for individual symbol occurrences.",
      "docstyle": "google"
    },
    {
      "full_name": "io.symbol_catalog.SymbolOccurrenceRow.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "symbol",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "uri",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "start_line",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "start_col",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "end_line",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "end_col",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "roles",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "kind",
          "kind": "positional_or_keyword",
          "annotated_type": "str | None",
          "default": null,
          "doc": null
        },
        {
          "name": "language",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "chunk_id",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.symbol_catalog.SymbolOccurrenceRow.chunk_id",
      "short_name": "chunk_id",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.symbol_catalog.SymbolOccurrenceRow.language",
      "short_name": "language",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.symbol_catalog.SymbolOccurrenceRow.kind",
      "short_name": "kind",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.symbol_catalog.SymbolOccurrenceRow.roles",
      "short_name": "roles",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.symbol_catalog.SymbolOccurrenceRow.end_col",
      "short_name": "end_col",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.symbol_catalog.SymbolOccurrenceRow.end_line",
      "short_name": "end_line",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.symbol_catalog.SymbolOccurrenceRow.start_col",
      "short_name": "start_col",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.symbol_catalog.SymbolOccurrenceRow.start_line",
      "short_name": "start_line",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.symbol_catalog.SymbolOccurrenceRow.uri",
      "short_name": "uri",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.symbol_catalog.SymbolOccurrenceRow.symbol",
      "short_name": "symbol",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.symbol_catalog.SymbolDefRow",
      "short_name": "SymbolDefRow",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "dataclass(frozen=True)"
      ],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "symbol",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "display_name",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "kind",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "language",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "uri",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "start_line",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "start_col",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "end_line",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "end_col",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "chunk_id",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "docstring",
          "kind": "positional_or_keyword",
          "annotated_type": "str | None",
          "default": "None",
          "doc": null
        },
        {
          "name": "signature",
          "kind": "positional_or_keyword",
          "annotated_type": "str | None",
          "default": "None",
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Immutable row describing a symbol definition.",
      "doc_raw": "Immutable row describing a symbol definition.",
      "docstyle": "google"
    },
    {
      "full_name": "io.symbol_catalog.SymbolDefRow.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "symbol",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "display_name",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "kind",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "language",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "uri",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "start_line",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "start_col",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "end_line",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "end_col",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "chunk_id",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "docstring",
          "kind": "positional_or_keyword",
          "annotated_type": "str | None",
          "default": "None",
          "doc": null
        },
        {
          "name": "signature",
          "kind": "positional_or_keyword",
          "annotated_type": "str | None",
          "default": "None",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.symbol_catalog.SymbolDefRow.signature",
      "short_name": "signature",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.symbol_catalog.SymbolDefRow.docstring",
      "short_name": "docstring",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.symbol_catalog.SymbolDefRow.chunk_id",
      "short_name": "chunk_id",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.symbol_catalog.SymbolDefRow.end_col",
      "short_name": "end_col",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.symbol_catalog.SymbolDefRow.end_line",
      "short_name": "end_line",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.symbol_catalog.SymbolDefRow.start_col",
      "short_name": "start_col",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.symbol_catalog.SymbolDefRow.start_line",
      "short_name": "start_line",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.symbol_catalog.SymbolDefRow.uri",
      "short_name": "uri",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.symbol_catalog.SymbolDefRow.language",
      "short_name": "language",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.symbol_catalog.SymbolDefRow.kind",
      "short_name": "kind",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.symbol_catalog.SymbolDefRow.display_name",
      "short_name": "display_name",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.symbol_catalog.SymbolDefRow.symbol",
      "short_name": "symbol",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.vllm_engine",
      "short_name": "vllm_engine",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "In-process vLLM embedding engine for Stage-0 retrieval.",
      "doc_raw": "In-process vLLM embedding engine for Stage-0 retrieval.",
      "docstyle": "google"
    },
    {
      "full_name": "io.vllm_engine.__all__",
      "short_name": "__all__",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.vllm_engine.InprocessVLLMEmbedder",
      "short_name": "InprocessVLLMEmbedder",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "dataclass(slots=True, frozen=True)"
      ],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "config",
          "kind": "positional_or_keyword",
          "annotated_type": "VLLMConfig",
          "default": null,
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Embed text batches locally using vLLM.",
      "doc_raw": "Embed text batches locally using vLLM.\n\nExtended Summary\n----------------\nThis embedder provides in-process embedding generation using vLLM, enabling\nhigh-throughput batch embedding without HTTP overhead. It initializes a local\nvLLM engine with the specified model and pooling configuration, tokenizes input\ntexts, and generates embeddings via vLLM's embedding API. The embedder is used\nin Stage-0 retrieval pipelines when vLLM is available and in-process mode is\npreferred over HTTP-based embedding services.\n\nAttributes\n----------\nconfig : VLLMConfig\n    Fully populated vLLM configuration. The ``run.mode`` field must be\n    ``\"inprocess\"`` to avoid HTTP calls. Contains model path, pooling type,\n    normalization settings, and GPU memory configuration.\n\nExamples\n--------\n>>> from codeintel_rev.config.settings import VLLMConfig, VLLMRunMode\n>>> cfg = VLLMConfig(run=VLLMRunMode(mode=\"inprocess\"))\n>>> embedder = InprocessVLLMEmbedder(cfg)\n>>> vecs = embedder.embed_batch([\"hello world\"])\n>>> vecs.shape[0]\n1",
      "docstyle": "google"
    },
    {
      "full_name": "io.vllm_engine.InprocessVLLMEmbedder.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "config",
          "kind": "positional_or_keyword",
          "annotated_type": "VLLMConfig",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.vllm_engine.InprocessVLLMEmbedder._runtime",
      "short_name": "_runtime",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "_InprocessVLLMRuntime",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.vllm_engine.InprocessVLLMEmbedder._initialize_runtime",
      "short_name": "_initialize_runtime",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "_InprocessVLLMRuntime",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.vllm_engine.InprocessVLLMEmbedder._load_engine",
      "short_name": "_load_engine",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "LLM",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.vllm_engine.InprocessVLLMEmbedder._load_tokenizer",
      "short_name": "_load_tokenizer",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "PreTrainedTokenizerBase",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.vllm_engine.InprocessVLLMEmbedder.close",
      "short_name": "close",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Release tokenizer/engine references to help GC.",
      "doc_raw": "Release tokenizer/engine references to help GC.",
      "docstyle": "google"
    },
    {
      "full_name": "io.vllm_engine.InprocessVLLMEmbedder.embed_batch",
      "short_name": "embed_batch",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "texts",
          "kind": "positional_or_keyword",
          "annotated_type": "Sequence[str]",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "NDArrayF32",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Return embeddings for ``texts`` (shape ``[N, dim]``).",
      "doc_raw": "Return embeddings for ``texts`` (shape ``[N, dim]``).\n\nParameters\n----------\ntexts : Sequence[str]\n    Ordered text payload to embed.\n\nReturns\n-------\nNDArrayF32\n    Embedding matrix aligned with the input order.\n\nRaises\n------\nRuntimeError\n    If the vLLM runtime failed to initialize.",
      "docstyle": "google"
    },
    {
      "full_name": "io.vllm_engine.InprocessVLLMEmbedder.__post_init__",
      "short_name": "__post_init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Initialize tokenizer and vLLM engine.",
      "doc_raw": "Initialize tokenizer and vLLM engine.",
      "docstyle": "google"
    },
    {
      "full_name": "io.vllm_engine.InprocessVLLMEmbedder._cell",
      "short_name": "_cell",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.vllm_engine.InprocessVLLMEmbedder.config",
      "short_name": "config",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.vllm_engine._InprocessVLLMRuntime",
      "short_name": "_InprocessVLLMRuntime",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Mutable runtime backing the frozen embedder.",
      "doc_raw": "Mutable runtime backing the frozen embedder.",
      "docstyle": "google"
    },
    {
      "full_name": "io.vllm_engine._InprocessVLLMRuntime.close",
      "short_name": "close",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Release tokenizer/engine references.",
      "doc_raw": "Release tokenizer/engine references.",
      "docstyle": "google"
    },
    {
      "full_name": "io.vllm_engine._InprocessVLLMRuntime.engine",
      "short_name": "engine",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.vllm_engine._InprocessVLLMRuntime.tokenizer",
      "short_name": "tokenizer",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.vllm_engine._InprocessVLLMRuntime.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.vllm_engine._InprocessVLLMRuntime.__slots__",
      "short_name": "__slots__",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.vllm_engine.LOGGER",
      "short_name": "LOGGER",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.coderank_embedder",
      "short_name": "coderank_embedder",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Pooled wrapper around the CodeRank embedding SentenceTransformer.",
      "doc_raw": "Pooled wrapper around the CodeRank embedding SentenceTransformer.",
      "docstyle": "google"
    },
    {
      "full_name": "io.coderank_embedder.CodeRankEmbedder",
      "short_name": "CodeRankEmbedder",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "settings",
          "kind": "keyword_only",
          "annotated_type": "SupportsCodeRankSettings",
          "default": null,
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Encode queries or code snippets with the CodeRank bi-encoder.",
      "doc_raw": "Encode queries or code snippets with the CodeRank bi-encoder.\n\nThis wrapper enforces the instruction prefix required by the CodeRankEmbed\nmodel card and caches the loaded ``SentenceTransformer`` per ``(model_id,\ndevice)`` tuple to avoid repeated initialization overhead.",
      "docstyle": "google"
    },
    {
      "full_name": "io.coderank_embedder.CodeRankEmbedder._ensure_model",
      "short_name": "_ensure_model",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "SentenceTransformer",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Load the underlying SentenceTransformer lazily.",
      "doc_raw": "Load the underlying SentenceTransformer lazily.\n\nReturns\n-------\nSentenceTransformer\n    Cached or newly loaded SentenceTransformer model instance.\n\nRaises\n------\nRuntimeError\n    If model loading fails or the model cannot be initialized.",
      "docstyle": "google"
    },
    {
      "full_name": "io.coderank_embedder.CodeRankEmbedder.encode_codes",
      "short_name": "encode_codes",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "snippets",
          "kind": "positional_or_keyword",
          "annotated_type": "Iterable[str]",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "NDArrayF32",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Return embeddings for code snippets (used during indexing).",
      "doc_raw": "Return embeddings for code snippets (used during indexing).\n\nParameters\n----------\nsnippets : Iterable[str]\n    Iterable of code snippet strings to embed. Used during indexing\n    to create document embeddings.\n\nReturns\n-------\nNDArrayF32\n    Array of code embeddings with shape (num_snippets, embedding_dim).\n\nRaises\n------\nValueError\n    If snippets is empty or contains no valid code snippets.",
      "docstyle": "google"
    },
    {
      "full_name": "io.coderank_embedder.CodeRankEmbedder.encode_queries",
      "short_name": "encode_queries",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "queries",
          "kind": "positional_or_keyword",
          "annotated_type": "Iterable[str]",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "NDArrayF32",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Return CodeRank embeddings for queries with prefix applied.",
      "doc_raw": "Return CodeRank embeddings for queries with prefix applied.\n\nParameters\n----------\nqueries : Iterable[str]\n    Iterable of query strings. Each query will have the configured\n    query_prefix prepended before encoding.\n\nReturns\n-------\nNDArrayF32\n    Array of query embeddings with shape (num_queries, embedding_dim).\n\nRaises\n------\nValueError\n    If queries is empty or contains no valid query strings.",
      "docstyle": "google"
    },
    {
      "full_name": "io.coderank_embedder.CodeRankEmbedder.batch_size",
      "short_name": "batch_size",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.coderank_embedder.CodeRankEmbedder.normalize",
      "short_name": "normalize",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.coderank_embedder.CodeRankEmbedder.query_prefix",
      "short_name": "query_prefix",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.coderank_embedder.CodeRankEmbedder.trust_remote_code",
      "short_name": "trust_remote_code",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.coderank_embedder.CodeRankEmbedder.device",
      "short_name": "device",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.coderank_embedder.CodeRankEmbedder.model_id",
      "short_name": "model_id",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.coderank_embedder.CodeRankEmbedder.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "settings",
          "kind": "keyword_only",
          "annotated_type": "SupportsCodeRankSettings",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.coderank_embedder.CodeRankEmbedder._CACHE_LOCK",
      "short_name": "_CACHE_LOCK",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.coderank_embedder.CodeRankEmbedder._MODEL_CACHE",
      "short_name": "_MODEL_CACHE",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.coderank_embedder.LOGGER",
      "short_name": "LOGGER",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.coderank_embedder.SupportsCodeRankSettings",
      "short_name": "SupportsCodeRankSettings",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [
        "Protocol"
      ],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Protocol describing the minimal settings required by the embedder.",
      "doc_raw": "Protocol describing the minimal settings required by the embedder.",
      "docstyle": "google"
    },
    {
      "full_name": "io.coderank_embedder.SupportsCodeRankSettings.batch_size",
      "short_name": "batch_size",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Batch size used when encoding queries.",
      "doc_raw": "Batch size used when encoding queries.",
      "docstyle": "google"
    },
    {
      "full_name": "io.coderank_embedder.SupportsCodeRankSettings.normalize",
      "short_name": "normalize",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Whether embeddings should be normalized.",
      "doc_raw": "Whether embeddings should be normalized.",
      "docstyle": "google"
    },
    {
      "full_name": "io.coderank_embedder.SupportsCodeRankSettings.query_prefix",
      "short_name": "query_prefix",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Instruction prefix required by the model.",
      "doc_raw": "Instruction prefix required by the model.",
      "docstyle": "google"
    },
    {
      "full_name": "io.coderank_embedder.SupportsCodeRankSettings.trust_remote_code",
      "short_name": "trust_remote_code",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Whether to trust remote code when loading the model.",
      "doc_raw": "Whether to trust remote code when loading the model.",
      "docstyle": "google"
    },
    {
      "full_name": "io.coderank_embedder.SupportsCodeRankSettings.device",
      "short_name": "device",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Target device for inference.",
      "doc_raw": "Target device for inference.",
      "docstyle": "google"
    },
    {
      "full_name": "io.coderank_embedder.SupportsCodeRankSettings.model_id",
      "short_name": "model_id",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "CodeRank model identifier.",
      "doc_raw": "CodeRank model identifier.",
      "docstyle": "google"
    },
    {
      "full_name": "io.path_utils",
      "short_name": "path_utils",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Path safety utilities for repository-scoped operations.",
      "doc_raw": "Path safety utilities for repository-scoped operations.",
      "docstyle": "google"
    },
    {
      "full_name": "io.path_utils.resolve_within_repo",
      "short_name": "resolve_within_repo",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "repo_root",
          "kind": "positional_or_keyword",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        },
        {
          "name": "target",
          "kind": "positional_or_keyword",
          "annotated_type": "str | Path",
          "default": null,
          "doc": null
        },
        {
          "name": "allow_nonexistent",
          "kind": "keyword_only",
          "annotated_type": "bool",
          "default": "True",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "Path",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Resolve ``target`` against ``repo_root`` and ensure it stays within bounds.",
      "doc_raw": "Resolve ``target`` against ``repo_root`` and ensure it stays within bounds.\n\nParameters\n----------\nrepo_root : Path\n    Repository root directory.\ntarget : str | Path\n    Requested path (relative or absolute).\nallow_nonexistent : bool, optional\n    When ``False`` the resolved path must already exist on disk.\n\nReturns\n-------\nPath\n    Absolute path inside ``repo_root``.\n\nRaises\n------\nPathOutsideRepositoryError\n    If the resolved path is outside the repository.\nFileNotFoundError\n    When ``allow_nonexistent`` is ``False`` and the path does not exist.",
      "docstyle": "google"
    },
    {
      "full_name": "io.path_utils.PathOutsideRepositoryError",
      "short_name": "PathOutsideRepositoryError",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [
        "ValueError"
      ],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Raised when a path escapes the configured repository root.",
      "doc_raw": "Raised when a path escapes the configured repository root.",
      "docstyle": "google"
    },
    {
      "full_name": "io.rrf",
      "short_name": "rrf",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Reciprocal Rank Fusion utilities (legacy compatibility wrappers).",
      "doc_raw": "Reciprocal Rank Fusion utilities (legacy compatibility wrappers).",
      "docstyle": "google"
    },
    {
      "full_name": "io.rrf.__all__",
      "short_name": "__all__",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.rrf._to_int",
      "short_name": "_to_int",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "value",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "int",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.rrf._normalize_channel_hits",
      "short_name": "_normalize_channel_hits",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "hits",
          "kind": "positional_or_keyword",
          "annotated_type": "Sequence[tuple[int, float]]",
          "default": null,
          "doc": null
        },
        {
          "name": "mode",
          "kind": "positional_or_keyword",
          "annotated_type": "Literal['none', 'minmax', 'z']",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "list[tuple[int, float]]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Normalize channel hit scores using the specified mode.",
      "doc_raw": "Normalize channel hit scores using the specified mode.\n\nParameters\n----------\nhits : Sequence[tuple[int, float]]\n    Original hits as (doc_id, score) tuples.\nmode : Literal[\"none\", \"minmax\", \"z\"]\n    Normalization mode: \"none\" returns hits unchanged, \"minmax\" scales to [0, 1],\n    \"z\" applies z-score normalization.\n\nReturns\n-------\nlist[tuple[int, float]]\n    Normalized hits with same doc_ids but transformed scores.",
      "docstyle": "google"
    },
    {
      "full_name": "io.rrf.weighted_rrf",
      "short_name": "weighted_rrf",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "channels",
          "kind": "positional_or_keyword",
          "annotated_type": "Mapping[str, Sequence[tuple[int, float]]]",
          "default": null,
          "doc": null
        },
        {
          "name": "weights",
          "kind": "keyword_only",
          "annotated_type": "Mapping[str, float]",
          "default": null,
          "doc": null
        },
        {
          "name": "k",
          "kind": "keyword_only",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "top_k",
          "kind": "keyword_only",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "normalize",
          "kind": "keyword_only",
          "annotated_type": "Literal['none', 'minmax', 'z']",
          "default": "'none'",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "tuple[list[int], dict[int, list[tuple[str, int, float]]], dict[int, float]]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Apply weighted Reciprocal Rank Fusion to channel hits.",
      "doc_raw": "Apply weighted Reciprocal Rank Fusion to channel hits.\n\nExtended Summary\n----------------\nThis function performs weighted Reciprocal Rank Fusion (RRF) across multiple\nretrieval channels, combining ranked lists from different search methods (e.g.,\nCodeRank, WARP, BM25) into a single unified ranking. It serves as a legacy\ncompatibility wrapper that converts integer-based channel hits into the internal\nChannelHit format, optionally normalizes scores per-channel (minmax or z-score),\ndelegates to the core fusion engine, and converts results back to integer document\nIDs. The function is used by the hybrid search pipeline to merge semantic and\nsparse retrieval signals with configurable per-channel weights and normalization.\n\nParameters\n----------\nchannels : Mapping[str, Sequence[tuple[int, float]]]\n    Per-channel ranked lists mapping channel names to sequences of (doc_id, score)\n    tuples. Each channel represents a distinct retrieval method (e.g., \"coderank\",\n    \"warp\", \"bm25\"). Document IDs must be convertible to integers.\nweights : Mapping[str, float]\n    Per-channel fusion weights. Channels not present in this mapping default to\n    weight 1.0. Zero-weighted channels are excluded from fusion. Weights control\n    the relative influence of each channel in the final ranking.\nk : int\n    RRF damping constant. Controls how quickly reciprocal rank contributions decay\n    with position. Higher values reduce the impact of lower-ranked items. Typical\n    values range from 20 to 100.\ntop_k : int\n    Maximum number of documents to return in the fused ranking. Must be positive.\n    The function returns the top_k highest-scoring documents after fusion.\nnormalize : Literal[\"none\", \"minmax\", \"z\"], optional\n    Optional per-channel score normalization applied before fusion. Use \"minmax\"\n    to scale raw scores to [0, 1] or \"z\" for z-score normalization. Defaults to\n    \"none\", preserving incoming scores.\n\nReturns\n-------\ntuple[list[int], dict[int, list[tuple[str, int, float]]], dict[int, float]]\n    A 3-tuple containing:\n    - Ranked list of document IDs (integers) sorted by fused RRF score (descending).\n    - Per-document contribution map: doc_id -> list of (channel, rank, score) tuples\n      showing which channels contributed to each document's final score.\n    - Per-document fused score map: doc_id -> final fused RRF score.\n\nRaises\n------\nValueError\n    If a document ID cannot be converted to an integer, or if top_k is not positive.\n\nNotes\n-----\nTime complexity O(n * m) where n is total hits across channels and m is the number\nof channels. Space complexity O(n) for the fused score map and contributions.\nThe function performs no I/O and has no side effects. Thread-safe if input mappings\nare immutable or accessed read-only.\n\nExamples\n--------\n>>> channels = {\"coderank\": [(1, 0.9), (2, 0.8)], \"warp\": [(2, 0.85), (1, 0.75)]}\n>>> weights = {\"coderank\": 1.0, \"warp\": 0.5}\n>>> doc_ids, contribs, scores = weighted_rrf(channels, weights=weights, k=60, top_k=2)\n>>> len(doc_ids) <= 2\nTrue\n>>> 1 in doc_ids and 2 in doc_ids\nTrue",
      "docstyle": "google"
    },
    {
      "full_name": "io.__dir__",
      "short_name": "__dir__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": {
        "annotated_type": "list[str]",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.__getattr__",
      "short_name": "__getattr__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "name",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "object",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Resolve exports lazily to avoid importing heavy adapter modules at import time.",
      "doc_raw": "Resolve exports lazily to avoid importing heavy adapter modules at import time.\n\nParameters\n----------\nname : str\n    Export requested by the caller.\n\nReturns\n-------\nobject\n    Attribute resolved from the target adapter module.\n\nRaises\n------\nAttributeError\n    If the requested export is unknown.",
      "docstyle": "google"
    },
    {
      "full_name": "io._EXPORTS",
      "short_name": "_EXPORTS",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "io.__all__",
      "short_name": "__all__",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server",
      "short_name": "mcp_server",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "MCP server implementation and tool adapters for CodeIntel.",
      "doc_raw": "MCP server implementation and tool adapters for CodeIntel.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters",
      "short_name": "adapters",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "MCP tool adapters.",
      "doc_raw": "MCP tool adapters.\n\nAdapters implement the actual logic for MCP tools, separating\nconcerns between the MCP interface and business logic.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.history",
      "short_name": "history",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Git history adapter for blame and log operations.",
      "doc_raw": "Git history adapter for blame and log operations.\n\nProvides git blame and commit history using GitPython via GitClient.\nThis replaces subprocess-based Git operations with typed Python APIs for\nbetter performance (50-80ms latency reduction) and reliability.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.history.__all__",
      "short_name": "__all__",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.history.file_history",
      "short_name": "file_history",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "context",
          "kind": "positional_or_keyword",
          "annotated_type": "ApplicationContext",
          "default": null,
          "doc": null
        },
        {
          "name": "path",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "limit",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": "50",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "dict",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Get commit history for file using GitPython (async).",
      "doc_raw": "Get commit history for file using GitPython (async).\n\nUses AsyncGitClient for typed Git operations, providing structured commit data\nwithout subprocess overhead or text parsing. This is faster and more\nreliable than parsing git log output. The async implementation enables\nconcurrent Git operations without blocking the event loop.\n\nParameters\n----------\ncontext : ApplicationContext\n    Application context containing GitClient and repo root.\npath : str\n    File path relative to repo root.\nlimit : int, optional\n    Maximum number of commits to return (default: 50).\n\nReturns\n-------\ndict\n    Dictionary with \"commits\" key containing list of commit dicts with\n    fields: sha, full_sha, author, email, date, message.\n\nRaises\n------\nGitOperationError\n    If Git log operation fails. This function calls ``resolve_within_repo``\n    which may raise ``PathOutsideRepositoryError``. If the requested path\n    does not exist, ``PathNotFoundError`` is raised.\nPathNotFoundError\n    If the requested file path does not exist within the repository.\n\nExamples\n--------\n>>> result = file_history(context, \"README.md\", limit=10)\n>>> isinstance(result[\"commits\"], list)\nTrue\n>>> commit = result[\"commits\"][0]\n>>> \"sha\" in commit and \"author\" in commit\nTrue\n\nNotes\n-----\nAsync Pattern:\n- Uses AsyncGitClient which wraps GitClient operations in asyncio.to_thread.\n- This prevents blocking the event loop and enables concurrent Git operations.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.history.blame_range",
      "short_name": "blame_range",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "context",
          "kind": "positional_or_keyword",
          "annotated_type": "ApplicationContext",
          "default": null,
          "doc": null
        },
        {
          "name": "path",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "start_line",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "end_line",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "dict",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Get git blame for line range using GitPython (async).",
      "doc_raw": "Get git blame for line range using GitPython (async).\n\nUses AsyncGitClient for typed Git operations, providing structured data returns\nwithout subprocess overhead. This is faster and more reliable than parsing\ngit blame porcelain output. The async implementation enables concurrent Git\noperations without blocking the event loop.\n\nParameters\n----------\ncontext : ApplicationContext\n    Application context containing GitClient and repo root.\npath : str\n    File path relative to repo root.\nstart_line : int\n    Start line (1-indexed, inclusive).\nend_line : int\n    End line (1-indexed, inclusive).\n\nReturns\n-------\ndict\n    Dictionary with \"blame\" key containing list of GitBlameEntry dicts.\n\nRaises\n------\nGitOperationError\n    If Git blame operation fails. This function calls ``resolve_within_repo``\n    which may raise ``PathOutsideRepositoryError``. If the requested path\n    does not exist, ``PathNotFoundError`` is raised.\nPathNotFoundError\n    If the requested file path does not exist within the repository.\n\nExamples\n--------\n>>> result = blame_range(context, \"README.md\", 1, 10)\n>>> isinstance(result[\"blame\"], list)\nTrue\n>>> entry = result[\"blame\"][0]\n>>> \"line\" in entry and \"author\" in entry\nTrue\n\nNotes\n-----\nAsync Pattern:\n- Uses AsyncGitClient which wraps GitClient operations in asyncio.to_thread.\n- This prevents blocking the event loop and enables concurrent Git operations.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.history.LOGGER",
      "short_name": "LOGGER",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.text_search",
      "short_name": "text_search",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Text search adapter using ripgrep.",
      "doc_raw": "Text search adapter using ripgrep.\n\nFast text search with regex support.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.text_search.__all__",
      "short_name": "__all__",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.text_search._parse_ripgrep_output",
      "short_name": "_parse_ripgrep_output",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "stdout",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "repo_root",
          "kind": "positional_or_keyword",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        },
        {
          "name": "max_results",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "tuple[list[Match], bool]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Parse ripgrep JSON output into structured matches.",
      "doc_raw": "Parse ripgrep JSON output into structured matches.\n\nParameters\n----------\nstdout : str\n    Ripgrep JSON output.\nrepo_root : Path\n    Repository root directory.\nmax_results : int\n    Maximum number of results to parse.\n\nReturns\n-------\ntuple[list[Match], bool]\n    Parsed match list and whether results were truncated at max_results.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.text_search._build_ripgrep_command",
      "short_name": "_build_ripgrep_command",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "params",
          "kind": "positional_or_keyword",
          "annotated_type": "RipgrepCommandParams",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "list[str]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Assemble the ripgrep command arguments.",
      "doc_raw": "Assemble the ripgrep command arguments.\n\nParameters\n----------\nparams : RipgrepCommandParams\n    Parameter bundle describing ripgrep invocation.\n\nReturns\n-------\nlist[str]\n    Argument vector for ripgrep invocation.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.text_search.RipgrepCommandParams",
      "short_name": "RipgrepCommandParams",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "dataclass(slots=True, frozen=True)"
      ],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "query",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "regex",
          "kind": "positional_or_keyword",
          "annotated_type": "bool",
          "default": null,
          "doc": null
        },
        {
          "name": "case_sensitive",
          "kind": "positional_or_keyword",
          "annotated_type": "bool",
          "default": null,
          "doc": null
        },
        {
          "name": "include_globs",
          "kind": "positional_or_keyword",
          "annotated_type": "Sequence[str] | None",
          "default": null,
          "doc": null
        },
        {
          "name": "exclude_globs",
          "kind": "positional_or_keyword",
          "annotated_type": "Sequence[str] | None",
          "default": null,
          "doc": null
        },
        {
          "name": "paths",
          "kind": "positional_or_keyword",
          "annotated_type": "Sequence[str] | None",
          "default": null,
          "doc": null
        },
        {
          "name": "max_results",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Parameter bundle for constructing ripgrep commands.",
      "doc_raw": "Parameter bundle for constructing ripgrep commands.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.text_search.RipgrepCommandParams.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "query",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "regex",
          "kind": "positional_or_keyword",
          "annotated_type": "bool",
          "default": null,
          "doc": null
        },
        {
          "name": "case_sensitive",
          "kind": "positional_or_keyword",
          "annotated_type": "bool",
          "default": null,
          "doc": null
        },
        {
          "name": "include_globs",
          "kind": "positional_or_keyword",
          "annotated_type": "Sequence[str] | None",
          "default": null,
          "doc": null
        },
        {
          "name": "exclude_globs",
          "kind": "positional_or_keyword",
          "annotated_type": "Sequence[str] | None",
          "default": null,
          "doc": null
        },
        {
          "name": "paths",
          "kind": "positional_or_keyword",
          "annotated_type": "Sequence[str] | None",
          "default": null,
          "doc": null
        },
        {
          "name": "max_results",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.text_search.RipgrepCommandParams.max_results",
      "short_name": "max_results",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.text_search.RipgrepCommandParams.paths",
      "short_name": "paths",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.text_search.RipgrepCommandParams.exclude_globs",
      "short_name": "exclude_globs",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.text_search.RipgrepCommandParams.include_globs",
      "short_name": "include_globs",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.text_search.RipgrepCommandParams.case_sensitive",
      "short_name": "case_sensitive",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.text_search.RipgrepCommandParams.regex",
      "short_name": "regex",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.text_search.RipgrepCommandParams.query",
      "short_name": "query",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.text_search._fallback_grep",
      "short_name": "_fallback_grep",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "observation",
          "kind": "keyword_only",
          "annotated_type": "Observation",
          "default": null,
          "doc": null
        },
        {
          "name": "repo_root",
          "kind": "keyword_only",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        },
        {
          "name": "query",
          "kind": "keyword_only",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "case_sensitive",
          "kind": "keyword_only",
          "annotated_type": "bool",
          "default": null,
          "doc": null
        },
        {
          "name": "max_results",
          "kind": "keyword_only",
          "annotated_type": "int",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "dict",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Fallback to basic grep if ripgrep unavailable.",
      "doc_raw": "Fallback to basic grep if ripgrep unavailable.\n\nParameters\n----------\nobservation : Observation\n    Metrics observation context used to record success or failure.\nrepo_root : Path\n    Repository root directory.\nquery : str\n    Search query.\ncase_sensitive : bool\n    Case-sensitive search.\nmax_results : int\n    Maximum results.\n\nReturns\n-------\ndict\n    Search results.\n\nRaises\n------\nVectorSearchError\n    If fallback grep operation fails (timeout, subprocess error, etc.).",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.text_search._search_text_sync",
      "short_name": "_search_text_sync",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "context",
          "kind": "positional_or_keyword",
          "annotated_type": "ApplicationContext",
          "default": null,
          "doc": null
        },
        {
          "name": "session_id",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "scope",
          "kind": "positional_or_keyword",
          "annotated_type": "ScopeIn | None",
          "default": null,
          "doc": null
        },
        {
          "name": "options",
          "kind": "positional_or_keyword",
          "annotated_type": "TextSearchOptions",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "dict",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.text_search.search_text",
      "short_name": "search_text",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "context",
          "kind": "positional_or_keyword",
          "annotated_type": "ApplicationContext",
          "default": null,
          "doc": null
        },
        {
          "name": "query",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "options",
          "kind": "keyword_only",
          "annotated_type": "TextSearchOptions | None",
          "default": "None",
          "doc": null
        },
        {
          "name": "overrides",
          "kind": "var_keyword",
          "annotated_type": "object",
          "default": "{}",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "dict",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Fast text search using ripgrep (async wrapper).",
      "doc_raw": "Fast text search using ripgrep (async wrapper).\n\nApplies session scope path filters if set via `set_scope`. Explicit parameters\noverride session scope following the precedence rules documented above.\n\nParameters\n----------\ncontext : ApplicationContext\n    Application context containing repo root and settings.\nquery : str\n    Search query string (regex pattern if ``regex=True``).\noptions : TextSearchOptions | None, optional\n    Explicit search configuration. When ``None``, keyword overrides are permitted.\n**overrides : object\n    Backward-compatible keyword overrides corresponding to\n    ``TextSearchOptions`` fields (``regex``, ``case_sensitive``, ``paths``,\n    ``include_globs``, ``exclude_globs``, ``max_results``).\n\nReturns\n-------\ndict\n    Search results containing matched paths and metadata.\n\nRaises\n------\nTypeError\n    If both ``options`` and keyword ``overrides`` are provided simultaneously.\n    Only one method of providing search options is allowed per call.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.text_search._int_override",
      "short_name": "_int_override",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "overrides",
          "kind": "positional_or_keyword",
          "annotated_type": "Mapping[str, object]",
          "default": null,
          "doc": null
        },
        {
          "name": "key",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "int",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Return an integer override for the given key.",
      "doc_raw": "Return an integer override for the given key.\n\nParameters\n----------\noverrides : Mapping[str, object]\n    Override dictionary provided by the adapter call.\nkey : str\n    Lookup key corresponding to the ``max_results`` parameter.\n\nReturns\n-------\nint\n    Integer override value retrieved from the overrides mapping.\n\nRaises\n------\nTypeError\n    If the override is present but not an integer.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.text_search._sequence_override",
      "short_name": "_sequence_override",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "overrides",
          "kind": "positional_or_keyword",
          "annotated_type": "Mapping[str, object]",
          "default": null,
          "doc": null
        },
        {
          "name": "key",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "Sequence[str] | None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Return a sequence override if the value is a valid sequence of strings.",
      "doc_raw": "Return a sequence override if the value is a valid sequence of strings.\n\nParameters\n----------\noverrides : Mapping[str, object]\n    Override dictionary provided by the adapter call.\nkey : str\n    Lookup key corresponding to a sequence field in TextSearchOptions.\n\nReturns\n-------\nSequence[str] | None\n    Sequence override if present, otherwise ``None``.\n\nRaises\n------\nTypeError\n    If the override is present but not a sequence of strings.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.text_search._bool_override",
      "short_name": "_bool_override",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "overrides",
          "kind": "positional_or_keyword",
          "annotated_type": "Mapping[str, object]",
          "default": null,
          "doc": null
        },
        {
          "name": "key",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "bool",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Return a boolean override for the given key.",
      "doc_raw": "Return a boolean override for the given key.\n\nParameters\n----------\noverrides : Mapping[str, object]\n    Override dictionary provided by the adapter call.\nkey : str\n    Lookup key corresponding to a TextSearchOptions boolean field.\n\nReturns\n-------\nbool\n    Boolean override value retrieved from the overrides mapping.\n\nRaises\n------\nTypeError\n    If the override is present but not a boolean.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.text_search.TextSearchOptions",
      "short_name": "TextSearchOptions",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "dataclass(frozen=True)"
      ],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "query",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "regex",
          "kind": "positional_or_keyword",
          "annotated_type": "bool",
          "default": "False",
          "doc": null
        },
        {
          "name": "case_sensitive",
          "kind": "positional_or_keyword",
          "annotated_type": "bool",
          "default": "False",
          "doc": null
        },
        {
          "name": "paths",
          "kind": "positional_or_keyword",
          "annotated_type": "Sequence[str] | None",
          "default": "None",
          "doc": null
        },
        {
          "name": "include_globs",
          "kind": "positional_or_keyword",
          "annotated_type": "Sequence[str] | None",
          "default": "None",
          "doc": null
        },
        {
          "name": "exclude_globs",
          "kind": "positional_or_keyword",
          "annotated_type": "Sequence[str] | None",
          "default": "None",
          "doc": null
        },
        {
          "name": "max_results",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": "50",
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Parameters controlling ripgrep execution.",
      "doc_raw": "Parameters controlling ripgrep execution.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.text_search.TextSearchOptions.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "query",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "regex",
          "kind": "positional_or_keyword",
          "annotated_type": "bool",
          "default": "False",
          "doc": null
        },
        {
          "name": "case_sensitive",
          "kind": "positional_or_keyword",
          "annotated_type": "bool",
          "default": "False",
          "doc": null
        },
        {
          "name": "paths",
          "kind": "positional_or_keyword",
          "annotated_type": "Sequence[str] | None",
          "default": "None",
          "doc": null
        },
        {
          "name": "include_globs",
          "kind": "positional_or_keyword",
          "annotated_type": "Sequence[str] | None",
          "default": "None",
          "doc": null
        },
        {
          "name": "exclude_globs",
          "kind": "positional_or_keyword",
          "annotated_type": "Sequence[str] | None",
          "default": "None",
          "doc": null
        },
        {
          "name": "max_results",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": "50",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.text_search.TextSearchOptions.from_overrides",
      "short_name": "from_overrides",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "classmethod"
      ],
      "params": [
        {
          "name": "cls",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "query",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "overrides",
          "kind": "positional_or_keyword",
          "annotated_type": "Mapping[str, object]",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "TextSearchOptions",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Build search options from keyword overrides.",
      "doc_raw": "Build search options from keyword overrides.\n\nConstructs a TextSearchOptions instance from a query string and a mapping\nof keyword arguments. Validates that all override keys are allowed options.\n\nParameters\n----------\nquery : str\n    Search query string (regex pattern if regex=True).\noverrides : Mapping[str, object]\n    Dictionary of keyword arguments corresponding to TextSearchOptions fields.\n    Valid keys are: regex, case_sensitive, paths, include_globs, exclude_globs,\n    max_results.\n\nReturns\n-------\nTextSearchOptions\n    Configured search options instance with query and overrides applied.\n\nRaises\n------\nTypeError\n    If any keys in overrides are not recognized as valid TextSearchOptions\n    fields. This prevents typos and ensures type safety.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.text_search.TextSearchOptions.max_results",
      "short_name": "max_results",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.text_search.TextSearchOptions.exclude_globs",
      "short_name": "exclude_globs",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.text_search.TextSearchOptions.include_globs",
      "short_name": "include_globs",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.text_search.TextSearchOptions.paths",
      "short_name": "paths",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.text_search.TextSearchOptions.case_sensitive",
      "short_name": "case_sensitive",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.text_search.TextSearchOptions.regex",
      "short_name": "regex",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.text_search.TextSearchOptions.query",
      "short_name": "query",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.text_search.TextSearchOptions._ALLOWED_KEYS",
      "short_name": "_ALLOWED_KEYS",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.text_search.LOGGER",
      "short_name": "LOGGER",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.text_search.COMPONENT_NAME",
      "short_name": "COMPONENT_NAME",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.text_search.COMMAND_NOT_FOUND_RETURN_CODE",
      "short_name": "COMMAND_NOT_FOUND_RETURN_CODE",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.text_search.GREP_SPLIT_PARTS",
      "short_name": "GREP_SPLIT_PARTS",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.text_search.MAX_PREVIEW_CHARS",
      "short_name": "MAX_PREVIEW_CHARS",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.text_search.SEARCH_TIMEOUT_SECONDS",
      "short_name": "SEARCH_TIMEOUT_SECONDS",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro",
      "short_name": "semantic_pro",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Two-stage semantic search (CodeRank \u2192 optional WARP \u2192 optional reranker).",
      "doc_raw": "Two-stage semantic search (CodeRank \u2192 optional WARP \u2192 optional reranker).",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro.MethodContext",
      "short_name": "MethodContext",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "dataclass(slots=True, frozen=True)"
      ],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "findings_count",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "requested_limit",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "effective_limit",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "start_time",
          "kind": "positional_or_keyword",
          "annotated_type": "float",
          "default": null,
          "doc": null
        },
        {
          "name": "channels",
          "kind": "positional_or_keyword",
          "annotated_type": "list[str]",
          "default": null,
          "doc": null
        },
        {
          "name": "stages",
          "kind": "positional_or_keyword",
          "annotated_type": "Sequence[StageTiming] | None",
          "default": null,
          "doc": null
        },
        {
          "name": "notes",
          "kind": "positional_or_keyword",
          "annotated_type": "tuple[str, ...] | None",
          "default": "None",
          "doc": null
        },
        {
          "name": "explainability",
          "kind": "positional_or_keyword",
          "annotated_type": "dict[str, list[dict[str, Any]]] | None",
          "default": "None",
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Inputs required to build the MethodInfo payload.",
      "doc_raw": "Inputs required to build the MethodInfo payload.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro.MethodContext.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "findings_count",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "requested_limit",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "effective_limit",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "start_time",
          "kind": "positional_or_keyword",
          "annotated_type": "float",
          "default": null,
          "doc": null
        },
        {
          "name": "channels",
          "kind": "positional_or_keyword",
          "annotated_type": "list[str]",
          "default": null,
          "doc": null
        },
        {
          "name": "stages",
          "kind": "positional_or_keyword",
          "annotated_type": "Sequence[StageTiming] | None",
          "default": null,
          "doc": null
        },
        {
          "name": "notes",
          "kind": "positional_or_keyword",
          "annotated_type": "tuple[str, ...] | None",
          "default": "None",
          "doc": null
        },
        {
          "name": "explainability",
          "kind": "positional_or_keyword",
          "annotated_type": "dict[str, list[dict[str, Any]]] | None",
          "default": "None",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro.MethodContext.explainability",
      "short_name": "explainability",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro.MethodContext.notes",
      "short_name": "notes",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro.MethodContext.stages",
      "short_name": "stages",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro.MethodContext.channels",
      "short_name": "channels",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro.MethodContext.start_time",
      "short_name": "start_time",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro.MethodContext.effective_limit",
      "short_name": "effective_limit",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro.MethodContext.requested_limit",
      "short_name": "requested_limit",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro.MethodContext.findings_count",
      "short_name": "findings_count",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro.FusionRequest",
      "short_name": "FusionRequest",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "dataclass(slots=True, frozen=True)"
      ],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "query",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "coderank_hits",
          "kind": "positional_or_keyword",
          "annotated_type": "Sequence[tuple[int, float]]",
          "default": null,
          "doc": null
        },
        {
          "name": "warp_hits",
          "kind": "positional_or_keyword",
          "annotated_type": "list[tuple[int, float]]",
          "default": null,
          "doc": null
        },
        {
          "name": "warp_channel",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "effective_limit",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "weights",
          "kind": "positional_or_keyword",
          "annotated_type": "Mapping[str, float]",
          "default": null,
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Inputs required to execute the fusion stage.",
      "doc_raw": "Inputs required to execute the fusion stage.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro.FusionRequest.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "query",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "coderank_hits",
          "kind": "positional_or_keyword",
          "annotated_type": "Sequence[tuple[int, float]]",
          "default": null,
          "doc": null
        },
        {
          "name": "warp_hits",
          "kind": "positional_or_keyword",
          "annotated_type": "list[tuple[int, float]]",
          "default": null,
          "doc": null
        },
        {
          "name": "warp_channel",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "effective_limit",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "weights",
          "kind": "positional_or_keyword",
          "annotated_type": "Mapping[str, float]",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro.FusionRequest.weights",
      "short_name": "weights",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro.FusionRequest.effective_limit",
      "short_name": "effective_limit",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro.FusionRequest.warp_channel",
      "short_name": "warp_channel",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro.FusionRequest.warp_hits",
      "short_name": "warp_hits",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro.FusionRequest.coderank_hits",
      "short_name": "coderank_hits",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro.FusionRequest.query",
      "short_name": "query",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro.WarpOutcome",
      "short_name": "WarpOutcome",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "dataclass(slots=True, frozen=True)"
      ],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "hits",
          "kind": "positional_or_keyword",
          "annotated_type": "list[tuple[int, float]]",
          "default": null,
          "doc": null
        },
        {
          "name": "notes",
          "kind": "positional_or_keyword",
          "annotated_type": "list[str]",
          "default": null,
          "doc": null
        },
        {
          "name": "timing",
          "kind": "positional_or_keyword",
          "annotated_type": "StageTiming | None",
          "default": null,
          "doc": null
        },
        {
          "name": "explainability",
          "kind": "positional_or_keyword",
          "annotated_type": "tuple[tuple[int, dict[str, Any]], ...]",
          "default": null,
          "doc": null
        },
        {
          "name": "channel",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": "'warp'",
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Container describing the results of the optional WARP stage.",
      "doc_raw": "Container describing the results of the optional WARP stage.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro.WarpOutcome.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "hits",
          "kind": "positional_or_keyword",
          "annotated_type": "list[tuple[int, float]]",
          "default": null,
          "doc": null
        },
        {
          "name": "notes",
          "kind": "positional_or_keyword",
          "annotated_type": "list[str]",
          "default": null,
          "doc": null
        },
        {
          "name": "timing",
          "kind": "positional_or_keyword",
          "annotated_type": "StageTiming | None",
          "default": null,
          "doc": null
        },
        {
          "name": "explainability",
          "kind": "positional_or_keyword",
          "annotated_type": "tuple[tuple[int, dict[str, Any]], ...]",
          "default": null,
          "doc": null
        },
        {
          "name": "channel",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": "'warp'",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro.WarpOutcome.channel",
      "short_name": "channel",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro.WarpOutcome.explainability",
      "short_name": "explainability",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro.WarpOutcome.timing",
      "short_name": "timing",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro.WarpOutcome.notes",
      "short_name": "notes",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro.WarpOutcome.hits",
      "short_name": "hits",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro._dedupe_preserve_order",
      "short_name": "_dedupe_preserve_order",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "ids",
          "kind": "positional_or_keyword",
          "annotated_type": "list[int]",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "list[int]",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro._clamp_limit",
      "short_name": "_clamp_limit",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "requested",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "max_results",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "notes",
          "kind": "positional_or_keyword",
          "annotated_type": "list[str]",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "int",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro._make_envelope",
      "short_name": "_make_envelope",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "answer",
          "kind": "keyword_only",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "findings",
          "kind": "keyword_only",
          "annotated_type": "list[Finding]",
          "default": null,
          "doc": null
        },
        {
          "name": "extras",
          "kind": "keyword_only",
          "annotated_type": "AnswerEnvelope",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "AnswerEnvelope",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro._assemble_extras",
      "short_name": "_assemble_extras",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "method",
          "kind": "keyword_only",
          "annotated_type": "MethodInfo",
          "default": null,
          "doc": null
        },
        {
          "name": "limits",
          "kind": "keyword_only",
          "annotated_type": "list[str]",
          "default": null,
          "doc": null
        },
        {
          "name": "scope",
          "kind": "keyword_only",
          "annotated_type": "ScopeIn | None",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "AnswerEnvelope",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Assemble response metadata extras dictionary.",
      "doc_raw": "Assemble response metadata extras dictionary.\n\nExtended Summary\n----------------\nThis helper function constructs the extras dictionary for an AnswerEnvelope,\ncombining method metadata (retrieval channels, coverage, stage timings) with\noptional limits warnings and scope filters. It is called after the retrieval\npipeline completes to package telemetry and configuration context into the\nresponse. The function ensures that only non-empty optional fields are included,\nkeeping the response payload minimal.\n\nParameters\n----------\nmethod : MethodInfo\n    Method metadata dictionary containing retrieval channels, coverage string,\n    and optional stage timings. This is produced by _build_method() and describes\n    how the search was executed.\nlimits : list[str]\n    List of warning messages about budget overruns, limit clamping, or other\n    operational constraints. Empty list means no warnings. Non-empty lists are\n    included in the extras as the \"limits\" field.\nscope : ScopeIn | None\n    Scope filters that were applied during search (include_globs, exclude_globs,\n    languages). None means no scope filtering was applied. Non-None values are\n    included in the extras as the \"scope\" field.\n\nReturns\n-------\nAnswerEnvelope\n    Dictionary containing the method field (always present) and optionally\n    limits and scope fields if they are non-empty/non-None. This dictionary\n    is merged into the final AnswerEnvelope by _make_envelope().\n\nNotes\n-----\nTime complexity O(1). No I/O or side effects. The function performs shallow\ndictionary construction only. Thread-safe.\n\nExamples\n--------\n>>> method = {\"retrieval\": [\"coderank\"], \"coverage\": \"5/10 results in 42ms\"}\n>>> extras = _assemble_extras(method=method, limits=[], scope=None)\n>>> extras[\"method\"] == method\nTrue\n>>> \"limits\" in extras\nFalse\n>>> extras = _assemble_extras(method=method, limits=[\"Budget exceeded\"], scope=None)\n>>> extras[\"limits\"] == [\"Budget exceeded\"]\nTrue",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro._build_method",
      "short_name": "_build_method",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "context",
          "kind": "positional_or_keyword",
          "annotated_type": "MethodContext",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "MethodInfo",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro._build_method_explainability",
      "short_name": "_build_method_explainability",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "explainability",
          "kind": "positional_or_keyword",
          "annotated_type": "Sequence[tuple[int, dict[str, Any]]]",
          "default": null,
          "doc": null
        },
        {
          "name": "limit",
          "kind": "keyword_only",
          "annotated_type": "int",
          "default": "5",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "dict[str, list[dict[str, Any]]] | None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Build explainability payload for MethodInfo.",
      "doc_raw": "Build explainability payload for MethodInfo.\n\nExtended Summary\n----------------\nThis helper function converts raw explainability tuples (chunk_id, payload) into\na structured dictionary format suitable for inclusion in MethodInfo. It filters\nentries to include only those with token matches, limits the number of entries\nto prevent payload bloat, and organizes them by channel (currently \"warp\").\nThe function is called after the retrieval pipeline completes to package\ntoken-level alignment data for observability.\n\nParameters\n----------\nexplainability : Sequence[tuple[int, dict[str, Any]]]\n    Raw explainability data as (chunk_id, payload) tuples. Each payload should\n    contain a \"token_matches\" key with alignment information. Empty sequences\n    result in None return.\nlimit : int, optional\n    Maximum number of explainability entries to include in the result. Defaults\n    to 5 to keep payload sizes manageable. Higher values provide more detail but\n    increase response size.\n\nReturns\n-------\ndict[str, list[dict[str, Any]]] | None\n    Structured explainability data keyed by channel name (e.g., \"warp\"). Each\n    entry contains chunk_id and token_matches. Returns None if no valid entries\n    are found or if explainability is empty.\n\nNotes\n-----\nTime complexity O(n) where n is min(len(explainability), limit). Space complexity\nO(n) for the result dictionary. No I/O or side effects. Thread-safe.\n\nExamples\n--------\n>>> explain = [(1, {\"token_matches\": [{\"q_index\": 0, \"doc_index\": 5, \"similarity\": 0.8}]})]\n>>> result = _build_method_explainability(explain, limit=5)\n>>> result is not None and \"warp\" in result\nTrue\n>>> result = _build_method_explainability([], limit=5)\n>>> result is None\nTrue",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro.merge_explainability_into_findings",
      "short_name": "merge_explainability_into_findings",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "findings",
          "kind": "positional_or_keyword",
          "annotated_type": "list[Finding]",
          "default": null,
          "doc": null
        },
        {
          "name": "explainability",
          "kind": "positional_or_keyword",
          "annotated_type": "Sequence[tuple[int, dict[str, Any]]]",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Append token-level explainability snippets to existing findings.",
      "doc_raw": "Append token-level explainability snippets to existing findings.\n\nExtended Summary\n----------------\nThis function enriches Finding objects with token-level alignment information\nfrom XTR/WARP explainability data. It matches explainability entries to findings\nby chunk_id, extracts token match summaries, and appends formatted alignment\nstrings to the \"why\" field. The function mutates findings in-place, adding\nXTR alignment details (query token index \u2192 document token index with similarity\nscores) to help users understand why specific code chunks were retrieved.\nThis is called after findings are built but before the final AnswerEnvelope\nis assembled.\n\nParameters\n----------\nfindings : list[Finding]\n    List of Finding dictionaries to enrich. Each finding should have a \"chunk_id\"\n    field for matching. Findings without matching explainability entries are\n    left unchanged. Mutated in-place.\nexplainability : Sequence[tuple[int, dict[str, Any]]]\n    Explainability data as (chunk_id, payload) tuples. Each payload should\n    contain a \"token_matches\" key with alignment information. Empty sequences\n    result in no modifications.\n\nNotes\n-----\nTime complexity O(n * m) where n is len(findings) and m is len(explainability)\ndue to lookup construction and matching. Space complexity O(m) for the lookup\ndictionary. The function mutates findings in-place and has no return value.\nThread-safe if findings list is not modified concurrently.\n\nExamples\n--------\n>>> findings = [{\"chunk_id\": 1, \"why\": \"Fusion weights: coderank rank=1\"}]\n>>> explain = [(1, {\"token_matches\": [{\"q_index\": 0, \"doc_index\": 5, \"similarity\": 0.8}]})]\n>>> merge_explainability_into_findings(findings, explain)\n>>> \"XTR alignments\" in findings[0][\"why\"]\nTrue",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro._build_findings",
      "short_name": "_build_findings",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "records",
          "kind": "keyword_only",
          "annotated_type": "list[dict]",
          "default": null,
          "doc": null
        },
        {
          "name": "docs",
          "kind": "keyword_only",
          "annotated_type": "Sequence[HybridResultDoc]",
          "default": null,
          "doc": null
        },
        {
          "name": "contribution_map",
          "kind": "keyword_only",
          "annotated_type": "Mapping[str, list[tuple[str, int, float]]]",
          "default": null,
          "doc": null
        },
        {
          "name": "explain",
          "kind": "keyword_only",
          "annotated_type": "bool",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "list[Finding]",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro._maybe_rerank",
      "short_name": "_maybe_rerank",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "query",
          "kind": "keyword_only",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "records",
          "kind": "keyword_only",
          "annotated_type": "list[dict]",
          "default": null,
          "doc": null
        },
        {
          "name": "context",
          "kind": "keyword_only",
          "annotated_type": "ApplicationContext",
          "default": null,
          "doc": null
        },
        {
          "name": "enabled",
          "kind": "keyword_only",
          "annotated_type": "bool",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "list[dict]",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro._hydrate_and_rerank_records",
      "short_name": "_hydrate_and_rerank_records",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "plan",
          "kind": "positional_or_keyword",
          "annotated_type": "HydrationPlan",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "tuple[list[dict], list[StageTiming]]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Hydrate DuckDB records and optionally rerank them using CodeRankLLM.",
      "doc_raw": "Hydrate DuckDB records and optionally rerank them using CodeRankLLM.\n\nExtended Summary\n----------------\nThis function performs the hydration and reranking stage of semantic search,\nconverting chunk IDs from hybrid search results into full DuckDB records with\nmetadata. It optionally applies CodeRankLLM reranking when enabled in options,\nand clips results to the effective limit specified in the plan. The function\naggregates timing information from both hydration and reranking operations,\nproviding observability into stage performance. This is a critical path in the\nsemantic search pipeline, bridging between vector search results and final\nranked document outputs.\n\nParameters\n----------\nplan : HydrationPlan\n    Container holding hydration and reranking inputs including context, query,\n    fused hybrid search results, scope filters, effective limit, options, and\n    observation tracking. The plan encapsulates all state needed to hydrate\n    and rerank search results.\n\nReturns\n-------\ntuple[list[dict], list[StageTiming]]\n    A tuple containing:\n    - Hydrated records clipped to ``effective_limit``, each record is a dict\n      with chunk metadata from DuckDB.\n    - Timing snapshots from hydration and reranking stages for observability.\n\nRaises\n------\nVectorSearchError\n    Raised when DuckDB hydration fails even after retries. This occurs when\n    the database is unavailable, queries timeout, or chunk IDs are invalid.\n\nNotes\n-----\nTime complexity O(R + L) where R is reranking cost (if enabled, depends on\nLLM inference) and L is limit clipping. Space complexity O(k) where k is\neffective_limit. The function performs database I/O for hydration and optional\nLLM API calls for reranking. Thread-safe for concurrent plan processing.\nResults are clipped to effective_limit to respect user constraints and prevent\nmemory exhaustion. Timing snapshots enable performance monitoring and debugging.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro._hydrate_records",
      "short_name": "_hydrate_records",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "context",
          "kind": "keyword_only",
          "annotated_type": "ApplicationContext",
          "default": null,
          "doc": null
        },
        {
          "name": "chunk_ids",
          "kind": "keyword_only",
          "annotated_type": "list[int]",
          "default": null,
          "doc": null
        },
        {
          "name": "scope",
          "kind": "keyword_only",
          "annotated_type": "ScopeIn | None",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "list[dict]",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro._xtr_rescore_hits",
      "short_name": "_xtr_rescore_hits",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "context",
          "kind": "keyword_only",
          "annotated_type": "ApplicationContext",
          "default": null,
          "doc": null
        },
        {
          "name": "query",
          "kind": "keyword_only",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "candidates",
          "kind": "keyword_only",
          "annotated_type": "list[tuple[int, float]]",
          "default": null,
          "doc": null
        },
        {
          "name": "options",
          "kind": "keyword_only",
          "annotated_type": "SemanticProRuntimeOptions",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "tuple[list[tuple[int, float]], list[str], list[tuple[int, dict[str, Any]]]]",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro._warp_executor_hits",
      "short_name": "_warp_executor_hits",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "context",
          "kind": "positional_or_keyword",
          "annotated_type": "ApplicationContext",
          "default": null,
          "doc": null
        },
        {
          "name": "query",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "candidates",
          "kind": "positional_or_keyword",
          "annotated_type": "list[tuple[int, float]]",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "tuple[list[tuple[int, float]] | None, list[str]]",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro._run_warp_stage",
      "short_name": "_run_warp_stage",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "context",
          "kind": "keyword_only",
          "annotated_type": "ApplicationContext",
          "default": null,
          "doc": null
        },
        {
          "name": "query",
          "kind": "keyword_only",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "candidates",
          "kind": "keyword_only",
          "annotated_type": "list[tuple[int, float]]",
          "default": null,
          "doc": null
        },
        {
          "name": "options",
          "kind": "keyword_only",
          "annotated_type": "SemanticProRuntimeOptions",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "tuple[list[tuple[int, float]], list[str], list[tuple[int, dict[str, Any]]], str]",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro._merge_rrf_weights",
      "short_name": "_merge_rrf_weights",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "defaults",
          "kind": "positional_or_keyword",
          "annotated_type": "Mapping[str, float]",
          "default": null,
          "doc": null
        },
        {
          "name": "overrides",
          "kind": "positional_or_keyword",
          "annotated_type": "Mapping[str, float]",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "dict[str, float]",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro._safe_int",
      "short_name": "_safe_int",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "value",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "int",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro._append_budget_notes",
      "short_name": "_append_budget_notes",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "component",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "stage_timings",
          "kind": "positional_or_keyword",
          "annotated_type": "Sequence[StageTiming]",
          "default": null,
          "doc": null
        },
        {
          "name": "limits",
          "kind": "positional_or_keyword",
          "annotated_type": "list[str]",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro._build_extra_channels",
      "short_name": "_build_extra_channels",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "warp_hits",
          "kind": "positional_or_keyword",
          "annotated_type": "list[tuple[int, float]]",
          "default": null,
          "doc": null
        },
        {
          "name": "channel_name",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "dict[str, list[ChannelHit]] | None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro._calculate_xtr_k",
      "short_name": "_calculate_xtr_k",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "limit",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "cfg",
          "kind": "positional_or_keyword",
          "annotated_type": "XTRConfig",
          "default": null,
          "doc": null
        },
        {
          "name": "options",
          "kind": "positional_or_keyword",
          "annotated_type": "SemanticProRuntimeOptions",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "int",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro._run_xtr_wide_stage",
      "short_name": "_run_xtr_wide_stage",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "index",
          "kind": "positional_or_keyword",
          "annotated_type": "XTRIndex",
          "default": null,
          "doc": null
        },
        {
          "name": "query",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "k",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "explain",
          "kind": "keyword_only",
          "annotated_type": "bool",
          "default": null,
          "doc": null
        },
        {
          "name": "budget_ms",
          "kind": "keyword_only",
          "annotated_type": "int | None",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "WarpOutcome",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro._resolve_stage_one_outcome",
      "short_name": "_resolve_stage_one_outcome",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "plan",
          "kind": "positional_or_keyword",
          "annotated_type": "StageOnePlan",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "WarpOutcome",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Resolve Stage-1 orchestration outcome from a StageOnePlan.",
      "doc_raw": "Resolve Stage-1 orchestration outcome from a StageOnePlan.\n\nExtended Summary\n----------------\nThis function orchestrates the resolution of Stage-1 search outcomes, coordinating\nbetween wide-mode XTR search (if initiated) and narrow-mode Stage-2 execution.\nIt evaluates whether Stage-2 should run based on candidate quality and options,\nhandles wide search futures, and falls back to narrow mode when wide search fails\nor is not available. The function manages executor lifecycle and aggregates notes\nfrom both stages, producing a unified WarpOutcome for downstream processing.\n\nParameters\n----------\nplan : StageOnePlan\n    Container holding Stage-1 orchestration inputs including context, query,\n    candidates, options, coderank timing, and optional wide search handle.\n    The plan encapsulates all state needed to resolve the search outcome.\n\nReturns\n-------\nWarpOutcome\n    Outcome describing hits, notes, timing, explainability, and channel.\n    The outcome aggregates results from wide search (if successful) or Stage-2\n    execution, with notes from both stages combined.\n\nNotes\n-----\nTime complexity depends on search mode: O(1) if Stage-2 is skipped, O(C * T * D)\nfor narrow mode where C is candidate count, T is tokens, D is embedding dimension.\nSpace complexity O(k) for results where k is the effective limit. The function\nperforms I/O via wide search future and Stage-2 execution. Executor shutdown is\nbest-effort (wait=False) to avoid blocking. Thread-safe for concurrent plan\nprocessing. Handles wide search failures gracefully by falling back to narrow mode.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro._maybe_schedule_xtr_wide",
      "short_name": "_maybe_schedule_xtr_wide",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "context",
          "kind": "keyword_only",
          "annotated_type": "ApplicationContext",
          "default": null,
          "doc": null
        },
        {
          "name": "query",
          "kind": "keyword_only",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "limit",
          "kind": "keyword_only",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "options",
          "kind": "keyword_only",
          "annotated_type": "SemanticProRuntimeOptions",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "WideSearchHandle | None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro._run_fusion_stage",
      "short_name": "_run_fusion_stage",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "context",
          "kind": "keyword_only",
          "annotated_type": "ApplicationContext",
          "default": null,
          "doc": null
        },
        {
          "name": "request",
          "kind": "keyword_only",
          "annotated_type": "FusionRequest",
          "default": null,
          "doc": null
        },
        {
          "name": "stage_timings",
          "kind": "keyword_only",
          "annotated_type": "list[StageTiming]",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "HybridSearchResult",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro._execute_stage_two",
      "short_name": "_execute_stage_two",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "context",
          "kind": "keyword_only",
          "annotated_type": "ApplicationContext",
          "default": null,
          "doc": null
        },
        {
          "name": "query",
          "kind": "keyword_only",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "candidates",
          "kind": "keyword_only",
          "annotated_type": "list[tuple[int, float]]",
          "default": null,
          "doc": null
        },
        {
          "name": "options",
          "kind": "keyword_only",
          "annotated_type": "SemanticProRuntimeOptions",
          "default": null,
          "doc": null
        },
        {
          "name": "base_notes",
          "kind": "keyword_only",
          "annotated_type": "list[str]",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "WarpOutcome",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro._should_execute_stage_two",
      "short_name": "_should_execute_stage_two",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "context",
          "kind": "keyword_only",
          "annotated_type": "ApplicationContext",
          "default": null,
          "doc": null
        },
        {
          "name": "candidates",
          "kind": "keyword_only",
          "annotated_type": "list[tuple[int, float]]",
          "default": null,
          "doc": null
        },
        {
          "name": "options",
          "kind": "keyword_only",
          "annotated_type": "SemanticProRuntimeOptions",
          "default": null,
          "doc": null
        },
        {
          "name": "coderank_stage",
          "kind": "keyword_only",
          "annotated_type": "StageTiming",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "tuple[bool, list[str]]",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro._maybe_run_warp",
      "short_name": "_maybe_run_warp",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "context",
          "kind": "keyword_only",
          "annotated_type": "ApplicationContext",
          "default": null,
          "doc": null
        },
        {
          "name": "query",
          "kind": "keyword_only",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "candidates",
          "kind": "keyword_only",
          "annotated_type": "list[tuple[int, float]]",
          "default": null,
          "doc": null
        },
        {
          "name": "options",
          "kind": "keyword_only",
          "annotated_type": "SemanticProRuntimeOptions",
          "default": null,
          "doc": null
        },
        {
          "name": "coderank_stage",
          "kind": "keyword_only",
          "annotated_type": "StageTiming",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "WarpOutcome",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro._timed_coderank_stage",
      "short_name": "_timed_coderank_stage",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "context",
          "kind": "keyword_only",
          "annotated_type": "ApplicationContext",
          "default": null,
          "doc": null
        },
        {
          "name": "query",
          "kind": "keyword_only",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "fanout",
          "kind": "keyword_only",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "observation",
          "kind": "keyword_only",
          "annotated_type": "Observation",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "tuple[list[tuple[int, float]], StageTiming]",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro._run_coderank_stage",
      "short_name": "_run_coderank_stage",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "context",
          "kind": "keyword_only",
          "annotated_type": "ApplicationContext",
          "default": null,
          "doc": null
        },
        {
          "name": "query",
          "kind": "keyword_only",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "fanout",
          "kind": "keyword_only",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "observation",
          "kind": "keyword_only",
          "annotated_type": "Observation",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "list[tuple[int, float]]",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro._semantic_search_pro_sync",
      "short_name": "_semantic_search_pro_sync",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "context",
          "kind": "positional_or_keyword",
          "annotated_type": "ApplicationContext",
          "default": null,
          "doc": null
        },
        {
          "name": "query",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "limit",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "scope",
          "kind": "positional_or_keyword",
          "annotated_type": "ScopeIn | None",
          "default": null,
          "doc": null
        },
        {
          "name": "options",
          "kind": "positional_or_keyword",
          "annotated_type": "SemanticProRuntimeOptions",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "AnswerEnvelope",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro.semantic_search_pro",
      "short_name": "semantic_search_pro",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "context",
          "kind": "positional_or_keyword",
          "annotated_type": "ApplicationContext",
          "default": null,
          "doc": null
        },
        {
          "name": "query",
          "kind": "keyword_only",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "limit",
          "kind": "keyword_only",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "options",
          "kind": "keyword_only",
          "annotated_type": "SemanticProOptions | None",
          "default": "None",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "AnswerEnvelope",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Execute the two-stage semantic search pipeline (CodeRank \u2192 optional WARP \u2192 optional reranker).",
      "doc_raw": "Execute the two-stage semantic search pipeline (CodeRank \u2192 optional WARP \u2192 optional reranker).\n\nExtended Summary\n----------------\nThis async function orchestrates the semantic_pro retrieval pipeline, which combines\nCodeRank dense vector search with optional WARP late-interaction reranking and optional\nCodeRankLLM listwise reranking. The function normalizes options, resolves scope filters,\nexecutes stages conditionally based on gating logic and user preferences, fuses results\nusing weighted RRF, hydrates metadata from DuckDB, and assembles the final AnswerEnvelope\nwith findings, explanations, and telemetry. It is the primary entry point for semantic\ncode search in the MCP server, providing high-quality ranked results with explainability\nand performance budgets.\n\nParameters\n----------\ncontext : ApplicationContext\n    Application context containing settings, paths, and initialized components\n    (FAISS managers, embedders, catalog). Must have valid CodeRank FAISS index\n    and catalog configured.\nquery : str\n    Natural language search query. Will be embedded using CodeRank embedder\n    and optionally processed by WARP for late-interaction scoring.\nlimit : int\n    Maximum number of results to return. Will be clamped to the configured\n    max_results limit. Must be positive.\noptions : SemanticProOptions | None, optional\n    User-supplied pipeline options. Controls which stages run (use_coderank,\n    use_warp, use_reranker), fusion weights (stage_weights), and whether to\n    include explanations (explain). Defaults to None (all defaults applied).\n\nReturns\n-------\nAnswerEnvelope\n    Search results envelope containing:\n    - ``answer``: Human-readable summary string\n    - ``findings``: List of Finding objects with location, snippet, score, and optional why\n    - ``method``: Retrieval metadata including channels used, coverage, and stage timings\n    - ``limits``: Optional list of warnings about budget overruns or limit clamping\n    - ``scope``: Optional scope filters that were applied\n    - ``query_kind``: Always \"semantic_pro\"\n    - ``confidence``: Float between 0.0 and 1.0\n\nRaises\n------\nVectorSearchError\n    If limit is not positive, CodeRank FAISS index is missing, search fails,\n    or DuckDB hydration fails. All errors include Problem Details context.\n\nNotes\n-----\nTime complexity dominated by I/O: embedding (O(1) queries), FAISS search (O(k log n)\nwhere k is fanout and n is index size), WARP reranking (O(m * d) where m is candidates\nand d is sequence length), fusion (O(n * c) where n is hits and c is channels), DuckDB\nhydration (O(r) where r is result count), optional reranking (O(r * model_latency)).\nThe function performs extensive I/O (FAISS, DuckDB, optional GPU models) and is not\nthread-safe (uses context managers and shared state). Performance budgets are tracked\nper stage and violations are reported in the limits field. The function uses asyncio\nto offload synchronous work to a thread pool. Note that EmbeddingError may be propagated\nfrom downstream functions (e.g., CodeRank embedder failures) but is wrapped as VectorSearchError\nat the API boundary.\n\nExamples\n--------\n>>> # Minimal example (requires ApplicationContext setup)\n>>> # from codeintel_rev.app.config_context import ApplicationContext\n>>> # context = ApplicationContext(...)\n>>> # results = await semantic_search_pro(context, query=\"vector store\", limit=10)\n>>> # assert results[\"query_kind\"] == \"semantic_pro\"\n>>> # assert len(results[\"findings\"]) <= 10",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro.build_runtime_options",
      "short_name": "build_runtime_options",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "options",
          "kind": "positional_or_keyword",
          "annotated_type": "SemanticProOptions | None",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "SemanticProRuntimeOptions",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Normalize user-supplied options into an immutable dataclass.",
      "doc_raw": "Normalize user-supplied options into an immutable dataclass.\n\nExtended Summary\n----------------\nThis function converts user-facing TypedDict options into an internal immutable\ndataclass representation with defaults applied. It serves as the boundary between\nthe MCP server's request schema and the internal retrieval pipeline, ensuring\ntype safety and providing sensible defaults for optional configuration. The\nfunction is called once per semantic_pro request to prepare runtime options\nfor the two-stage retrieval pipeline (CodeRank \u2192 optional WARP \u2192 optional reranker).\n\nParameters\n----------\noptions : SemanticProOptions | None\n    User-supplied options dictionary. May be ``None`` to use all defaults.\n    Keys include: ``use_coderank`` (default True), ``use_warp`` (default True),\n    ``use_reranker`` (default False), ``stage_weights`` (default empty dict),\n    ``explain`` (default True). Missing keys are filled with defaults.\n\nReturns\n-------\nSemanticProRuntimeOptions\n    Immutable dataclass instance with normalized options. All fields have\n    defaults applied, ensuring the returned value is always valid for pipeline\n    execution.\n\nNotes\n-----\nTime complexity O(1). No I/O or side effects. The function performs a shallow\ncopy of stage_weights to ensure immutability of the returned dataclass.\n\nExamples\n--------\n>>> opts = build_runtime_options(None)\n>>> opts.use_coderank\nTrue\n>>> opts.use_warp\nTrue\n>>> opts.use_reranker\nFalse\n>>> user_opts = {\"use_warp\": False, \"use_reranker\": True}\n>>> opts = build_runtime_options(user_opts)\n>>> opts.use_warp\nFalse\n>>> opts.use_reranker\nTrue",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro.HydrationPlan",
      "short_name": "HydrationPlan",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "dataclass(slots=True, frozen=True)"
      ],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "context",
          "kind": "positional_or_keyword",
          "annotated_type": "ApplicationContext",
          "default": null,
          "doc": null
        },
        {
          "name": "query",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "fused",
          "kind": "positional_or_keyword",
          "annotated_type": "HybridSearchResult",
          "default": null,
          "doc": null
        },
        {
          "name": "scope",
          "kind": "positional_or_keyword",
          "annotated_type": "ScopeIn | None",
          "default": null,
          "doc": null
        },
        {
          "name": "effective_limit",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "options",
          "kind": "positional_or_keyword",
          "annotated_type": "SemanticProRuntimeOptions",
          "default": null,
          "doc": null
        },
        {
          "name": "observation",
          "kind": "positional_or_keyword",
          "annotated_type": "Observation",
          "default": null,
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Hydration plus rerank inputs passed as a cohesive plan.",
      "doc_raw": "Hydration plus rerank inputs passed as a cohesive plan.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro.HydrationPlan.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "context",
          "kind": "positional_or_keyword",
          "annotated_type": "ApplicationContext",
          "default": null,
          "doc": null
        },
        {
          "name": "query",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "fused",
          "kind": "positional_or_keyword",
          "annotated_type": "HybridSearchResult",
          "default": null,
          "doc": null
        },
        {
          "name": "scope",
          "kind": "positional_or_keyword",
          "annotated_type": "ScopeIn | None",
          "default": null,
          "doc": null
        },
        {
          "name": "effective_limit",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "options",
          "kind": "positional_or_keyword",
          "annotated_type": "SemanticProRuntimeOptions",
          "default": null,
          "doc": null
        },
        {
          "name": "observation",
          "kind": "positional_or_keyword",
          "annotated_type": "Observation",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro.HydrationPlan.observation",
      "short_name": "observation",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro.HydrationPlan.options",
      "short_name": "options",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro.HydrationPlan.effective_limit",
      "short_name": "effective_limit",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro.HydrationPlan.scope",
      "short_name": "scope",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro.HydrationPlan.fused",
      "short_name": "fused",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro.HydrationPlan.query",
      "short_name": "query",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro.HydrationPlan.context",
      "short_name": "context",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro.StageOnePlan",
      "short_name": "StageOnePlan",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "dataclass(slots=True, frozen=True)"
      ],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "context",
          "kind": "positional_or_keyword",
          "annotated_type": "ApplicationContext",
          "default": null,
          "doc": null
        },
        {
          "name": "query",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "candidates",
          "kind": "positional_or_keyword",
          "annotated_type": "Sequence[tuple[int, float]]",
          "default": null,
          "doc": null
        },
        {
          "name": "options",
          "kind": "positional_or_keyword",
          "annotated_type": "SemanticProRuntimeOptions",
          "default": null,
          "doc": null
        },
        {
          "name": "coderank_stage",
          "kind": "positional_or_keyword",
          "annotated_type": "StageTiming",
          "default": null,
          "doc": null
        },
        {
          "name": "wide_handle",
          "kind": "positional_or_keyword",
          "annotated_type": "WideSearchHandle | None",
          "default": null,
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Container for Stage-1 orchestration inputs to reduce argument lists.",
      "doc_raw": "Container for Stage-1 orchestration inputs to reduce argument lists.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro.StageOnePlan.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "context",
          "kind": "positional_or_keyword",
          "annotated_type": "ApplicationContext",
          "default": null,
          "doc": null
        },
        {
          "name": "query",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "candidates",
          "kind": "positional_or_keyword",
          "annotated_type": "Sequence[tuple[int, float]]",
          "default": null,
          "doc": null
        },
        {
          "name": "options",
          "kind": "positional_or_keyword",
          "annotated_type": "SemanticProRuntimeOptions",
          "default": null,
          "doc": null
        },
        {
          "name": "coderank_stage",
          "kind": "positional_or_keyword",
          "annotated_type": "StageTiming",
          "default": null,
          "doc": null
        },
        {
          "name": "wide_handle",
          "kind": "positional_or_keyword",
          "annotated_type": "WideSearchHandle | None",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro.StageOnePlan.wide_handle",
      "short_name": "wide_handle",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro.StageOnePlan.coderank_stage",
      "short_name": "coderank_stage",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro.StageOnePlan.options",
      "short_name": "options",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro.StageOnePlan.candidates",
      "short_name": "candidates",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro.StageOnePlan.query",
      "short_name": "query",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro.StageOnePlan.context",
      "short_name": "context",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro.WideSearchHandle",
      "short_name": "WideSearchHandle",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro.SemanticProRuntimeOptions",
      "short_name": "SemanticProRuntimeOptions",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "dataclass(frozen=True)"
      ],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "use_coderank",
          "kind": "positional_or_keyword",
          "annotated_type": "bool",
          "default": "True",
          "doc": null
        },
        {
          "name": "use_warp",
          "kind": "positional_or_keyword",
          "annotated_type": "bool",
          "default": "True",
          "doc": null
        },
        {
          "name": "use_reranker",
          "kind": "positional_or_keyword",
          "annotated_type": "bool",
          "default": "False",
          "doc": null
        },
        {
          "name": "stage_weights",
          "kind": "positional_or_keyword",
          "annotated_type": "dict[str, float]",
          "default": "dict()",
          "doc": null
        },
        {
          "name": "explain",
          "kind": "positional_or_keyword",
          "annotated_type": "bool",
          "default": "True",
          "doc": null
        },
        {
          "name": "xtr_k",
          "kind": "positional_or_keyword",
          "annotated_type": "int | None",
          "default": "None",
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Internal immutable representation of semantic_pro options.",
      "doc_raw": "Internal immutable representation of semantic_pro options.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro.SemanticProRuntimeOptions.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "use_coderank",
          "kind": "positional_or_keyword",
          "annotated_type": "bool",
          "default": "True",
          "doc": null
        },
        {
          "name": "use_warp",
          "kind": "positional_or_keyword",
          "annotated_type": "bool",
          "default": "True",
          "doc": null
        },
        {
          "name": "use_reranker",
          "kind": "positional_or_keyword",
          "annotated_type": "bool",
          "default": "False",
          "doc": null
        },
        {
          "name": "stage_weights",
          "kind": "positional_or_keyword",
          "annotated_type": "dict[str, float]",
          "default": "dict()",
          "doc": null
        },
        {
          "name": "explain",
          "kind": "positional_or_keyword",
          "annotated_type": "bool",
          "default": "True",
          "doc": null
        },
        {
          "name": "xtr_k",
          "kind": "positional_or_keyword",
          "annotated_type": "int | None",
          "default": "None",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro.SemanticProRuntimeOptions.xtr_k",
      "short_name": "xtr_k",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro.SemanticProRuntimeOptions.explain",
      "short_name": "explain",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro.SemanticProRuntimeOptions.stage_weights",
      "short_name": "stage_weights",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro.SemanticProRuntimeOptions.use_reranker",
      "short_name": "use_reranker",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro.SemanticProRuntimeOptions.use_warp",
      "short_name": "use_warp",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro.SemanticProRuntimeOptions.use_coderank",
      "short_name": "use_coderank",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro.SemanticProOptions",
      "short_name": "SemanticProOptions",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [
        "TypedDict"
      ],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "User-facing options for semantic_pro retrieval.",
      "doc_raw": "User-facing options for semantic_pro retrieval.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro.SemanticProOptions.xtr_k",
      "short_name": "xtr_k",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro.SemanticProOptions.explain",
      "short_name": "explain",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro.SemanticProOptions.stage_weights",
      "short_name": "stage_weights",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro.SemanticProOptions.use_reranker",
      "short_name": "use_reranker",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro.SemanticProOptions.use_warp",
      "short_name": "use_warp",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro.SemanticProOptions.use_coderank",
      "short_name": "use_coderank",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro.LOGGER",
      "short_name": "LOGGER",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro.COMPONENT_NAME",
      "short_name": "COMPONENT_NAME",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic_pro.SNIPPET_PREVIEW_CHARS",
      "short_name": "SNIPPET_PREVIEW_CHARS",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.files",
      "short_name": "files",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "File and scope management adapter.",
      "doc_raw": "File and scope management adapter.\n\nProvides file listing, reading, and scope configuration.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.files._matches_language",
      "short_name": "_matches_language",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "path",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "extensions",
          "kind": "positional_or_keyword",
          "annotated_type": "set[str]",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "bool",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Return True when the path matches one of the requested extensions.",
      "doc_raw": "Return True when the path matches one of the requested extensions.\n\nParameters\n----------\npath : str\n    File path to check.\nextensions : set[str]\n    Set of file extensions (with leading dots) to match against.\n\nReturns\n-------\nbool\n    True if the path ends with one of the extensions (case-insensitive),\n    False otherwise.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.files._collect_language_extensions",
      "short_name": "_collect_language_extensions",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "languages",
          "kind": "positional_or_keyword",
          "annotated_type": "Sequence[str]",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "set[str]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Return canonical file extensions for the requested languages.",
      "doc_raw": "Return canonical file extensions for the requested languages.\n\nParameters\n----------\nlanguages : Sequence[str]\n    Language codes to get extensions for (e.g., [\"python\", \"javascript\"]).\n\nReturns\n-------\nset[str]\n    Set of file extensions (with leading dots) for the requested languages.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.files._safe_stat",
      "short_name": "_safe_stat",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "path",
          "kind": "positional_or_keyword",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "os.stat_result | None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.files._relative_path_str",
      "short_name": "_relative_path_str",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "path",
          "kind": "positional_or_keyword",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        },
        {
          "name": "repo_root",
          "kind": "positional_or_keyword",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "str | None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.files._matches_any",
      "short_name": "_matches_any",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "target",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "patterns",
          "kind": "positional_or_keyword",
          "annotated_type": "Sequence[str]",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "bool",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.files._resolve_search_root",
      "short_name": "_resolve_search_root",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "repo_root",
          "kind": "positional_or_keyword",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        },
        {
          "name": "requested",
          "kind": "positional_or_keyword",
          "annotated_type": "str | None",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "Path",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Resolve search root path, raising descriptive errors on failure.",
      "doc_raw": "Resolve search root path, raising descriptive errors on failure.\n\nThis function calls ``resolve_within_repo`` and converts generic file\nexceptions into domain-specific errors for consistent error handling.\n\nParameters\n----------\nrepo_root : Path\n    Repository root directory.\nrequested : str | None\n    Requested path (None = root).\n\nReturns\n-------\nPath\n    Resolved search root path.\n\nRaises\n------\nPathOutsideRepositoryError\n    If the resolved path escapes the repository root (raised by\n    ``resolve_within_repo``).\nPathNotFoundError\n    If the requested path does not exist within the repository.\nPathNotDirectoryError\n    If the resolved path exists but is not a directory.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.files.__all__",
      "short_name": "__all__",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.files.open_file",
      "short_name": "open_file",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "context",
          "kind": "positional_or_keyword",
          "annotated_type": "ApplicationContext",
          "default": null,
          "doc": null
        },
        {
          "name": "path",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "start_line",
          "kind": "positional_or_keyword",
          "annotated_type": "int | None",
          "default": "None",
          "doc": null
        },
        {
          "name": "end_line",
          "kind": "positional_or_keyword",
          "annotated_type": "int | None",
          "default": "None",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "dict",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Read file content with optional line slicing.",
      "doc_raw": "Read file content with optional line slicing.\n\nParameters\n----------\ncontext : ApplicationContext\n    Application context containing repo root and settings.\npath : str\n    File path relative to repo root.\nstart_line : int | None\n    Start line (1-indexed, inclusive). Must be positive when provided.\nend_line : int | None\n    End line (1-indexed, inclusive). Must be positive when provided.\n\nReturns\n-------\ndict\n    File content and metadata with keys: path, content, lines, size.\n\nRaises\n------\nPathNotFoundError\n    If the requested file does not exist or is not a regular file.\nFileReadError\n    If file is binary or has encoding issues.\nInvalidLineRangeError\n    If line range parameters are invalid.\n\nNotes\n-----\n``start_line`` and ``end_line`` are inclusive and 1-indexed. If both bounds\nare supplied then ``start_line`` must be less than or equal to ``end_line``.\nProviding a single bound slices from the start or through the end of the\nfile respectively.\n\nExamples\n--------\n>>> result = open_file(context, \"README.md\", start_line=1, end_line=10)\n>>> \"content\" in result\nTrue",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.files._create_file_entry",
      "short_name": "_create_file_entry",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "file_path",
          "kind": "keyword_only",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        },
        {
          "name": "repo_root",
          "kind": "keyword_only",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        },
        {
          "name": "includes",
          "kind": "keyword_only",
          "annotated_type": "list[str]",
          "default": null,
          "doc": null
        },
        {
          "name": "excludes",
          "kind": "keyword_only",
          "annotated_type": "list[str]",
          "default": null,
          "doc": null
        },
        {
          "name": "language_extensions",
          "kind": "keyword_only",
          "annotated_type": "set[str] | None",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "dict[str, object] | None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Return a file entry dict when filters accept the file.",
      "doc_raw": "Return a file entry dict when filters accept the file.\n\nChecks if a file path matches the provided include/exclude patterns and\nlanguage extensions. Returns a dictionary with file metadata if the file\npasses all filters, otherwise returns None.\n\nParameters\n----------\nfile_path : Path\n    Absolute path to the file being checked.\nrepo_root : Path\n    Root directory of the repository, used to compute relative paths.\nincludes : list[str]\n    List of glob patterns that the file path must match to be included.\n    Empty list means no inclusion filter is applied.\nexcludes : list[str]\n    List of glob patterns that the file path must not match to be included.\n    Empty list means no exclusion filter is applied.\nlanguage_extensions : set[str] | None\n    Set of file extensions (with leading dot) that the file must have.\n    If None, no language filter is applied.\n\nReturns\n-------\ndict[str, object] | None\n    Dictionary containing file metadata (path, relative_path, etc.) when\n    filters are satisfied, otherwise ``None``.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.files._prune_directories",
      "short_name": "_prune_directories",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "dirnames",
          "kind": "positional_or_keyword",
          "annotated_type": "list[str]",
          "default": null,
          "doc": null
        },
        {
          "name": "resolved_root",
          "kind": "positional_or_keyword",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        },
        {
          "name": "repo_root",
          "kind": "positional_or_keyword",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        },
        {
          "name": "excludes",
          "kind": "positional_or_keyword",
          "annotated_type": "list[str]",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.files._collect_filtered_paths",
      "short_name": "_collect_filtered_paths",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "search_root",
          "kind": "keyword_only",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        },
        {
          "name": "repo_root",
          "kind": "keyword_only",
          "annotated_type": "Path",
          "default": null,
          "doc": null
        },
        {
          "name": "filters",
          "kind": "keyword_only",
          "annotated_type": "DirectoryFilters",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "tuple[list[dict[str, object]], int, bool]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Walk directories and apply include/exclude filters.",
      "doc_raw": "Walk directories and apply include/exclude filters.\n\nParameters\n----------\nsearch_root : Path\n    Directory to start walking from.\nrepo_root : Path\n    Repository root directory.\nfilters : DirectoryFilters\n    Prepared include/exclude/language filters plus max results.\n\nReturns\n-------\ntuple[list[dict[str, object]], int, bool]\n    Tuple containing:\n    - items: List of file entries with path, size, and modified time\n    - matched_count: Total number of files that matched filters\n    - truncated: True if results were truncated due to max_results limit",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.files._list_paths_sync",
      "short_name": "_list_paths_sync",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "context",
          "kind": "positional_or_keyword",
          "annotated_type": "ApplicationContext",
          "default": null,
          "doc": null
        },
        {
          "name": "session_id",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "scope",
          "kind": "positional_or_keyword",
          "annotated_type": "ScopeIn | None",
          "default": null,
          "doc": null
        },
        {
          "name": "path",
          "kind": "positional_or_keyword",
          "annotated_type": "str | None",
          "default": "None",
          "doc": null
        },
        {
          "name": "filters",
          "kind": "positional_or_keyword",
          "annotated_type": "FileListFilters | None",
          "default": "None",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "dict",
        "doc": null
      },
      "raises": [],
      "doc_summary": "List files in repository (synchronous implementation).",
      "doc_raw": "List files in repository (synchronous implementation).\n\nSynchronous implementation of list_paths that performs the actual directory\ntraversal. This function runs in a threadpool when called from the async\n`list_paths` wrapper.\n\nParameters\n----------\ncontext : ApplicationContext\n    Application context containing repo root and settings.\nsession_id : str\n    Session identifier for logging and scope resolution.\nscope : ScopeIn | None\n    Session scope containing include/exclude globs and language filters.\n    Overridden by explicit ``include_globs`` and ``exclude_globs`` parameters.\npath : str | None\n    Starting path relative to repo root (None = root).\nfilters : FileListFilters | None\n    Filters for includes, excludes, language restrictions, and max results.\n    If None, default filters are used (no restrictions).\n\nReturns\n-------\ndict\n    File listing with paths and metadata.\n\nNotes\n-----\nExceptions raised by ``_resolve_search_root`` (PathNotFoundError,\nPathNotDirectoryError, PathOutsideRepositoryError) may propagate through\nthis function.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.files._normalize_list_paths_arguments",
      "short_name": "_normalize_list_paths_arguments",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "args",
          "kind": "positional_or_keyword",
          "annotated_type": "tuple[object, ...]",
          "default": null,
          "doc": null
        },
        {
          "name": "kwargs",
          "kind": "positional_or_keyword",
          "annotated_type": "dict[str, object]",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "tuple[str | None, list[str] | None, list[str] | None, list[str] | None, int]",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.files.list_paths",
      "short_name": "list_paths",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "context",
          "kind": "positional_or_keyword",
          "annotated_type": "ApplicationContext",
          "default": null,
          "doc": null
        },
        {
          "name": "args",
          "kind": "var_positional",
          "annotated_type": "object",
          "default": "()",
          "doc": null
        },
        {
          "name": "kwargs",
          "kind": "var_keyword",
          "annotated_type": "object",
          "default": "{}",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "dict",
        "doc": null
      },
      "raises": [],
      "doc_summary": "List files in repository (async with threadpool offload).",
      "doc_raw": "List files in repository (async with threadpool offload).\n\nApplies session scope filters (include_globs, exclude_globs, languages) if\nset via `set_scope`. Explicit parameters override session scope.\n\nThis function runs the blocking directory traversal in a threadpool via\n`asyncio.to_thread` to prevent blocking the event loop. This enables\nconcurrent file listing operations without thread exhaustion.\n\nParameters\n----------\ncontext : ApplicationContext\n    Application context containing repo root and settings.\n*args : object\n    Positional arguments (up to 5): path, include_globs, exclude_globs, languages, max_results.\n    Positional arguments are supported for backward compatibility but keyword\n    arguments are preferred.\n**kwargs : object\n    Keyword arguments accepted:\n    - path : str | None\n        Starting path relative to repo root (None = root).\n    - include_globs : list[str] | None\n        Glob patterns to include (e.g., [\"*.py\"]).\n        Overrides session scope if provided.\n    - exclude_globs : list[str] | None\n        Glob patterns to exclude (e.g., [\"__pycache__\", \"*.pyc\"]).\n        Overrides session scope if provided.\n    - languages : list[str] | None\n        Programming languages to include (overrides session scope when provided).\n    - max_results : int\n        Maximum number of files to return (default: 1000).\n\nReturns\n-------\ndict\n    File listing with paths and metadata.\n\nExamples\n--------\nBasic usage:\n\n>>> result = list_paths(context, path=\"src\", include_globs=[\"*.py\"])\n>>> isinstance(result[\"items\"], list)\nTrue\n\nWith session scope:\n\n>>> set_scope(context, {\"languages\": [\"python\"], \"include_globs\": [\"src/**\"]})\n>>> result = list_paths(context, path=None)\n>>> # Returns only Python files in src/ directory\n\nExplicit parameters override scope:\n\n>>> set_scope(context, {\"languages\": [\"python\"]})\n>>> result = list_paths(context, include_globs=[\"**/*.ts\"])\n>>> # Returns TypeScript files (explicit override), not Python\n\nNotes\n-----\nAsync Pattern:\n- The blocking directory traversal runs in a threadpool via `asyncio.to_thread`.\n- This prevents blocking the event loop and enables concurrent operations.\n- The sync implementation (`_list_paths_sync`) contains the actual logic.\n\nScope Integration:\n- Session scope is retrieved from registry using session ID (set by middleware).\n- Scope's `include_globs` and `exclude_globs` are merged with explicit parameters.\n- Explicit parameters take precedence over scope (explicit wins).\n- Scope's `languages` filter is applied after directory traversal (post-filtering).\n- If no scope is set, behaves as before (no filtering beyond explicit params).\n\nThe traversal skips directories that match the default or user supplied\nexclusion globs (for example ``**/.git/**``) so that large dependency\nfolders are pruned without visiting their contents.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.files.set_scope",
      "short_name": "set_scope",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "context",
          "kind": "positional_or_keyword",
          "annotated_type": "ApplicationContext",
          "default": null,
          "doc": null
        },
        {
          "name": "scope",
          "kind": "positional_or_keyword",
          "annotated_type": "ScopeIn",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "dict",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Set query scope for subsequent operations.",
      "doc_raw": "Set query scope for subsequent operations.\n\nStores scope in the session-scoped registry keyed by session ID. Subsequent\nqueries within the same session automatically apply these constraints.\n\nParameters\n----------\ncontext : ApplicationContext\n    Application context containing scope registry.\nscope : ScopeIn\n    Scope configuration with repos, branches, paths, languages.\n\nReturns\n-------\ndict\n    Confirmation with effective scope and session ID.\n\nExamples\n--------\n>>> result = set_scope(context, {\"languages\": [\"python\"], \"include_globs\": [\"src/**\"]})\n>>> result[\"status\"]\n'ok'\n>>> result[\"session_id\"]  # UUID format\n'abc123...'\n>>> result[\"effective_scope\"][\"languages\"]\n['python']\n\nNotes\n-----\nThe session ID is extracted from the request context (set by middleware).\nIf no session ID is available, this function will raise RuntimeError.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.files.DirectoryFilters",
      "short_name": "DirectoryFilters",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "dataclass(frozen=True)"
      ],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "includes",
          "kind": "positional_or_keyword",
          "annotated_type": "list[str]",
          "default": null,
          "doc": null
        },
        {
          "name": "excludes",
          "kind": "positional_or_keyword",
          "annotated_type": "list[str]",
          "default": null,
          "doc": null
        },
        {
          "name": "language_extensions",
          "kind": "positional_or_keyword",
          "annotated_type": "set[str] | None",
          "default": null,
          "doc": null
        },
        {
          "name": "max_results",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Prepared filters used during directory traversal.",
      "doc_raw": "Prepared filters used during directory traversal.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.files.DirectoryFilters.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "includes",
          "kind": "positional_or_keyword",
          "annotated_type": "list[str]",
          "default": null,
          "doc": null
        },
        {
          "name": "excludes",
          "kind": "positional_or_keyword",
          "annotated_type": "list[str]",
          "default": null,
          "doc": null
        },
        {
          "name": "language_extensions",
          "kind": "positional_or_keyword",
          "annotated_type": "set[str] | None",
          "default": null,
          "doc": null
        },
        {
          "name": "max_results",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.files.DirectoryFilters.max_results",
      "short_name": "max_results",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.files.DirectoryFilters.language_extensions",
      "short_name": "language_extensions",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.files.DirectoryFilters.excludes",
      "short_name": "excludes",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.files.DirectoryFilters.includes",
      "short_name": "includes",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.files.FileListFilters",
      "short_name": "FileListFilters",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "dataclass(frozen=True)"
      ],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "include_globs",
          "kind": "positional_or_keyword",
          "annotated_type": "list[str] | None",
          "default": "None",
          "doc": null
        },
        {
          "name": "exclude_globs",
          "kind": "positional_or_keyword",
          "annotated_type": "list[str] | None",
          "default": "None",
          "doc": null
        },
        {
          "name": "languages",
          "kind": "positional_or_keyword",
          "annotated_type": "list[str] | None",
          "default": "None",
          "doc": null
        },
        {
          "name": "max_results",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": "1000",
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Configuration for file listing filters.",
      "doc_raw": "Configuration for file listing filters.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.files.FileListFilters.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "include_globs",
          "kind": "positional_or_keyword",
          "annotated_type": "list[str] | None",
          "default": "None",
          "doc": null
        },
        {
          "name": "exclude_globs",
          "kind": "positional_or_keyword",
          "annotated_type": "list[str] | None",
          "default": "None",
          "doc": null
        },
        {
          "name": "languages",
          "kind": "positional_or_keyword",
          "annotated_type": "list[str] | None",
          "default": "None",
          "doc": null
        },
        {
          "name": "max_results",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": "1000",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.files.FileListFilters.max_results",
      "short_name": "max_results",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.files.FileListFilters.languages",
      "short_name": "languages",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.files.FileListFilters.exclude_globs",
      "short_name": "exclude_globs",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.files.FileListFilters.include_globs",
      "short_name": "include_globs",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.files.LOGGER",
      "short_name": "LOGGER",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic",
      "short_name": "semantic",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Semantic search adapter using FAISS GPU and DuckDB.",
      "doc_raw": "Semantic search adapter using FAISS GPU and DuckDB.\n\nImplements semantic code search by embedding queries and searching\nthe FAISS index, then hydrating results from DuckDB.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic.__all__",
      "short_name": "__all__",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic._build_response_extras",
      "short_name": "_build_response_extras",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "context",
          "kind": "positional_or_keyword",
          "annotated_type": "_MethodContext",
          "default": null,
          "doc": null
        },
        {
          "name": "limits",
          "kind": "positional_or_keyword",
          "annotated_type": "Sequence[str]",
          "default": null,
          "doc": null
        },
        {
          "name": "scope",
          "kind": "positional_or_keyword",
          "annotated_type": "ScopeIn | None",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "dict[str, object]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Build extras payload including method metadata and optional scope.",
      "doc_raw": "Build extras payload including method metadata and optional scope.\n\nParameters\n----------\ncontext : _MethodContext\n    Context values required to build method metadata.\nlimits : Sequence[str]\n    Search limitations or warnings.\nscope : ScopeIn | None\n    Optional scope configuration to include in extras.\n\nReturns\n-------\ndict[str, object]\n    Extras payload dictionary containing method metadata and optional scope.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic._success_extras",
      "short_name": "_success_extras",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "limits",
          "kind": "positional_or_keyword",
          "annotated_type": "Sequence[str]",
          "default": null,
          "doc": null
        },
        {
          "name": "method",
          "kind": "positional_or_keyword",
          "annotated_type": "MethodInfo",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "dict[str, object]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Build a success extras payload with optional limits metadata.",
      "doc_raw": "Build a success extras payload with optional limits metadata.\n\nParameters\n----------\nlimits : Sequence[str]\n    Search limitations or warnings.\nmethod : MethodInfo\n    Retrieval metadata to include in the response.\n\nReturns\n-------\ndict[str, object]\n    Extras payload including method metadata and optional limits.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic._make_envelope",
      "short_name": "_make_envelope",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "findings",
          "kind": "keyword_only",
          "annotated_type": "Sequence[Finding]",
          "default": null,
          "doc": null
        },
        {
          "name": "answer",
          "kind": "keyword_only",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "confidence",
          "kind": "keyword_only",
          "annotated_type": "float",
          "default": null,
          "doc": null
        },
        {
          "name": "extras",
          "kind": "keyword_only",
          "annotated_type": "dict[str, object] | None",
          "default": "None",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "AnswerEnvelope",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Construct an AnswerEnvelope with optional metadata.",
      "doc_raw": "Construct an AnswerEnvelope with optional metadata.\n\nParameters\n----------\nfindings : Sequence[Finding]\n    Search findings.\nanswer : str\n    Answer text.\nconfidence : float\n    Confidence score (0.0 to 1.0).\nextras : dict[str, object] | None, optional\n    Additional envelope fields (for example ``limits``, ``method``, or\n    ``problem`` metadata). Defaults to None.\n\nReturns\n-------\nAnswerEnvelope\n    Response payload ready for MCP clients.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic._build_method",
      "short_name": "_build_method",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "findings_count",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "requested_limit",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "effective_limit",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "start_time",
          "kind": "positional_or_keyword",
          "annotated_type": "float",
          "default": null,
          "doc": null
        },
        {
          "name": "retrieval_channels",
          "kind": "positional_or_keyword",
          "annotated_type": "Sequence[str]",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "MethodInfo",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Build method metadata for the response.",
      "doc_raw": "Build method metadata for the response.\n\nParameters\n----------\nfindings_count : int\n    Number of findings returned.\nrequested_limit : int\n    Requested result limit.\neffective_limit : int\n    Effective limit applied after clamping.\nstart_time : float\n    Search start time (monotonic clock).\nretrieval_channels : Sequence[str]\n    Retrieval systems that contributed to the final result set.\n\nReturns\n-------\nMethodInfo\n    Retrieval metadata describing semantic search coverage.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic._hydrate_findings",
      "short_name": "_hydrate_findings",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "context",
          "kind": "positional_or_keyword",
          "annotated_type": "ApplicationContext",
          "default": null,
          "doc": null
        },
        {
          "name": "chunk_ids",
          "kind": "positional_or_keyword",
          "annotated_type": "Sequence[int]",
          "default": null,
          "doc": null
        },
        {
          "name": "scores",
          "kind": "positional_or_keyword",
          "annotated_type": "Sequence[float]",
          "default": null,
          "doc": null
        },
        {
          "name": "scope",
          "kind": "keyword_only",
          "annotated_type": "ScopeIn | None",
          "default": "None",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "tuple[list[Finding], Exception | None]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Hydrate FAISS search results from DuckDB.",
      "doc_raw": "Hydrate FAISS search results from DuckDB.\n\nApplies scope filters (path globs, languages) during chunk hydration if scope\nis provided. FAISS search is performed without scope constraints, then results\nare filtered via DuckDB catalog queries.\n\nParameters\n----------\ncontext : ApplicationContext\n    Application context for accessing DuckDB catalog.\nchunk_ids : Sequence[int]\n    Chunk identifiers from FAISS search.\nscores : Sequence[float]\n    Similarity scores aligned with chunk_ids.\nscope : ScopeIn | None, optional\n    Session scope with optional `include_globs`, `exclude_globs`, and `languages`\n    fields. If provided and contains filters, uses `query_by_filters` instead of\n    `query_by_ids`. Defaults to None.\n\nReturns\n-------\ntuple[list[Finding], Exception | None]\n    Findings constructed from the catalog and optional hydration exception.\n\nNotes\n-----\nScope Filtering:\n- If scope has `include_globs`, `exclude_globs`, or `languages`, uses\n  `catalog.query_by_filters()` to filter chunks by path patterns and file\n  extensions.\n- If scope is None or has no filters, uses `catalog.query_by_ids()` for\n  unfiltered retrieval (backward compatible).\n- Filtering happens during DuckDB hydration (post-FAISS), so FAISS search\n  may return more IDs than needed to compensate for filtering.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic._run_faiss_search",
      "short_name": "_run_faiss_search",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "faiss_mgr",
          "kind": "positional_or_keyword",
          "annotated_type": "FAISSManager",
          "default": null,
          "doc": null
        },
        {
          "name": "query_vector",
          "kind": "positional_or_keyword",
          "annotated_type": "NDArrayF32",
          "default": null,
          "doc": null
        },
        {
          "name": "limit",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "nprobe",
          "kind": "keyword_only",
          "annotated_type": "int",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "tuple[list[int], list[float], Exception | None]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Execute FAISS search and return result identifiers and scores.",
      "doc_raw": "Execute FAISS search and return result identifiers and scores.\n\nParameters\n----------\nfaiss_mgr : FAISSManager\n    FAISS index manager instance.\nquery_vector : NDArrayF32\n    Query vector of shape (1, vec_dim).\nlimit : int\n    Maximum number of results to return.\nnprobe : int\n    Number of IVF cells to probe during the search. Higher values improve\n    recall at the cost of latency. Passed directly to\n    :meth:`FAISSManager.search`.\n\nReturns\n-------\ntuple[list[int], list[float], Exception | None]\n    Tuple of (chunk_ids, distances, error). ``error`` is ``None`` when the\n    search succeeds; otherwise it contains the triggering exception.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic._embed_query",
      "short_name": "_embed_query",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "client",
          "kind": "positional_or_keyword",
          "annotated_type": "VLLMClient",
          "default": null,
          "doc": null
        },
        {
          "name": "query",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "tuple[NDArrayF32 | None, str | None]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Embed query text and return a normalized vector and error message.",
      "doc_raw": "Embed query text and return a normalized vector and error message.\n\nParameters\n----------\nclient : VLLMClient\n    vLLM client for generating embeddings.\nquery : str\n    Query text to embed.\n\nReturns\n-------\ntuple[NDArrayF32 | None, str | None]\n    Pair of (query_vector, error_message). Exactly one element will be ``None``.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic._annotate_hybrid_contributions",
      "short_name": "_annotate_hybrid_contributions",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "findings",
          "kind": "positional_or_keyword",
          "annotated_type": "list[Finding]",
          "default": null,
          "doc": null
        },
        {
          "name": "contribution_map",
          "kind": "positional_or_keyword",
          "annotated_type": "dict[int, list[tuple[str, int, float]]] | None",
          "default": null,
          "doc": null
        },
        {
          "name": "rrf_k",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Attach hybrid contribution narratives to findings when available.",
      "doc_raw": "Attach hybrid contribution narratives to findings when available.\n\nParameters\n----------\nfindings : list[Finding]\n    Findings returned to the client.\ncontribution_map : dict[int, list[tuple[str, int, float]]] | None\n    Contribution information keyed by chunk id.\nrrf_k : int\n    Reciprocal rank fusion parameter used for the narrative.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic._warn_scope_filter_reduction",
      "short_name": "_warn_scope_filter_reduction",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "scope",
          "kind": "positional_or_keyword",
          "annotated_type": "ScopeIn | None",
          "default": null,
          "doc": null
        },
        {
          "name": "scope_flags",
          "kind": "positional_or_keyword",
          "annotated_type": "_ScopeFilterFlags",
          "default": null,
          "doc": null
        },
        {
          "name": "findings_count",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "effective_limit",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "faiss_result_count",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Log when scope filtering reduces the result set below the requested limit.",
      "doc_raw": "Log when scope filtering reduces the result set below the requested limit.\n\nParameters\n----------\nscope : ScopeIn | None\n    Applied scope configuration.\nscope_flags : _ScopeFilterFlags\n    Flags describing the active scope filters.\nfindings_count : int\n    Number of findings returned to the client.\neffective_limit : int\n    Limit applied after clamping.\nfaiss_result_count : int\n    Number of results returned from FAISS prior to filtering.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic._ensure_hydration_success",
      "short_name": "_ensure_hydration_success",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "hydrate_exc",
          "kind": "positional_or_keyword",
          "annotated_type": "Exception | None",
          "default": null,
          "doc": null
        },
        {
          "name": "observation",
          "kind": "positional_or_keyword",
          "annotated_type": "Observation",
          "default": null,
          "doc": null
        },
        {
          "name": "context",
          "kind": "positional_or_keyword",
          "annotated_type": "ApplicationContext",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Stop execution when DuckDB hydration fails.",
      "doc_raw": "Stop execution when DuckDB hydration fails.\n\nParameters\n----------\nhydrate_exc : Exception | None\n    Exception returned from ``_hydrate_findings``.\nobservation : Observation\n    Observation used to mark the duration as failed.\ncontext : ApplicationContext\n    Context for building error metadata.\n\nRaises\n------\nVectorSearchError\n    If hydration fails.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic._run_faiss_search_or_raise",
      "short_name": "_run_faiss_search_or_raise",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "context",
          "kind": "positional_or_keyword",
          "annotated_type": "ApplicationContext",
          "default": null,
          "doc": null
        },
        {
          "name": "query_vector",
          "kind": "positional_or_keyword",
          "annotated_type": "NDArrayF32",
          "default": null,
          "doc": null
        },
        {
          "name": "limit",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "nprobe",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "observation",
          "kind": "positional_or_keyword",
          "annotated_type": "Observation",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "tuple[list[int], list[float]]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Perform FAISS search and raise when the index search fails.",
      "doc_raw": "Perform FAISS search and raise when the index search fails.\n\nParameters\n----------\ncontext : ApplicationContext\n    Application context providing the FAISS manager and metadata.\nquery_vector : NDArrayF32\n    Query vector produced by the embedding service.\nlimit : int\n    Requested fan-out.\nnprobe : int\n    Number of IVF cells to probe.\nobservation : Observation\n    Observation block used to mark errors.\n\nReturns\n-------\ntuple[list[int], list[float]]\n    Chunk identifiers and their similarity scores.\n\nRaises\n------\nVectorSearchError\n    If FAISS search fails.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic._embed_query_or_raise",
      "short_name": "_embed_query_or_raise",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "client",
          "kind": "positional_or_keyword",
          "annotated_type": "VLLMClient",
          "default": null,
          "doc": null
        },
        {
          "name": "query",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "observation",
          "kind": "positional_or_keyword",
          "annotated_type": "Observation",
          "default": null,
          "doc": null
        },
        {
          "name": "vllm_url",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "NDArrayF32",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Embed text or raise with a structured embedding error.",
      "doc_raw": "Embed text or raise with a structured embedding error.\n\nParameters\n----------\nclient : VLLMClient\n    vLLM client used to emit the embedding.\nquery : str\n    Query text to embed.\nobservation : Observation\n    Duration observation used for marking failure.\nvllm_url : str\n    URL used for diagnostics in error contexts.\n\nReturns\n-------\nNDArrayF32\n    Normalized query vector with shape (1, dim).\n\nRaises\n------\nEmbeddingError\n    If embedding fails or service is unavailable.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic._build_hybrid_result",
      "short_name": "_build_hybrid_result",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "hydration_ids",
          "kind": "positional_or_keyword",
          "annotated_type": "list[int]",
          "default": null,
          "doc": null
        },
        {
          "name": "hydration_scores",
          "kind": "positional_or_keyword",
          "annotated_type": "list[float]",
          "default": null,
          "doc": null
        },
        {
          "name": "limit",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "contribution_map",
          "kind": "positional_or_keyword",
          "annotated_type": "dict[int, list[tuple[str, int, float]]] | None",
          "default": null,
          "doc": null
        },
        {
          "name": "retrieval_channels",
          "kind": "positional_or_keyword",
          "annotated_type": "Sequence[str]",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "_HybridResult",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Trim FAISS/hybrid candidates to the effective limit.",
      "doc_raw": "Trim FAISS/hybrid candidates to the effective limit.\n\nParameters\n----------\nhydration_ids : list[int]\n    Candidate IDs to trim.\nhydration_scores : list[float]\n    Candidate scores corresponding to IDs.\nlimit : int\n    Maximum number of results to return.\ncontribution_map : dict[int, list[tuple[str, int, float]]] | None\n    Optional contribution map for hybrid results.\nretrieval_channels : Sequence[str]\n    List of retrieval channels used.\n\nReturns\n-------\n_HybridResult\n    Trimmed result with IDs, scores, contribution map, and channels.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic._resolve_hybrid_results",
      "short_name": "_resolve_hybrid_results",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "context",
          "kind": "positional_or_keyword",
          "annotated_type": "ApplicationContext",
          "default": null,
          "doc": null
        },
        {
          "name": "state",
          "kind": "positional_or_keyword",
          "annotated_type": "_HybridSearchState",
          "default": null,
          "doc": null
        },
        {
          "name": "limits_metadata",
          "kind": "positional_or_keyword",
          "annotated_type": "list[str]",
          "default": null,
          "doc": null
        },
        {
          "name": "retrieval_channels",
          "kind": "positional_or_keyword",
          "annotated_type": "Sequence[str]",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "_HybridResult",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Join hybrid retrieval results with the FAISS output when available.",
      "doc_raw": "Join hybrid retrieval results with the FAISS output when available.\n\nParameters\n----------\ncontext : ApplicationContext\n    Application context that can provide the hybrid search engine.\nstate : _HybridSearchState\n    FAISS search state carrying IDs, scores, query text, and applied limit.\nlimits_metadata : list[str]\n    Mutable metadata bucket for reporting search limitations.\nretrieval_channels : Sequence[str]\n    Base retrieval channels (semantic + FAISS).\n\nReturns\n-------\n_HybridResult\n    Hydration IDs, scores, optional hybrid contributions, and the final list of\n    retrieval channels that contributed to the answer.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic._overfetch_bonus",
      "short_name": "_overfetch_bonus",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "effective_limit",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "scope_flags",
          "kind": "positional_or_keyword",
          "annotated_type": "_ScopeFilterFlags",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "int",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Determine additional fan-out when scope filters may drop results.",
      "doc_raw": "Determine additional fan-out when scope filters may drop results.\n\nCalculates an over-fetch bonus to compensate for results that may be filtered\nout by scope filters (include/exclude globs, language filters). The bonus\nis higher when multiple filter types are active, as more results are likely\nto be filtered out.\n\nParameters\n----------\neffective_limit : int\n    Base number of results requested by the user.\nscope_flags : _ScopeFilterFlags\n    Flags indicating which types of scope filters are active (include globs,\n    exclude globs, language filters).\n\nReturns\n-------\nint\n    Additional results to fetch beyond effective_limit to account for filtering.\n    Returns effective_limit when both glob and language filters are active,\n    effective_limit // 2 when only one type is active, or 0 when no filters\n    are active.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic._calculate_faiss_fanout",
      "short_name": "_calculate_faiss_fanout",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "effective_limit",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "max_results",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "multiplier",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "scope_flags",
          "kind": "positional_or_keyword",
          "annotated_type": "_ScopeFilterFlags",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "_FaissFanout",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Compute FAISS fan-out (k) and the target expansion for filtering.",
      "doc_raw": "Compute FAISS fan-out (k) and the target expansion for filtering.\n\nParameters\n----------\neffective_limit : int\n    Limit after applying clamping rules.\nmax_results : int\n    System-wide cap on FAISS results.\nmultiplier : int\n    Semantic over-fetch multiplier configured in settings.\nscope_flags : _ScopeFilterFlags\n    Flags describing whether scope filters are active.\n\nReturns\n-------\n_FaissFanout\n    Fan-out plan containing both the actual FAISS ``k`` and the unclamped\n    ``k`` target prior to ``max_results`` enforcement.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic._build_search_budget",
      "short_name": "_build_search_budget",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "context",
          "kind": "positional_or_keyword",
          "annotated_type": "ApplicationContext",
          "default": null,
          "doc": null
        },
        {
          "name": "requested_limit",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "observation",
          "kind": "positional_or_keyword",
          "annotated_type": "Observation",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "_SearchBudget",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Combine limit clamping and FAISS readiness metadata for a search.",
      "doc_raw": "Combine limit clamping and FAISS readiness metadata for a search.\n\nParameters\n----------\ncontext : ApplicationContext\n    Application context providing settings and FAISS manager.\nrequested_limit : int\n    Requested result limit from client.\nobservation : Observation\n    Observation block used to mark errors.\n\nReturns\n-------\n_SearchBudget\n    Search budget containing effective limit, max results, and limits metadata.\n\nRaises\n------\nVectorSearchError\n    If FAISS index is not ready or unavailable.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic._clamp_result_limit",
      "short_name": "_clamp_result_limit",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "requested_limit",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "max_results",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "tuple[int, list[str]]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Enforce bounds on requested limit with explanatory metadata.",
      "doc_raw": "Enforce bounds on requested limit with explanatory metadata.\n\nParameters\n----------\nrequested_limit : int\n    Client supplied limit from the API call.\nmax_results : int\n    Globally configured maximum number of results.\n\nReturns\n-------\ntuple[int, list[str]]\n    Adjusted limit and zero or more informational messages describing why\n    truncation occurred.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic._semantic_search_sync",
      "short_name": "_semantic_search_sync",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "context",
          "kind": "positional_or_keyword",
          "annotated_type": "ApplicationContext",
          "default": null,
          "doc": null
        },
        {
          "name": "query",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "limit",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "session_id",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "scope",
          "kind": "positional_or_keyword",
          "annotated_type": "ScopeIn | None",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "AnswerEnvelope",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic.semantic_search",
      "short_name": "semantic_search",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "context",
          "kind": "positional_or_keyword",
          "annotated_type": "ApplicationContext",
          "default": null,
          "doc": null
        },
        {
          "name": "query",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "limit",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": "20",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "AnswerEnvelope",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Perform semantic search using embeddings.",
      "doc_raw": "Perform semantic search using embeddings.\n\nApplies session scope filters during DuckDB hydration (if scope has path/language\nconstraints). FAISS search is performed without scope constraints (FAISS has no\nbuilt-in filtering), then results are filtered via DuckDB catalog queries.\n\nParameters\n----------\ncontext : ApplicationContext\n    Application context containing FAISS manager, vLLM client, and settings.\nquery : str\n    Search query text.\nlimit : int, optional\n    Maximum number of results to return. Defaults to 20.\n\nReturns\n-------\nAnswerEnvelope\n    Semantic search response payload with findings and applied scope.\n\nNotes\n-----\nThis function delegates to ``_semantic_search_sync`` which may raise\n``VectorSearchError`` or ``EmbeddingError``. Those exceptions are not\nexplicitly caught or re-raised by this async wrapper function.\n\nExamples\n--------\nBasic usage:\n\n>>> result = await semantic_search(context, \"data processing\")\n>>> isinstance(result[\"findings\"], list)\nTrue\n\nWith session scope:\n\n>>> set_scope(context, {\"languages\": [\"python\"], \"include_globs\": [\"src/**\"]})\n>>> result = await semantic_search(context, \"data processing\")\n>>> # Returns only Python chunks from src/ directory\n>>> result[\"scope\"][\"languages\"]\n['python']\n\nNotes\n-----\nScope Integration:\n- Session scope is retrieved from registry using session ID (set by middleware).\n- FAISS search is performed without scope constraints (FAISS has no built-in filtering).\n- Chunk IDs from FAISS are filtered via DuckDB catalog using scope's `include_globs`,\n  `exclude_globs`, and `languages` (see `query_by_filters` method).\n- Applied scope is included in response envelope (`scope` field) for transparency.\n- If no scope is set, searches all indexed chunks without filtering.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic._MethodContext",
      "short_name": "_MethodContext",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "dataclass(frozen=True)"
      ],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "findings_count",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "requested_limit",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "effective_limit",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "start_time",
          "kind": "positional_or_keyword",
          "annotated_type": "float",
          "default": null,
          "doc": null
        },
        {
          "name": "retrieval_channels",
          "kind": "positional_or_keyword",
          "annotated_type": "Sequence[str]",
          "default": null,
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Inputs required to build method metadata.",
      "doc_raw": "Inputs required to build method metadata.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic._MethodContext.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "findings_count",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "requested_limit",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "effective_limit",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "start_time",
          "kind": "positional_or_keyword",
          "annotated_type": "float",
          "default": null,
          "doc": null
        },
        {
          "name": "retrieval_channels",
          "kind": "positional_or_keyword",
          "annotated_type": "Sequence[str]",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic._MethodContext.retrieval_channels",
      "short_name": "retrieval_channels",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic._MethodContext.start_time",
      "short_name": "start_time",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic._MethodContext.effective_limit",
      "short_name": "effective_limit",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic._MethodContext.requested_limit",
      "short_name": "requested_limit",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic._MethodContext.findings_count",
      "short_name": "findings_count",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic._SearchBudget",
      "short_name": "_SearchBudget",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "dataclass(frozen=True)"
      ],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "effective_limit",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "max_results",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "limits_metadata",
          "kind": "positional_or_keyword",
          "annotated_type": "tuple[str, ...]",
          "default": null,
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Typed representation of the effective limit and metadata.",
      "doc_raw": "Typed representation of the effective limit and metadata.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic._SearchBudget.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "effective_limit",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "max_results",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "limits_metadata",
          "kind": "positional_or_keyword",
          "annotated_type": "tuple[str, ...]",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic._SearchBudget.limits_metadata",
      "short_name": "limits_metadata",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic._SearchBudget.max_results",
      "short_name": "max_results",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic._SearchBudget.effective_limit",
      "short_name": "effective_limit",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic._HybridResult",
      "short_name": "_HybridResult",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "dataclass(frozen=True)"
      ],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "hydration_ids",
          "kind": "positional_or_keyword",
          "annotated_type": "list[int]",
          "default": null,
          "doc": null
        },
        {
          "name": "hydration_scores",
          "kind": "positional_or_keyword",
          "annotated_type": "list[float]",
          "default": null,
          "doc": null
        },
        {
          "name": "contribution_map",
          "kind": "positional_or_keyword",
          "annotated_type": "dict[int, list[tuple[str, int, float]]] | None",
          "default": null,
          "doc": null
        },
        {
          "name": "retrieval_channels",
          "kind": "positional_or_keyword",
          "annotated_type": "list[str]",
          "default": null,
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Hydration payload returned after hybrid re-ranking.",
      "doc_raw": "Hydration payload returned after hybrid re-ranking.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic._HybridResult.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "hydration_ids",
          "kind": "positional_or_keyword",
          "annotated_type": "list[int]",
          "default": null,
          "doc": null
        },
        {
          "name": "hydration_scores",
          "kind": "positional_or_keyword",
          "annotated_type": "list[float]",
          "default": null,
          "doc": null
        },
        {
          "name": "contribution_map",
          "kind": "positional_or_keyword",
          "annotated_type": "dict[int, list[tuple[str, int, float]]] | None",
          "default": null,
          "doc": null
        },
        {
          "name": "retrieval_channels",
          "kind": "positional_or_keyword",
          "annotated_type": "list[str]",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic._HybridResult.retrieval_channels",
      "short_name": "retrieval_channels",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic._HybridResult.contribution_map",
      "short_name": "contribution_map",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic._HybridResult.hydration_scores",
      "short_name": "hydration_scores",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic._HybridResult.hydration_ids",
      "short_name": "hydration_ids",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic._HybridSearchState",
      "short_name": "_HybridSearchState",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "dataclass(frozen=True)"
      ],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "query",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "result_ids",
          "kind": "positional_or_keyword",
          "annotated_type": "Sequence[int]",
          "default": null,
          "doc": null
        },
        {
          "name": "result_scores",
          "kind": "positional_or_keyword",
          "annotated_type": "Sequence[float]",
          "default": null,
          "doc": null
        },
        {
          "name": "effective_limit",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Encapsulate the outputs of FAISS prior to hybrid re-ranking.",
      "doc_raw": "Encapsulate the outputs of FAISS prior to hybrid re-ranking.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic._HybridSearchState.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "query",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "result_ids",
          "kind": "positional_or_keyword",
          "annotated_type": "Sequence[int]",
          "default": null,
          "doc": null
        },
        {
          "name": "result_scores",
          "kind": "positional_or_keyword",
          "annotated_type": "Sequence[float]",
          "default": null,
          "doc": null
        },
        {
          "name": "effective_limit",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic._HybridSearchState.effective_limit",
      "short_name": "effective_limit",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic._HybridSearchState.result_scores",
      "short_name": "result_scores",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic._HybridSearchState.result_ids",
      "short_name": "result_ids",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic._HybridSearchState.query",
      "short_name": "query",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic._FaissFanout",
      "short_name": "_FaissFanout",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "dataclass(frozen=True)"
      ],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "faiss_k",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "faiss_k_target",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "FAISS fan-out plan produced for a semantic search request.",
      "doc_raw": "FAISS fan-out plan produced for a semantic search request.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic._FaissFanout.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "faiss_k",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "faiss_k_target",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic._FaissFanout.faiss_k_target",
      "short_name": "faiss_k_target",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic._FaissFanout.faiss_k",
      "short_name": "faiss_k",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic._ScopeFilterFlags",
      "short_name": "_ScopeFilterFlags",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "dataclass(frozen=True)"
      ],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "has_include_globs",
          "kind": "positional_or_keyword",
          "annotated_type": "bool",
          "default": null,
          "doc": null
        },
        {
          "name": "has_exclude_globs",
          "kind": "positional_or_keyword",
          "annotated_type": "bool",
          "default": null,
          "doc": null
        },
        {
          "name": "has_languages",
          "kind": "positional_or_keyword",
          "annotated_type": "bool",
          "default": null,
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Aggregated boolean flags describing the active scope filters.",
      "doc_raw": "Aggregated boolean flags describing the active scope filters.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic._ScopeFilterFlags.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "has_include_globs",
          "kind": "positional_or_keyword",
          "annotated_type": "bool",
          "default": null,
          "doc": null
        },
        {
          "name": "has_exclude_globs",
          "kind": "positional_or_keyword",
          "annotated_type": "bool",
          "default": null,
          "doc": null
        },
        {
          "name": "has_languages",
          "kind": "positional_or_keyword",
          "annotated_type": "bool",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic._ScopeFilterFlags.has_filters",
      "short_name": "has_filters",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Return ``True`` when any of the scope filters are active.",
      "doc_raw": "Return ``True`` when any of the scope filters are active.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic._ScopeFilterFlags.from_scope",
      "short_name": "from_scope",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "classmethod"
      ],
      "params": [
        {
          "name": "cls",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "scope",
          "kind": "positional_or_keyword",
          "annotated_type": "ScopeIn | None",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "_ScopeFilterFlags",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Create flags from an optional ``ScopeIn`` dictionary.",
      "doc_raw": "Create flags from an optional ``ScopeIn`` dictionary.\n\nParameters\n----------\nscope : ScopeIn | None\n    Optional scope dictionary containing include_globs, exclude_globs,\n    or languages keys.\n\nReturns\n-------\n_ScopeFilterFlags\n    Flags instance indicating which scope filters are present.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic._ScopeFilterFlags.has_languages",
      "short_name": "has_languages",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic._ScopeFilterFlags.has_exclude_globs",
      "short_name": "has_exclude_globs",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic._ScopeFilterFlags.has_include_globs",
      "short_name": "has_include_globs",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic.LOGGER",
      "short_name": "LOGGER",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic.COMPONENT_NAME",
      "short_name": "COMPONENT_NAME",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.semantic.SNIPPET_PREVIEW_CHARS",
      "short_name": "SNIPPET_PREVIEW_CHARS",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.adapters.__all__",
      "short_name": "__all__",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.retrieval",
      "short_name": "retrieval",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Retrieval utilities exposed via MCP tooling.",
      "doc_raw": "Retrieval utilities exposed via MCP tooling.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.retrieval.__all__",
      "short_name": "__all__",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.retrieval.xtr_cli",
      "short_name": "xtr_cli",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Typer CLI for building, verifying, and probing XTR artifacts.",
      "doc_raw": "Typer CLI for building, verifying, and probing XTR artifacts.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.retrieval.xtr_cli.main",
      "short_name": "main",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Execute the Typer app.",
      "doc_raw": "Execute the Typer app.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.retrieval.xtr_cli.search",
      "short_name": "search",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "app.command('search')"
      ],
      "params": [
        {
          "name": "query",
          "kind": "positional_or_keyword",
          "annotated_type": "_QueryArg",
          "default": null,
          "doc": null
        },
        {
          "name": "k",
          "kind": "positional_or_keyword",
          "annotated_type": "_KOption",
          "default": "5",
          "doc": null
        },
        {
          "name": "candidate_ids",
          "kind": "positional_or_keyword",
          "annotated_type": "_CandidateIdsOption",
          "default": "None",
          "doc": null
        },
        {
          "name": "explain",
          "kind": "positional_or_keyword",
          "annotated_type": "_ExplainOption",
          "default": "None",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Run a quick XTR search (wide or narrow depending on candidate ids).",
      "doc_raw": "Run a quick XTR search (wide or narrow depending on candidate ids).\n\nExtended Summary\n----------------\nThis CLI command performs XTR-based semantic search, supporting both wide-mode\n(index-wide search) and narrow-mode (rescoring Stage-0 candidates) depending on\nwhether candidate_ids are provided. It loads the XTR index, executes the search,\nand prints results to stdout. This is a utility command for testing and debugging\nXTR search functionality outside of the main MCP server.\n\nParameters\n----------\nquery : _QueryArg\n    Natural language query string to search for. Will be encoded into token\n    embeddings and used for MaxSim computation against the XTR index.\n    Type alias for ``Annotated[str, typer.Argument(...)]`` for CLI argument\n    specification. Provided as a positional argument via typer.\nk : _KOption, optional\n    Maximum number of top-k documents to return. Must be at least 1.\n    Defaults to 5. Type alias for ``Annotated[int, typer.Option(...)]`` for\n    CLI option specification. Provided as an option via typer (--k, -k).\ncandidate_ids : _CandidateIdsOption, optional\n    Optional list of Stage-0 candidate chunk IDs to rescore. If provided,\n    performs narrow-mode rescoring on these candidates only. If None, performs\n    wide-mode search across all chunks. Defaults to None. Type alias for\n    ``Annotated[list[int] | None, typer.Option(...)]`` for CLI option\n    specification. Provided as an option via typer (--candidate-id, -c).\nexplain : _ExplainOption, optional\n    Whether to include token-level attribution information in results. If True,\n    includes explainability data showing token alignments. If None, defaults\n    to True (explainability enabled). Type alias for\n    ``Annotated[bool | None, typer.Option(...)]`` for CLI option specification.\n    Provided as an option via typer.\n\nRaises\n------\ntyper.Exit\n    If XTR artifacts are missing and the command cannot run. This occurs when\n    the XTR index has not been built or is not ready for search operations.\n\nNotes\n-----\nTime complexity depends on search mode: O(N * T * D) for wide-mode where N is\ntotal chunks, T is tokens per chunk, D is embedding dimension; O(C * T * D) for\nnarrow-mode where C is candidate count. Space complexity O(k) for results.\nThe function performs file I/O to load the XTR index and GPU/CPU computation\nfor encoding and scoring. Not thread-safe due to index loading.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.retrieval.xtr_cli.verify",
      "short_name": "verify",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "app.command('verify')"
      ],
      "params": [],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Verify that XTR artifacts can be opened.",
      "doc_raw": "Verify that XTR artifacts can be opened.\n\nRaises\n------\ntyper.Exit\n    If artifacts are missing or unreadable.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.retrieval.xtr_cli.build",
      "short_name": "build",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "app.command('build')"
      ],
      "params": [],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Build token-level XTR artifacts from the DuckDB catalog.",
      "doc_raw": "Build token-level XTR artifacts from the DuckDB catalog.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.retrieval.xtr_cli._ExplainOption",
      "short_name": "_ExplainOption",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.retrieval.xtr_cli._CandidateIdsOption",
      "short_name": "_CandidateIdsOption",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.retrieval.xtr_cli._KOption",
      "short_name": "_KOption",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.retrieval.xtr_cli._QueryArg",
      "short_name": "_QueryArg",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.retrieval.xtr_cli.app",
      "short_name": "app",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.tools",
      "short_name": "tools",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Public tool exports for the CodeIntel MCP server.",
      "doc_raw": "Public tool exports for the CodeIntel MCP server.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.tools.gpu_doctor",
      "short_name": "gpu_doctor",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "GPU diagnostics script for PyTorch and FAISS.",
      "doc_raw": "GPU diagnostics script for PyTorch and FAISS.\n\nTiny GPU diagnostics for PyTorch and FAISS:\n- Initializes CUDA context\n- Runs a small GEMM in torch (cuBLAS path)\n- Runs a tiny FAISS-GPU search (GpuIndexFlatIP)\n\nExits non-zero if --require-gpu is set and a GPU isn't usable.\n\nUsage:\n    python -m codeintel_rev.mcp_server.tools.gpu_doctor\n    python -m codeintel_rev.mcp_server.tools.gpu_doctor --require-gpu\n    python -m codeintel_rev.mcp_server.tools.gpu_doctor --torch-only\n    python -m codeintel_rev.mcp_server.tools.gpu_doctor --faiss-only",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.tools.gpu_doctor.main",
      "short_name": "main",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Run GPU diagnostics and print results.",
      "doc_raw": "Run GPU diagnostics and print results.\n\nParses command-line arguments and runs GPU checks. Exits with non-zero\nstatus if --require-gpu is set and GPU is not usable.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.tools.gpu_doctor.check_faiss",
      "short_name": "check_faiss",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": {
        "annotated_type": "tuple[bool, dict[str, object]]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Check FAISS GPU availability and perform smoke test.",
      "doc_raw": "Check FAISS GPU availability and perform smoke test.\n\nReturns\n-------\ntuple[bool, dict[str, object]]\n    (success, info_dict) where info_dict contains diagnostic information.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.tools.gpu_doctor.check_torch",
      "short_name": "check_torch",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "device_index",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": "0",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "tuple[bool, dict[str, object]]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Check PyTorch CUDA availability and perform smoke test.",
      "doc_raw": "Check PyTorch CUDA availability and perform smoke test.\n\nParameters\n----------\ndevice_index : int, optional\n    CUDA device index to test (default: 0).\n\nReturns\n-------\ntuple[bool, dict[str, object]]\n    (success, info_dict) where info_dict contains diagnostic information.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.common",
      "short_name": "common",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Common utilities and shared code for MCP server adapters.",
      "doc_raw": "Common utilities and shared code for MCP server adapters.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.common.observability",
      "short_name": "observability",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Unified observability helpers for CodeIntel MCP adapters.",
      "doc_raw": "Unified observability helpers for CodeIntel MCP adapters.\n\nThe adapters previously duplicated more than sixty lines of metrics boilerplate.\nThis module centralises the logic, delegates to :mod:`kgfoundry_common`\nobservability primitives, and keeps behaviour backward compatible with existing\nPrometheus dashboards.\n\nExamples\n--------\nBasic usage in an adapter:\n\n>>> from codeintel_rev.mcp_server.common.observability import observe_duration\n>>> with observe_duration(\"search\", \"text_search\") as observation:\n...     result = perform_search()\n...     observation.mark_success()\n\nGraceful degradation when metrics are unavailable:\n\n>>> with observe_duration(\"semantic_search\", \"codeintel_mcp\") as observation:\n...     try:\n...         perform_semantic_search()\n...         observation.mark_success()\n...     except RuntimeError:\n...         observation.mark_error()\n...         raise",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.common.observability.observe_duration",
      "short_name": "observe_duration",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "contextmanager"
      ],
      "params": [
        {
          "name": "operation",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "component",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "metrics",
          "kind": "keyword_only",
          "annotated_type": "MetricsProvider | None",
          "default": "None",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "Iterator[Observation]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Yield a metrics observation with graceful degradation.",
      "doc_raw": "Yield a metrics observation with graceful degradation.\n\nParameters\n----------\noperation : str\n    Operation identifier, propagated to the ``operation`` metric label.\ncomponent : str\n    Component identifier, propagated to the ``component`` metric label.\nmetrics : MetricsProvider | None, optional\n    Metrics provider instance. When ``None`` (the default), the global\n    :class:`~kgfoundry_common.observability.MetricsProvider` singleton is\n    used.\n\nYields\n------\nObservation\n    Observation object supporting ``mark_success`` and ``mark_error``.\n\nNotes\n-----\n- Ensures label compatibility before attempting to record metrics.\n- Catches ``ValueError`` raised by the underlying observability helper and\n  falls back to a no-op observation.\n- Logging uses structured fields (``operation`` and ``component``) for\n  downstream correlation.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.common.observability.Observation",
      "short_name": "Observation",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [
        "Protocol"
      ],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Protocol describing the helpers provided by metrics observations.",
      "doc_raw": "Protocol describing the helpers provided by metrics observations.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.common.observability.Observation.mark_success",
      "short_name": "mark_success",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Mark the observation as successful.",
      "doc_raw": "Mark the observation as successful.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.common.observability.Observation.mark_error",
      "short_name": "mark_error",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Mark the observation as failed.",
      "doc_raw": "Mark the observation as failed.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.common.observability._NoopObservation",
      "short_name": "_NoopObservation",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Fallback observation used when metrics cannot be recorded.",
      "doc_raw": "Fallback observation used when metrics cannot be recorded.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.common.observability._NoopObservation.mark_success",
      "short_name": "mark_success",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Mark the observation as successful without recording metrics.",
      "doc_raw": "Mark the observation as successful without recording metrics.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.common.observability._NoopObservation.mark_error",
      "short_name": "mark_error",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Mark the observation as failed without recording metrics.",
      "doc_raw": "Mark the observation as failed without recording metrics.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.common.observability._supports_histogram_labels",
      "short_name": "_supports_histogram_labels",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "histogram",
          "kind": "positional_or_keyword",
          "annotated_type": "object",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "bool",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Return ``True`` when the histogram exposes label support.",
      "doc_raw": "Return ``True`` when the histogram exposes label support.\n\nParameters\n----------\nhistogram : object\n    Prometheus histogram instance or stub implementing ``_labelnames``.\n\nReturns\n-------\nbool\n    ``True`` when the histogram exposes at least one label, ``False`` when\n    labels are missing or the attribute cannot be inspected.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.common.observability.LOGGER",
      "short_name": "LOGGER",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.common.observability.__all__",
      "short_name": "__all__",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.server",
      "short_name": "server",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "FastMCP server with QueryScope tools.",
      "doc_raw": "FastMCP server with QueryScope tools.\n\nImplements full MCP tool catalog for code intelligence.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.server.__all__",
      "short_name": "__all__",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.server.build_http_app",
      "short_name": "build_http_app",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "capabilities",
          "kind": "positional_or_keyword",
          "annotated_type": "Capabilities",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "ASGIApp",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Return the FastMCP ASGI app with capability-gated tool registration.",
      "doc_raw": "Return the FastMCP ASGI app with capability-gated tool registration.\n\nReturns\n-------\nASGIApp\n    ASGI application implementing the MCP HTTP API.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.server.prompt_code_review",
      "short_name": "prompt_code_review",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "mcp.prompt()"
      ],
      "params": [
        {
          "name": "area",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "str",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Code review prompt template.",
      "doc_raw": "Code review prompt template.\n\nParameters\n----------\narea : str\n    Code area to review.\n\nReturns\n-------\nstr\n    Prompt template.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.server.file_resource",
      "short_name": "file_resource",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "mcp.resource('file://{path}')"
      ],
      "params": [
        {
          "name": "path",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "str",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Serve file content as resource.",
      "doc_raw": "Serve file content as resource.\n\nParameters\n----------\npath : str\n    File path.\n\nReturns\n-------\nstr\n    File content.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.server.file_history",
      "short_name": "file_history",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "mcp.tool()",
        "handle_adapter_errors(operation='git:file_history', empty_result={'commits': []})"
      ],
      "params": [
        {
          "name": "path",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "limit",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": "50",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "dict",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Get file commit history (async).",
      "doc_raw": "Get file commit history (async).\n\nError handling is automatic via decorator. All exceptions are caught\nand converted to unified error envelopes with Problem Details.\n\nParameters\n----------\npath : str\n    File path.\nlimit : int\n    Maximum commits.\n\nReturns\n-------\ndict\n    Commit history. On error, returns error envelope with empty result\n    fields and Problem Details.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.server.blame_range",
      "short_name": "blame_range",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "mcp.tool()",
        "handle_adapter_errors(operation='git:blame_range', empty_result={'blame': []})"
      ],
      "params": [
        {
          "name": "path",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "start_line",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "end_line",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "dict",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Git blame for line range (async).",
      "doc_raw": "Git blame for line range (async).\n\nError handling is automatic via decorator. All exceptions are caught\nand converted to unified error envelopes with Problem Details.\n\nParameters\n----------\npath : str\n    File path.\nstart_line : int\n    Start line (1-indexed).\nend_line : int\n    End line (1-indexed).\n\nReturns\n-------\ndict\n    Blame entries for each line. On error, returns error envelope with\n    empty result fields and Problem Details.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.server.search_text",
      "short_name": "search_text",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "mcp.tool()",
        "handle_adapter_errors(operation='search:text', empty_result={'matches': [], 'total': 0, 'truncated': False})"
      ],
      "params": [
        {
          "name": "query",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "regex",
          "kind": "keyword_only",
          "annotated_type": "bool",
          "default": "False",
          "doc": null
        },
        {
          "name": "case_sensitive",
          "kind": "keyword_only",
          "annotated_type": "bool",
          "default": "False",
          "doc": null
        },
        {
          "name": "paths",
          "kind": "keyword_only",
          "annotated_type": "list[str] | None",
          "default": "None",
          "doc": null
        },
        {
          "name": "max_results",
          "kind": "keyword_only",
          "annotated_type": "int",
          "default": "50",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "dict",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Fast text search (ripgrep-like).",
      "doc_raw": "Fast text search (ripgrep-like).\n\nError handling is automatic via decorator. All exceptions are caught\nand converted to unified error envelopes with Problem Details.\n\nParameters\n----------\nquery : str\n    Search query.\nregex : bool\n    Treat query as regex.\ncase_sensitive : bool\n    Case-sensitive search.\npaths : list[str] | None\n    Paths to search in.\nmax_results : int\n    Maximum results.\n\nReturns\n-------\ndict\n    Search matches. On error, returns error envelope with empty result\n    fields and Problem Details.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.server.open_file",
      "short_name": "open_file",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "mcp.tool()",
        "handle_adapter_errors(operation='files:open_file', empty_result={'path': '', 'content': '', 'lines': 0, 'size': 0})"
      ],
      "params": [
        {
          "name": "path",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "start_line",
          "kind": "positional_or_keyword",
          "annotated_type": "int | None",
          "default": "None",
          "doc": null
        },
        {
          "name": "end_line",
          "kind": "positional_or_keyword",
          "annotated_type": "int | None",
          "default": "None",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "dict",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Read file content.",
      "doc_raw": "Read file content.\n\nError handling is automatic via decorator. All exceptions are caught\nand converted to unified error envelopes with Problem Details.\n\nParameters\n----------\npath : str\n    File path.\nstart_line : int | None\n    Start line (1-indexed, inclusive).\nend_line : int | None\n    End line (1-indexed, inclusive).\n\nReturns\n-------\ndict\n    File content and metadata. On error, returns error envelope with\n    empty result fields and Problem Details.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.server.list_paths",
      "short_name": "list_paths",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "mcp.tool()",
        "handle_adapter_errors(operation='files:list_paths', empty_result={'items': [], 'total': 0, 'truncated': False})"
      ],
      "params": [
        {
          "name": "path",
          "kind": "positional_or_keyword",
          "annotated_type": "str | None",
          "default": "None",
          "doc": null
        },
        {
          "name": "include_globs",
          "kind": "positional_or_keyword",
          "annotated_type": "list[str] | None",
          "default": "None",
          "doc": null
        },
        {
          "name": "exclude_globs",
          "kind": "positional_or_keyword",
          "annotated_type": "list[str] | None",
          "default": "None",
          "doc": null
        },
        {
          "name": "languages",
          "kind": "positional_or_keyword",
          "annotated_type": "list[str] | None",
          "default": "None",
          "doc": null
        },
        {
          "name": "max_results",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": "1000",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "dict",
        "doc": null
      },
      "raises": [],
      "doc_summary": "List files in scope (async).",
      "doc_raw": "List files in scope (async).\n\nError handling is automatic via decorator. All exceptions are caught\nand converted to unified error envelopes with Problem Details.\n\nParameters\n----------\npath : str | None\n    Starting path (defaults to repo root).\ninclude_globs : list[str] | None\n    Glob patterns to include.\nexclude_globs : list[str] | None\n    Glob patterns to exclude.\nlanguages : list[str] | None\n    Programming languages to include.\nmax_results : int\n    Maximum results to return.\n\nReturns\n-------\ndict\n    File listing with paths. On error, returns error envelope with\n    empty result fields and Problem Details.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.server.set_scope",
      "short_name": "set_scope",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "mcp.tool()"
      ],
      "params": [
        {
          "name": "scope",
          "kind": "positional_or_keyword",
          "annotated_type": "ScopeIn",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "dict",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Set query scope for subsequent operations.",
      "doc_raw": "Set query scope for subsequent operations.\n\nParameters\n----------\nscope : ScopeIn\n    Scope parameters (repos, branches, paths, languages).\n\nReturns\n-------\ndict\n    Effective scope configuration.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.server.get_context",
      "short_name": "get_context",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": {
        "annotated_type": "ApplicationContext",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Extract ApplicationContext from context variable.",
      "doc_raw": "Extract ApplicationContext from context variable.\n\nThe context is set by middleware in main.py for each request.\nThis allows tool handlers to access ApplicationContext without\nrequiring Request injection (which FastMCP doesn't support).\n\nReturns\n-------\nApplicationContext\n    Application context for the current request.\n\nRaises\n------\nRuntimeError\n    If context is not initialized (should never happen after startup).",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.server.app_context",
      "short_name": "app_context",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.server.mcp",
      "short_name": "mcp",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.scope_utils",
      "short_name": "scope_utils",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Scope filtering and merging utilities for CodeIntel MCP.",
      "doc_raw": "Scope filtering and merging utilities for CodeIntel MCP.\n\nThis module provides helper functions for retrieving session scopes, merging them\nwith explicit adapter parameters, and applying path/language filters to search results.\n\nKey Functions\n-------------\nget_effective_scope : Retrieve session scope from registry\nmerge_scope_filters : Merge session scope with explicit parameters (explicit wins)\napply_path_filters : Filter paths using glob patterns (fnmatch)\napply_language_filter : Filter paths by programming language extension\npath_matches_glob : Test if path matches glob pattern\n\nDesign Principles\n-----------------\n- **Explicit Precedence**: Explicit adapter parameters always override session scope\n- **Fail-Safe**: Missing scope or empty filters return unfiltered results\n- **Cross-Platform**: Normalize path separators for Windows/Unix compatibility\n- **Performance**: Early-exit for empty filters to avoid unnecessary iterations\n\nExample Usage\n-------------\nRetrieve and merge scope in adapter:\n\n>>> from codeintel_rev.mcp_server.scope_utils import get_effective_scope, merge_scope_filters\n>>> session_id = get_session_id()\n>>> scope = get_effective_scope(context, session_id)\n>>> merged = merge_scope_filters(scope, {\"include_globs\": [\"src/**\"]})\n>>> # merged[\"include_globs\"] is now [\"src/**\"] (explicit overrides scope)\n\nFilter paths by glob patterns:\n\n>>> from codeintel_rev.mcp_server.scope_utils import apply_path_filters\n>>> paths = [\"src/main.py\", \"tests/test_main.py\", \"docs/README.md\"]\n>>> filtered = apply_path_filters(paths, include_globs=[\"**/*.py\"], exclude_globs=[\"**/test_*.py\"])\n>>> filtered\n['src/main.py']\n\nFilter paths by language:\n\n>>> from codeintel_rev.mcp_server.scope_utils import apply_language_filter\n>>> paths = [\"src/main.py\", \"src/app.ts\", \"README.md\"]\n>>> filtered = apply_language_filter(paths, [\"python\"])\n>>> filtered\n['src/main.py']\n\nSee Also\n--------\ncodeintel_rev.app.scope_store : ScopeStore for storing session scopes\ncodeintel_rev.app.middleware : get_session_id for retrieving session ID",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.scope_utils.__all__",
      "short_name": "__all__",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.scope_utils.path_matches_glob",
      "short_name": "path_matches_glob",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "path",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "pattern",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "bool",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Test if path matches glob pattern.",
      "doc_raw": "Test if path matches glob pattern.\n\nWrapper around fnmatch.fnmatchcase with path normalization for cross-platform\ncompatibility. Handles both simple patterns (*.py) and recursive patterns\n(**/*.py).\n\nParameters\n----------\npath : str\n    File path to test (typically relative to repo root).\npattern : str\n    Glob pattern (Unix shell-style).\n\nReturns\n-------\nbool\n    True if path matches pattern, False otherwise.\n\nExamples\n--------\nSimple suffix match:\n\n>>> path_matches_glob(\"test.py\", \"*.py\")\nTrue\n>>> path_matches_glob(\"test.ts\", \"*.py\")\nFalse\n\nRecursive pattern:\n\n>>> path_matches_glob(\"src/utils/helpers.py\", \"**/*.py\")\nTrue\n>>> path_matches_glob(\"README.md\", \"**/*.py\")\nFalse\n\nDirectory prefix:\n\n>>> path_matches_glob(\"src/main.py\", \"src/**\")\nTrue\n>>> path_matches_glob(\"lib/util.py\", \"src/**\")\nFalse\n\nNotes\n-----\nfnmatch treats `*` as matching any characters INCLUDING slashes, unlike\nsome glob implementations (e.g., bash) where `*` doesn't match `/`. This\nmakes `**/*.py` and `*/*.py` functionally equivalent in our implementation.\n\nFor more complex patterns (e.g., brace expansion {a,b}), consider using\nthe `wcmatch` library which supports advanced glob features.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.scope_utils.apply_language_filter",
      "short_name": "apply_language_filter",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "paths",
          "kind": "positional_or_keyword",
          "annotated_type": "list[str]",
          "default": null,
          "doc": null
        },
        {
          "name": "languages",
          "kind": "positional_or_keyword",
          "annotated_type": "list[str]",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "list[str]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Filter paths by programming language.",
      "doc_raw": "Filter paths by programming language.\n\nReturns only paths whose file extensions match the specified languages.\nUses LANGUAGE_EXTENSIONS mapping to resolve language names to extensions.\n\nParameters\n----------\npaths : list[str]\n    File paths to filter.\nlanguages : list[str]\n    Programming language names (e.g., [\"python\", \"typescript\"]).\n    Case-insensitive (normalized to lowercase).\n\nReturns\n-------\nlist[str]\n    Paths with extensions matching specified languages (order preserved).\n\nExamples\n--------\nFilter to Python files only:\n\n>>> paths = [\"src/main.py\", \"src/app.ts\", \"README.md\"]\n>>> filtered = apply_language_filter(paths, [\"python\"])\n>>> filtered\n['src/main.py']\n\nMultiple languages:\n\n>>> filtered = apply_language_filter(paths, [\"python\", \"typescript\"])\n>>> filtered\n['src/main.py', 'src/app.ts']\n\nUnknown language (no matches):\n\n>>> filtered = apply_language_filter(paths, [\"cobol\"])\n>>> filtered\n[]\n\nNotes\n-----\nLanguage names are case-insensitive: \"Python\", \"python\", \"PYTHON\" all work.\n\nIf a language is not in LANGUAGE_EXTENSIONS, it's silently ignored (no\nerror raised). This allows forward compatibility if new languages are added\nto the mapping later.\n\nExtension matching is case-sensitive: \".PY\" will NOT match Python (use\nlowercase extensions in path normalization if needed).",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.scope_utils.apply_path_filters",
      "short_name": "apply_path_filters",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "paths",
          "kind": "positional_or_keyword",
          "annotated_type": "list[str]",
          "default": null,
          "doc": null
        },
        {
          "name": "include_globs",
          "kind": "positional_or_keyword",
          "annotated_type": "list[str]",
          "default": null,
          "doc": null
        },
        {
          "name": "exclude_globs",
          "kind": "positional_or_keyword",
          "annotated_type": "list[str]",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "list[str]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Filter paths using glob patterns.",
      "doc_raw": "Filter paths using glob patterns.\n\nApplies include and exclude glob patterns to a list of file paths. Paths\nmust match at least one include pattern AND no exclude patterns to be kept.\n\nMatching is done using fnmatch (Unix shell-style globs):\n- `*` matches anything (including `/` in our implementation)\n- `?` matches any single character\n- `[seq]` matches any character in seq\n- `[!seq]` matches any character not in seq\n\nParameters\n----------\npaths : list[str]\n    File paths to filter (typically relative to repo root).\ninclude_globs : list[str]\n    Glob patterns to include. Paths must match at least one pattern.\n    Empty list means \"include all\" (no filtering).\nexclude_globs : list[str]\n    Glob patterns to exclude. Paths matching any pattern are removed.\n    Empty list means \"exclude none\".\n\nReturns\n-------\nlist[str]\n    Filtered paths list (order preserved from input).\n\nExamples\n--------\nInclude only Python files:\n\n>>> paths = [\"src/main.py\", \"src/app.ts\", \"README.md\"]\n>>> filtered = apply_path_filters(paths, include_globs=[\"**/*.py\"], exclude_globs=[])\n>>> filtered\n['src/main.py']\n\nExclude test files:\n\n>>> paths = [\"src/main.py\", \"tests/test_main.py\", \"src/utils.py\"]\n>>> filtered = apply_path_filters(paths, include_globs=[\"**/*.py\"], exclude_globs=[\"**/test_*\"])\n>>> filtered\n['src/main.py', 'src/utils.py']\n\nEmpty include globs (include all):\n\n>>> filtered = apply_path_filters(paths, include_globs=[], exclude_globs=[\"**/test_*\"])\n>>> # All paths except test files\n\nNotes\n-----\nPath separators are normalized to forward slashes (/) before matching to\nensure Windows paths (backslash) match Unix-style glob patterns.\n\nPerformance: O(n * m) where n = len(paths), m = max(len(include), len(exclude)).\nFor large path lists, consider pre-filtering during directory traversal\ninstead of post-filtering.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.scope_utils.merge_scope_filters",
      "short_name": "merge_scope_filters",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "scope",
          "kind": "positional_or_keyword",
          "annotated_type": "ScopeIn | None",
          "default": null,
          "doc": null
        },
        {
          "name": "explicit_params",
          "kind": "positional_or_keyword",
          "annotated_type": "dict",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "dict",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Merge session scope with explicit adapter parameters.",
      "doc_raw": "Merge session scope with explicit adapter parameters.\n\nCombines scope fields with explicit function parameters, giving precedence\nto explicit parameters. This allows users to override session scope for\nindividual queries without clearing the scope.\n\nMerge Rules:\n- If explicit param is present (not None), use it (override scope).\n- If explicit param is absent (None), use scope value (default).\n- If both absent, field is omitted from result.\n\nParameters\n----------\nscope : ScopeIn | None\n    Session scope from registry (may be None if no scope set).\nexplicit_params : dict\n    Parameters passed directly to adapter (e.g., {\"include_globs\": [...]}).\n    Keys match ScopeIn fields. Values of None are treated as \"not provided\".\n\nReturns\n-------\ndict\n    Merged dictionary with explicit params overriding scope defaults.\n\nExamples\n--------\nExplicit parameter overrides scope:\n\n>>> scope = {\"include_globs\": [\"**/*.py\"], \"languages\": [\"python\"]}\n>>> explicit = {\"include_globs\": [\"src/**\"]}\n>>> merged = merge_scope_filters(scope, explicit)\n>>> merged\n{'include_globs': ['src/**'], 'languages': ['python']}\n\nScope provides defaults for unspecified params:\n\n>>> scope = {\"include_globs\": [\"**/*.py\"], \"exclude_globs\": [\"**/test_*\"]}\n>>> explicit = {\"include_globs\": None, \"exclude_globs\": None}\n>>> merged = merge_scope_filters(scope, explicit)\n>>> merged\n{'include_globs': ['**/*.py'], 'exclude_globs': ['**/test_*']}\n\nNo scope (all from explicit params):\n\n>>> merged = merge_scope_filters(None, {\"include_globs\": [\"**/*.ts\"]})\n>>> merged\n{'include_globs': ['**/*.ts']}\n\nEmpty scope and empty params:\n\n>>> merged = merge_scope_filters(None, {})\n>>> merged\n{}\n\nNotes\n-----\nThe function does not modify input dicts\u2014it returns a new dict. This\nensures thread safety (no shared mutable state).",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.scope_utils.get_effective_scope",
      "short_name": "get_effective_scope",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "context",
          "kind": "positional_or_keyword",
          "annotated_type": "ApplicationContext",
          "default": null,
          "doc": null
        },
        {
          "name": "session_id",
          "kind": "positional_or_keyword",
          "annotated_type": "str | None",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "ScopeIn | None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Retrieve session scope from the scope store.",
      "doc_raw": "Retrieve session scope from the scope store.\n\nHelper function that wraps ScopeStore.get with null-safety for missing session\nIDs. Returns None if session_id is None or scope not found, allowing adapters\nto gracefully fall back to \"no scope\" behavior.\n\nParameters\n----------\ncontext : ApplicationContext\n    Application context containing scope store.\nsession_id : str | None\n    Session identifier to look up. If None, returns None immediately\n    without registry access.\n\nReturns\n-------\nScopeIn | None\n    Scope dictionary if session exists and has scope, None otherwise.\n\nExamples\n--------\n>>> context = ApplicationContext.create()\n>>> session_id = \"test-session-123\"\n>>> await context.scope_store.set(session_id, {\"languages\": [\"python\"]})\n>>> scope = await get_effective_scope(context, session_id)\n>>> scope\n{'languages': ['python']}\n>>> get_effective_scope(context, None)  # No session ID\n>>> get_effective_scope(context, \"nonexistent\")  # No scope set\n\nNotes\n-----\nThis function is preferred over direct registry access because it handles\nthe None case explicitly, making adapter code cleaner.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.scope_utils.LANGUAGE_EXTENSIONS",
      "short_name": "LANGUAGE_EXTENSIONS",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.scope_utils._scope_filter_duration_seconds",
      "short_name": "_scope_filter_duration_seconds",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.scope_utils.LOGGER",
      "short_name": "LOGGER",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.error_handling",
      "short_name": "error_handling",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Centralized error handling for CodeIntel MCP server.",
      "doc_raw": "Centralized error handling for CodeIntel MCP server.\n\nThis module provides the unified error handling infrastructure for all MCP tools,\nensuring consistent error responses with RFC 9457 Problem Details compliance and\nstructured logging for observability.\n\nArchitecture\n------------\nThe error handling follows a three-layer pattern:\n\n1. **Adapter Layer**: Pure domain logic that raises typed exceptions\n2. **Decorator Layer**: Automatic exception \u2192 envelope conversion\n3. **Client Layer**: Uniform error envelope with Problem Details\n\nAll MCP tool functions are decorated with ``@handle_adapter_errors`` which\ncatches all exceptions, converts them to Problem Details, logs with structured\ncontext, and returns a unified error envelope.\n\nExamples\n--------\nApplying decorator to MCP tool:\n\n>>> @mcp.tool()\n>>> @handle_adapter_errors(\n...     operation=\"files:open_file\", empty_result={\"path\": \"\", \"content\": \"\", \"lines\": 0, \"size\": 0}\n... )\n... def open_file(path: str, start_line: int | None, end_line: int | None) -> dict:\n...     context = get_context()\n...     return files_adapter.open_file(context, path, start_line, end_line)\n\nError envelope structure:\n\n>>> # On success:\n>>> {\"path\": \"src/main.py\", \"content\": \"...\", \"lines\": 10, \"size\": 234}\n>>>\n>>> # On error (FileNotFoundError):\n>>> {\n...     \"path\": \"\",\n...     \"content\": \"\",\n...     \"lines\": 0,\n...     \"size\": 0,\n...     \"error\": \"File not found: src/main.py\",\n...     \"problem\": {\n...         \"type\": \"https://kgfoundry.dev/problems/file-not-found\",\n...         \"title\": \"File Not Found\",\n...         \"status\": 404,\n...         \"detail\": \"File not found: src/main.py\",\n...         \"instance\": \"urn:codeintel:files:open_file\",\n...         \"code\": \"file-not-found\",\n...     },\n... }",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.error_handling.__all__",
      "short_name": "__all__",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.error_handling.handle_adapter_errors",
      "short_name": "handle_adapter_errors",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "operation",
          "kind": "keyword_only",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "empty_result",
          "kind": "keyword_only",
          "annotated_type": "Mapping[str, object]",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "Callable[[F], F]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Convert adapter exceptions to unified error envelopes.",
      "doc_raw": "Convert adapter exceptions to unified error envelopes.\n\nThis decorator is applied to all MCP tool functions to provide automatic\nerror handling. It catches all exceptions raised by adapters and converts\nthem to consistent error envelopes with Problem Details.\n\nThe decorator:\n\n1. Catches ALL exceptions (no exception escapes)\n2. Converts exception \u2192 Problem Details \u2192 error envelope\n3. Logs with structured context (operation, error_code, etc.)\n4. Returns error envelope (does not re-raise)\n5. Preserves function signature (important for FastMCP schema generation)\n\nParameters\n----------\noperation : str\n    Operation identifier in format \"category:operation\". Examples:\n\n    - \"files:open_file\"\n    - \"files:list_paths\"\n    - \"search:text\"\n    - \"search:semantic\"\n    - \"git:blame_range\"\n    - \"git:file_history\"\n\n    Used for Problem Details instance field and structured logging.\nempty_result : Mapping[str, object]\n    Tool-specific result fields with empty/zero values. These are merged\n    into the error envelope so clients always see the same field structure\n    (just with empty values on error).\n\nExamples\n--------\n    - open_file: ``{\"path\": \"\", \"content\": \"\", \"lines\": 0, \"size\": 0}``\n    - list_paths: ``{\"items\": [], \"total\": 0, \"truncated\": False}``\n    - blame_range: ``{\"blame\": []}``\n    - file_history: ``{\"commits\": []}``\n    - search_text: ``{\"matches\": [], \"total\": 0, \"truncated\": False}``\n    - semantic_search: ``{\"findings\": [], \"answer\": \"\", \"confidence\": 0.0}``\n\nReturns\n-------\nCallable[[F], F]\n    Decorator function that wraps the adapter call in try/except and\n    converts exceptions to error envelopes.\n\nNotes\n-----\nDecorator Order:\n\nThe decorator MUST be applied AFTER ``@mcp.tool()`` so FastMCP sees the\nunwrapped function signature for JSON Schema generation:\n\n.. code-block:: python\n\n    @mcp.tool()  # FIRST\n    @handle_adapter_errors(...)  # SECOND\n    def my_tool(...):\n        ...\n\nFunction Signature Preservation:\n\nThe decorator uses ``functools.wraps`` to preserve the function's\n``__name__``, ``__doc__``, and ``__annotations__``. This is critical for\nFastMCP's automatic JSON Schema generation.\n\nAsync Function Compatibility:\n\nThe decorator works with both sync and async functions. Async functions\nshould use ``async def`` and the decorator will properly await the result.\n\nExamples\n--------\nSync function:\n\n>>> @mcp.tool()\n>>> @handle_adapter_errors(\n...     operation=\"files:open_file\",\n...     empty_result={\"path\": \"\", \"content\": \"\", \"lines\": 0, \"size\": 0},\n... )\n... def open_file(path: str, start_line: int | None, end_line: int | None) -> dict:\n...     context = get_context()\n...     return files_adapter.open_file(context, path, start_line, end_line)\n\nAsync function:\n\n>>> @mcp.tool()\n>>> @handle_adapter_errors(operation=\"git:blame_range\", empty_result={\"blame\": []})\n... async def blame_range(path: str, start_line: int, end_line: int) -> dict:\n...     context = get_context()\n...     return await history_adapter.blame_range(context, path, start_line, end_line)\n\nSuccess case (no exception):\n\n>>> @handle_adapter_errors(operation=\"test\", empty_result={\"value\": 0})\n... def func():\n...     return {\"value\": 42}\n>>> result = func()\n>>> result\n{'value': 42}\n\nError case (exception raised):\n\n>>> @handle_adapter_errors(operation=\"test\", empty_result={\"value\": 0})\n... def func():\n...     raise FileNotFoundError(\"File not found\")\n>>> result = func()\n>>> result[\"error\"]\n'File not found'\n>>> result[\"problem\"][\"status\"]\n404\n>>> result[\"value\"]\n0",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.error_handling.convert_exception_to_envelope",
      "short_name": "convert_exception_to_envelope",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "exc",
          "kind": "positional_or_keyword",
          "annotated_type": "BaseException",
          "default": null,
          "doc": null
        },
        {
          "name": "operation",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "empty_result",
          "kind": "positional_or_keyword",
          "annotated_type": "Mapping[str, object]",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "dict",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Convert exception to unified error envelope with Problem Details.",
      "doc_raw": "Convert exception to unified error envelope with Problem Details.\n\nThis function is the single source of truth for exception \u2192 envelope\nconversion. It handles all exception types (KgFoundryError subclasses,\nbuiltin exceptions, unknown exceptions) and produces a consistent error\nstructure with RFC 9457 Problem Details compliance.\n\nThe error envelope includes:\n- All fields from ``empty_result`` (tool-specific fields with empty/zero values)\n- ``error`` field with human-readable message\n- ``problem`` field with RFC 9457 Problem Details\n\nParameters\n----------\nexc : BaseException\n    Exception to convert. Can be any exception type - KgFoundryError\n    subclasses are handled specially, builtin exceptions (FileNotFoundError,\n    ValueError, etc.) are mapped to standard Problem Details, unknown\n    exceptions are mapped to 500 Internal Error.\noperation : str\n    Operation identifier in format \"category:operation\" (e.g.,\n    \"files:open_file\", \"search:text\"). Used for Problem Details instance\n    field and structured logging.\nempty_result : Mapping[str, object]\n    Tool-specific result fields with empty/zero values. These are merged\n    into the error envelope so clients always see the same field structure.\n    Example: ``{\"path\": \"\", \"content\": \"\", \"lines\": 0, \"size\": 0}``\n\nReturns\n-------\ndict\n    Error envelope with:\n\n    - All fields from ``empty_result`` (empty/zero values)\n    - ``error: str`` - Human-readable error message\n    - ``problem: ProblemDetails`` - RFC 9457 Problem Details with type,\n      title, status, detail, instance, code, and optional extensions\n\nNotes\n-----\nException Mapping:\n\n- **KgFoundryError**: Uses ``to_problem_details()`` method. HTTP status,\n  error code, and context from exception fields. Logged at exception's\n  log_level with structured context.\n- **FileNotFoundError**: 404 Not Found, code \"file-not-found\". Logged\n  at WARNING level.\n- **UnicodeDecodeError**: 415 Unsupported Media Type, code\n  \"unsupported-encoding\". Encoding and reason in extensions. Logged at\n  WARNING level.\n- **ValueError**: 400 Bad Request, code \"invalid-parameter\". Logged at\n  WARNING level.\n- **Unknown exceptions**: 500 Internal Server Error, code \"internal-error\".\n  Exception type in extensions. Logged at EXCEPTION level (includes stack\n  trace).\n\nStructured Logging:\n\nAll exceptions are logged with structured context:\n\n- KgFoundryError: ``operation``, ``error_code``, ``component``\n- Builtin exceptions: ``operation``, ``component``, ``error``\n- Unknown exceptions: ``operation``, ``component``, ``exception_type``\n\nExamples\n--------\nConvert FileNotFoundError:\n\n>>> exc = FileNotFoundError(\"File not found: src/main.py\")\n>>> envelope = convert_exception_to_envelope(\n...     exc,\n...     operation=\"files:open_file\",\n...     empty_result={\"path\": \"\", \"content\": \"\", \"lines\": 0, \"size\": 0},\n... )\n>>> envelope[\"error\"]\n'File not found: src/main.py'\n>>> envelope[\"problem\"][\"status\"]\n404\n>>> envelope[\"problem\"][\"code\"]\n'file-not-found'\n>>> envelope[\"path\"]\n''\n\nConvert KgFoundryError with context:\n\n>>> from kgfoundry_common.errors import VectorSearchError\n>>> exc = VectorSearchError(\"Search timeout\", context={\"query\": \"def main\"})\n>>> envelope = convert_exception_to_envelope(\n...     exc, operation=\"search:text\", empty_result={\"matches\": [], \"total\": 0}\n... )\n>>> envelope[\"problem\"][\"extensions\"][\"query\"]\n'def main'",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.error_handling.format_error_response",
      "short_name": "format_error_response",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "exc",
          "kind": "positional_or_keyword",
          "annotated_type": "BaseException",
          "default": null,
          "doc": null
        },
        {
          "name": "instance",
          "kind": "keyword_only",
          "annotated_type": "str",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "dict[str, object]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Return Problem Details payload for the provided exception.",
      "doc_raw": "Return Problem Details payload for the provided exception.\n\nParameters\n----------\nexc : BaseException\n    Exception instance to convert into Problem Details.\ninstance : str\n    RFC 9457 ``instance`` URI identifying the operation that failed.\n\nReturns\n-------\ndict[str, object]\n    Dictionary containing ``problem`` (Problem Details payload) and\n    ``status`` (HTTP status code).",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.error_handling.EXCEPTION_TO_ERROR_CODE",
      "short_name": "EXCEPTION_TO_ERROR_CODE",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.error_handling.ProblemMapping",
      "short_name": "ProblemMapping",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "dataclass(frozen=True)"
      ],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "code",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "title",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "status",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.error_handling.ProblemMapping.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "code",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "title",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "status",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.error_handling.ProblemMapping.status",
      "short_name": "status",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.error_handling.ProblemMapping.title",
      "short_name": "title",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.error_handling.ProblemMapping.code",
      "short_name": "code",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.error_handling._USER_EXCEPTIONS",
      "short_name": "_USER_EXCEPTIONS",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.error_handling.F",
      "short_name": "F",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.error_handling.COMPONENT_NAME",
      "short_name": "COMPONENT_NAME",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.error_handling.LOGGER",
      "short_name": "LOGGER",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.server_symbols",
      "short_name": "server_symbols",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Symbol MCP tool registrations (pure move from server.py).",
      "doc_raw": "Symbol MCP tool registrations (pure move from server.py).",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.server_symbols.references_at",
      "short_name": "references_at",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "mcp.tool()",
        "handle_adapter_errors(operation='symbols:references_at', empty_result={'locations': []})"
      ],
      "params": [
        {
          "name": "path",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "line",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "character",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "dict",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Find references at position.",
      "doc_raw": "Find references at position.\n\nReturns\n-------\ndict\n    Reference locations response.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.server_symbols.definition_at",
      "short_name": "definition_at",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "mcp.tool()",
        "handle_adapter_errors(operation='symbols:definition_at', empty_result={'locations': []})"
      ],
      "params": [
        {
          "name": "path",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "line",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "character",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "dict",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Find definition at position.",
      "doc_raw": "Find definition at position.\n\nReturns\n-------\ndict\n    Definition locations response.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.server_symbols.symbol_search",
      "short_name": "symbol_search",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "mcp.tool()",
        "handle_adapter_errors(operation='symbols:search', empty_result={'symbols': [], 'total': 0})"
      ],
      "params": [
        {
          "name": "query",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "kind",
          "kind": "positional_or_keyword",
          "annotated_type": "str | None",
          "default": "None",
          "doc": null
        },
        {
          "name": "language",
          "kind": "positional_or_keyword",
          "annotated_type": "str | None",
          "default": "None",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "dict",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Search for symbols (functions, classes, etc).",
      "doc_raw": "Search for symbols (functions, classes, etc).\n\nReturns\n-------\ndict\n    Symbol matches payload.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.server_semantic",
      "short_name": "server_semantic",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Semantic MCP tool registrations (pure move from server.py).",
      "doc_raw": "Semantic MCP tool registrations (pure move from server.py).",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.server_semantic.semantic_search_pro",
      "short_name": "semantic_search_pro",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "mcp.tool()",
        "handle_adapter_errors(operation='search:semantic_pro', empty_result={'findings': [], 'answer': '', 'confidence': 0.0})"
      ],
      "params": [
        {
          "name": "query",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "limit",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": "20",
          "doc": null
        },
        {
          "name": "options",
          "kind": "keyword_only",
          "annotated_type": "semantic_pro_adapter.SemanticProOptions | None",
          "default": "None",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "AnswerEnvelope",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Two-stage semantic retrieval with optional late interaction and reranker.",
      "doc_raw": "Two-stage semantic retrieval with optional late interaction and reranker.\n\nReturns\n-------\nAnswerEnvelope\n    Structured response including fusion metadata.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.server_semantic.semantic_search",
      "short_name": "semantic_search",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "mcp.tool()",
        "handle_adapter_errors(operation='search:semantic', empty_result={'findings': [], 'answer': '', 'confidence': 0.0})"
      ],
      "params": [
        {
          "name": "query",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "limit",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": "20",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "AnswerEnvelope",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Semantic code search using embeddings.",
      "doc_raw": "Semantic code search using embeddings.\n\nReturns\n-------\nAnswerEnvelope\n    Structured semantic search response.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas",
      "short_name": "schemas",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "MCP server schemas using TypedDict for FastMCP compatibility.",
      "doc_raw": "MCP server schemas using TypedDict for FastMCP compatibility.\n\nTypedDict provides automatic JSON Schema generation for FastMCP tools.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.__all__",
      "short_name": "__all__",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.SearchTextResponse",
      "short_name": "SearchTextResponse",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [
        "BaseErrorFields"
      ],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Response from search_text tool.",
      "doc_raw": "Response from search_text tool.\n\nOn success: matches list is populated, total > 0.\nOn error: matches is empty, total is 0, error and problem are present.\n\nAttributes\n----------\nmatches : list[Match]\n    List of search matches. Empty list on error.\ntotal : int\n    Total number of matches found. Zero on error.\ntruncated : NotRequired[bool]\n    Whether results were truncated due to max_results limit. False on error.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.SearchTextResponse.truncated",
      "short_name": "truncated",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.SearchTextResponse.total",
      "short_name": "total",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.SearchTextResponse.matches",
      "short_name": "matches",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.FileHistoryResponse",
      "short_name": "FileHistoryResponse",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [
        "BaseErrorFields"
      ],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Response from file_history tool.",
      "doc_raw": "Response from file_history tool.\n\nOn success: commits list is populated.\nOn error: commits is empty list, error and problem are present.\n\nAttributes\n----------\ncommits : list[dict]\n    List of commit entries with SHA, author, date, message. Empty list on error.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.FileHistoryResponse.commits",
      "short_name": "commits",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.BlameRangeResponse",
      "short_name": "BlameRangeResponse",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [
        "BaseErrorFields"
      ],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Response from blame_range tool.",
      "doc_raw": "Response from blame_range tool.\n\nOn success: blame list is populated.\nOn error: blame is empty list, error and problem are present.\n\nAttributes\n----------\nblame : list[GitBlameEntry]\n    List of git blame entries for the requested line range. Empty list on error.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.BlameRangeResponse.blame",
      "short_name": "blame",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.ListPathsResponse",
      "short_name": "ListPathsResponse",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [
        "BaseErrorFields"
      ],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Response from list_paths tool.",
      "doc_raw": "Response from list_paths tool.\n\nOn success: items list is populated, total > 0.\nOn error: items is empty list, total is 0, error and problem are present.\n\nAttributes\n----------\nitems : list[dict]\n    List of file items with path, size, modified timestamp. Empty list on error.\ntotal : int\n    Total number of files found. Zero on error.\ntruncated : NotRequired[bool]\n    Whether results were truncated due to max_results limit. False on error.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.ListPathsResponse.truncated",
      "short_name": "truncated",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.ListPathsResponse.total",
      "short_name": "total",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.ListPathsResponse.items",
      "short_name": "items",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.OpenFileResponse",
      "short_name": "OpenFileResponse",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [
        "BaseErrorFields"
      ],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Response from open_file tool.",
      "doc_raw": "Response from open_file tool.\n\nOn success: path, content, lines, size are populated.\nOn error: all result fields are empty/zero, error and problem are present.\n\nAttributes\n----------\npath : str\n    File path relative to repository root. Empty string on error.\ncontent : str\n    File content (optionally sliced by line range). Empty string on error.\nlines : int\n    Number of lines in the returned content. Zero on error.\nsize : int\n    Size of the returned content in bytes. Zero on error.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.OpenFileResponse.size",
      "short_name": "size",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.OpenFileResponse.lines",
      "short_name": "lines",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.OpenFileResponse.content",
      "short_name": "content",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.OpenFileResponse.path",
      "short_name": "path",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.GitBlameEntry",
      "short_name": "GitBlameEntry",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [
        "TypedDict"
      ],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Git blame entry for a single line of code.",
      "doc_raw": "Git blame entry for a single line of code.\n\nRepresents the git blame information for one line, showing who last modified\nit, when, and why. Used for code ownership queries and understanding code\nhistory.\n\nAttributes\n----------\nline : int\n    Line number (1-indexed for human readability). The line this blame entry\n    refers to.\ncommit : str\n    Full commit SHA (40-character hex string) that last modified this line.\n    Used for linking to commit details and diffs.\nauthor : str\n    Name of the author who made the commit. Typically in \"Name <email>\"\n    format. Used for identifying code owners.\ndate : str\n    Commit date in ISO 8601 format (e.g., \"2024-01-15T10:30:00Z\"). Used for\n    temporal analysis and filtering by date.\nmessage : str\n    Commit message explaining why the change was made. First line or full\n    message depending on context. Used for understanding the reason for changes.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.GitBlameEntry.message",
      "short_name": "message",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.GitBlameEntry.date",
      "short_name": "date",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.GitBlameEntry.author",
      "short_name": "author",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.GitBlameEntry.commit",
      "short_name": "commit",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.GitBlameEntry.line",
      "short_name": "line",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.SymbolInfo",
      "short_name": "SymbolInfo",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [
        "TypedDict"
      ],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Symbol information with location and documentation.",
      "doc_raw": "Symbol information with location and documentation.\n\nRepresents a programming language symbol (function, class, variable, etc.)\nwith its location and optional documentation. Used for symbol search results\nand \"go to definition\" functionality.\n\nAttributes\n----------\nname : str\n    Symbol name as it appears in source code (e.g., \"process_data\", \"DataProcessor\").\n    Used for display and matching.\nkind : str\n    Symbol kind/type (e.g., \"function\", \"class\", \"variable\", \"method\", \"module\").\n    Language-specific but typically follows LSP symbol kinds. Used for\n    filtering and categorization.\nlocation : Location\n    Source code location where the symbol is defined. Includes file URI and\n    precise line/column positions for navigation.\ndoc : NotRequired[str]\n    Documentation string for the symbol (docstring, JSDoc, etc.). May be\n    omitted if no documentation is available. Used for displaying symbol\n    information without opening the file.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.SymbolInfo.doc",
      "short_name": "doc",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.SymbolInfo.location",
      "short_name": "location",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.SymbolInfo.kind",
      "short_name": "kind",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.SymbolInfo.name",
      "short_name": "name",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.AnswerEnvelope",
      "short_name": "AnswerEnvelope",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [
        "TypedDict"
      ],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Standard response envelope for MCP code intelligence tools.",
      "doc_raw": "Standard response envelope for MCP code intelligence tools.\n\nComprehensive response structure that wraps all types of code intelligence\nresults. This envelope provides a consistent format across all MCP tools,\nmaking it easy for clients to process results uniformly.\n\nAll fields are optional (total=False) - tools include only relevant fields\nfor their specific operation. For example, a semantic search might include\nfindings and method, while a symbol lookup might include xrefs and docs.\n\nAttributes\n----------\nanswer : str\n    Human-readable summary answer to the query. Provides a natural language\n    explanation of the results (e.g., \"Found 15 functions related to data\n    processing in src/core/\"). Used for display in chat interfaces.\nquery_kind : str\n    Type of query that was executed (e.g., \"semantic_search\", \"symbol_lookup\",\n    \"text_search\", \"code_review\"). Used for result categorization and routing.\nscope : ScopeIn\n    Query scope that was applied to filter results. Shows which repositories,\n    branches, files, and languages were searched. Useful for understanding\n    result limitations.\nmethod : MethodInfo\n    Retrieval method metadata describing how results were generated. Includes\n    which retrieval systems were used and search coverage information.\nfindings : list[Finding]\n    Primary search results as Finding objects. Each finding represents a\n    code location with context. This is the main result field for most queries.\nxrefs : dict\n    Cross-reference information (callers, callees, dependencies). Structure\n    varies by query type. For symbol queries, might contain \"callers\" and\n    \"callees\" lists. For dependency queries, might contain dependency graphs.\nhistory : list[dict]\n    Git history entries related to the query. Each entry typically contains\n    commit SHA, author, date, message. Used for \"who changed this\" queries.\ndocs : list[dict]\n    Documentation entries found. Might include ADRs, API docs, README sections.\n    Structure varies by documentation format.\nsecurity : list[dict]\n    Security-related findings (vulnerabilities, issues, best practices).\n    Each entry describes a security concern with location and severity.\napi : dict\n    API catalog information. Contains API definitions, endpoints, schemas\n    relevant to the query. Structure depends on API format (OpenAPI, etc.).\nowners : list[dict]\n    Code ownership information. Lists who owns or maintains the code in question.\n    Each entry might contain name, email, team, ownership percentage.\nrelated : list[dict]\n    Related findings or suggestions. Might include similar code, related\n    symbols, or follow-up queries. Structure varies.\nconfidence : float\n    Overall confidence score for the results (0.0 to 1.0). Indicates how\n    confident the system is that results are relevant and complete. Higher\n    values indicate high-quality, complete results.\nlimits : list[str]\n    List of limitations or degraded service notices. Explains any constraints\n    on the search (e.g., \"Index incomplete\", \"GPU unavailable - using CPU\",\n    \"Limited to 1000 results\"). Used for transparency and debugging.\nnext_steps : list[str]\n    Suggested follow-up queries or actions. Provides guidance on how to\n    refine the search or explore related topics (e.g., \"Try searching for\n    'data validation'\", \"See callers of this function\").\nproblem : ProblemDetailsDict\n    RFC 9457 Problem Details payload describing the failure when the request\n    could not be fulfilled successfully.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.AnswerEnvelope.problem",
      "short_name": "problem",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.AnswerEnvelope.next_steps",
      "short_name": "next_steps",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.AnswerEnvelope.limits",
      "short_name": "limits",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.AnswerEnvelope.confidence",
      "short_name": "confidence",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.AnswerEnvelope.related",
      "short_name": "related",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.AnswerEnvelope.owners",
      "short_name": "owners",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.AnswerEnvelope.api",
      "short_name": "api",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.AnswerEnvelope.security",
      "short_name": "security",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.AnswerEnvelope.docs",
      "short_name": "docs",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.AnswerEnvelope.history",
      "short_name": "history",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.AnswerEnvelope.xrefs",
      "short_name": "xrefs",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.AnswerEnvelope.findings",
      "short_name": "findings",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.AnswerEnvelope.method",
      "short_name": "method",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.AnswerEnvelope.scope",
      "short_name": "scope",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.AnswerEnvelope.query_kind",
      "short_name": "query_kind",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.AnswerEnvelope.answer",
      "short_name": "answer",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.StageInfo",
      "short_name": "StageInfo",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [
        "TypedDict"
      ],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Timing metadata for an individual retrieval stage.",
      "doc_raw": "Timing metadata for an individual retrieval stage.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.StageInfo.exceeded_budget",
      "short_name": "exceeded_budget",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.StageInfo.budget_ms",
      "short_name": "budget_ms",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.StageInfo.duration_ms",
      "short_name": "duration_ms",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.StageInfo.name",
      "short_name": "name",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.MethodInfo",
      "short_name": "MethodInfo",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [
        "TypedDict"
      ],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Retrieval method metadata for search operations.",
      "doc_raw": "Retrieval method metadata for search operations.\n\nDescribes which retrieval methods were used to generate search results and\nprovides information about search coverage. Useful for understanding result\nquality and debugging search behavior.\n\nAll fields are optional (total=False) to allow flexible metadata structures.\n\nAttributes\n----------\nretrieval : list[str]\n    List of retrieval methods used to generate results. Common values:\n    \"semantic\" (FAISS/dense embeddings), \"bm25\" (keyword/BM25), \"splade\"\n    (learned sparse), \"structural\" (AST-based). Multiple methods indicate\n    hybrid retrieval with RRF fusion.\ncoverage : str\n    Human-readable description of search coverage. Explains what was searched\n    and any limitations (e.g., \"Searched 1.2M chunks across Python files\",\n    \"Limited to main branch\", \"Index incomplete - missing recent commits\").\nstages : list[StageInfo]\n    Optional stage-level timing data for observability.\nnotes : list[str]\n    Optional free-form notes about retrieval decisions (e.g., gating reasons).\nexplainability : dict[str, list[dict[str, object]]]\n    Optional structured explainability payload keyed by channel.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.MethodInfo.explainability",
      "short_name": "explainability",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.MethodInfo.notes",
      "short_name": "notes",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.MethodInfo.stages",
      "short_name": "stages",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.MethodInfo.coverage",
      "short_name": "coverage",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.MethodInfo.retrieval",
      "short_name": "retrieval",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.Finding",
      "short_name": "Finding",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [
        "TypedDict"
      ],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Generic finding result from code intelligence queries.",
      "doc_raw": "Generic finding result from code intelligence queries.\n\nRepresents a single finding from a search or analysis operation. Findings\ncan be symbol definitions, references, documentation, security issues, API\nusages, etc. All fields are optional (total=False) to allow flexible\nresult structures.\n\nFindings are the primary result type returned by MCP tools. They combine\nlocation information, code snippets, and metadata to provide actionable\ncode intelligence.\n\nAttributes\n----------\ntype : Literal[\"definition\", \"reference\", \"usage\", \"doc\", \"security\", \"api\"]\n    Type of finding. \"definition\" = symbol definition, \"reference\" = symbol\n    reference/usage, \"usage\" = how something is used, \"doc\" = documentation,\n    \"security\" = security-related finding, \"api\" = API usage or definition.\ntitle : str\n    Human-readable title for the finding. Should be concise and descriptive\n    (e.g., \"Function definition: process_data\", \"Security issue: SQL injection\").\n    Used for display in search results and tooltips.\nlocation : Location\n    Source code location where this finding occurs. Includes file URI and\n    precise line/column positions for navigation.\nsnippet : str\n    Code snippet showing the relevant code. Typically 3-10 lines of context\n    around the finding. Used for preview without opening the full file.\nscore : float\n    Relevance score (0.0 to 1.0, higher is better). Indicates how well this\n    finding matches the query. Used for ranking and filtering results.\nwhy : str\n    Explanation of why this finding matches the query. Provides context and\n    reasoning for the match (e.g., \"Matches query 'data processing' because\n    function name contains 'process' and docstring mentions 'data'\").\nchunk_id : int\n    Internal chunk identifier used for hydration bookkeeping and hybrid fusion.\n    Not all clients need this value; it is primarily used by the server when\n    combining multiple retrieval channels.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.Finding.chunk_id",
      "short_name": "chunk_id",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.Finding.why",
      "short_name": "why",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.Finding.score",
      "short_name": "score",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.Finding.snippet",
      "short_name": "snippet",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.Finding.location",
      "short_name": "location",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.Finding.title",
      "short_name": "title",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.Finding.type",
      "short_name": "type",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.Location",
      "short_name": "Location",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [
        "TypedDict"
      ],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Source code location with precise line and column positions.",
      "doc_raw": "Source code location with precise line and column positions.\n\nRepresents a contiguous region of source code using line and column\ncoordinates. Used for symbol definitions, references, and code ranges.\nMatches the LSP Location format for compatibility with language servers.\n\nAll coordinates are 0-indexed to match programming conventions. The range\nis inclusive at start, exclusive at end (matching LSP/SCIP convention).\n\nAttributes\n----------\nuri : str\n    File URI or path identifying the source file. Typically a relative path\n    from the repository root. Used to locate and open the file.\nstart_line : int\n    Starting line number (0-indexed). The first line of a file is line 0.\n    Together with start_column, defines the start of the range.\nstart_column : int\n    Starting column/character position (0-indexed) within start_line.\n    Character 0 is the first character on the line. Defines the precise\n    start position.\nend_line : int\n    Ending line number (0-indexed, inclusive). The range spans from start_line\n    to end_line (inclusive). For single-line ranges, equals start_line.\nend_column : int\n    Ending column/character position (0-indexed, exclusive) within end_line.\n    The range includes characters from start_column up to (but not including)\n    end_column. This matches LSP/SCIP convention.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.Location.end_column",
      "short_name": "end_column",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.Location.end_line",
      "short_name": "end_line",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.Location.start_column",
      "short_name": "start_column",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.Location.start_line",
      "short_name": "start_line",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.Location.uri",
      "short_name": "uri",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.Match",
      "short_name": "Match",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [
        "TypedDict"
      ],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Search match result from text or semantic search.",
      "doc_raw": "Search match result from text or semantic search.\n\nRepresents a single match found by a search operation (text search, semantic\nsearch, etc.). Contains the file location and a code preview for display.\n\nThe score field is optional because some search types (like exact text match)\nmay not have a relevance score. When present, scores are typically normalized\nto 0-1 range with higher values indicating better matches.\n\nAttributes\n----------\npath : str\n    File path where the match was found. Typically a relative path from the\n    repository root. Used for navigation and file filtering.\nline : int\n    Line number where the match occurs (1-indexed for human readability).\n    Used for \"go to line\" functionality and displaying code context.\ncolumn : int\n    Column/character position within the line (0-indexed). Used for precise\n    positioning within a line, especially for symbol references.\npreview : str\n    Code snippet preview showing the matched code in context. Typically\n    1-3 lines around the match. Used for displaying search results without\n    opening the full file.\nscore : NotRequired[float]\n    Relevance score for the match (0.0 to 1.0, higher is better). Present\n    for semantic search results, may be omitted for exact text matches.\n    Used for ranking and filtering results.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.Match.score",
      "short_name": "score",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.Match.preview",
      "short_name": "preview",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.Match.column",
      "short_name": "column",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.Match.line",
      "short_name": "line",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.Match.path",
      "short_name": "path",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.ScopeIn",
      "short_name": "ScopeIn",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [
        "TypedDict"
      ],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Query scope parameters for filtering search results.",
      "doc_raw": "Query scope parameters for filtering search results.\n\nDefines the scope of a code intelligence query, allowing filtering by\nrepository, branch, commit, file patterns, and languages. All fields\nare optional (total=False) - unspecified fields don't filter results.\n\nThis scope is used throughout the MCP server to limit searches to relevant\nparts of the codebase. For example, a query might be scoped to a specific\nrepository and Python files only.\n\nAttributes\n----------\nrepos : list[str]\n    List of repository names to include in the search. Repository names\n    should match the repository identifier in the index. Empty list or\n    omitted means all repositories.\nbranches : list[str]\n    List of branch names to search. Useful for limiting to specific branches\n    (e.g., [\"main\", \"develop\"]). Empty list or omitted means all branches.\ncommit : str\n    Specific commit SHA to search. If provided, results are limited to\n    code as it existed at this commit. Useful for historical queries.\ninclude_globs : list[str]\n    File path glob patterns to include (e.g., [\"**/*.py\", \"src/**\"]).\n    Only files matching these patterns are searched. Empty list or omitted\n    means all files.\nexclude_globs : list[str]\n    File path glob patterns to exclude (e.g., [\"**/test_*.py\", \"**/__pycache__/**\"]).\n    Files matching these patterns are excluded from search. Empty list or\n    omitted means no exclusions.\nlanguages : list[str]\n    Programming languages to include (e.g., [\"python\", \"typescript\"]).\n    Only files of these languages are searched. Empty list or omitted means\n    all languages.\nkinds : list[str]\n    Symbol kinds to include (e.g., [\"function\", \"class\", \"method\"]).\n    Results are scoped to these symbol categories when provided.\nsymbols : list[str]\n    Specific SCIP symbol identifiers to focus on regardless of location.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.ScopeIn.symbols",
      "short_name": "symbols",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.ScopeIn.kinds",
      "short_name": "kinds",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.ScopeIn.languages",
      "short_name": "languages",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.ScopeIn.exclude_globs",
      "short_name": "exclude_globs",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.ScopeIn.include_globs",
      "short_name": "include_globs",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.ScopeIn.commit",
      "short_name": "commit",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.ScopeIn.branches",
      "short_name": "branches",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.ScopeIn.repos",
      "short_name": "repos",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.BaseErrorFields",
      "short_name": "BaseErrorFields",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [
        "TypedDict"
      ],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Base fields present in ALL error responses.",
      "doc_raw": "Base fields present in ALL error responses.\n\nThese fields are automatically added by the error handling decorator\nwhen an exception is caught. Adapters should never construct these\nmanually - they only appear on error paths handled by the decorator.\n\nAttributes\n----------\nerror : str\n    Human-readable error message. Present on all error responses.\n    Used for display in user interfaces and debugging.\nproblem : ProblemDetailsDict\n    RFC 9457 Problem Details payload with structured error information.\n    Includes type, title, status, detail, instance, code, and optional\n    extensions. Present on all error responses.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.BaseErrorFields.problem",
      "short_name": "problem",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.schemas.BaseErrorFields.error",
      "short_name": "error",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.service_context",
      "short_name": "service_context",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Cached application context for MCP tool adapters.",
      "doc_raw": "Cached application context for MCP tool adapters.\n\nThis module exposes a small facade that lazily creates and caches the\n:class:`~codeintel_rev.app.config_context.ApplicationContext` used by the MCP\nserver tool adapters. The cached context reuses the same configuration and\npath-resolution logic as the FastAPI app and readiness probes because it\nultimately delegates creation to :meth:`ApplicationContext.create`, which reads\nenvironment overrides and resolves paths via\n:func:`~codeintel_rev.app.config_context.resolve_application_paths`.\n\nThe cache ensures heavy resources such as the FAISS index manager and DuckDB\ncatalog are only initialized once per process. Tests and administrative scripts\ncan call :func:`reset_service_context` to clear the cache when environment\nvariables change or when they need fresh dependencies.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.service_context.reset_service_context",
      "short_name": "reset_service_context",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Clear the cached :class:`ApplicationContext`.",
      "doc_raw": "Clear the cached :class:`ApplicationContext`.\n\nPrimarily intended for tests or scripts that mutate environment variables\nbetween runs. The next call to :func:`get_service_context` will recreate the\ncontext from the latest configuration.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.service_context.get_service_context",
      "short_name": "get_service_context",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": {
        "annotated_type": "ApplicationContext",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Return the cached :class:`ApplicationContext` instance.",
      "doc_raw": "Return the cached :class:`ApplicationContext` instance.\n\nThe first invocation creates the context via\n:meth:`ApplicationContext.create`. Subsequent calls return the cached\ninstance so that adapters share the same settings, resolved paths, and\nlong-lived clients.\n\nReturns\n-------\nApplicationContext\n    Cached application context instance with settings, resolved paths,\n    and long-lived clients (FAISS manager, vLLM client, DuckDB catalog).",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.service_context._set_cached_context",
      "short_name": "_set_cached_context",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "context",
          "kind": "positional_or_keyword",
          "annotated_type": "ApplicationContext | None",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Update the cached context reference.",
      "doc_raw": "Update the cached context reference.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.service_context._get_cached_context",
      "short_name": "_get_cached_context",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": {
        "annotated_type": "ApplicationContext | None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Return the cached context instance, if any.",
      "doc_raw": "Return the cached context instance, if any.\n\nReturns\n-------\nApplicationContext | None\n    Previously cached context or ``None`` when not initialized.",
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.service_context._CONTEXT_LOCK",
      "short_name": "_CONTEXT_LOCK",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.service_context._CONTEXT_CACHE",
      "short_name": "_CONTEXT_CACHE",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "mcp_server.service_context.__all__",
      "short_name": "__all__",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "ops",
      "short_name": "ops",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Operations and maintenance scripts.",
      "doc_raw": "Operations and maintenance scripts.",
      "docstyle": "google"
    },
    {
      "full_name": "ops.runtime",
      "short_name": "runtime",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Runtime health and validation utilities.",
      "doc_raw": "Runtime health and validation utilities.",
      "docstyle": "google"
    },
    {
      "full_name": "ops.runtime.xtr_open",
      "short_name": "xtr_open",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Fail-fast probe for XTR artifacts.",
      "doc_raw": "Fail-fast probe for XTR artifacts.\n\nExample failure payload::\n\n    {\n        \"type\": \"https://kgfoundry.dev/problems/resource-unavailable\",\n        \"title\": \"XTR artifacts unavailable\",\n        \"status\": 503,\n        \"detail\": \"Index metadata missing.\",\n        \"runtime\": \"xtr\",\n        \"instance\": \"/ops/runtime/xtr-open\",\n    }",
      "docstyle": "google"
    },
    {
      "full_name": "ops.runtime.xtr_open.main",
      "short_name": "main",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Execute the Typer CLI.",
      "doc_raw": "Execute the Typer CLI.",
      "docstyle": "google"
    },
    {
      "full_name": "ops.runtime.xtr_open._exit_with_problem",
      "short_name": "_exit_with_problem",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "message",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "detail",
          "kind": "keyword_only",
          "annotated_type": "str | None",
          "default": "None",
          "doc": null
        },
        {
          "name": "cause",
          "kind": "keyword_only",
          "annotated_type": "Exception | None",
          "default": "None",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "ops.runtime.xtr_open.xtr_open",
      "short_name": "xtr_open",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "APP.command('xtr-open')"
      ],
      "params": [
        {
          "name": "root",
          "kind": "positional_or_keyword",
          "annotated_type": "_RootOption",
          "default": "None",
          "doc": null
        },
        {
          "name": "verbose",
          "kind": "keyword_only",
          "annotated_type": "_VerboseOption",
          "default": "_VERBOSE_DEFAULT",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Validate that XTR artifacts are present and readable.",
      "doc_raw": "Validate that XTR artifacts are present and readable.\n\nExtended Summary\n----------------\nThis CLI command performs a fail-fast probe for XTR (eXtended Token Retrieval)\nartifacts. It validates that the XTR index directory exists, can be opened,\nand is ready for use. The command is used for health checks and deployment\nvalidation. On success, it prints a JSON payload with readiness status and\nmetadata (chunk count, token count, dimension, dtype). On failure, it exits\nwith a non-zero code and prints RFC 9457 Problem Details.\n\nParameters\n----------\nroot : _RootOption, optional\n    Override the configured XTR artifact directory. If None (default), uses\n    the directory resolved from application settings. Type alias for\n    ``Annotated[Path | None, typer.Option(...)]`` for CLI option specification.\n    Defaults to None.\nverbose : _VerboseOption, optional\n    Pretty-print success payloads with indentation. When False (default),\n    outputs compact JSON. Type alias for ``Annotated[bool, typer.Option(...)]``\n    for CLI option specification. Defaults to False.\n\nRaises\n------\ntyper.Exit\n    Raised by Typer to signal successful completion (code=0) or failure\n    (code=1). On failure, the exit includes RFC 9457 Problem Details\n    printed to stderr.\n\nNotes\n-----\nTime complexity O(1) for directory checks; O(I) for index opening where I\nis the cost of loading index metadata. The function performs filesystem I/O\nto validate paths and open the index. Thread-safe if called from a single\nprocess. The function is idempotent - multiple calls with the same inputs\nproduce the same results.\n\nExamples\n--------\n>>> # Validate default XTR directory\n>>> xtr_open(root=None, verbose=False)\n{\"ready\": true, \"limits\": [], \"metadata\": {...}}\n\n>>> # Validate custom directory with verbose output\n>>> xtr_open(root=Path(\"/custom/xtr\"), verbose=True)\n{\n  \"ready\": true,\n  \"limits\": [],\n  \"metadata\": {\n    \"root\": \"/custom/xtr\",\n    \"chunks\": 1000,\n    \"tokens\": 50000,\n    \"dim\": 768,\n    \"dtype\": \"float32\"\n  }\n}",
      "docstyle": "google"
    },
    {
      "full_name": "ops.runtime.xtr_open._VerboseOption",
      "short_name": "_VerboseOption",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "ops.runtime.xtr_open._RootOption",
      "short_name": "_RootOption",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "ops.runtime.xtr_open._VERBOSE_FLAGS",
      "short_name": "_VERBOSE_FLAGS",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "ops.runtime.xtr_open._VERBOSE_DEFAULT",
      "short_name": "_VERBOSE_DEFAULT",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "ops.runtime.xtr_open.PROBLEM_INSTANCE",
      "short_name": "PROBLEM_INSTANCE",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "ops.runtime.xtr_open.APP",
      "short_name": "APP",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "ops.runtime.xtr_open.LOGGER",
      "short_name": "LOGGER",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "retrieval",
      "short_name": "retrieval",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Hybrid retrieval algorithms for the CodeIntel MCP stack.",
      "doc_raw": "Hybrid retrieval algorithms for the CodeIntel MCP stack.",
      "docstyle": "google"
    },
    {
      "full_name": "retrieval.fusion",
      "short_name": "fusion",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Fusion helpers for multi-channel retrieval.",
      "doc_raw": "Fusion helpers for multi-channel retrieval.",
      "docstyle": "google"
    },
    {
      "full_name": "retrieval.fusion.weighted_rrf",
      "short_name": "weighted_rrf",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Weighted reciprocal rank fusion utilities.",
      "doc_raw": "Weighted reciprocal rank fusion utilities.",
      "docstyle": "google"
    },
    {
      "full_name": "retrieval.fusion.weighted_rrf.__all__",
      "short_name": "__all__",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "retrieval.fusion.weighted_rrf.fuse_weighted_rrf",
      "short_name": "fuse_weighted_rrf",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "runs",
          "kind": "positional_or_keyword",
          "annotated_type": "Mapping[str, Sequence[ChannelHit]]",
          "default": null,
          "doc": null
        },
        {
          "name": "weights",
          "kind": "keyword_only",
          "annotated_type": "Mapping[str, float]",
          "default": null,
          "doc": null
        },
        {
          "name": "k",
          "kind": "keyword_only",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "limit",
          "kind": "keyword_only",
          "annotated_type": "int",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "tuple[list[HybridResultDoc], dict[str, list[tuple[str, int, float]]]]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Apply weighted RRF across runs and return fused docs plus contributions.",
      "doc_raw": "Apply weighted RRF across runs and return fused docs plus contributions.\n\nExtended Summary\n----------------\nThis function performs weighted Reciprocal Rank Fusion (RRF) across multiple\nretrieval channels, combining ranked lists with channel-specific weights. It computes\nfused scores using the RRF formula (weight * 1/(k + rank)) and tracks contribution\nmetadata showing which channels contributed to each document's final score. This is\nused in hybrid search pipelines to combine results from different retrieval methods\n(e.g., dense vectors, sparse BM25, semantic search) into a single ranked list.\n\nParameters\n----------\nruns : Mapping[str, Sequence[ChannelHit]]\n    Dictionary mapping channel names to their ranked hit lists. Each channel\n    provides a sequence of ChannelHit objects with doc_id, rank, and score.\n    Empty sequences are skipped.\nweights : Mapping[str, float]\n    Dictionary mapping channel names to their fusion weights. Channels not\n    present in weights default to weight 1.0. Channels with weight 0.0 are\n    excluded from fusion.\nk : int\n    RRF constant used in the formula 1/(k + rank). Larger k values reduce the\n    impact of rank differences. Typical values range from 20 to 100.\nlimit : int\n    Maximum number of fused documents to return. Must be positive. Results are\n    sorted by fused score in descending order and truncated to this limit.\n\nReturns\n-------\ntuple[list[HybridResultDoc], dict[str, list[tuple[str, int, float]]]]\n    Two-element tuple containing:\n    - List of HybridResultDoc objects with fused scores, sorted descending\n    - Dictionary mapping doc_id to list of (channel, rank, score) contributions\n\nRaises\n------\nValueError\n    If limit is not positive. This ensures the function returns at least one\n    result when limit > 0.\n\nNotes\n-----\nTime complexity O(C * N) where C is channel count and N is average hits per channel.\nSpace complexity O(N) for fused scores and contributions. The function performs\nno I/O and has no side effects. Thread-safe as it operates on input data only.\nRRF formula: fused_score = sum(weight[channel] * 1/(k + rank[channel])) for all channels.",
      "docstyle": "google"
    },
    {
      "full_name": "retrieval.fusion.__all__",
      "short_name": "__all__",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "retrieval.hybrid",
      "short_name": "hybrid",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Hybrid retrieval with RRF fusion.",
      "doc_raw": "Hybrid retrieval with RRF fusion.\n\nFuses results from BM25, SPLADE, and FAISS using Reciprocal Rank Fusion.",
      "docstyle": "google"
    },
    {
      "full_name": "retrieval.hybrid.__all__",
      "short_name": "__all__",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "retrieval.hybrid.create_hit_list",
      "short_name": "create_hit_list",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "doc_ids",
          "kind": "positional_or_keyword",
          "annotated_type": "Sequence[str]",
          "default": null,
          "doc": null
        },
        {
          "name": "scores",
          "kind": "positional_or_keyword",
          "annotated_type": "Sequence[float]",
          "default": null,
          "doc": null
        },
        {
          "name": "source",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "list[SearchHit]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Create SearchHit list from retrieval results.",
      "doc_raw": "Create SearchHit list from retrieval results.\n\nParameters\n----------\ndoc_ids : Sequence[str]\n    Document IDs in rank order.\nscores : Sequence[float]\n    Scores for each document.\nsource : str\n    Source identifier (e.g., \"bm25\", \"faiss\").\n\nReturns\n-------\nlist[SearchHit]\n    Search hits with ranks.",
      "docstyle": "google"
    },
    {
      "full_name": "retrieval.hybrid.reciprocal_rank_fusion",
      "short_name": "reciprocal_rank_fusion",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "result_lists",
          "kind": "positional_or_keyword",
          "annotated_type": "Sequence[Sequence[SearchHit]]",
          "default": null,
          "doc": null
        },
        {
          "name": "k",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": "60",
          "doc": null
        },
        {
          "name": "top_k",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": "50",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "list[tuple[str, float]]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Fuse multiple ranked lists using RRF.",
      "doc_raw": "Fuse multiple ranked lists using RRF.\n\nParameters\n----------\nresult_lists : Sequence[Sequence[SearchHit]]\n    Lists of search hits from different retrieval systems.\nk : int\n    RRF K parameter (higher = more weight to lower ranks).\ntop_k : int\n    Number of results to return.\n\nReturns\n-------\nlist[tuple[str, float]]\n    Fused results as (doc_id, rrf_score) sorted by score descending.\n\nNotes\n-----\nRRF score for document d is:\n    RRF(d) = sum over all systems S of: 1 / (k + rank_S(d))\n\nwhere rank_S(d) is the rank of d in system S (1-indexed).",
      "docstyle": "google"
    },
    {
      "full_name": "retrieval.hybrid.SearchHit",
      "short_name": "SearchHit",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "dataclass(frozen=True)"
      ],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "doc_id",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "score",
          "kind": "positional_or_keyword",
          "annotated_type": "float",
          "default": null,
          "doc": null
        },
        {
          "name": "rank",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "source",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Search result hit from a single retrieval system.",
      "doc_raw": "Search result hit from a single retrieval system.\n\nRepresents one search result from a retrieval system (FAISS, BM25, SPLADE, etc.)\nbefore fusion. Contains the document/chunk ID, its relevance score, rank\nposition, and which retrieval system found it.\n\nSearchHit objects are created for each retrieval system's results, then\ncombined using Reciprocal Rank Fusion (RRF) to produce a unified ranked list.\nThe source field allows tracking which system contributed each result, which\nis useful for analysis and debugging.\n\nAttributes\n----------\ndoc_id : str\n    Document or chunk ID that was retrieved. This should match the ID used\n    in the index (e.g., chunk ID from DuckDB). Used to look up full chunk\n    information after fusion.\nscore : float\n    Original relevance score from the retrieval system. Score ranges and\n    meanings vary by system (FAISS uses cosine similarity, BM25 uses BM25 score,\n    etc.). Used for debugging and understanding individual system performance.\nrank : int\n    Rank position in the original result list (0-indexed). Rank 0 is the\n    top result. Used by RRF to compute fusion scores - lower ranks get higher\n    RRF scores.\nsource : str\n    Identifier for the retrieval system that produced this hit (e.g., \"faiss\",\n    \"bm25\", \"splade\", \"structural\"). Used for analysis, debugging, and\n    understanding which systems contribute to final results.",
      "docstyle": "google"
    },
    {
      "full_name": "retrieval.hybrid.SearchHit.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "doc_id",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "score",
          "kind": "positional_or_keyword",
          "annotated_type": "float",
          "default": null,
          "doc": null
        },
        {
          "name": "rank",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "source",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "retrieval.hybrid.SearchHit.source",
      "short_name": "source",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "retrieval.hybrid.SearchHit.rank",
      "short_name": "rank",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "retrieval.hybrid.SearchHit.score",
      "short_name": "score",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "retrieval.hybrid.SearchHit.doc_id",
      "short_name": "doc_id",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "retrieval.gating",
      "short_name": "gating",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Adaptive gating helpers for multi-stage retrieval pipelines.",
      "doc_raw": "Adaptive gating helpers for multi-stage retrieval pipelines.",
      "docstyle": "google"
    },
    {
      "full_name": "retrieval.gating.__all__",
      "short_name": "__all__",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "retrieval.gating.should_run_secondary_stage",
      "short_name": "should_run_secondary_stage",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "signals",
          "kind": "positional_or_keyword",
          "annotated_type": "StageSignals",
          "default": null,
          "doc": null
        },
        {
          "name": "config",
          "kind": "positional_or_keyword",
          "annotated_type": "StageGateConfig",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "StageDecision",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Return a gating decision for a downstream stage based on upstream signals.",
      "doc_raw": "Return a gating decision for a downstream stage based on upstream signals.\n\nExtended Summary\n----------------\nThis function implements adaptive gating logic for multi-stage retrieval pipelines,\ndeciding whether to run expensive secondary stages (e.g., reranking, late interaction)\nbased on upstream performance signals. It evaluates candidate count, elapsed time budget,\nand score margin to determine if the secondary stage would provide sufficient value.\nThis prevents unnecessary computation when upstream results are already high-quality or\nwhen time budgets are exceeded, improving overall pipeline efficiency.\n\nParameters\n----------\nsignals : StageSignals\n    Performance signals from the upstream stage, including candidate count, elapsed\n    time, and score distribution. Used to assess whether secondary stage is warranted.\nconfig : StageGateConfig\n    Gating configuration specifying thresholds for candidate count, margin, and time\n    budget. Defines the decision criteria for running the secondary stage.\n\nReturns\n-------\nStageDecision\n    Decision object describing whether the stage should run and why. Contains\n    should_run boolean, reason string, and optional notes explaining the decision.\n    Reasons include: \"no_candidates\", \"insufficient_candidates\", \"upstream_budget_exceeded\",\n    \"high_margin\", \"within_budget\".\n\nNotes\n-----\nTime complexity O(1) for decision logic. Space complexity O(1) aside from the\nStageDecision object. The function performs no I/O and has no side effects.\nThread-safe as it operates on input data only. Decision logic prioritizes:\n1. Candidate availability (must have candidates)\n2. Time budget (must not exceed budget)\n3. Score margin (high margin suggests good results already)",
      "docstyle": "google"
    },
    {
      "full_name": "retrieval.gating.StageGateConfig",
      "short_name": "StageGateConfig",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "dataclass(slots=True, frozen=True)"
      ],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "min_candidates",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": "40",
          "doc": null
        },
        {
          "name": "margin_threshold",
          "kind": "positional_or_keyword",
          "annotated_type": "float",
          "default": "0.1",
          "doc": null
        },
        {
          "name": "budget_ms",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": "150",
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Configuration inputs for deciding whether to invoke a follow-up stage.",
      "doc_raw": "Configuration inputs for deciding whether to invoke a follow-up stage.",
      "docstyle": "google"
    },
    {
      "full_name": "retrieval.gating.StageGateConfig.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "min_candidates",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": "40",
          "doc": null
        },
        {
          "name": "margin_threshold",
          "kind": "positional_or_keyword",
          "annotated_type": "float",
          "default": "0.1",
          "doc": null
        },
        {
          "name": "budget_ms",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": "150",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "retrieval.gating.StageGateConfig.budget_ms",
      "short_name": "budget_ms",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "retrieval.gating.StageGateConfig.margin_threshold",
      "short_name": "margin_threshold",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "retrieval.gating.StageGateConfig.min_candidates",
      "short_name": "min_candidates",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "retrieval.telemetry",
      "short_name": "telemetry",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Stage-level telemetry helpers used by multi-stage retrieval pipelines.",
      "doc_raw": "Stage-level telemetry helpers used by multi-stage retrieval pipelines.",
      "docstyle": "google"
    },
    {
      "full_name": "retrieval.telemetry.__all__",
      "short_name": "__all__",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "retrieval.telemetry.record_stage_decision",
      "short_name": "record_stage_decision",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "component",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "stage",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "decision",
          "kind": "keyword_only",
          "annotated_type": "StageDecision",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Increment the stage decision counter for the given outcome.",
      "doc_raw": "Increment the stage decision counter for the given outcome.",
      "docstyle": "google"
    },
    {
      "full_name": "retrieval.telemetry.record_stage_metric",
      "short_name": "record_stage_metric",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "component",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "timing",
          "kind": "positional_or_keyword",
          "annotated_type": "StageTiming",
          "default": null,
          "doc": null
        },
        {
          "name": "metrics",
          "kind": "keyword_only",
          "annotated_type": "MetricsProvider | None",
          "default": "None",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Record the provided ``timing`` in Prometheus metrics.",
      "doc_raw": "Record the provided ``timing`` in Prometheus metrics.",
      "docstyle": "google"
    },
    {
      "full_name": "retrieval.telemetry._STAGE_DECISION_COUNTER",
      "short_name": "_STAGE_DECISION_COUNTER",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "retrieval.telemetry.LOGGER",
      "short_name": "LOGGER",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "retrieval.telemetry.track_stage",
      "short_name": "track_stage",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "contextmanager"
      ],
      "params": [
        {
          "name": "name",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "budget_ms",
          "kind": "keyword_only",
          "annotated_type": "int | None",
          "default": "None",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "Iterator[_StageTimer]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Context manager yielding a timer that can be converted into StageTiming.",
      "doc_raw": "Context manager yielding a timer that can be converted into StageTiming.\n\nExtended Summary\n----------------\nThis context manager provides stage-level timing and observability for retrieval\npipeline stages. It creates a timer that automatically captures start/stop times\nand can be converted to StageTiming objects for telemetry. The timer tracks\nelapsed time and compares it against an optional budget, enabling performance\nmonitoring and budget-based gating decisions. This is used throughout the retrieval\npipeline to instrument stage execution times.\n\nParameters\n----------\nname : str\n    Stage name identifier for telemetry and logging. Used to label metrics and\n    identify the stage in observability dashboards.\nbudget_ms : int | None, optional\n    Optional time budget in milliseconds. If provided, the timer compares elapsed\n    time against this budget. Used for adaptive gating decisions. Defaults to None.\n\nYields\n------\n_StageTimer\n    Timer instance used to capture duration metrics. The timer is automatically\n    started when entering the context and stopped when exiting. Can be converted\n    to StageTiming via timer.as_timing().\n\nNotes\n-----\nTime complexity O(1) for timer operations. Space complexity O(1) aside from the\ntimer object. The function performs no I/O but captures system time via\ntime.monotonic(). Thread-safe if used within a single thread context. The timer\nis automatically stopped even if an exception occurs within the context.",
      "docstyle": "google"
    },
    {
      "full_name": "retrieval.telemetry._StageTimer",
      "short_name": "_StageTimer",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "dataclass(slots=True, frozen=True)"
      ],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "name",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "budget_ms",
          "kind": "positional_or_keyword",
          "annotated_type": "int | None",
          "default": null,
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "retrieval.telemetry._StageTimer.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "name",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "budget_ms",
          "kind": "positional_or_keyword",
          "annotated_type": "int | None",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "retrieval.telemetry._StageTimer.snapshot",
      "short_name": "snapshot",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "StageTiming",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "retrieval.telemetry._StageTimer.stop",
      "short_name": "stop",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "retrieval.telemetry._StageTimer._runtime",
      "short_name": "_runtime",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "retrieval.telemetry._StageTimer.budget_ms",
      "short_name": "budget_ms",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "retrieval.telemetry._StageTimer.name",
      "short_name": "name",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "retrieval.telemetry._TimerRuntime",
      "short_name": "_TimerRuntime",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Mutable stopwatch backing the frozen stage timer.",
      "doc_raw": "Mutable stopwatch backing the frozen stage timer.",
      "docstyle": "google"
    },
    {
      "full_name": "retrieval.telemetry._TimerRuntime.stop",
      "short_name": "stop",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "float",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "retrieval.telemetry._TimerRuntime.stopped",
      "short_name": "stopped",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "retrieval.telemetry._TimerRuntime.duration_ms",
      "short_name": "duration_ms",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "retrieval.telemetry._TimerRuntime.started_at",
      "short_name": "started_at",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "retrieval.telemetry._TimerRuntime.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "retrieval.telemetry._TimerRuntime.__slots__",
      "short_name": "__slots__",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "retrieval.telemetry.StageTiming",
      "short_name": "StageTiming",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "dataclass(slots=True, frozen=True)"
      ],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "name",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "duration_ms",
          "kind": "positional_or_keyword",
          "annotated_type": "float",
          "default": null,
          "doc": null
        },
        {
          "name": "budget_ms",
          "kind": "positional_or_keyword",
          "annotated_type": "int | None",
          "default": null,
          "doc": null
        },
        {
          "name": "exceeded_budget",
          "kind": "positional_or_keyword",
          "annotated_type": "bool",
          "default": null,
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Snapshot describing how long a stage took relative to its budget.",
      "doc_raw": "Snapshot describing how long a stage took relative to its budget.",
      "docstyle": "google"
    },
    {
      "full_name": "retrieval.telemetry.StageTiming.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "name",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "duration_ms",
          "kind": "positional_or_keyword",
          "annotated_type": "float",
          "default": null,
          "doc": null
        },
        {
          "name": "budget_ms",
          "kind": "positional_or_keyword",
          "annotated_type": "int | None",
          "default": null,
          "doc": null
        },
        {
          "name": "exceeded_budget",
          "kind": "positional_or_keyword",
          "annotated_type": "bool",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "retrieval.telemetry.StageTiming.as_payload",
      "short_name": "as_payload",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "dict[str, float | int | bool | str | None]",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Return a JSON-friendly payload for inclusion in envelopes.",
      "doc_raw": "Return a JSON-friendly payload for inclusion in envelopes.\n\nReturns\n-------\ndict[str, float | int | bool | str | None]\n    Mapping containing stage timing metadata.",
      "docstyle": "google"
    },
    {
      "full_name": "retrieval.telemetry.StageTiming.exceeded_budget",
      "short_name": "exceeded_budget",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "retrieval.telemetry.StageTiming.budget_ms",
      "short_name": "budget_ms",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "retrieval.telemetry.StageTiming.duration_ms",
      "short_name": "duration_ms",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "retrieval.telemetry.StageTiming.name",
      "short_name": "name",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "retrieval.types",
      "short_name": "types",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Shared retrieval dataclasses for multi-stage pipelines.",
      "doc_raw": "Shared retrieval dataclasses for multi-stage pipelines.",
      "docstyle": "google"
    },
    {
      "full_name": "retrieval.types.__all__",
      "short_name": "__all__",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "retrieval.types.StageDecision",
      "short_name": "StageDecision",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "dataclass(slots=True, frozen=True)"
      ],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "should_run",
          "kind": "positional_or_keyword",
          "annotated_type": "bool",
          "default": null,
          "doc": null
        },
        {
          "name": "reason",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "notes",
          "kind": "positional_or_keyword",
          "annotated_type": "tuple[str, ...]",
          "default": "()",
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Decision emitted by gating logic describing whether to run the stage.",
      "doc_raw": "Decision emitted by gating logic describing whether to run the stage.",
      "docstyle": "google"
    },
    {
      "full_name": "retrieval.types.StageDecision.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "should_run",
          "kind": "positional_or_keyword",
          "annotated_type": "bool",
          "default": null,
          "doc": null
        },
        {
          "name": "reason",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "notes",
          "kind": "positional_or_keyword",
          "annotated_type": "tuple[str, ...]",
          "default": "()",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "retrieval.types.StageDecision.notes",
      "short_name": "notes",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "retrieval.types.StageDecision.reason",
      "short_name": "reason",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "retrieval.types.StageDecision.should_run",
      "short_name": "should_run",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "retrieval.types.StageSignals",
      "short_name": "StageSignals",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "dataclass(slots=True, frozen=True)"
      ],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "candidate_count",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "elapsed_ms",
          "kind": "positional_or_keyword",
          "annotated_type": "float",
          "default": null,
          "doc": null
        },
        {
          "name": "best_score",
          "kind": "positional_or_keyword",
          "annotated_type": "float | None",
          "default": "None",
          "doc": null
        },
        {
          "name": "second_best_score",
          "kind": "positional_or_keyword",
          "annotated_type": "float | None",
          "default": "None",
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Signals gathered from a stage for downstream gating decisions.",
      "doc_raw": "Signals gathered from a stage for downstream gating decisions.",
      "docstyle": "google"
    },
    {
      "full_name": "retrieval.types.StageSignals.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "candidate_count",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        },
        {
          "name": "elapsed_ms",
          "kind": "positional_or_keyword",
          "annotated_type": "float",
          "default": null,
          "doc": null
        },
        {
          "name": "best_score",
          "kind": "positional_or_keyword",
          "annotated_type": "float | None",
          "default": "None",
          "doc": null
        },
        {
          "name": "second_best_score",
          "kind": "positional_or_keyword",
          "annotated_type": "float | None",
          "default": "None",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "retrieval.types.StageSignals.margin",
      "short_name": "margin",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "float | None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Return score gap between best and runner-up when available.",
      "doc_raw": "Return score gap between best and runner-up when available.\n\nReturns\n-------\nfloat | None\n    Score margin or ``None`` when insufficient data exists.",
      "docstyle": "google"
    },
    {
      "full_name": "retrieval.types.StageSignals.second_best_score",
      "short_name": "second_best_score",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "retrieval.types.StageSignals.best_score",
      "short_name": "best_score",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "retrieval.types.StageSignals.elapsed_ms",
      "short_name": "elapsed_ms",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "retrieval.types.StageSignals.candidate_count",
      "short_name": "candidate_count",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "retrieval.types.HybridSearchResult",
      "short_name": "HybridSearchResult",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "dataclass(slots=True, frozen=True)"
      ],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "docs",
          "kind": "positional_or_keyword",
          "annotated_type": "Sequence[HybridResultDoc]",
          "default": null,
          "doc": null
        },
        {
          "name": "contributions",
          "kind": "positional_or_keyword",
          "annotated_type": "Mapping[str, list[tuple[str, int, float]]]",
          "default": null,
          "doc": null
        },
        {
          "name": "channels",
          "kind": "positional_or_keyword",
          "annotated_type": "list[str]",
          "default": null,
          "doc": null
        },
        {
          "name": "warnings",
          "kind": "positional_or_keyword",
          "annotated_type": "list[str]",
          "default": null,
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Container for fused docs alongside explainability metadata.",
      "doc_raw": "Container for fused docs alongside explainability metadata.",
      "docstyle": "google"
    },
    {
      "full_name": "retrieval.types.HybridSearchResult.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "docs",
          "kind": "positional_or_keyword",
          "annotated_type": "Sequence[HybridResultDoc]",
          "default": null,
          "doc": null
        },
        {
          "name": "contributions",
          "kind": "positional_or_keyword",
          "annotated_type": "Mapping[str, list[tuple[str, int, float]]]",
          "default": null,
          "doc": null
        },
        {
          "name": "channels",
          "kind": "positional_or_keyword",
          "annotated_type": "list[str]",
          "default": null,
          "doc": null
        },
        {
          "name": "warnings",
          "kind": "positional_or_keyword",
          "annotated_type": "list[str]",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "retrieval.types.HybridSearchResult.warnings",
      "short_name": "warnings",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "retrieval.types.HybridSearchResult.channels",
      "short_name": "channels",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "retrieval.types.HybridSearchResult.contributions",
      "short_name": "contributions",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "retrieval.types.HybridSearchResult.docs",
      "short_name": "docs",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "retrieval.types.HybridResultDoc",
      "short_name": "HybridResultDoc",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "dataclass(slots=True, frozen=True)"
      ],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "doc_id",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "score",
          "kind": "positional_or_keyword",
          "annotated_type": "float",
          "default": null,
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Final fused result produced by weighted RRF.",
      "doc_raw": "Final fused result produced by weighted RRF.",
      "docstyle": "google"
    },
    {
      "full_name": "retrieval.types.HybridResultDoc.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "doc_id",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "score",
          "kind": "positional_or_keyword",
          "annotated_type": "float",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "retrieval.types.HybridResultDoc.score",
      "short_name": "score",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "retrieval.types.HybridResultDoc.doc_id",
      "short_name": "doc_id",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "retrieval.types.ChannelHit",
      "short_name": "ChannelHit",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "dataclass(slots=True, frozen=True)"
      ],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "doc_id",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "score",
          "kind": "positional_or_keyword",
          "annotated_type": "float",
          "default": null,
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Score emitted by a retrieval channel prior to fusion.",
      "doc_raw": "Score emitted by a retrieval channel prior to fusion.",
      "docstyle": "google"
    },
    {
      "full_name": "retrieval.types.ChannelHit.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "doc_id",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "score",
          "kind": "positional_or_keyword",
          "annotated_type": "float",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "retrieval.types.ChannelHit.score",
      "short_name": "score",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "retrieval.types.ChannelHit.doc_id",
      "short_name": "doc_id",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "runtime",
      "short_name": "runtime",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Runtime helpers for mutable, closeable state.",
      "doc_raw": "Runtime helpers for mutable, closeable state.",
      "docstyle": "google"
    },
    {
      "full_name": "runtime.cells",
      "short_name": "cells",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Thread-safe runtime cell primitive for mutable subsystems.",
      "doc_raw": "Thread-safe runtime cell primitive for mutable subsystems.",
      "docstyle": "google"
    },
    {
      "full_name": "runtime.cells.__all__",
      "short_name": "__all__",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "runtime.cells.RuntimeCell",
      "short_name": "RuntimeCell",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "final"
      ],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "name",
          "kind": "keyword_only",
          "annotated_type": "str | None",
          "default": "None",
          "doc": null
        },
        {
          "name": "observer",
          "kind": "keyword_only",
          "annotated_type": "RuntimeCellObserver | None",
          "default": "None",
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Thread-safe lazy holder for mutable runtime state.",
      "doc_raw": "Thread-safe lazy holder for mutable runtime state.\n\nExtended Summary\n----------------\nThe cell stores a single payload created on demand via :meth:`get_or_initialize`.\nTest suites can inject fakes via :meth:`seed` when ``PYTEST_CURRENT_TEST`` or\n``KGFOUNDRY_ALLOW_RUNTIME_SEED=1`` is set. The :meth:`close` method resets the\ncell and best-effort invokes ``close()``/``__exit__`` on the payload. The cell\nuses a reentrant lock to ensure thread-safe initialization and disposal, making\nit suitable for use in multi-threaded environments where runtime resources need\nto be lazily initialized and safely cleaned up.\n\nParameters\n----------\nname : str | None, optional\n    Optional identifier used in debug logging and observer callbacks. Defaults\n    to ``\"runtime\"``.\nobserver : RuntimeCellObserver | None, optional\n    Observer instance that receives lifecycle callbacks (on_init_start,\n    on_init_end, on_close_end). Used for instrumentation, monitoring, and\n    diagnostics. If None (default), uses NullRuntimeCellObserver which\n    suppresses all callbacks. Defaults to None.",
      "docstyle": "google"
    },
    {
      "full_name": "runtime.cells.RuntimeCell._resolve_disposer",
      "short_name": "_resolve_disposer",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "staticmethod"
      ],
      "params": [
        {
          "name": "value",
          "kind": "positional_or_keyword",
          "annotated_type": "T",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "tuple[Callable[[], None] | None, bool]",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "runtime.cells.RuntimeCell.close",
      "short_name": "close",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "silent",
          "kind": "keyword_only",
          "annotated_type": "bool",
          "default": "True",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Clear the payload and attempt to release runtime resources.",
      "doc_raw": "Clear the payload and attempt to release runtime resources.\n\nExtended Summary\n----------------\nThis method clears the cell's payload and attempts to release associated\nruntime resources by invoking the payload's ``close()`` method if available.\nWhen ``silent=True`` (default), any exceptions during disposal are logged\nand suppressed, ensuring cleanup failures don't propagate. When ``silent=False``,\nexceptions are re-raised to allow callers to handle disposal errors explicitly.\nThis design supports both defensive cleanup (silent mode) and explicit error\nhandling (non-silent mode) depending on the use case.\n\nParameters\n----------\nsilent : bool, optional\n    When ``True`` (default), disposal errors are logged and suppressed.\n    When ``False``, exceptions raised by the payload's disposal propagate\n    to the caller. Defaults to True.\n\nRaises\n------\nOSError\n    When ``silent=False`` and the payload's disposal raises an OS-level error\n    (e.g., file handle closure failures). Note: IOError is an alias for OSError\n    in Python 3 and is handled by this exception type.\nRuntimeError\n    When ``silent=False`` and the payload's disposal raises a runtime error.\nAttributeError\n    When ``silent=False`` and the payload's disposal raises an attribute error.\nException\n    When ``silent=False`` and the payload's disposal raises any other exception\n    type. This catch-all handles exceptions from third-party libraries that may\n    raise custom exception types during resource disposal. The exception is\n    re-raised to the caller after logging.\n\nNotes\n-----\nTime complexity O(1) for clearing state; O(D) for disposal where D is\nthe cost of the payload's close operation. Space complexity O(1).\nThe method performs I/O if the payload's close method does I/O (e.g.,\nclosing file handles, network connections). Thread-safe due to lock\nacquisition. Idempotent - multiple calls are safe and have no effect\nafter the first successful close. The method uses best-effort disposal\nwhen silent=True, logging warnings for failures without interrupting\nexecution flow.\n\nWhen ``silent=False``, any exception raised by the payload's disposal\n(including custom exception types from third-party libraries) is re-raised\nto the caller. The specific exception types listed in Raises are the most\ncommon, but other exception types may also be propagated.",
      "docstyle": "google"
    },
    {
      "full_name": "runtime.cells.RuntimeCell.seed",
      "short_name": "seed",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "value",
          "kind": "positional_or_keyword",
          "annotated_type": "T",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Inject a payload for tests when the cell is empty.",
      "doc_raw": "Inject a payload for tests when the cell is empty.\n\nParameters\n----------\nvalue : T\n    Payload instance to cache for subsequent calls.\n\nRaises\n------\nRuntimeError\n    If seeding is attempted outside a test context or the cell is already\n    initialized.",
      "docstyle": "google"
    },
    {
      "full_name": "runtime.cells.RuntimeCell.get_or_initialize",
      "short_name": "get_or_initialize",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "factory",
          "kind": "positional_or_keyword",
          "annotated_type": "Callable[[], T]",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "T",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Return the payload, invoking ``factory`` exactly once when empty.",
      "doc_raw": "Return the payload, invoking ``factory`` exactly once when empty.\n\nExtended Summary\n----------------\nThis method implements thread-safe lazy initialization using double-checked\nlocking. If the cell already contains a payload, it returns immediately.\nOtherwise, it acquires a lock, checks again (to handle race conditions),\nand invokes the factory function to create the payload. The factory is\ncalled exactly once, even under concurrent access. Observer callbacks are\ninvoked before and after initialization, providing instrumentation hooks\nfor monitoring and diagnostics.\n\nParameters\n----------\nfactory : Callable[[], T]\n    Callable that builds the runtime payload. Must be a zero-argument function\n    that returns an instance of type T. The factory is invoked only when the\n    cell is empty, and its return value is cached for subsequent calls.\n\nReturns\n-------\nT\n    Existing payload if present, otherwise the value returned by ``factory``.\n    The payload is cached for subsequent calls, ensuring the factory is\n    invoked at most once.\n\nRaises\n------\nException\n    Any exception raised by the factory function is logged with context\n    (cell name, exception type, error message) and re-raised to the caller.\n    The cell remains in an uninitialized state after a factory failure,\n    allowing retry on subsequent calls.\n\nNotes\n-----\nTime complexity O(1) for cached payload access; O(F) for initialization\nwhere F is the cost of the factory function. Space complexity O(1) aside\nfrom the payload itself. The method performs I/O if the factory performs\nI/O (e.g., loading files, establishing network connections). Thread-safe\ndue to reentrant lock acquisition. The method is idempotent - multiple\nconcurrent calls with the same factory converge to a single initialization.\n\nAny exception raised by the factory function is logged with context (cell\nname, exception type, error message) and re-raised to the caller. The cell\nremains in an uninitialized state after a factory failure, allowing retry\non subsequent calls.\n\nExamples\n--------\n>>> cell = RuntimeCell(name=\"my-runtime\")\n>>> def create_client():\n...     return MyClient()\n>>> client = cell.get_or_initialize(create_client)\n>>> assert client is not None\n>>> # Subsequent calls return the same instance\n>>> assert cell.get_or_initialize(create_client) is client",
      "docstyle": "google"
    },
    {
      "full_name": "runtime.cells.RuntimeCell.configure_observer",
      "short_name": "configure_observer",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "observer",
          "kind": "positional_or_keyword",
          "annotated_type": "RuntimeCellObserver",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Attach an observer that receives lifecycle callbacks.",
      "doc_raw": "Attach an observer that receives lifecycle callbacks.\n\nParameters\n----------\nobserver : RuntimeCellObserver\n    Observer instance. May be swapped once during context wiring.",
      "docstyle": "google"
    },
    {
      "full_name": "runtime.cells.RuntimeCell.peek",
      "short_name": "peek",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "T | None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Return the current payload without triggering initialization.",
      "doc_raw": "Return the current payload without triggering initialization.\n\nReturns\n-------\nT | None\n    The cached payload if present; otherwise ``None``.",
      "docstyle": "google"
    },
    {
      "full_name": "runtime.cells.RuntimeCell.__bool__",
      "short_name": "__bool__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "bool",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Return ``True`` when the cell currently holds a value.",
      "doc_raw": "Return ``True`` when the cell currently holds a value.\n\nReturns\n-------\nbool\n    ``True`` if a payload exists; otherwise ``False``.",
      "docstyle": "google"
    },
    {
      "full_name": "runtime.cells.RuntimeCell.__repr__",
      "short_name": "__repr__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "str",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Return a concise representation without exposing payload internals.",
      "doc_raw": "Return a concise representation without exposing payload internals.\n\nReturns\n-------\nstr\n    Debug-friendly representation that omits the payload itself.",
      "docstyle": "google"
    },
    {
      "full_name": "runtime.cells.RuntimeCell._observer",
      "short_name": "_observer",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "runtime.cells.RuntimeCell._name",
      "short_name": "_name",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "runtime.cells.RuntimeCell._initialized",
      "short_name": "_initialized",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "runtime.cells.RuntimeCell._value",
      "short_name": "_value",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "runtime.cells.RuntimeCell._lock",
      "short_name": "_lock",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "runtime.cells.RuntimeCell.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "name",
          "kind": "keyword_only",
          "annotated_type": "str | None",
          "default": "None",
          "doc": null
        },
        {
          "name": "observer",
          "kind": "keyword_only",
          "annotated_type": "RuntimeCellObserver | None",
          "default": "None",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "runtime.cells.RuntimeCell.__slots__",
      "short_name": "__slots__",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "runtime.cells.NullRuntimeCellObserver",
      "short_name": "NullRuntimeCellObserver",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "No-op observer used when instrumentation is disabled.",
      "doc_raw": "No-op observer used when instrumentation is disabled.",
      "docstyle": "google"
    },
    {
      "full_name": "runtime.cells.NullRuntimeCellObserver.on_close_end",
      "short_name": "on_close_end",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "event",
          "kind": "positional_or_keyword",
          "annotated_type": "RuntimeCellCloseResult",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "No-op observer hook.",
      "doc_raw": "No-op observer hook.",
      "docstyle": "google"
    },
    {
      "full_name": "runtime.cells.NullRuntimeCellObserver.on_init_end",
      "short_name": "on_init_end",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "event",
          "kind": "positional_or_keyword",
          "annotated_type": "RuntimeCellInitResult",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "No-op observer hook.",
      "doc_raw": "No-op observer hook.",
      "docstyle": "google"
    },
    {
      "full_name": "runtime.cells.NullRuntimeCellObserver.on_init_start",
      "short_name": "on_init_start",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "cell",
          "kind": "keyword_only",
          "annotated_type": "str",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "No-op observer hook.",
      "doc_raw": "No-op observer hook.",
      "docstyle": "google"
    },
    {
      "full_name": "runtime.cells.NullRuntimeCellObserver.__slots__",
      "short_name": "__slots__",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "runtime.cells.RuntimeCellObserver",
      "short_name": "RuntimeCellObserver",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [
        "Protocol"
      ],
      "decorators": [
        "runtime_checkable"
      ],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Protocol for observing RuntimeCell lifecycle events.",
      "doc_raw": "Protocol for observing RuntimeCell lifecycle events.",
      "docstyle": "google"
    },
    {
      "full_name": "runtime.cells.RuntimeCellObserver.on_close_end",
      "short_name": "on_close_end",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "event",
          "kind": "positional_or_keyword",
          "annotated_type": "RuntimeCellCloseResult",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Handle completion (success/failure) of ``close()``.",
      "doc_raw": "Handle completion (success/failure) of ``close()``.",
      "docstyle": "google"
    },
    {
      "full_name": "runtime.cells.RuntimeCellObserver.on_init_end",
      "short_name": "on_init_end",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "event",
          "kind": "positional_or_keyword",
          "annotated_type": "RuntimeCellInitResult",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Handle completion (success/failure) of initialization.",
      "doc_raw": "Handle completion (success/failure) of initialization.",
      "docstyle": "google"
    },
    {
      "full_name": "runtime.cells.RuntimeCellObserver.on_init_start",
      "short_name": "on_init_start",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "cell",
          "kind": "keyword_only",
          "annotated_type": "str",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Invoke before initialization begins.",
      "doc_raw": "Invoke before initialization begins.",
      "docstyle": "google"
    },
    {
      "full_name": "runtime.cells._seed_allowed",
      "short_name": "_seed_allowed",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": {
        "annotated_type": "bool",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "runtime.cells.RuntimeCellCloseResult",
      "short_name": "RuntimeCellCloseResult",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "dataclass(slots=True, frozen=True)"
      ],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "cell",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "had_payload",
          "kind": "positional_or_keyword",
          "annotated_type": "bool",
          "default": null,
          "doc": null
        },
        {
          "name": "close_called",
          "kind": "positional_or_keyword",
          "annotated_type": "bool",
          "default": null,
          "doc": null
        },
        {
          "name": "status",
          "kind": "positional_or_keyword",
          "annotated_type": "CloseStatus",
          "default": null,
          "doc": null
        },
        {
          "name": "duration_ms",
          "kind": "positional_or_keyword",
          "annotated_type": "float",
          "default": null,
          "doc": null
        },
        {
          "name": "error",
          "kind": "positional_or_keyword",
          "annotated_type": "Exception | None",
          "default": null,
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Immutable payload describing close outcome.",
      "doc_raw": "Immutable payload describing close outcome.",
      "docstyle": "google"
    },
    {
      "full_name": "runtime.cells.RuntimeCellCloseResult.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "cell",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "had_payload",
          "kind": "positional_or_keyword",
          "annotated_type": "bool",
          "default": null,
          "doc": null
        },
        {
          "name": "close_called",
          "kind": "positional_or_keyword",
          "annotated_type": "bool",
          "default": null,
          "doc": null
        },
        {
          "name": "status",
          "kind": "positional_or_keyword",
          "annotated_type": "CloseStatus",
          "default": null,
          "doc": null
        },
        {
          "name": "duration_ms",
          "kind": "positional_or_keyword",
          "annotated_type": "float",
          "default": null,
          "doc": null
        },
        {
          "name": "error",
          "kind": "positional_or_keyword",
          "annotated_type": "Exception | None",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "runtime.cells.RuntimeCellCloseResult.error",
      "short_name": "error",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "runtime.cells.RuntimeCellCloseResult.duration_ms",
      "short_name": "duration_ms",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "runtime.cells.RuntimeCellCloseResult.status",
      "short_name": "status",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "runtime.cells.RuntimeCellCloseResult.close_called",
      "short_name": "close_called",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "runtime.cells.RuntimeCellCloseResult.had_payload",
      "short_name": "had_payload",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "runtime.cells.RuntimeCellCloseResult.cell",
      "short_name": "cell",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "runtime.cells.RuntimeCellInitResult",
      "short_name": "RuntimeCellInitResult",
      "kind": "class",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [
        "dataclass(slots=True, frozen=True)"
      ],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "cell",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "payload",
          "kind": "positional_or_keyword",
          "annotated_type": "object | None",
          "default": null,
          "doc": null
        },
        {
          "name": "status",
          "kind": "positional_or_keyword",
          "annotated_type": "InitStatus",
          "default": null,
          "doc": null
        },
        {
          "name": "duration_ms",
          "kind": "positional_or_keyword",
          "annotated_type": "float",
          "default": null,
          "doc": null
        },
        {
          "name": "error",
          "kind": "positional_or_keyword",
          "annotated_type": "Exception | None",
          "default": null,
          "doc": null
        }
      ],
      "returns": null,
      "raises": [],
      "doc_summary": "Immutable payload describing initialization outcome.",
      "doc_raw": "Immutable payload describing initialization outcome.",
      "docstyle": "google"
    },
    {
      "full_name": "runtime.cells.RuntimeCellInitResult.__init__",
      "short_name": "__init__",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "self",
          "kind": "positional_or_keyword",
          "annotated_type": null,
          "default": null,
          "doc": null
        },
        {
          "name": "cell",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "payload",
          "kind": "positional_or_keyword",
          "annotated_type": "object | None",
          "default": null,
          "doc": null
        },
        {
          "name": "status",
          "kind": "positional_or_keyword",
          "annotated_type": "InitStatus",
          "default": null,
          "doc": null
        },
        {
          "name": "duration_ms",
          "kind": "positional_or_keyword",
          "annotated_type": "float",
          "default": null,
          "doc": null
        },
        {
          "name": "error",
          "kind": "positional_or_keyword",
          "annotated_type": "Exception | None",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "runtime.cells.RuntimeCellInitResult.error",
      "short_name": "error",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "runtime.cells.RuntimeCellInitResult.duration_ms",
      "short_name": "duration_ms",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "runtime.cells.RuntimeCellInitResult.status",
      "short_name": "status",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "runtime.cells.RuntimeCellInitResult.payload",
      "short_name": "payload",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "runtime.cells.RuntimeCellInitResult.cell",
      "short_name": "cell",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "runtime.cells.CloseStatus",
      "short_name": "CloseStatus",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "runtime.cells.InitStatus",
      "short_name": "InitStatus",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "runtime.cells._SEED_GUARD_MESSAGE",
      "short_name": "_SEED_GUARD_MESSAGE",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "runtime.cells._SEED_ENV",
      "short_name": "_SEED_ENV",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "runtime.cells.LOGGER",
      "short_name": "LOGGER",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "runtime.cells.T",
      "short_name": "T",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "runtime.__all__",
      "short_name": "__all__",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "tests",
      "short_name": "tests",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "tests.test_utils",
      "short_name": "test_utils",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "tests.test_utils.test_default_user_agent",
      "short_name": "test_default_user_agent",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "tests.test_cdx_api",
      "short_name": "test_cdx_api",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "tests.test_cdx_api.test_near",
      "short_name": "test_near",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "tests.test_cdx_api.test_newest",
      "short_name": "test_newest",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "tests.test_cdx_api.test_oldest",
      "short_name": "test_oldest",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "tests.test_cdx_api.test_d",
      "short_name": "test_d",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "tests.test_cdx_api.test_c",
      "short_name": "test_c",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "tests.test_cdx_api.test_b",
      "short_name": "test_b",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "tests.test_cdx_api.test_a",
      "short_name": "test_a",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "tests.test_cdx_api.rndstr",
      "short_name": "rndstr",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "n",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "str",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "tests.test_wrapper",
      "short_name": "test_wrapper",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "tests.test_wrapper.test_Save",
      "short_name": "test_Save",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "tests.test_wrapper.test_known_urls",
      "short_name": "test_known_urls",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "tests.test_wrapper.test_total_archives",
      "short_name": "test_total_archives",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "tests.test_wrapper.test_near",
      "short_name": "test_near",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "tests.test_wrapper.test_newest",
      "short_name": "test_newest",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "tests.test_wrapper.test_oldest",
      "short_name": "test_oldest",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "tests.test_save_api",
      "short_name": "test_save_api",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "tests.test_save_api.test_archive_url",
      "short_name": "test_archive_url",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Checks the attribute archive_url's value when the save method was not",
      "doc_raw": "Checks the attribute archive_url's value when the save method was not\nexplicitly invoked by the end-user but the save method was invoked implicitly\nby the archive_url method which is an attribute due to @property.",
      "docstyle": "google"
    },
    {
      "full_name": "tests.test_save_api.test_archive_url_parser",
      "short_name": "test_archive_url_parser",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Testing three regex for matches and also tests the response URL.",
      "doc_raw": "Testing three regex for matches and also tests the response URL.",
      "docstyle": "google"
    },
    {
      "full_name": "tests.test_save_api.test_timestamp",
      "short_name": "test_timestamp",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "tests.test_save_api.test_sleep",
      "short_name": "test_sleep",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "sleeping is actually very important for SaveAPI",
      "doc_raw": "sleeping is actually very important for SaveAPI\ninterface stability.\nThe test checks that the time taken by sleep method\nis as intended.",
      "docstyle": "google"
    },
    {
      "full_name": "tests.test_save_api.test_max_redirect_exceeded",
      "short_name": "test_max_redirect_exceeded",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "tests.test_save_api.test_save",
      "short_name": "test_save",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "tests.test_save_api.rndstr",
      "short_name": "rndstr",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "n",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "str",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "tests.test_cdx_snapshot",
      "short_name": "test_cdx_snapshot",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "tests.test_cdx_snapshot.test_CDXSnapshot",
      "short_name": "test_CDXSnapshot",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "tests.test_availability_api",
      "short_name": "test_availability_api",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "tests.test_availability_api.test_no_call_timestamp",
      "short_name": "test_no_call_timestamp",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "If no API requests were made the bound timestamp() method returns",
      "doc_raw": "If no API requests were made the bound timestamp() method returns\nthe datetime.max as a default value.",
      "docstyle": "google"
    },
    {
      "full_name": "tests.test_availability_api.test_no_api_call_str_repr",
      "short_name": "test_no_api_call_str_repr",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Some entitled users maybe want to see what is the string representation",
      "doc_raw": "Some entitled users maybe want to see what is the string representation\nif they don\u2019t make any API requests.\n\nstr() must not return None so we return \"\"",
      "docstyle": "google"
    },
    {
      "full_name": "tests.test_availability_api.test_no_archive",
      "short_name": "test_no_archive",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "ArchiveNotInAvailabilityAPIResponse may be raised if Wayback Machine did not",
      "doc_raw": "ArchiveNotInAvailabilityAPIResponse may be raised if Wayback Machine did not\nreplied with the archive despite the fact that we know the site has million\nof archives. Don't know the reason for this wierd behavior.\n\nAnd also if really there are no archives for the passed URL this exception\nis raised.",
      "docstyle": "google"
    },
    {
      "full_name": "tests.test_availability_api.test_invalid_json",
      "short_name": "test_invalid_json",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "When the API is malfunctioning or we don't pass a URL,",
      "doc_raw": "When the API is malfunctioning or we don't pass a URL,\nit may return invalid JSON data.",
      "docstyle": "google"
    },
    {
      "full_name": "tests.test_availability_api.test_newest",
      "short_name": "test_newest",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Assuming that the recent most Google Archive was made no more earlier than",
      "doc_raw": "Assuming that the recent most Google Archive was made no more earlier than\nlast one day which is 86400 seconds.",
      "docstyle": "google"
    },
    {
      "full_name": "tests.test_availability_api.test_oldest",
      "short_name": "test_oldest",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Test the oldest archive of Google.com and also checks the attributes.",
      "doc_raw": "Test the oldest archive of Google.com and also checks the attributes.",
      "docstyle": "google"
    },
    {
      "full_name": "tests.test_availability_api.rndstr",
      "short_name": "rndstr",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "n",
          "kind": "positional_or_keyword",
          "annotated_type": "int",
          "default": null,
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "str",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "tests.test_availability_api.user_agent",
      "short_name": "user_agent",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "tests.test_availability_api.url",
      "short_name": "url",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "tests.test_availability_api.now",
      "short_name": "now",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "tests.test_cdx_utils",
      "short_name": "test_cdx_utils",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "tests.test_cdx_utils.test_check_sort",
      "short_name": "test_check_sort",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "tests.test_cdx_utils.test_check_match_type",
      "short_name": "test_check_match_type",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "tests.test_cdx_utils.test_check_collapses",
      "short_name": "test_check_collapses",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "tests.test_cdx_utils.test_check_filters",
      "short_name": "test_check_filters",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "tests.test_cdx_utils.test_get_response",
      "short_name": "test_get_response",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "tests.test_cdx_utils.test_full_url",
      "short_name": "test_full_url",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "tests.test_cdx_utils.test_get_total_pages",
      "short_name": "test_get_total_pages",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "tests.test_cli",
      "short_name": "test_cli",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "tests.test_cli.test_known_url",
      "short_name": "test_known_url",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "tests.test_cli.test_only_url",
      "short_name": "test_only_url",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "tests.test_cli.test_license",
      "short_name": "test_license",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "tests.test_cli.test_version",
      "short_name": "test_version",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "tests.test_cli.test_save",
      "short_name": "test_save",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "tests.test_cli.test_cdx",
      "short_name": "test_cdx",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "tests.test_cli.test_newest",
      "short_name": "test_newest",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "tests.test_cli.test_near",
      "short_name": "test_near",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "tests.test_cli.test_oldest",
      "short_name": "test_oldest",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": {
        "annotated_type": "None",
        "doc": null
      },
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "typing",
      "short_name": "typing",
      "kind": "module",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Typing fa\u00e7ade for codeintel_rev heavy optional dependencies.",
      "doc_raw": "Typing fa\u00e7ade for codeintel_rev heavy optional dependencies.\n\nThis module centralizes numpy-style array aliases and exposes a wrapper around\n``kgfoundry_common.typing.gate_import`` that is aware of the local heavy\ndependency policy. Keeping aliases and dependency metadata in one place lets\nlint/type tooling (PR-E) and runtime helpers share the same source of truth.",
      "docstyle": "google"
    },
    {
      "full_name": "typing.gate_import",
      "short_name": "gate_import",
      "kind": "function",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [
        {
          "name": "module_name",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "purpose",
          "kind": "positional_or_keyword",
          "annotated_type": "str",
          "default": null,
          "doc": null
        },
        {
          "name": "min_version",
          "kind": "keyword_only",
          "annotated_type": "str | None",
          "default": "None",
          "doc": null
        }
      ],
      "returns": {
        "annotated_type": "object",
        "doc": null
      },
      "raises": [],
      "doc_summary": "Resolve ``module_name`` lazily using the heavy dependency policy.",
      "doc_raw": "Resolve ``module_name`` lazily using the heavy dependency policy.\n\nReturns\n-------\nobject\n    Imported module or attribute returned by the shared gate helper.",
      "docstyle": "google"
    },
    {
      "full_name": "typing.HEAVY_DEPS",
      "short_name": "HEAVY_DEPS",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": "Registry of heavy optional dependencies and their minimum supported versions.",
      "doc_raw": "Registry of heavy optional dependencies and their minimum supported versions.",
      "docstyle": "google"
    },
    {
      "full_name": "typing.__all__",
      "short_name": "__all__",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "typing.NDArrayAny",
      "short_name": "NDArrayAny",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "typing.NDArrayI64",
      "short_name": "NDArrayI64",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    },
    {
      "full_name": "typing.NDArrayF32",
      "short_name": "NDArrayF32",
      "kind": "attribute",
      "file": null,
      "lineno": null,
      "bases": [],
      "decorators": [],
      "params": [],
      "returns": null,
      "raises": [],
      "doc_summary": null,
      "doc_raw": null,
      "docstyle": "google"
    }
  ],
  "external_deps": [
    "__future__",
    "_faiss",
    "_pytest",
    "_torch",
    "argparse",
    "ast",
    "asyncio",
    "bisect",
    "click",
    "codeintel_rev",
    "collections",
    "concurrent",
    "contextlib",
    "contextvars",
    "copy",
    "dataclasses",
    "datetime",
    "docs",
    "duckdb",
    "faiss",
    "fastapi",
    "fastmcp",
    "fnmatch",
    "functools",
    "git",
    "griffe",
    "hashlib",
    "http",
    "httpx",
    "importlib",
    "inspect",
    "json",
    "kgfoundry",
    "kgfoundry_common",
    "libcst",
    "logging",
    "math",
    "msgspec",
    "np",
    "npt",
    "numpy",
    "orchestration",
    "os",
    "pathlib",
    "prometheus_client",
    "pyarrow",
    "pytest",
    "queue",
    "redis",
    "search_api",
    "sentence_transformers",
    "shutil",
    "socket",
    "starlette",
    "statistics",
    "sys",
    "tempfile",
    "textwrap",
    "threading",
    "time",
    "tools",
    "torch",
    "traceback",
    "transformers",
    "typer",
    "types",
    "unittest",
    "urllib",
    "uuid",
    "vllm",
    "vllm_config",
    "vllm_inputs",
    "warnings"
  ],
  "graph_summary": {
    "nodes": {
      "typing": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": false
      },
      "errors": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": false
      },
      "": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": false
      },
      "_lazy_imports": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": false
      },
      "ops": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": false
      },
      "app.scope_registry": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": false
      },
      "app.middleware": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": false
      },
      "app.gpu_warmup": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": false
      },
      "app.config_context": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": false
      },
      "app.main": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": false
      },
      "app.scope_store": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": false
      },
      "app": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": false
      },
      "app.capabilities": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": false
      },
      "app.readiness": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": false
      },
      "bin.index_all": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": false
      },
      "bin": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": false
      },
      "config.settings": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": false
      },
      "config.utils": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": false
      },
      "config": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": false
      },
      "indexing.scip_reader": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": false
      },
      "indexing.xtr_build": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": false
      },
      "indexing": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": false
      },
      "indexing.cast_chunker": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": false
      },
      "io.rrf": {
        "in_degree": 4,
        "out_degree": 0,
        "pagerank": 0.001078,
        "cycle": false,
        "is_test": false
      },
      "io.path_utils": {
        "in_degree": 4,
        "out_degree": 0,
        "pagerank": 0.001078,
        "cycle": false,
        "is_test": false
      },
      "io.coderank_embedder": {
        "in_degree": 4,
        "out_degree": 0,
        "pagerank": 0.001078,
        "cycle": false,
        "is_test": false
      },
      "io.vllm_engine": {
        "in_degree": 4,
        "out_degree": 0,
        "pagerank": 0.001078,
        "cycle": false,
        "is_test": false
      },
      "io.symbol_catalog": {
        "in_degree": 4,
        "out_degree": 0,
        "pagerank": 0.001078,
        "cycle": false,
        "is_test": false
      },
      "io.splade_manager": {
        "in_degree": 4,
        "out_degree": 0,
        "pagerank": 0.001078,
        "cycle": false,
        "is_test": false
      },
      "io.vllm_client": {
        "in_degree": 4,
        "out_degree": 0,
        "pagerank": 0.001078,
        "cycle": false,
        "is_test": false
      },
      "io.parquet_store": {
        "in_degree": 4,
        "out_degree": 0,
        "pagerank": 0.001078,
        "cycle": false,
        "is_test": false
      },
      "io.duckdb_manager": {
        "in_degree": 4,
        "out_degree": 0,
        "pagerank": 0.001078,
        "cycle": false,
        "is_test": false
      },
      "io.xtr_manager": {
        "in_degree": 4,
        "out_degree": 0,
        "pagerank": 0.001078,
        "cycle": false,
        "is_test": false
      },
      "io.hybrid_search": {
        "in_degree": 4,
        "out_degree": 0,
        "pagerank": 0.001078,
        "cycle": false,
        "is_test": false
      },
      "io.warp_engine": {
        "in_degree": 4,
        "out_degree": 0,
        "pagerank": 0.001078,
        "cycle": false,
        "is_test": false
      },
      "io.faiss_manager": {
        "in_degree": 4,
        "out_degree": 0,
        "pagerank": 0.001078,
        "cycle": false,
        "is_test": false
      },
      "io.faiss_dual_index": {
        "in_degree": 4,
        "out_degree": 0,
        "pagerank": 0.001078,
        "cycle": false,
        "is_test": false
      },
      "io.duckdb_catalog": {
        "in_degree": 4,
        "out_degree": 0,
        "pagerank": 0.001078,
        "cycle": false,
        "is_test": false
      },
      "io.bm25_manager": {
        "in_degree": 4,
        "out_degree": 0,
        "pagerank": 0.001078,
        "cycle": false,
        "is_test": false
      },
      "io": {
        "in_degree": 4,
        "out_degree": 0,
        "pagerank": 0.001078,
        "cycle": false,
        "is_test": false
      },
      "io.git_client": {
        "in_degree": 4,
        "out_degree": 0,
        "pagerank": 0.001078,
        "cycle": false,
        "is_test": false
      },
      "io.rerank_coderankllm": {
        "in_degree": 4,
        "out_degree": 0,
        "pagerank": 0.001078,
        "cycle": false,
        "is_test": false
      },
      "retrieval.types": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": false
      },
      "retrieval.telemetry": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": false
      },
      "retrieval.gating": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": false
      },
      "retrieval.hybrid": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": false
      },
      "retrieval": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": false
      },
      "runtime.cells": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": false
      },
      "runtime": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": false
      },
      "mcp_server.service_context": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": false
      },
      "mcp_server.schemas": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": false
      },
      "mcp_server.server_semantic": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": false
      },
      "mcp_server.server_symbols": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": false
      },
      "mcp_server.error_handling": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": false
      },
      "mcp_server.scope_utils": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": false
      },
      "mcp_server.server": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": false
      },
      "mcp_server": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": false
      },
      "cache": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": false
      },
      "cli.xtr": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": false
      },
      "cli.splade": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": false
      },
      "cli.bm25": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": false
      },
      "cli": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": false
      },
      "mcp_server.common.observability": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": false
      },
      "mcp_server.common": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": false
      },
      "mcp_server.tools": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": false
      },
      "mcp_server.tools.gpu_doctor": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": false
      },
      "mcp_server.retrieval.xtr_cli": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": false
      },
      "mcp_server.retrieval": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": false
      },
      "mcp_server.adapters.semantic": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": false
      },
      "mcp_server.adapters.files": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": false
      },
      "mcp_server.adapters.semantic_pro": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": false
      },
      "mcp_server.adapters.text_search": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": false
      },
      "mcp_server.adapters": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": false
      },
      "mcp_server.adapters.history": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": false
      },
      "retrieval.fusion.weighted_rrf": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": false
      },
      "retrieval.fusion": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": false
      },
      "ops.runtime": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": false
      },
      "ops.runtime.xtr_open": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": false
      },
      "tests.test_namespace_proxy": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.test_runtime_determinism": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.test_regression_public_api_hardening": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.bootstrap": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.test_logging": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.conftest": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.test_logging_contexts": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.docstring_builder.test_plugin_registry": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.docstring_builder.test_pipeline_runner": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.docstring_builder.test_pipeline_helpers": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.app._context_factory": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.app.test_lifespan_runtime_cleanup": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.app.test_capz": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.docs.test_griffe_facade": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.docs.test_doc_artifacts": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.docs.conftest": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.docs.test_validate_artifacts_script": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.docs.test_artifact_models": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.docs.test_scripts_testing_helpers": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.orchestration.test_cli_configuration_error": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.orchestration.test_cli_refactor": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.orchestration.test_cli_envelopes": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.orchestration.test_index_cli_idempotency": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.search_api.test_client_idempotency": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.search_api.test_faiss_adapter": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.io.test_hybrid_search_paths": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.tools.test_check_typing_gates": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.tools.test_cli_context_registry": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.tools.test_generate_pr_summary": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.tools.test_check_stub_parity": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.tools.test_repo_scan": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.tools.test_mkdocs_serve": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.tools.test_typing_gate_metrics": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.tools.test_check_new_suppressions": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.faiss_gpu.test_040_cuvs_toggle": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.faiss_gpu.test_010_flat_gpu_correctness": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.faiss_gpu.test_030_ivf_gpu_correctness": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.faiss_gpu.test_050_multi_gpu_optional": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.faiss_gpu.test_020_index_transfer": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.faiss_gpu.test_001_import_and_env": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.helpers.typing_facades": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.helpers.immutability": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.helpers.importing": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.codeintel_rev.test_service_context_paths": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.codeintel_rev.test_observability_common": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.codeintel_rev.test_error_handling": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.codeintel_rev.test_semantic_adapter": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.codeintel_rev.test_faiss_manager_adaptive": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.codeintel_rev.test_splade_manager": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.codeintel_rev.test_faiss_dual_index": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.codeintel_rev.test_scope_store": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.codeintel_rev.test_faiss_manager": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.codeintel_rev.test_faiss_incremental": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.codeintel_rev.test_scope_integration": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.codeintel_rev.test_scope_utils": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.vector_ingestion.test_vector_cli": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.vector_ingestion.test_vector_schema": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.vector_ingestion.test_vector_types": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.vector_ingestion.conftest": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.kgfoundry_common.test_configuration_error": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.kgfoundry_common.test_subprocess_utils": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.kgfoundry_common.test_configuration_problem_schema": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.kgfoundry_common.test_prometheus_metrics": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.kgfoundry_common.test_optional_deps": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.kgfoundry_common.test_sequence_guards": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.kgfoundry_common.test_safe_pickle_v2": {
        "in_degree": 0,
        "out_degree": 19,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.codeintel_rev.benchmarks.test_faiss_performance": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.codeintel_rev.io.test_vllm_engine": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.codeintel_rev.io.test_rerank_coderankllm": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.codeintel_rev.mcp_server.test_semantic_pro_adapter": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.tools.docstring_builder.test_orchestrator_additional": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.tools.docstring_builder.test_docfacts_invariants": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.tools.docstring_builder.test_orchestrator_new_api": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.tools.docstring_builder.test_pipeline_helpers": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.tools.docstring_builder.test_cache_interfaces": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.tools.docs.test_build_graphs_cli": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.tools.mkdocs_suite.test_operation_links": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.tools.mkdocs_suite.test_gen_module_pages": {
        "in_degree": 0,
        "out_degree": 19,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.tools.mkdocs_suite.test_gen_cli_diagram": {
        "in_degree": 0,
        "out_degree": 19,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.tools.mkdocs_suite.test_gen_interface_pages": {
        "in_degree": 0,
        "out_degree": 19,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.tools.navmap.test_cli_api": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.tools.navmap.test_build_navmap_cli": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.tools.navmap.test_check_navmap_cli": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.tools.navmap.test_cache_interfaces": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.tools.codemods.test_transformers": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      },
      "tests.tools.mkdocs_suite.docs._scripts.test_gen_module_pages": {
        "in_degree": 0,
        "out_degree": 0,
        "pagerank": 0.000915,
        "cycle": false,
        "is_test": true
      }
    },
    "cycles": []
  }
}