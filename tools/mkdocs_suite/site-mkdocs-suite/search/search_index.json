{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":""},{"location":"#kgfoundry-mkdocs-suite","title":"KgFoundry MkDocs Suite","text":"<p>Welcome to the experimental MkDocs-driven documentation experience for KgFoundry. This site is generated independently from the primary Sphinx build so that new navigation patterns and auxiliary assets can evolve without putting pressure on the production pipeline.</p> <p>Use the navigation sidebar to explore architecture notes, API references, and dynamically generated module summaries powered by Griffe.</p>"},{"location":"api/","title":"API","text":""},{"location":"api/#http-api","title":"HTTP API","text":""},{"location":"api/ReDoc-powered%20API%20with%20X-tags/","title":"ReDoc powered API with X tags","text":"<p>Awesome\u2014let\u2019s make your ReDoc-powered API area feel first-class and tightly woven into the rest of your docs, diagrams, and code pages (not a bolt-on \u201cAPI island\u201d). Below is a complete, junior-friendly plan with guidelines, examples, and build scripts.</p>"},{"location":"api/ReDoc-powered%20API%20with%20X-tags/#what-best-in-class-redoc-looks-like","title":"What \u201cbest-in-class ReDoc\u201d looks like","text":"<ol> <li> <p>A tuned ReDoc page embedded in MkDocs, with:</p> </li> <li> <p>clean tag taxonomy (+ x-tagGroups for 2-level nav)</p> </li> <li>stable, URL-safe operationIds (for deep links from everywhere)</li> <li>rich samples (x-codeSamples), meaningful examples, and optional x-badges</li> <li> <p>tasteful config (expand levels, sorting, path in middle panel, etc.). (Redocly)</p> </li> <li> <p>API \u201ctags as a first-class navigation concept\u201d across the whole site:</p> </li> <li> <p>per-tag pages in MkDocs (not just in ReDoc)</p> </li> <li>clickable tag chips on module pages (Material\u2019s tags plugin) that jump into the ReDoc operation section</li> <li> <p>diagrams that show API tags and operations; nodes click straight into ReDoc. (GitHub Pages)</p> </li> <li> <p>Source\u2194API cross-links:</p> </li> <li> <p>from code/module pages \u2192 ReDoc #operation/{operationId} anchors</p> </li> <li>from ReDoc (via externalDocs and/or tag descriptions) \u2192 relevant module or architecture pages</li> <li> <p>optional private vendor extension (e.g., x-handler) that records the code path that implements an operation (so generators can wire links automatically). (Redocly)</p> </li> <li> <p>API quality gate in CI:</p> </li> <li> <p>enforce tag hygiene, operationId uniqueness + URL-safety, and descriptions with Redocly CLI rules. (Redocly)</p> </li> </ol>"},{"location":"api/ReDoc-powered%20API%20with%20X-tags/#a-embed-redoc-in-mkdocs-two-solid-choices","title":"A. Embed ReDoc in MkDocs (two solid choices)","text":""},{"location":"api/ReDoc-powered%20API%20with%20X-tags/#option-1-use-mkdocs-redoc-tag-simplest","title":"Option 1 \u2014 Use <code>mkdocs-redoc-tag</code> (simplest)","text":"<p>In any Markdown page (e.g., <code>docs/api/index.md</code>):</p> <pre><code>---\nhide:\n  - navigation\n  - toc\n---\n\n# HTTP API\n\n&lt;redoc src=\"../../openapi/openapi.yaml\"/&gt;\n</code></pre> <p>And in <code>mkdocs.yml</code>:</p> <pre><code>plugins:\n  - redoc-tag\n</code></pre> <p>This plugin ships the ReDoc assets with your site (no CDN), syncs dark mode with Material, and works offline\u2014nice for intranet docs. (It uses an iframe; you don\u2019t pass many runtime options.) (GitHub)</p>"},{"location":"api/ReDoc-powered%20API%20with%20X-tags/#option-2-prebuild-a-redoc-html-with-options-more-control","title":"Option 2 \u2014 Prebuild a ReDoc HTML with options (more control)","text":"<p>If you need specific ReDoc options (e.g., <code>pathInMiddlePanel</code>, <code>jsonSamplesExpandLevel</code>, <code>scrollYOffset</code>, <code>hideDownloadButtons</code>, etc.), prebuild a static page:</p> <pre><code># install once\nnpm i -g @redocly/cli\n# generate a standalone redoc page\nredocly build-docs openapi/openapi.yaml --output docs/api/reference.html\n</code></pre> <p>Then link to <code>docs/api/reference.html</code> from your nav or embed it in an <code>&lt;iframe&gt;</code>. ReDoc options are extensive\u2014sorting, expansion, samples, and layout\u2014and differ between CE 2.x vs newer docs; see the config reference for the canonical list and kebab-case attribute names. (Redocly)</p> <p>Recommended ReDoc options for big specs</p> <ul> <li><code>pathInMiddlePanel: true</code> (move method+path into center panel)</li> <li><code>jsonSamplesExpandLevel: 3..5</code> (or <code>\"all\"</code> during authoring)</li> <li><code>schemasExpansionLevel: 1..2</code></li> <li><code>sortTagsAlphabetically: true</code>, <code>sortOperationsAlphabetically: true</code></li> <li><code>scrollYOffset: \".md-header\"</code> (so deep links account for sticky header)</li> <li><code>hideDownloadButtons: true</code> (if you don\u2019t want spec download)   All are documented in the ReDoc config reference. (Redocly)</li> </ul>"},{"location":"api/ReDoc-powered%20API%20with%20X-tags/#b-design-a-tag-taxonomy-that-works-across-redoc-and-mkdocs","title":"B. Design a tag taxonomy that works across ReDoc and MkDocs","text":""},{"location":"api/ReDoc-powered%20API%20with%20X-tags/#1-authoritative-tags-openapi","title":"1) Authoritative tags (OpenAPI)","text":"<p>Define tags at the root with clear descriptions and (optional) <code>externalDocs</code> pointing back into your MkDocs content:</p> <pre><code>tags:\n  - name: orders\n    x-displayName: Orders &amp; Checkout\n    description: Endpoints to create and manage orders.\n    externalDocs:\n      description: Architecture notes for the ordering domain\n      url: /architecture/orders/           # MkDocs page\n  - name: auth\n    x-displayName: Authentication\n    description: Login, refresh, and revoke tokens.\n</code></pre> <p>Use one tag per operation when tags act as categories; it keeps nav clean. Redocly rules can enforce this. x-displayName gives you a pretty label without changing the canonical <code>name</code>. (Redocly)</p> <p>Group your tags with x-tagGroups for a two-level left nav in ReDoc:</p> <pre><code>x-tagGroups:\n  - name: Core\n    tags: [orders, customers, auth]\n  - name: Admin\n    tags: [catalog, pricing]\n</code></pre> <p>ReDoc will render groups \u2192 tags \u2192 operations; any tag not in a group won\u2019t show\u2014so list them all. (Redocly)</p>"},{"location":"api/ReDoc-powered%20API%20with%20X-tags/#2-traits-non-nav-markers","title":"2) Traits (non-nav markers)","text":"<p>Use x-traitTag: true for traits like Pagination or Rate Limits. ReDoc shows them as info (no sub-items) and renders the description, which is great for shared concerns. (GitHub)</p>"},{"location":"api/ReDoc-powered%20API%20with%20X-tags/#3-stable-deep-links","title":"3) Stable deep links","text":"<p>Every operation needs a globally unique, URL-safe <code>operationId</code> so you can deep link to it from module pages, diagrams, and blog posts:</p> <pre><code>paths:\n  /orders:\n    post:\n      operationId: orders.create\n      tags: [orders]\n</code></pre> <p>Redocly CLI rules to enforce this:</p> <pre><code># redocly.yaml\nextends:\n  - recommended\nrules:\n  operation-operationId: error\n  operation-operationId-unique: error\n  operation-operationId-url-safe: error\n  operation-tag-defined: error\n  tag-description: warn\n</code></pre> <p>Run <code>redocly lint openapi/openapi.yaml</code> in CI to keep it healthy. (Redocly)</p>"},{"location":"api/ReDoc-powered%20API%20with%20X-tags/#c-add-depth-to-operations-samples-badges-logo","title":"C. Add depth to operations (samples, badges, logo)","text":"<ul> <li>x-codeSamples \u2014 language-specific snippets shown in the right panel:</li> </ul> <pre><code>paths:\n  /orders:\n    post:\n      operationId: orders.create\n      tags: [orders]\n      x-codeSamples:\n        - lang: Python\n          source: |\n            client.create_order({\"sku\": \"ABC\", \"qty\": 2})\n        - lang: curl\n          source: |\n            curl -X POST /orders -d '{\"sku\":\"ABC\",\"qty\":2}'\n</code></pre> <ul> <li>examples / x-examples \u2014 structured request/response examples to show realistic payloads.</li> <li>x-badges \u2014 add small capsules like \u201cBeta\u201d or \u201cDeprecated\u201d to the operation.</li> <li>x-logo (under <code>info</code>) \u2014 tasteful branding at the top of ReDoc. (Redocly)</li> </ul>"},{"location":"api/ReDoc-powered%20API%20with%20X-tags/#d-make-apis-visible-everywhere-generators-you-can-paste","title":"D. Make APIs visible everywhere (generators you can paste)","text":""},{"location":"api/ReDoc-powered%20API%20with%20X-tags/#1-generate-per-tag-pages-in-mkdocs-clickable-into-redoc","title":"1) Generate per-tag pages in MkDocs (clickable into ReDoc)","text":"<p>Add <code>docs/_scripts/gen_api_tag_pages.py</code> and wire it in <code>mkdocs.yml</code> under <code>gen-files</code>.</p> <pre><code># docs/_scripts/gen_api_tag_pages.py\nfrom __future__ import annotations\nimport yaml, mkdocs_gen_files\nfrom pathlib import Path\n\nSPEC = Path(\"openapi/openapi.yaml\")\n\nwith SPEC.open() as f:\n    oas = yaml.safe_load(f)\n\n# Build tag lookup\ntag_meta = {t[\"name\"]: t for t in oas.get(\"tags\", [])}\n\n# Iterate operations\ntag_to_ops = {}\nfor path, item in (oas.get(\"paths\") or {}).items():\n    for method, op in (item or {}).items():\n        if method.lower() not in {\"get\",\"put\",\"post\",\"delete\",\"patch\",\"options\",\"head\",\"trace\"}:\n            continue\n        op_id = op.get(\"operationId\")\n        for tag in op.get(\"tags\") or []:\n            tag_to_ops.setdefault(tag, []).append({\n                \"id\": op_id, \"method\": method.upper(), \"path\": path, \"summary\": op.get(\"summary\",\"\")\n            })\n\n# Write a landing page\nwith mkdocs_gen_files.open(\"api/tags/index.md\", \"w\") as f:\n    f.write(\"# API tags\\n\\n\")\n    for tag in sorted(tag_to_ops):\n        f.write(f\"- [{tag}](./{tag}.md)\\n\")\n\n# Write one page per tag\nfor tag, ops in sorted(tag_to_ops.items()):\n    meta = tag_meta.get(tag, {})\n    with mkdocs_gen_files.open(f\"api/tags/{tag}.md\", \"w\") as f:\n        display = meta.get(\"x-displayName\", tag)\n        f.write(f\"# {display}\\n\\n\")\n        if \"description\" in meta:\n            f.write(meta[\"description\"] + \"\\n\\n\")\n        if (ext := meta.get(\"externalDocs\")):\n            f.write(f\"&gt; See also: [{ext.get('description','More\u2026')}]({ext['url']})\\n\\n\")\n        for o in sorted(ops, key=lambda v: v[\"path\"]):\n            # Deep link to ReDoc section\n            f.write(f\"- **{o['method']}** `{o['path']}` \u2014 {o['summary']} \"\n                    f\"[View in ReDoc](../index/#operation/{o['id']})\\n\")\n</code></pre> <p>This gives you MkDocs pages for each tag (with summaries and one-click jumps into ReDoc), so tags are a first-class concept outside ReDoc too. (Redocly)</p> <p>Put a \u201cTags\u201d entry in your MkDocs nav under \u201cAPI\u201d. The <code>externalDocs</code> links you define on tags can point to your Architecture pages (conceptual guides), closing the loop. (Swagger)</p>"},{"location":"api/ReDoc-powered%20API%20with%20X-tags/#2-put-tag-chips-on-your-module-pages-material-tags-plugin","title":"2) Put tag chips on your module pages (Material tags plugin)","text":"<p>Enable Material\u2019s <code>tags</code> plugin and, when you generate your module pages, add front-matter like:</p> <pre><code>---\ntags: [ \"api:orders\", \"layer:domain\" ]\n---\n</code></pre> <p>Create a simple mapping in your generator (e.g., <code>api_usage.json</code>) that lists the API tags each module touches; write them into the module page\u2019s YAML. Material shows the chips and creates a tags index\u2014clicking the chip lands on <code>api/tags/orders.md</code>, which then deep-links into ReDoc. (GitHub Pages)</p>"},{"location":"api/ReDoc-powered%20API%20with%20X-tags/#3-draw-api-diagrams-d2-with-two-way-navigation","title":"3) Draw API diagrams (D2) with two-way navigation","text":"<p>Generate a diagram that clusters operations by tag, with links to ReDoc:</p> <pre><code># docs/_scripts/gen_api_diagrams.py (append to your D2 generator)\nimport yaml, mkdocs_gen_files\noas = yaml.safe_load(open(\"openapi/openapi.yaml\"))\nops = []\nfor p, item in (oas.get(\"paths\") or {}).items():\n    for m, op in (item or {}).items():\n        if m.upper() in {\"GET\",\"PUT\",\"POST\",\"DELETE\",\"PATCH\",\"OPTIONS\",\"HEAD\",\"TRACE\"}:\n            if op.get(\"operationId\"):\n                for tag in op.get(\"tags\") or [\"untagged\"]:\n                    ops.append((tag, m.upper(), p, op[\"operationId\"]))\nwith mkdocs_gen_files.open(\"diagrams/api_by_tag.d2\", \"w\") as d:\n    d.write('direction: right\\nAPIs: \"APIs\" {\\n')\n    for tag, *_ in sorted({(t,) for (t,_,_,_) in ops}):\n        d.write(f'  \"{tag}\": \"{tag}\" {{}}\\n')\n    for tag, method, path, opid in ops:\n        node = f'{method} {path}'\n        d.write(f'  \"{node}\": \"{node}\" {{ link: \"../api/index/#operation/{opid}\" }}\\n')\n        d.write(f'  \"{tag}\" -&gt; \"{node}\"\\n')\n    d.write('}\\n')\n</code></pre> <p>ReDoc accepts deep links of the form <code>#operation/{operationId}</code>, so every node in the diagram jumps into the correct operation in ReDoc. (GitHub)</p>"},{"location":"api/ReDoc-powered%20API%20with%20X-tags/#e-wire-code-api-automatically-for-humans-and-agents","title":"E. Wire code \u2194 API automatically (for humans and agents)","text":"<p>Add a private vendor extension to each operation that records the code symbol that implements it:</p> <pre><code>paths:\n  /orders:\n    post:\n      operationId: orders.create\n      tags: [orders]\n      x-handler: \"your_package.orders.service:create_order\"\n</code></pre> <p>Because <code>x-*</code> extensions are allowed anywhere in OpenAPI, your generators can read <code>x-handler</code> and:</p> <ul> <li>add \u201cRelated API operations\u201d on the module page (with deep links),</li> <li>add tag chips to the module,</li> <li>draw edges from module nodes to API nodes in D2. (Swagger)</li> </ul> <p>Using FastAPI? You can inject vendor extensions by post-processing the schema or with a custom OpenAPI function. You can also add x-logo in the same customizer. (FastAPI)</p>"},{"location":"api/ReDoc-powered%20API%20with%20X-tags/#f-authoring-guidelines-what-to-teach-the-team","title":"F. Authoring guidelines (what to teach the team)","text":"<p>Tags &amp; groups</p> <ul> <li>Treat tags as product categories (not dumping grounds). Prefer one tag per operation; if you need more, use x-traitTag (e.g., Pagination). Group tags with x-tagGroups (Core, Admin, etc.). Enforce with Redocly rules. (Redocly)</li> </ul> <p>operationId</p> <ul> <li>Required, unique, URL-safe, and stable. Use a predictable pattern like <code>resource.action</code> (<code>orders.create</code>, <code>orders.list</code>). Enforce with Redocly rules. Deep links from docs/diagrams/modules rely on this. (Redocly)</li> </ul> <p>Samples &amp; examples</p> <ul> <li>Provide x-codeSamples in the languages your users care about (at least cURL + one SDK). Pair with realistic examples under request/response content. (Redocly)</li> </ul> <p>Doc cohesion</p> <ul> <li>Use tag-level <code>externalDocs</code> to link to your MkDocs Architecture pages (domain guides). In those pages, link back into ReDoc via <code>#operation/{operationId}</code>. (Swagger)</li> </ul> <p>Branding &amp; clarity</p> <ul> <li>Add x-logo under <code>info</code> and keep the left nav readable with x-displayName on tags. (Redocly)</li> </ul>"},{"location":"api/ReDoc-powered%20API%20with%20X-tags/#g-example-gold-standard-openapi-header-one-operation","title":"G. Example: \u201cgold standard\u201d OpenAPI header &amp; one operation","text":"<pre><code>openapi: 3.1.0\ninfo:\n  title: Example Store API\n  version: 1.2.0\n  description: &gt;\n    REST API for order placement and management.\n  x-logo:\n    url: https://example.com/logo.svg\n    altText: Example\ntags:\n  - name: orders\n    x-displayName: Orders &amp; Checkout\n    description: Endpoints to create and manage orders.\n    externalDocs:\n      description: Domain overview\n      url: /architecture/orders/\n  - name: auth\n    x-displayName: Authentication\n    description: Token issuance and revocation.\n\nx-tagGroups:\n  - name: Core\n    tags: [orders, auth]\n\npaths:\n  /orders:\n    post:\n      operationId: orders.create\n      tags: [orders]               # single category tag\n      summary: Create an order\n      description: Create a new order from items in the cart.\n      x-handler: \"your_package.orders.service:create_order\"\n      x-codeSamples:\n        - lang: curl\n          source: |\n            curl -X POST /orders -H 'Content-Type: application/json' \\\n                 -d '{\"items\":[{\"sku\":\"ABC\",\"qty\":2}]}'\n        - lang: Python\n          source: |\n            client.create_order({\"items\":[{\"sku\":\"ABC\",\"qty\":2}]})\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema: { $ref: '#/components/schemas/NewOrder' }\n            examples:\n              simple:\n                value: { items: [ { sku: \"ABC\", qty: 2 } ] }\n      responses:\n        '201':\n          description: Created\n          content:\n            application/json:\n              schema: { $ref: '#/components/schemas/Order' }\n              examples:\n                ok:\n                  value: { id: \"ord_123\", status: \"pending\" }\ncomponents:\n  schemas:\n    NewOrder: { type: object, properties: { items: { type: array, items: { $ref: '#/components/schemas/Item' } } }, required: [items] }\n    Item:     { type: object, properties: { sku: { type: string }, qty: { type: integer, minimum: 1 } }, required: [sku, qty] }\n    Order:    { type: object, properties: { id: { type: string }, status: { type: string } }, required: [id, status] }\n</code></pre> <ul> <li>Notes: <code>operationId</code> enables ReDoc deep links, x-handler enables code\u2194API generation, x-codeSamples shows code on the right, <code>externalDocs</code> on the tag bridges to your concept pages. (Redocly)</li> </ul>"},{"location":"api/ReDoc-powered%20API%20with%20X-tags/#h-connect-everything-with-ci","title":"H. Connect everything with CI","text":"<ol> <li>Lint &amp; bundle OpenAPI:</li> </ol> <pre><code>redocly lint openapi/openapi.yaml &amp;&amp; redocly bundle openapi/openapi.yaml -o openapi/bundled.yaml\n</code></pre> <p>Use <code>redocly.yaml</code> with the rules above (and any others you want from the recommended/minimal sets). (Redocly)</p> <ol> <li> <p>MkDocs build runs the three generators:</p> </li> <li> <p><code>gen_module_pages.py</code> (modules + nearest neighbors)</p> </li> <li><code>gen_api_tag_pages.py</code> (MkDocs pages per tag)</li> <li> <p><code>gen_api_diagrams.py</code> (API diagram with clickable nodes)</p> </li> <li> <p>Optionally prebuild a ReDoc static HTML with options and ship it under <code>docs/api/reference.html</code>. (GitHub)</p> </li> </ol>"},{"location":"api/ReDoc-powered%20API%20with%20X-tags/#quick-checklist-for-your-repo","title":"Quick checklist for your repo","text":"<ul> <li>[ ] Root tags with description, x-displayName, and externalDocs</li> <li>[ ] x-tagGroups for 2-level nav grouping</li> <li>[ ] operationId: unique, URL-safe, stable (enforced by Redocly)</li> <li>[ ] x-codeSamples + realistic examples per operation</li> <li>[ ] x-handler (private) to bind operations to code symbols</li> <li>[ ] <code>gen_api_tag_pages.py</code> + <code>gen_api_diagrams.py</code> wired via <code>mkdocs-gen-files</code></li> <li>[ ] Material tags plugin enabled; module pages populated with <code>api:&lt;tag&gt;</code> chips</li> <li>[ ] ReDoc configured (via plugin or prebuilt HTML) with sensible options</li> <li>[ ] CI: <code>redocly lint</code> + MkDocs <code>--strict</code> builds</li> </ul> <p>If you want, share a small excerpt of your <code>openapi.yaml</code> (2\u20133 operations) and your package name; I\u2019ll tailor the two generators to emit tag chips and cross-links for your exact repo layout, and propose a focused Redocly ruleset matching your naming conventions.</p>"},{"location":"architecture/","title":"Architecture","text":""},{"location":"architecture/#architecture-overview","title":"Architecture Overview","text":"<p>This section is reserved for high-level system documentation. Populate the page with architecture narratives, diagrams, or operational guides as the MkDocs suite matures.</p>"},{"location":"diagrams/","title":"Diagrams","text":""},{"location":"diagrams/#diagrams","title":"Diagrams","text":"<ul> <li>fs</li> <li>gpu</li> <li>kgfoundry_common</li> <li>opentelemetry_types</li> <li>pydantic</li> <li>schema_helpers</li> <li>types</li> </ul>"},{"location":"modules/","title":"Modules","text":""},{"location":"modules/#modules","title":"Modules","text":"<ul> <li>kgfoundry_common</li> <li>kgfoundry_common.fs</li> <li>kgfoundry_common.gpu</li> <li>kgfoundry_common.opentelemetry_types</li> <li>kgfoundry_common.pydantic</li> <li>kgfoundry_common.schema_helpers</li> <li>kgfoundry_common.types</li> </ul>"},{"location":"modules/kgfoundry_common.fs/","title":"kgfoundry_common.fs","text":""},{"location":"modules/kgfoundry_common.fs/#kgfoundry_commonfs","title":"kgfoundry_common.fs","text":"<p>Filesystem utilities using pathlib for safe, typed operations.</p>"},{"location":"modules/kgfoundry_common.fs/#relationships","title":"Relationships","text":"<p>Imports: future.annotations, kgfoundry_common.logging.get_logger, pathlib.Path, sys, tempfile, typing.Literal</p>"},{"location":"modules/kgfoundry_common.fs/#contents","title":"Contents","text":""},{"location":"modules/kgfoundry_common.fs/#kgfoundry_commonfsatomic_write","title":"kgfoundry_common.fs.atomic_write","text":""},{"location":"modules/kgfoundry_common.fs/#kgfoundry_common.fs.atomic_write","title":"<code>kgfoundry_common.fs.atomic_write(path, data, mode='text')</code>","text":"<p>Write data atomically using a temporary file and rename.</p> <p>Writes data to a file using an atomic operation: first writes to a temporary file in the same directory, then renames it to the final path. This ensures that the final file is either completely written or not present, preventing partial writes in case of crashes.</p>"},{"location":"modules/kgfoundry_common.fs/#kgfoundry_common.fs.atomic_write--parameters","title":"Parameters","text":"<p>path : Path     Final file path to write. Parent directories will be created if needed. data : str | bytes     Content to write. Must be str for text mode or bytes for binary mode. mode : Literal['text', 'binary'], optional     Write mode. Use \"text\" for string data (UTF-8 encoding) or \"binary\"     for bytes data. Defaults to \"text\".</p>"},{"location":"modules/kgfoundry_common.fs/#kgfoundry_common.fs.atomic_write--raises","title":"Raises","text":"<p>ValueError     If mode is \"text\" but data is bytes, or mode is \"binary\" but data is str.</p>"},{"location":"modules/kgfoundry_common.fs/#kgfoundry_common.fs.atomic_write--notes","title":"Notes","text":"<p>Filesystem errors raised by :func:<code>ensure_dir</code>, :func:<code>tempfile.NamedTemporaryFile</code>, or :meth:<code>pathlib.Path.replace</code> propagate to the caller.</p>"},{"location":"modules/kgfoundry_common.fs/#kgfoundry_common.fs.atomic_write--notes_1","title":"Notes","text":"<p>The atomic operation ensures that concurrent readers never see a partially written file. The temporary file is created in the same directory as the final path to ensure the rename operation succeeds (requires same filesystem).</p>"},{"location":"modules/kgfoundry_common.fs/#kgfoundry_common.fs.atomic_write--examples","title":"Examples","text":"<p>from pathlib import Path atomic_write(Path(\"/tmp/atomic.txt\"), \"safe content\") read_text(Path(\"/tmp/atomic.txt\")) 'safe content'</p> Source code in <code>src/kgfoundry_common/fs.py</code> <pre><code>def atomic_write(\n    path: Path,\n    data: str | bytes,\n    mode: Literal[\"text\", \"binary\"] = \"text\",\n) -&gt; None:\n    \"\"\"Write data atomically using a temporary file and rename.\n\n    Writes data to a file using an atomic operation: first writes to a temporary\n    file in the same directory, then renames it to the final path. This ensures\n    that the final file is either completely written or not present, preventing\n    partial writes in case of crashes.\n\n    Parameters\n    ----------\n    path : Path\n        Final file path to write. Parent directories will be created if needed.\n    data : str | bytes\n        Content to write. Must be str for text mode or bytes for binary mode.\n    mode : Literal['text', 'binary'], optional\n        Write mode. Use \"text\" for string data (UTF-8 encoding) or \"binary\"\n        for bytes data. Defaults to \"text\".\n\n    Raises\n    ------\n    ValueError\n        If mode is \"text\" but data is bytes, or mode is \"binary\" but data is str.\n\n    Notes\n    -----\n    Filesystem errors raised by :func:`ensure_dir`, :func:`tempfile.NamedTemporaryFile`,\n    or :meth:`pathlib.Path.replace` propagate to the caller.\n\n    Notes\n    -----\n    The atomic operation ensures that concurrent readers never see a partially\n    written file. The temporary file is created in the same directory as the\n    final path to ensure the rename operation succeeds (requires same filesystem).\n\n    Examples\n    --------\n    &gt;&gt;&gt; from pathlib import Path\n    &gt;&gt;&gt; atomic_write(Path(\"/tmp/atomic.txt\"), \"safe content\")\n    &gt;&gt;&gt; read_text(Path(\"/tmp/atomic.txt\"))\n    'safe content'\n    \"\"\"\n    ensure_dir(path.parent, exist_ok=True)\n    tmp_path: Path | None = None\n    try:\n        dir_arg = str(path.parent) if path.parent else None\n        if mode == \"text\":\n            if not isinstance(data, str):\n                msg = \"text mode requires str data\"\n                raise ValueError(msg)\n            with tempfile.NamedTemporaryFile(\n                mode=\"w\",\n                dir=dir_arg,\n                delete=False,\n                encoding=\"utf-8\",\n            ) as temp_file:\n                tmp_path = Path(temp_file.name)\n                temp_file.write(data)\n                temp_file.flush()\n        else:\n            if not isinstance(data, bytes):\n                msg = \"binary mode requires bytes data\"\n                raise ValueError(msg)\n            with tempfile.NamedTemporaryFile(\n                mode=\"wb\",\n                dir=dir_arg,\n                delete=False,\n            ) as temp_file:\n                tmp_path = Path(temp_file.name)\n                temp_file.write(data)\n                temp_file.flush()\n        if tmp_path is not None:\n            tmp_path.replace(path)\n    finally:\n        if tmp_path is not None and sys.exc_info()[0] is not None:\n            tmp_path.unlink(missing_ok=True)\n</code></pre>"},{"location":"modules/kgfoundry_common.fs/#kgfoundry_commonfsensure_dir","title":"kgfoundry_common.fs.ensure_dir","text":""},{"location":"modules/kgfoundry_common.fs/#kgfoundry_common.fs.ensure_dir","title":"<code>kgfoundry_common.fs.ensure_dir(path, *, exist_ok=True)</code>","text":"<p>Create directory if it does not exist, including parent directories.</p> <p>Creates the specified directory path and all intermediate parent directories if they do not exist. Uses pathlib's mkdir with parents=True for atomic directory creation.</p>"},{"location":"modules/kgfoundry_common.fs/#kgfoundry_common.fs.ensure_dir--parameters","title":"Parameters","text":"<p>path : Path     Directory path to create. May be absolute or relative. exist_ok : bool, optional     If True, do not raise an exception if the directory already exists.     Defaults to True.</p>"},{"location":"modules/kgfoundry_common.fs/#kgfoundry_common.fs.ensure_dir--returns","title":"Returns","text":"<p>Path     The created or existing directory path (same as input).</p>"},{"location":"modules/kgfoundry_common.fs/#kgfoundry_common.fs.ensure_dir--notes","title":"Notes","text":"<p>This call delegates to :meth:<code>pathlib.Path.mkdir</code>. Filesystem-level errors such as <code>PermissionError</code> or <code>FileExistsError</code> propagate unchanged.</p>"},{"location":"modules/kgfoundry_common.fs/#kgfoundry_common.fs.ensure_dir--examples","title":"Examples","text":"<p>from pathlib import Path ensure_dir(Path(\"/tmp/data/subdir\")) Path('/tmp/data/subdir')</p> Source code in <code>src/kgfoundry_common/fs.py</code> <pre><code>def ensure_dir(path: Path, *, exist_ok: bool = True) -&gt; Path:\n    \"\"\"Create directory if it does not exist, including parent directories.\n\n    Creates the specified directory path and all intermediate parent directories\n    if they do not exist. Uses pathlib's mkdir with parents=True for atomic\n    directory creation.\n\n    Parameters\n    ----------\n    path : Path\n        Directory path to create. May be absolute or relative.\n    exist_ok : bool, optional\n        If True, do not raise an exception if the directory already exists.\n        Defaults to True.\n\n    Returns\n    -------\n    Path\n        The created or existing directory path (same as input).\n\n    Notes\n    -----\n    This call delegates to :meth:`pathlib.Path.mkdir`. Filesystem-level errors\n    such as ``PermissionError`` or ``FileExistsError`` propagate unchanged.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from pathlib import Path\n    &gt;&gt;&gt; ensure_dir(Path(\"/tmp/data/subdir\"))\n    Path('/tmp/data/subdir')\n    \"\"\"\n    path.mkdir(parents=True, exist_ok=exist_ok)\n    return path\n</code></pre>"},{"location":"modules/kgfoundry_common.fs/#kgfoundry_commonfsread_text","title":"kgfoundry_common.fs.read_text","text":""},{"location":"modules/kgfoundry_common.fs/#kgfoundry_common.fs.read_text","title":"<code>kgfoundry_common.fs.read_text(path, encoding='utf-8')</code>","text":"<p>Read text file contents with explicit encoding.</p> <p>Reads a text file and returns its contents as a string. Uses the specified encoding to decode bytes. This is a convenience wrapper around pathlib.Path.read_text().</p>"},{"location":"modules/kgfoundry_common.fs/#kgfoundry_common.fs.read_text--parameters","title":"Parameters","text":"<p>path : Path     File path to read. Must exist and be readable. encoding : str, optional     Text encoding to use for decoding bytes. Defaults to \"utf-8\".</p>"},{"location":"modules/kgfoundry_common.fs/#kgfoundry_common.fs.read_text--returns","title":"Returns","text":"<p>str     File contents as a decoded string.</p>"},{"location":"modules/kgfoundry_common.fs/#kgfoundry_common.fs.read_text--notes","title":"Notes","text":"<p>This helper delegates to :meth:<code>pathlib.Path.read_text</code>, so filesystem errors such as <code>FileNotFoundError</code> or <code>PermissionError</code> will surface unchanged.</p>"},{"location":"modules/kgfoundry_common.fs/#kgfoundry_common.fs.read_text--examples","title":"Examples","text":"<p>from pathlib import Path write_text(Path(\"/tmp/test.txt\"), \"hello\") read_text(Path(\"/tmp/test.txt\")) 'hello'</p> Source code in <code>src/kgfoundry_common/fs.py</code> <pre><code>def read_text(path: Path, encoding: str = \"utf-8\") -&gt; str:\n    \"\"\"Read text file contents with explicit encoding.\n\n    Reads a text file and returns its contents as a string. Uses the specified\n    encoding to decode bytes. This is a convenience wrapper around\n    pathlib.Path.read_text().\n\n    Parameters\n    ----------\n    path : Path\n        File path to read. Must exist and be readable.\n    encoding : str, optional\n        Text encoding to use for decoding bytes. Defaults to \"utf-8\".\n\n    Returns\n    -------\n    str\n        File contents as a decoded string.\n\n    Notes\n    -----\n    This helper delegates to :meth:`pathlib.Path.read_text`, so filesystem\n    errors such as ``FileNotFoundError`` or ``PermissionError`` will surface\n    unchanged.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from pathlib import Path\n    &gt;&gt;&gt; write_text(Path(\"/tmp/test.txt\"), \"hello\")\n    &gt;&gt;&gt; read_text(Path(\"/tmp/test.txt\"))\n    'hello'\n    \"\"\"\n    return path.read_text(encoding=encoding)\n</code></pre>"},{"location":"modules/kgfoundry_common.fs/#kgfoundry_commonfssafe_join","title":"kgfoundry_common.fs.safe_join","text":""},{"location":"modules/kgfoundry_common.fs/#kgfoundry_common.fs.safe_join","title":"<code>kgfoundry_common.fs.safe_join(base, *parts)</code>","text":"<p>Join path components safely, preventing directory traversal.</p> <p>Joins path components relative to a base directory and validates that the resolved path does not escape the base directory. This prevents path traversal attacks by ensuring all resolved paths are within the base.</p>"},{"location":"modules/kgfoundry_common.fs/#kgfoundry_common.fs.safe_join--parameters","title":"Parameters","text":"<p>base : Path     Base directory path. Must be absolute to enable validation. *parts : str | Path     Relative path components to join. These are joined relative to base.</p>"},{"location":"modules/kgfoundry_common.fs/#kgfoundry_common.fs.safe_join--returns","title":"Returns","text":"<p>Path     Resolved absolute path that is guaranteed to be within the base     directory.</p>"},{"location":"modules/kgfoundry_common.fs/#kgfoundry_common.fs.safe_join--raises","title":"Raises","text":"<p>ValueError     If base is not absolute or if the resolved path escapes the base     directory (path traversal attempt).</p>"},{"location":"modules/kgfoundry_common.fs/#kgfoundry_common.fs.safe_join--examples","title":"Examples","text":"<p>from pathlib import Path base = Path(\"/safe/base\") safe_join(base, \"file.txt\") Path('/safe/base/file.txt') safe_join(base, \"..\", \"etc\", \"passwd\")  # doctest: +SKIP ValueError: Path escapes base directory</p> Source code in <code>src/kgfoundry_common/fs.py</code> <pre><code>def safe_join(base: Path, *parts: str | Path) -&gt; Path:\n    \"\"\"Join path components safely, preventing directory traversal.\n\n    Joins path components relative to a base directory and validates that the\n    resolved path does not escape the base directory. This prevents path\n    traversal attacks by ensuring all resolved paths are within the base.\n\n    Parameters\n    ----------\n    base : Path\n        Base directory path. Must be absolute to enable validation.\n    *parts : str | Path\n        Relative path components to join. These are joined relative to base.\n\n    Returns\n    -------\n    Path\n        Resolved absolute path that is guaranteed to be within the base\n        directory.\n\n    Raises\n    ------\n    ValueError\n        If base is not absolute or if the resolved path escapes the base\n        directory (path traversal attempt).\n\n    Examples\n    --------\n    &gt;&gt;&gt; from pathlib import Path\n    &gt;&gt;&gt; base = Path(\"/safe/base\")\n    &gt;&gt;&gt; safe_join(base, \"file.txt\")\n    Path('/safe/base/file.txt')\n    &gt;&gt;&gt; safe_join(base, \"..\", \"etc\", \"passwd\")  # doctest: +SKIP\n    ValueError: Path escapes base directory\n    \"\"\"\n    if not base.is_absolute():\n        msg = f\"Base path must be absolute: {base}\"\n        raise ValueError(msg)\n    resolved = (base / Path(*parts)).resolve()\n    try:\n        resolved.relative_to(base.resolve())\n    except ValueError as exc:\n        msg = f\"Path escapes base directory: {resolved}\"\n        raise ValueError(msg) from exc\n    return resolved\n</code></pre>"},{"location":"modules/kgfoundry_common.fs/#kgfoundry_commonfswrite_text","title":"kgfoundry_common.fs.write_text","text":""},{"location":"modules/kgfoundry_common.fs/#kgfoundry_common.fs.write_text","title":"<code>kgfoundry_common.fs.write_text(path, data, encoding='utf-8')</code>","text":"<p>Write text data to a file, creating parent directories if needed.</p> <p>Writes text content to a file, encoding it using the specified encoding. Creates parent directories if they do not exist. Uses pathlib's write_text for atomic file operations.</p>"},{"location":"modules/kgfoundry_common.fs/#kgfoundry_common.fs.write_text--parameters","title":"Parameters","text":"<p>path : Path     File path to write. Parent directories will be created if needed. data : str     Text content to write. Will be encoded using the specified encoding. encoding : str, optional     Text encoding to use for encoding the string to bytes. Defaults to \"utf-8\".</p>"},{"location":"modules/kgfoundry_common.fs/#kgfoundry_common.fs.write_text--notes","title":"Notes","text":"<p>Exceptions raised by :func:<code>ensure_dir</code> or :meth:<code>pathlib.Path.write_text</code> (for example <code>OSError</code> or <code>PermissionError</code>) propagate to callers.</p>"},{"location":"modules/kgfoundry_common.fs/#kgfoundry_common.fs.write_text--examples","title":"Examples","text":"<p>from pathlib import Path write_text(Path(\"/tmp/output.txt\"), \"content\") read_text(Path(\"/tmp/output.txt\")) 'content'</p> Source code in <code>src/kgfoundry_common/fs.py</code> <pre><code>def write_text(path: Path, data: str, encoding: str = \"utf-8\") -&gt; None:\n    \"\"\"Write text data to a file, creating parent directories if needed.\n\n    Writes text content to a file, encoding it using the specified encoding.\n    Creates parent directories if they do not exist. Uses pathlib's write_text\n    for atomic file operations.\n\n    Parameters\n    ----------\n    path : Path\n        File path to write. Parent directories will be created if needed.\n    data : str\n        Text content to write. Will be encoded using the specified encoding.\n    encoding : str, optional\n        Text encoding to use for encoding the string to bytes. Defaults to \"utf-8\".\n\n    Notes\n    -----\n    Exceptions raised by :func:`ensure_dir` or :meth:`pathlib.Path.write_text`\n    (for example ``OSError`` or ``PermissionError``) propagate to callers.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from pathlib import Path\n    &gt;&gt;&gt; write_text(Path(\"/tmp/output.txt\"), \"content\")\n    &gt;&gt;&gt; read_text(Path(\"/tmp/output.txt\"))\n    'content'\n    \"\"\"\n    ensure_dir(path.parent, exist_ok=True)\n    path.write_text(data, encoding=encoding)\n</code></pre>"},{"location":"modules/kgfoundry_common.gpu/","title":"kgfoundry_common.gpu","text":""},{"location":"modules/kgfoundry_common.gpu/#kgfoundry_commongpu","title":"kgfoundry_common.gpu","text":"<p>Utilities for detecting GPU stack availability.</p>"},{"location":"modules/kgfoundry_common.gpu/#relationships","title":"Relationships","text":"<p>Imports: future.annotations, collections.abc.Callable, collections.abc.Iterable, importlib, os, types.ModuleType, typing.TYPE_CHECKING, typing.cast</p>"},{"location":"modules/kgfoundry_common.gpu/#contents","title":"Contents","text":""},{"location":"modules/kgfoundry_common.gpu/#kgfoundry_commongpu_modules_available","title":"kgfoundry_common.gpu._modules_available","text":""},{"location":"modules/kgfoundry_common.gpu/#kgfoundry_common.gpu._modules_available","title":"<code>kgfoundry_common.gpu._modules_available(modules)</code>","text":"<p>Check if all specified modules can be imported.</p> <p>Verifies that each module in the iterable can be resolved by Python's import system.</p>"},{"location":"modules/kgfoundry_common.gpu/#kgfoundry_common.gpu._modules_available--parameters","title":"Parameters","text":"<p>modules : Iterable[str]     Iterable of module names to check.</p>"},{"location":"modules/kgfoundry_common.gpu/#kgfoundry_common.gpu._modules_available--returns","title":"Returns","text":"<p>bool     True if all modules are available, False otherwise.</p> Source code in <code>src/kgfoundry_common/gpu.py</code> <pre><code>def _modules_available(modules: Iterable[str]) -&gt; bool:\n    \"\"\"Check if all specified modules can be imported.\n\n    Verifies that each module in the iterable can be resolved\n    by Python's import system.\n\n    Parameters\n    ----------\n    modules : Iterable[str]\n        Iterable of module names to check.\n\n    Returns\n    -------\n    bool\n        True if all modules are available, False otherwise.\n    \"\"\"\n    return all(importlib.util.find_spec(module) is not None for module in modules)\n</code></pre>"},{"location":"modules/kgfoundry_common.gpu/#kgfoundry_commongpuhas_gpu_stack","title":"kgfoundry_common.gpu.has_gpu_stack","text":""},{"location":"modules/kgfoundry_common.gpu/#kgfoundry_common.gpu.has_gpu_stack","title":"<code>kgfoundry_common.gpu.has_gpu_stack(*, allow_without_cuda_env='ALLOW_GPU_TESTS_WITHOUT_CUDA')</code>","text":"<p>Check if the optional GPU stack is available and CUDA is usable.</p> <p>Verifies that all core GPU modules can be imported and that CUDA is available via PyTorch. Can be overridden by an environment variable for testing on CPU-only hosts.</p>"},{"location":"modules/kgfoundry_common.gpu/#kgfoundry_common.gpu.has_gpu_stack--parameters","title":"Parameters","text":"<p>allow_without_cuda_env : str, optional     Environment variable name that, when set to \"1\", permits returning     True even when CUDA is unavailable. Defaults to     \"ALLOW_GPU_TESTS_WITHOUT_CUDA\".</p>"},{"location":"modules/kgfoundry_common.gpu/#kgfoundry_common.gpu.has_gpu_stack--returns","title":"Returns","text":"<p>bool     True when the GPU stack is available or the override environment     variable is set, False otherwise.</p> Source code in <code>src/kgfoundry_common/gpu.py</code> <pre><code>def has_gpu_stack(*, allow_without_cuda_env: str = \"ALLOW_GPU_TESTS_WITHOUT_CUDA\") -&gt; bool:\n    \"\"\"Check if the optional GPU stack is available and CUDA is usable.\n\n    Verifies that all core GPU modules can be imported and that CUDA\n    is available via PyTorch. Can be overridden by an environment variable\n    for testing on CPU-only hosts.\n\n    Parameters\n    ----------\n    allow_without_cuda_env : str, optional\n        Environment variable name that, when set to \"1\", permits returning\n        True even when CUDA is unavailable. Defaults to\n        \"ALLOW_GPU_TESTS_WITHOUT_CUDA\".\n\n    Returns\n    -------\n    bool\n        True when the GPU stack is available or the override environment\n        variable is set, False otherwise.\n    \"\"\"\n    if not _modules_available(GPU_CORE_MODULES):\n        return False\n    if os.getenv(allow_without_cuda_env) == \"1\":\n        return True\n    try:\n        torch_module = importlib.import_module(\"torch\")\n    except ImportError:  # pragma: no cover - import guard\n        return False\n    cuda_module: object = getattr(torch_module, \"cuda\", None)\n    if not isinstance(cuda_module, ModuleType):\n        return False\n    is_available_attr: object = getattr(cuda_module, \"is_available\", None)\n    if not callable(is_available_attr):\n        return False\n    is_available = cast(\"Callable[[], bool]\", is_available_attr)\n    return bool(is_available())\n</code></pre>"},{"location":"modules/kgfoundry_common/","title":"kgfoundry_common","text":""},{"location":"modules/kgfoundry_common/#kgfoundry_common","title":"kgfoundry_common","text":"<p>Overview of kgfoundry common.</p>"},{"location":"modules/kgfoundry_common/#relationships","title":"Relationships","text":"<p>Imports: future.annotations, kgfoundry_common.navmap_types.NavMap, typing.TYPE_CHECKING</p>"},{"location":"modules/kgfoundry_common.opentelemetry_types/","title":"kgfoundry_common.opentelemetry_types","text":""},{"location":"modules/kgfoundry_common.opentelemetry_types/#kgfoundry_commonopentelemetry_types","title":"kgfoundry_common.opentelemetry_types","text":"<p>Typed facades for optional OpenTelemetry integrations.</p>"},{"location":"modules/kgfoundry_common.opentelemetry_types/#relationships","title":"Relationships","text":"<p>Imports: future.annotations, collections.abc.Callable, collections.abc.Mapping, collections.abc.Sequence, contextlib.AbstractContextManager, dataclasses.dataclass, importlib.import_module, typing.Protocol, typing.TYPE_CHECKING, typing.cast</p>"},{"location":"modules/kgfoundry_common.opentelemetry_types/#contents","title":"Contents","text":""},{"location":"modules/kgfoundry_common.opentelemetry_types/#kgfoundry_commonopentelemetry_typesspanexporterprotocol","title":"kgfoundry_common.opentelemetry_types.SpanExporterProtocol","text":"<p>Bases: Protocol</p>"},{"location":"modules/kgfoundry_common.opentelemetry_types/#kgfoundry_common.opentelemetry_types.SpanExporterProtocol","title":"<code>kgfoundry_common.opentelemetry_types.SpanExporterProtocol</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Minimal exporter interface used by the OpenTelemetry fixtures.</p> Source code in <code>src/kgfoundry_common/opentelemetry_types.py</code> <pre><code>class SpanExporterProtocol(Protocol):\n    \"\"\"Minimal exporter interface used by the OpenTelemetry fixtures.\"\"\"\n\n    def export(self, spans: Sequence[object]) -&gt; None:\n        \"\"\"Export ``spans`` to the configured backend.\"\"\"\n        ...\n</code></pre>"},{"location":"modules/kgfoundry_common.opentelemetry_types/#kgfoundry_common.opentelemetry_types.SpanExporterProtocol.export","title":"<code>export(spans)</code>","text":"<p>Export <code>spans</code> to the configured backend.</p> Source code in <code>src/kgfoundry_common/opentelemetry_types.py</code> <pre><code>def export(self, spans: Sequence[object]) -&gt; None:\n    \"\"\"Export ``spans`` to the configured backend.\"\"\"\n    ...\n</code></pre>"},{"location":"modules/kgfoundry_common.opentelemetry_types/#kgfoundry_commonopentelemetry_typesspanprocessorprotocol","title":"kgfoundry_common.opentelemetry_types.SpanProcessorProtocol","text":"<p>Bases: Protocol</p>"},{"location":"modules/kgfoundry_common.opentelemetry_types/#kgfoundry_common.opentelemetry_types.SpanProcessorProtocol","title":"<code>kgfoundry_common.opentelemetry_types.SpanProcessorProtocol</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Span processor lifecycle hooks invoked by the tests.</p> Source code in <code>src/kgfoundry_common/opentelemetry_types.py</code> <pre><code>class SpanProcessorProtocol(Protocol):\n    \"\"\"Span processor lifecycle hooks invoked by the tests.\"\"\"\n\n    def on_start(self, span: SpanProtocol, parent_context: object | None = None) -&gt; None:\n        \"\"\"Observe ``span`` immediately after creation.\"\"\"\n        del self, span, parent_context\n        raise NotImplementedError\n\n    def on_end(self, span: SpanProtocol) -&gt; None:\n        \"\"\"Observe ``span`` once it has completed.\"\"\"\n        ...\n\n    def shutdown(self) -&gt; None:\n        \"\"\"Release resources associated with the processor.\"\"\"\n        ...\n\n    def force_flush(self, timeout_millis: int | None = None) -&gt; bool:\n        \"\"\"Flush buffered spans within ``timeout_millis``.\"\"\"\n        del self, timeout_millis\n        raise NotImplementedError\n</code></pre>"},{"location":"modules/kgfoundry_common.opentelemetry_types/#kgfoundry_common.opentelemetry_types.SpanProcessorProtocol.force_flush","title":"<code>force_flush(timeout_millis=None)</code>","text":"<p>Flush buffered spans within <code>timeout_millis</code>.</p> Source code in <code>src/kgfoundry_common/opentelemetry_types.py</code> <pre><code>def force_flush(self, timeout_millis: int | None = None) -&gt; bool:\n    \"\"\"Flush buffered spans within ``timeout_millis``.\"\"\"\n    del self, timeout_millis\n    raise NotImplementedError\n</code></pre>"},{"location":"modules/kgfoundry_common.opentelemetry_types/#kgfoundry_common.opentelemetry_types.SpanProcessorProtocol.on_end","title":"<code>on_end(span)</code>","text":"<p>Observe <code>span</code> once it has completed.</p> Source code in <code>src/kgfoundry_common/opentelemetry_types.py</code> <pre><code>def on_end(self, span: SpanProtocol) -&gt; None:\n    \"\"\"Observe ``span`` once it has completed.\"\"\"\n    ...\n</code></pre>"},{"location":"modules/kgfoundry_common.opentelemetry_types/#kgfoundry_common.opentelemetry_types.SpanProcessorProtocol.on_start","title":"<code>on_start(span, parent_context=None)</code>","text":"<p>Observe <code>span</code> immediately after creation.</p> Source code in <code>src/kgfoundry_common/opentelemetry_types.py</code> <pre><code>def on_start(self, span: SpanProtocol, parent_context: object | None = None) -&gt; None:\n    \"\"\"Observe ``span`` immediately after creation.\"\"\"\n    del self, span, parent_context\n    raise NotImplementedError\n</code></pre>"},{"location":"modules/kgfoundry_common.opentelemetry_types/#kgfoundry_common.opentelemetry_types.SpanProcessorProtocol.shutdown","title":"<code>shutdown()</code>","text":"<p>Release resources associated with the processor.</p> Source code in <code>src/kgfoundry_common/opentelemetry_types.py</code> <pre><code>def shutdown(self) -&gt; None:\n    \"\"\"Release resources associated with the processor.\"\"\"\n    ...\n</code></pre>"},{"location":"modules/kgfoundry_common.opentelemetry_types/#kgfoundry_commonopentelemetry_typesspanprotocol","title":"kgfoundry_common.opentelemetry_types.SpanProtocol","text":"<p>Bases: Protocol</p>"},{"location":"modules/kgfoundry_common.opentelemetry_types/#kgfoundry_common.opentelemetry_types.SpanProtocol","title":"<code>kgfoundry_common.opentelemetry_types.SpanProtocol</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Minimal span surface exercised by the observability helpers.</p> Source code in <code>src/kgfoundry_common/opentelemetry_types.py</code> <pre><code>class SpanProtocol(Protocol):\n    \"\"\"Minimal span surface exercised by the observability helpers.\"\"\"\n\n    def set_attribute(self, key: str, value: SpanAttributeValue) -&gt; None:\n        \"\"\"Attach ``value`` to ``key`` on the span.\"\"\"\n\n    def record_exception(self, exception: BaseException) -&gt; None:\n        \"\"\"Record ``exception`` on the span.\"\"\"\n\n    def set_status(self, status: object) -&gt; None:\n        \"\"\"Persist ``status`` on the span.\"\"\"\n</code></pre>"},{"location":"modules/kgfoundry_common.opentelemetry_types/#kgfoundry_common.opentelemetry_types.SpanProtocol.record_exception","title":"<code>record_exception(exception)</code>","text":"<p>Record <code>exception</code> on the span.</p> Source code in <code>src/kgfoundry_common/opentelemetry_types.py</code> <pre><code>def record_exception(self, exception: BaseException) -&gt; None:\n    \"\"\"Record ``exception`` on the span.\"\"\"\n</code></pre>"},{"location":"modules/kgfoundry_common.opentelemetry_types/#kgfoundry_common.opentelemetry_types.SpanProtocol.set_attribute","title":"<code>set_attribute(key, value)</code>","text":"<p>Attach <code>value</code> to <code>key</code> on the span.</p> Source code in <code>src/kgfoundry_common/opentelemetry_types.py</code> <pre><code>def set_attribute(self, key: str, value: SpanAttributeValue) -&gt; None:\n    \"\"\"Attach ``value`` to ``key`` on the span.\"\"\"\n</code></pre>"},{"location":"modules/kgfoundry_common.opentelemetry_types/#kgfoundry_common.opentelemetry_types.SpanProtocol.set_status","title":"<code>set_status(status)</code>","text":"<p>Persist <code>status</code> on the span.</p> Source code in <code>src/kgfoundry_common/opentelemetry_types.py</code> <pre><code>def set_status(self, status: object) -&gt; None:\n    \"\"\"Persist ``status`` on the span.\"\"\"\n</code></pre>"},{"location":"modules/kgfoundry_common.opentelemetry_types/#kgfoundry_commonopentelemetry_typesstatuscodeprotocol","title":"kgfoundry_common.opentelemetry_types.StatusCodeProtocol","text":"<p>Bases: Protocol</p>"},{"location":"modules/kgfoundry_common.opentelemetry_types/#kgfoundry_common.opentelemetry_types.StatusCodeProtocol","title":"<code>kgfoundry_common.opentelemetry_types.StatusCodeProtocol</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Subset of <code>opentelemetry.trace.StatusCode</code> used in observability.</p> Source code in <code>src/kgfoundry_common/opentelemetry_types.py</code> <pre><code>class StatusCodeProtocol(Protocol):\n    \"\"\"Subset of ``opentelemetry.trace.StatusCode`` used in observability.\"\"\"\n\n    ERROR: StatusCodeProtocol\n</code></pre>"},{"location":"modules/kgfoundry_common.opentelemetry_types/#kgfoundry_commonopentelemetry_typesstatusfactory","title":"kgfoundry_common.opentelemetry_types.StatusFactory","text":"<p>Bases: Protocol</p>"},{"location":"modules/kgfoundry_common.opentelemetry_types/#kgfoundry_common.opentelemetry_types.StatusFactory","title":"<code>kgfoundry_common.opentelemetry_types.StatusFactory</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Factory callable for instantiating <code>Status</code> instances.</p> Source code in <code>src/kgfoundry_common/opentelemetry_types.py</code> <pre><code>class StatusFactory(Protocol):\n    \"\"\"Factory callable for instantiating ``Status`` instances.\"\"\"\n\n    def __call__(\n        self,\n        status_code: StatusCodeProtocol,\n        description: str | None = None,\n    ) -&gt; object:\n        \"\"\"Create a status object using ``status_code`` and ``description``.\"\"\"\n        ...\n</code></pre>"},{"location":"modules/kgfoundry_common.opentelemetry_types/#kgfoundry_common.opentelemetry_types.StatusFactory.__call__","title":"<code>__call__(status_code, description=None)</code>","text":"<p>Create a status object using <code>status_code</code> and <code>description</code>.</p> Source code in <code>src/kgfoundry_common/opentelemetry_types.py</code> <pre><code>def __call__(\n    self,\n    status_code: StatusCodeProtocol,\n    description: str | None = None,\n) -&gt; object:\n    \"\"\"Create a status object using ``status_code`` and ``description``.\"\"\"\n    ...\n</code></pre>"},{"location":"modules/kgfoundry_common.opentelemetry_types/#kgfoundry_commonopentelemetry_typestraceapiprotocol","title":"kgfoundry_common.opentelemetry_types.TraceAPIProtocol","text":"<p>Bases: Protocol</p>"},{"location":"modules/kgfoundry_common.opentelemetry_types/#kgfoundry_common.opentelemetry_types.TraceAPIProtocol","title":"<code>kgfoundry_common.opentelemetry_types.TraceAPIProtocol</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Subset of the OpenTelemetry trace module used by the codebase.</p> Source code in <code>src/kgfoundry_common/opentelemetry_types.py</code> <pre><code>class TraceAPIProtocol(Protocol):\n    \"\"\"Subset of the OpenTelemetry trace module used by the codebase.\"\"\"\n\n    def get_tracer(self, name: str) -&gt; TracerProtocol:\n        \"\"\"Return a tracer for ``name``.\"\"\"\n        ...\n</code></pre>"},{"location":"modules/kgfoundry_common.opentelemetry_types/#kgfoundry_common.opentelemetry_types.TraceAPIProtocol.get_tracer","title":"<code>get_tracer(name)</code>","text":"<p>Return a tracer for <code>name</code>.</p> Source code in <code>src/kgfoundry_common/opentelemetry_types.py</code> <pre><code>def get_tracer(self, name: str) -&gt; TracerProtocol:\n    \"\"\"Return a tracer for ``name``.\"\"\"\n    ...\n</code></pre>"},{"location":"modules/kgfoundry_common.opentelemetry_types/#kgfoundry_commonopentelemetry_typestraceruntime","title":"kgfoundry_common.opentelemetry_types.TraceRuntime","text":""},{"location":"modules/kgfoundry_common.opentelemetry_types/#kgfoundry_common.opentelemetry_types.TraceRuntime","title":"<code>kgfoundry_common.opentelemetry_types.TraceRuntime</code>  <code>dataclass</code>","text":"<p>Container for optional OpenTelemetry runtime handles.</p> Source code in <code>src/kgfoundry_common/opentelemetry_types.py</code> <pre><code>@dataclass(slots=True)\nclass TraceRuntime:\n    \"\"\"Container for optional OpenTelemetry runtime handles.\"\"\"\n\n    api: TraceAPIProtocol | None\n    status_factory: StatusFactory | None\n    status_codes: StatusCodeProtocol | None\n</code></pre>"},{"location":"modules/kgfoundry_common.opentelemetry_types/#kgfoundry_commonopentelemetry_typestracerprotocol","title":"kgfoundry_common.opentelemetry_types.TracerProtocol","text":"<p>Bases: Protocol</p>"},{"location":"modules/kgfoundry_common.opentelemetry_types/#kgfoundry_common.opentelemetry_types.TracerProtocol","title":"<code>kgfoundry_common.opentelemetry_types.TracerProtocol</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Tracer facade returned by <code>opentelemetry.trace.get_tracer</code>.</p> Source code in <code>src/kgfoundry_common/opentelemetry_types.py</code> <pre><code>class TracerProtocol(Protocol):\n    \"\"\"Tracer facade returned by ``opentelemetry.trace.get_tracer``.\"\"\"\n\n    def start_as_current_span(self, name: str) -&gt; AbstractContextManager[SpanProtocol]:\n        \"\"\"Return a context manager yielding a span.\"\"\"\n        ...\n</code></pre>"},{"location":"modules/kgfoundry_common.opentelemetry_types/#kgfoundry_common.opentelemetry_types.TracerProtocol.start_as_current_span","title":"<code>start_as_current_span(name)</code>","text":"<p>Return a context manager yielding a span.</p> Source code in <code>src/kgfoundry_common/opentelemetry_types.py</code> <pre><code>def start_as_current_span(self, name: str) -&gt; AbstractContextManager[SpanProtocol]:\n    \"\"\"Return a context manager yielding a span.\"\"\"\n    ...\n</code></pre>"},{"location":"modules/kgfoundry_common.opentelemetry_types/#kgfoundry_commonopentelemetry_typestracerproviderprotocol","title":"kgfoundry_common.opentelemetry_types.TracerProviderProtocol","text":"<p>Bases: Protocol</p>"},{"location":"modules/kgfoundry_common.opentelemetry_types/#kgfoundry_common.opentelemetry_types.TracerProviderProtocol","title":"<code>kgfoundry_common.opentelemetry_types.TracerProviderProtocol</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Tracer provider constructor and helpers used in fixtures.</p> Source code in <code>src/kgfoundry_common/opentelemetry_types.py</code> <pre><code>class TracerProviderProtocol(Protocol):\n    \"\"\"Tracer provider constructor and helpers used in fixtures.\"\"\"\n\n    def __init__(self, *args: object, **kwargs: object) -&gt; None:\n        \"\"\"Initialise the provider with optional configuration.\"\"\"\n\n    def get_tracer(\n        self,\n        instrumenting_module_name: str,\n        instrumenting_library_version: str | None = None,\n        schema_url: str | None = None,\n        attributes: Attributes | None = None,\n    ) -&gt; TracerProtocol:\n        \"\"\"Return a tracer configured for the given instrumentation metadata.\"\"\"\n        del self, instrumenting_module_name, instrumenting_library_version, schema_url, attributes\n        raise NotImplementedError\n\n    def add_span_processor(self, processor: SpanProcessorProtocol) -&gt; None:\n        \"\"\"Register ``processor`` for span lifecycle callbacks.\"\"\"\n        del self, processor\n        raise NotImplementedError\n\n    def shutdown(self) -&gt; None:\n        \"\"\"Shut down the provider gracefully.\"\"\"\n        ...\n\n    def force_flush(self, timeout_millis: int | None = None) -&gt; bool:\n        \"\"\"Flush pending spans and return ``True`` on success.\"\"\"\n        del self, timeout_millis\n        raise NotImplementedError\n</code></pre>"},{"location":"modules/kgfoundry_common.opentelemetry_types/#kgfoundry_common.opentelemetry_types.TracerProviderProtocol.__init__","title":"<code>__init__(*args, **kwargs)</code>","text":"<p>Initialise the provider with optional configuration.</p> Source code in <code>src/kgfoundry_common/opentelemetry_types.py</code> <pre><code>def __init__(self, *args: object, **kwargs: object) -&gt; None:\n    \"\"\"Initialise the provider with optional configuration.\"\"\"\n</code></pre>"},{"location":"modules/kgfoundry_common.opentelemetry_types/#kgfoundry_common.opentelemetry_types.TracerProviderProtocol.add_span_processor","title":"<code>add_span_processor(processor)</code>","text":"<p>Register <code>processor</code> for span lifecycle callbacks.</p> Source code in <code>src/kgfoundry_common/opentelemetry_types.py</code> <pre><code>def add_span_processor(self, processor: SpanProcessorProtocol) -&gt; None:\n    \"\"\"Register ``processor`` for span lifecycle callbacks.\"\"\"\n    del self, processor\n    raise NotImplementedError\n</code></pre>"},{"location":"modules/kgfoundry_common.opentelemetry_types/#kgfoundry_common.opentelemetry_types.TracerProviderProtocol.force_flush","title":"<code>force_flush(timeout_millis=None)</code>","text":"<p>Flush pending spans and return <code>True</code> on success.</p> Source code in <code>src/kgfoundry_common/opentelemetry_types.py</code> <pre><code>def force_flush(self, timeout_millis: int | None = None) -&gt; bool:\n    \"\"\"Flush pending spans and return ``True`` on success.\"\"\"\n    del self, timeout_millis\n    raise NotImplementedError\n</code></pre>"},{"location":"modules/kgfoundry_common.opentelemetry_types/#kgfoundry_common.opentelemetry_types.TracerProviderProtocol.get_tracer","title":"<code>get_tracer(instrumenting_module_name, instrumenting_library_version=None, schema_url=None, attributes=None)</code>","text":"<p>Return a tracer configured for the given instrumentation metadata.</p> Source code in <code>src/kgfoundry_common/opentelemetry_types.py</code> <pre><code>def get_tracer(\n    self,\n    instrumenting_module_name: str,\n    instrumenting_library_version: str | None = None,\n    schema_url: str | None = None,\n    attributes: Attributes | None = None,\n) -&gt; TracerProtocol:\n    \"\"\"Return a tracer configured for the given instrumentation metadata.\"\"\"\n    del self, instrumenting_module_name, instrumenting_library_version, schema_url, attributes\n    raise NotImplementedError\n</code></pre>"},{"location":"modules/kgfoundry_common.opentelemetry_types/#kgfoundry_common.opentelemetry_types.TracerProviderProtocol.shutdown","title":"<code>shutdown()</code>","text":"<p>Shut down the provider gracefully.</p> Source code in <code>src/kgfoundry_common/opentelemetry_types.py</code> <pre><code>def shutdown(self) -&gt; None:\n    \"\"\"Shut down the provider gracefully.\"\"\"\n    ...\n</code></pre>"},{"location":"modules/kgfoundry_common.opentelemetry_types/#kgfoundry_commonopentelemetry_types_safe_getattr","title":"kgfoundry_common.opentelemetry_types._safe_getattr","text":""},{"location":"modules/kgfoundry_common.opentelemetry_types/#kgfoundry_common.opentelemetry_types._safe_getattr","title":"<code>kgfoundry_common.opentelemetry_types._safe_getattr(module, name)</code>","text":"Source code in <code>src/kgfoundry_common/opentelemetry_types.py</code> <pre><code>def _safe_getattr(module: object, name: str) -&gt; object | None:\n    try:\n        return cast(\"object\", getattr(module, name))\n    except AttributeError:  # pragma: no cover - defensive\n        return None\n</code></pre>"},{"location":"modules/kgfoundry_common.opentelemetry_types/#kgfoundry_commonopentelemetry_typesload_in_memory_span_exporter_cls","title":"kgfoundry_common.opentelemetry_types.load_in_memory_span_exporter_cls","text":""},{"location":"modules/kgfoundry_common.opentelemetry_types/#kgfoundry_common.opentelemetry_types.load_in_memory_span_exporter_cls","title":"<code>kgfoundry_common.opentelemetry_types.load_in_memory_span_exporter_cls()</code>","text":"<p>Return a factory for the in-memory span exporter if available.</p>"},{"location":"modules/kgfoundry_common.opentelemetry_types/#kgfoundry_common.opentelemetry_types.load_in_memory_span_exporter_cls--returns","title":"Returns","text":"<p>Callable[[], SpanExporterProtocol] | None     Factory function for creating InMemorySpanExporter instances, or None if not available.</p> Source code in <code>src/kgfoundry_common/opentelemetry_types.py</code> <pre><code>def load_in_memory_span_exporter_cls() -&gt; Callable[[], SpanExporterProtocol] | None:\n    \"\"\"Return a factory for the in-memory span exporter if available.\n\n    Returns\n    -------\n    Callable[[], SpanExporterProtocol] | None\n        Factory function for creating InMemorySpanExporter instances, or None if not available.\n    \"\"\"\n    try:\n        exporter_module = import_module(\"opentelemetry.sdk.trace.export.in_memory_span_exporter\")\n    except ImportError:\n        return None\n\n    exporter_raw = _safe_getattr(exporter_module, \"InMemorySpanExporter\")\n    if exporter_raw is None or not callable(exporter_raw):\n        return None\n    exporter_factory = cast(\"Callable[[], object]\", exporter_raw)\n\n    def factory() -&gt; SpanExporterProtocol:\n        \"\"\"Create and return an InMemorySpanExporter instance.\n\n        Returns\n        -------\n        SpanExporterProtocol\n            SpanExporter instance conforming to protocol.\n        \"\"\"\n        exporter = exporter_factory()\n        return cast(\"SpanExporterProtocol\", exporter)\n\n    return factory\n</code></pre>"},{"location":"modules/kgfoundry_common.opentelemetry_types/#kgfoundry_commonopentelemetry_typesload_trace_runtime","title":"kgfoundry_common.opentelemetry_types.load_trace_runtime","text":""},{"location":"modules/kgfoundry_common.opentelemetry_types/#kgfoundry_common.opentelemetry_types.load_trace_runtime","title":"<code>kgfoundry_common.opentelemetry_types.load_trace_runtime()</code>","text":"<p>Return the OpenTelemetry trace runtime handles if available.</p>"},{"location":"modules/kgfoundry_common.opentelemetry_types/#kgfoundry_common.opentelemetry_types.load_trace_runtime--returns","title":"Returns","text":"<p>TraceRuntime     Trace runtime handles with API, status factory, and status codes.</p> Source code in <code>src/kgfoundry_common/opentelemetry_types.py</code> <pre><code>def load_trace_runtime() -&gt; TraceRuntime:\n    \"\"\"Return the OpenTelemetry trace runtime handles if available.\n\n    Returns\n    -------\n    TraceRuntime\n        Trace runtime handles with API, status factory, and status codes.\n    \"\"\"\n    try:\n        trace_module = import_module(\"opentelemetry.trace\")\n    except ImportError:\n        return TraceRuntime(api=None, status_factory=None, status_codes=None)\n\n    api = cast(\"TraceAPIProtocol\", trace_module)\n    status_factory = _safe_getattr(trace_module, \"Status\")\n    status_codes = _safe_getattr(trace_module, \"StatusCode\")\n    return TraceRuntime(\n        api=api,\n        status_factory=cast(\"StatusFactory | None\", status_factory),\n        status_codes=cast(\"StatusCodeProtocol | None\", status_codes),\n    )\n</code></pre>"},{"location":"modules/kgfoundry_common.opentelemetry_types/#kgfoundry_commonopentelemetry_typesload_tracer_provider_cls","title":"kgfoundry_common.opentelemetry_types.load_tracer_provider_cls","text":""},{"location":"modules/kgfoundry_common.opentelemetry_types/#kgfoundry_common.opentelemetry_types.load_tracer_provider_cls","title":"<code>kgfoundry_common.opentelemetry_types.load_tracer_provider_cls()</code>","text":"<p>Return a factory for the OpenTelemetry <code>TracerProvider</code> if present.</p>"},{"location":"modules/kgfoundry_common.opentelemetry_types/#kgfoundry_common.opentelemetry_types.load_tracer_provider_cls--returns","title":"Returns","text":"<p>Callable[[], TracerProviderProtocol] | None     Factory function for creating TracerProvider instances, or None if not available.</p> Source code in <code>src/kgfoundry_common/opentelemetry_types.py</code> <pre><code>def load_tracer_provider_cls() -&gt; Callable[[], TracerProviderProtocol] | None:\n    \"\"\"Return a factory for the OpenTelemetry ``TracerProvider`` if present.\n\n    Returns\n    -------\n    Callable[[], TracerProviderProtocol] | None\n        Factory function for creating TracerProvider instances, or None if not available.\n    \"\"\"\n    try:\n        sdk_trace_module = import_module(\"opentelemetry.sdk.trace\")\n    except ImportError:\n        return None\n\n    provider_raw = _safe_getattr(sdk_trace_module, \"TracerProvider\")\n    if provider_raw is None or not callable(provider_raw):\n        return None\n    provider_factory = cast(\"Callable[[], object]\", provider_raw)\n\n    def factory() -&gt; TracerProviderProtocol:\n        \"\"\"Create and return a TracerProvider instance.\n\n        Returns\n        -------\n        TracerProviderProtocol\n            TracerProvider instance conforming to protocol.\n        \"\"\"\n        provider = provider_factory()\n        return cast(\"TracerProviderProtocol\", provider)\n\n    return factory\n</code></pre>"},{"location":"modules/kgfoundry_common.pydantic/","title":"kgfoundry_common.pydantic","text":""},{"location":"modules/kgfoundry_common.pydantic/#kgfoundry_commonpydantic","title":"kgfoundry_common.pydantic","text":"<p>Compatibility helpers for Pydantic adapters used in kgfoundry.</p>"},{"location":"modules/kgfoundry_common.pydantic/#relationships","title":"Relationships","text":"<p>Imports: future.annotations, pydantic.BaseModel, typing.ClassVar, typing.Self, typing.TYPE_CHECKING</p>"},{"location":"modules/kgfoundry_common.pydantic/#contents","title":"Contents","text":""},{"location":"modules/kgfoundry_common.pydantic/#kgfoundry_commonpydanticbasemodel","title":"kgfoundry_common.pydantic.BaseModel","text":""},{"location":"modules/kgfoundry_common.pydantic/#kgfoundry_common.pydantic.BaseModel","title":"<code>kgfoundry_common.pydantic.BaseModel</code>","text":"<p>Typing-friendly stub that mirrors Pydantic's <code>BaseModel</code>.</p>"},{"location":"modules/kgfoundry_common.pydantic/#kgfoundry_common.pydantic.BaseModel--parameters","title":"Parameters","text":"<p>**data : Any     Keyword arguments accepted by the Pydantic model.</p> Source code in <code>src/kgfoundry_common/pydantic.py</code> <pre><code>class BaseModel:\n    \"\"\"Typing-friendly stub that mirrors Pydantic's ``BaseModel``.\n\n    Parameters\n    ----------\n    **data : Any\n        Keyword arguments accepted by the Pydantic model.\n    \"\"\"\n\n    model_config: ClassVar[object]\n\n    def __init__(self, **data: object) -&gt; None:\n        \"\"\"Populate the model from keyword arguments.\n\n        Parameters\n        ----------\n        **data : Any\n            Keyword arguments forwarded to the underlying Pydantic model\n            constructor.\n        \"\"\"\n        raise NotImplementedError\n\n    @classmethod\n    def model_validate(cls, obj: object, /) -&gt; Self:\n        \"\"\"Validate ``obj`` using the underlying Pydantic implementation.\n\n        Parameters\n        ----------\n        obj : Any\n            Instance or mapping to validate.\n        strict : bool | None, optional\n            Whether to forbid coercion during validation.\n            Defaults to ``None`` (defer to Pydantic).\n        extra : ExtraValues | None, optional\n            Strategy for handling extra keys.\n            Defaults to ``None`` (use model configuration).\n        from_attributes : bool | None, optional\n            Allow attribute-based population when ``obj`` is not a mapping.\n            Defaults to ``None`` (follow model configuration).\n        context : Any | None, optional\n            Context data available to validators.\n            Defaults to ``None``.\n        by_alias : bool | None, optional\n            Interpret alias names when reading ``obj``.\n            Defaults to ``None`` (inherit from configuration).\n        by_name : bool | None, optional\n            Permit field-name based population alongside aliases.\n            Defaults to ``None``.\n        \"\"\"\n        raise NotImplementedError\n\n    def model_dump(self, **model_dump_kwargs: object) -&gt; dict[str, object]:\n        \"\"\"Return the dictionary representation produced by Pydantic.\n\n        Parameters\n        ----------\n        **model_dump_kwargs : dict[str, object]\n            Keyword arguments forwarded to :meth:`pydantic.BaseModel.model_dump`.\n        \"\"\"\n        del self, model_dump_kwargs\n        raise NotImplementedError\n\n    def model_dump_json(self, **model_dump_json_kwargs: object) -&gt; str:\n        \"\"\"Return the JSON representation produced by Pydantic.\n\n        Parameters\n        ----------\n        **model_dump_json_kwargs : dict[str, object]\n            Keyword arguments forwarded to :meth:`pydantic.BaseModel.model_dump_json`.\n        \"\"\"\n        del self, model_dump_json_kwargs\n        raise NotImplementedError\n</code></pre>"},{"location":"modules/kgfoundry_common.pydantic/#kgfoundry_common.pydantic.BaseModel.__init__","title":"<code>__init__(**data)</code>","text":"<p>Populate the model from keyword arguments.</p>"},{"location":"modules/kgfoundry_common.pydantic/#kgfoundry_common.pydantic.BaseModel.__init__--parameters","title":"Parameters","text":"<p>**data : Any     Keyword arguments forwarded to the underlying Pydantic model     constructor.</p> Source code in <code>src/kgfoundry_common/pydantic.py</code> <pre><code>def __init__(self, **data: object) -&gt; None:\n    \"\"\"Populate the model from keyword arguments.\n\n    Parameters\n    ----------\n    **data : Any\n        Keyword arguments forwarded to the underlying Pydantic model\n        constructor.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"modules/kgfoundry_common.pydantic/#kgfoundry_common.pydantic.BaseModel.model_dump","title":"<code>model_dump(**model_dump_kwargs)</code>","text":"<p>Return the dictionary representation produced by Pydantic.</p>"},{"location":"modules/kgfoundry_common.pydantic/#kgfoundry_common.pydantic.BaseModel.model_dump--parameters","title":"Parameters","text":"<p>**model_dump_kwargs : dict[str, object]     Keyword arguments forwarded to :meth:<code>pydantic.BaseModel.model_dump</code>.</p> Source code in <code>src/kgfoundry_common/pydantic.py</code> <pre><code>def model_dump(self, **model_dump_kwargs: object) -&gt; dict[str, object]:\n    \"\"\"Return the dictionary representation produced by Pydantic.\n\n    Parameters\n    ----------\n    **model_dump_kwargs : dict[str, object]\n        Keyword arguments forwarded to :meth:`pydantic.BaseModel.model_dump`.\n    \"\"\"\n    del self, model_dump_kwargs\n    raise NotImplementedError\n</code></pre>"},{"location":"modules/kgfoundry_common.pydantic/#kgfoundry_common.pydantic.BaseModel.model_dump_json","title":"<code>model_dump_json(**model_dump_json_kwargs)</code>","text":"<p>Return the JSON representation produced by Pydantic.</p>"},{"location":"modules/kgfoundry_common.pydantic/#kgfoundry_common.pydantic.BaseModel.model_dump_json--parameters","title":"Parameters","text":"<p>**model_dump_json_kwargs : dict[str, object]     Keyword arguments forwarded to :meth:<code>pydantic.BaseModel.model_dump_json</code>.</p> Source code in <code>src/kgfoundry_common/pydantic.py</code> <pre><code>def model_dump_json(self, **model_dump_json_kwargs: object) -&gt; str:\n    \"\"\"Return the JSON representation produced by Pydantic.\n\n    Parameters\n    ----------\n    **model_dump_json_kwargs : dict[str, object]\n        Keyword arguments forwarded to :meth:`pydantic.BaseModel.model_dump_json`.\n    \"\"\"\n    del self, model_dump_json_kwargs\n    raise NotImplementedError\n</code></pre>"},{"location":"modules/kgfoundry_common.pydantic/#kgfoundry_common.pydantic.BaseModel.model_validate","title":"<code>model_validate(obj)</code>  <code>classmethod</code>","text":"<p>Validate <code>obj</code> using the underlying Pydantic implementation.</p>"},{"location":"modules/kgfoundry_common.pydantic/#kgfoundry_common.pydantic.BaseModel.model_validate--parameters","title":"Parameters","text":"<p>obj : Any     Instance or mapping to validate. strict : bool | None, optional     Whether to forbid coercion during validation.     Defaults to <code>None</code> (defer to Pydantic). extra : ExtraValues | None, optional     Strategy for handling extra keys.     Defaults to <code>None</code> (use model configuration). from_attributes : bool | None, optional     Allow attribute-based population when <code>obj</code> is not a mapping.     Defaults to <code>None</code> (follow model configuration). context : Any | None, optional     Context data available to validators.     Defaults to <code>None</code>. by_alias : bool | None, optional     Interpret alias names when reading <code>obj</code>.     Defaults to <code>None</code> (inherit from configuration). by_name : bool | None, optional     Permit field-name based population alongside aliases.     Defaults to <code>None</code>.</p> Source code in <code>src/kgfoundry_common/pydantic.py</code> <pre><code>@classmethod\ndef model_validate(cls, obj: object, /) -&gt; Self:\n    \"\"\"Validate ``obj`` using the underlying Pydantic implementation.\n\n    Parameters\n    ----------\n    obj : Any\n        Instance or mapping to validate.\n    strict : bool | None, optional\n        Whether to forbid coercion during validation.\n        Defaults to ``None`` (defer to Pydantic).\n    extra : ExtraValues | None, optional\n        Strategy for handling extra keys.\n        Defaults to ``None`` (use model configuration).\n    from_attributes : bool | None, optional\n        Allow attribute-based population when ``obj`` is not a mapping.\n        Defaults to ``None`` (follow model configuration).\n    context : Any | None, optional\n        Context data available to validators.\n        Defaults to ``None``.\n    by_alias : bool | None, optional\n        Interpret alias names when reading ``obj``.\n        Defaults to ``None`` (inherit from configuration).\n    by_name : bool | None, optional\n        Permit field-name based population alongside aliases.\n        Defaults to ``None``.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"modules/kgfoundry_common.schema_helpers/","title":"kgfoundry_common.schema_helpers","text":""},{"location":"modules/kgfoundry_common.schema_helpers/#kgfoundry_commonschema_helpers","title":"kgfoundry_common.schema_helpers","text":"<p>Schema and model round-trip validation helpers.</p>"},{"location":"modules/kgfoundry_common.schema_helpers/#relationships","title":"Relationships","text":"<p>Imports: future.annotations, json, kgfoundry_common.errors.DeserializationError, kgfoundry_common.errors.SerializationError, kgfoundry_common.fs.read_text, kgfoundry_common.jsonschema_utils.Draft202012Validator, kgfoundry_common.jsonschema_utils.SchemaError, kgfoundry_common.jsonschema_utils.ValidationError, kgfoundry_common.jsonschema_utils.validate, kgfoundry_common.logging.get_logger, kgfoundry_common.problem_details.JsonValue, kgfoundry_common.pydantic.BaseModel, pathlib.Path, typing.TYPE_CHECKING, typing.cast</p>"},{"location":"modules/kgfoundry_common.schema_helpers/#contents","title":"Contents","text":""},{"location":"modules/kgfoundry_common.schema_helpers/#kgfoundry_commonschema_helpersassert_model_roundtrip","title":"kgfoundry_common.schema_helpers.assert_model_roundtrip","text":""},{"location":"modules/kgfoundry_common.schema_helpers/#kgfoundry_common.schema_helpers.assert_model_roundtrip","title":"<code>kgfoundry_common.schema_helpers.assert_model_roundtrip(model_cls, example_path, *, schema_path=None)</code>","text":"<p>Assert that a Pydantic model round-trips correctly with an example JSON file.</p> <p>This function performs a complete round-trip validation: 1. Loads the example JSON file 2. Validates it against the schema (if provided) 3. Deserializes it into a model instance 4. Re-serializes the model instance 5. Validates the re-serialized data matches the schema 6. Compares the round-trip data structure (allowing for type coercion)</p>"},{"location":"modules/kgfoundry_common.schema_helpers/#kgfoundry_common.schema_helpers.assert_model_roundtrip--parameters","title":"Parameters","text":"<p>model_cls : type[BaseModel]     Pydantic model class to test. example_path : Path     Path to example JSON file. schema_path : Path | None, optional     Path to JSON Schema file. If None, schema validation is skipped.     Defaults to None.</p>"},{"location":"modules/kgfoundry_common.schema_helpers/#kgfoundry_common.schema_helpers.assert_model_roundtrip--raises","title":"Raises","text":"<p>FileNotFoundError     If example or schema file does not exist. DeserializationError     If example JSON is invalid or fails schema validation. SerializationError     If model instance fails schema validation after round-trip.</p>"},{"location":"modules/kgfoundry_common.schema_helpers/#kgfoundry_common.schema_helpers.assert_model_roundtrip--examples","title":"Examples","text":"<p>from pathlib import Path from kgfoundry_common.models import Doc example = Path(\"schema/examples/models/doc.v1.json\") schema = Path(\"schema/models/doc.v1.json\") assert_model_roundtrip(Doc, example, schema_path=schema)</p> Source code in <code>src/kgfoundry_common/schema_helpers.py</code> <pre><code>def assert_model_roundtrip(\n    model_cls: type[BaseModel],\n    example_path: Path,\n    *,\n    schema_path: Path | None = None,\n) -&gt; None:\n    \"\"\"Assert that a Pydantic model round-trips correctly with an example JSON file.\n\n    This function performs a complete round-trip validation:\n    1. Loads the example JSON file\n    2. Validates it against the schema (if provided)\n    3. Deserializes it into a model instance\n    4. Re-serializes the model instance\n    5. Validates the re-serialized data matches the schema\n    6. Compares the round-trip data structure (allowing for type coercion)\n\n    Parameters\n    ----------\n    model_cls : type[BaseModel]\n        Pydantic model class to test.\n    example_path : Path\n        Path to example JSON file.\n    schema_path : Path | None, optional\n        Path to JSON Schema file. If None, schema validation is skipped.\n        Defaults to None.\n\n    Raises\n    ------\n    FileNotFoundError\n        If example or schema file does not exist.\n    DeserializationError\n        If example JSON is invalid or fails schema validation.\n    SerializationError\n        If model instance fails schema validation after round-trip.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from pathlib import Path\n    &gt;&gt;&gt; from kgfoundry_common.models import Doc\n    &gt;&gt;&gt; example = Path(\"schema/examples/models/doc.v1.json\")\n    &gt;&gt;&gt; schema = Path(\"schema/models/doc.v1.json\")\n    &gt;&gt;&gt; assert_model_roundtrip(Doc, example, schema_path=schema)\n    \"\"\"\n    if not example_path.exists():\n        msg = f\"Example file not found: {example_path}\"\n        raise FileNotFoundError(msg)\n\n    # Load example JSON\n    try:\n        example_text = read_text(example_path)\n        example_data: dict[str, JsonValue] = json.loads(example_text)\n    except json.JSONDecodeError as exc:\n        msg = f\"Invalid JSON in example file {example_path}: {exc}\"\n        raise DeserializationError(msg) from exc\n\n    # Load and validate schema if provided\n    schema_obj: dict[str, JsonValue] | None = None\n    if schema_path is not None:\n        schema_obj = load_schema(schema_path)\n        # Validate example against schema\n        try:\n            jsonschema_validate(instance=example_data, schema=schema_obj)\n        except ValidationError as exc:\n            msg = f\"Example JSON does not match schema: {exc}\"\n            raise DeserializationError(msg) from exc\n\n    # Deserialize example into model instance\n    try:\n        instance = model_cls.model_validate(example_data)\n    except Exception as exc:\n        msg = f\"Failed to deserialize example into {model_cls.__name__}: {exc}\"\n        raise DeserializationError(msg) from exc\n\n    # Re-serialize model instance (validates serialization works)\n    try:\n        _round_trip_data = instance.model_dump(mode=\"json\")\n    except Exception as exc:\n        msg = f\"Failed to serialize {model_cls.__name__} instance: {exc}\"\n        raise SerializationError(msg) from exc\n\n    # Validate round-trip data against schema if provided\n    if schema_obj is not None:\n        validate_model_against_schema(instance, schema_obj)\n\n    logger.debug(\n        \"Model round-trip validated\",\n        extra={\n            \"model\": model_cls.__name__,\n            \"example_path\": str(example_path),\n            \"schema_path\": str(schema_path) if schema_path else None,\n        },\n    )\n</code></pre>"},{"location":"modules/kgfoundry_common.schema_helpers/#kgfoundry_commonschema_helpersload_schema","title":"kgfoundry_common.schema_helpers.load_schema","text":""},{"location":"modules/kgfoundry_common.schema_helpers/#kgfoundry_common.schema_helpers.load_schema","title":"<code>kgfoundry_common.schema_helpers.load_schema(schema_path)</code>","text":"<p>Load and parse a JSON Schema file.</p> <p>Loads a JSON Schema 2020-12 file from disk, parses it, and validates it against the JSON Schema 2020-12 meta-schema.</p>"},{"location":"modules/kgfoundry_common.schema_helpers/#kgfoundry_common.schema_helpers.load_schema--parameters","title":"Parameters","text":"<p>schema_path : Path     Path to JSON Schema 2020-12 file.</p>"},{"location":"modules/kgfoundry_common.schema_helpers/#kgfoundry_common.schema_helpers.load_schema--returns","title":"Returns","text":"<p>dict[str, JsonValue]     Parsed schema dictionary.</p>"},{"location":"modules/kgfoundry_common.schema_helpers/#kgfoundry_common.schema_helpers.load_schema--raises","title":"Raises","text":"<p>FileNotFoundError     If schema file does not exist. DeserializationError     If schema is invalid JSON or fails validation.</p>"},{"location":"modules/kgfoundry_common.schema_helpers/#kgfoundry_common.schema_helpers.load_schema--examples","title":"Examples","text":"<p>from pathlib import Path schema = load_schema(Path(\"schema/models/doc.v1.json\")) assert \"$schema\" in schema</p> Source code in <code>src/kgfoundry_common/schema_helpers.py</code> <pre><code>def load_schema(schema_path: Path) -&gt; dict[str, JsonValue]:\n    \"\"\"Load and parse a JSON Schema file.\n\n    Loads a JSON Schema 2020-12 file from disk, parses it, and validates\n    it against the JSON Schema 2020-12 meta-schema.\n\n    Parameters\n    ----------\n    schema_path : Path\n        Path to JSON Schema 2020-12 file.\n\n    Returns\n    -------\n    dict[str, JsonValue]\n        Parsed schema dictionary.\n\n    Raises\n    ------\n    FileNotFoundError\n        If schema file does not exist.\n    DeserializationError\n        If schema is invalid JSON or fails validation.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from pathlib import Path\n    &gt;&gt;&gt; schema = load_schema(Path(\"schema/models/doc.v1.json\"))\n    &gt;&gt;&gt; assert \"$schema\" in schema\n    \"\"\"\n    if not schema_path.exists():\n        msg = f\"Schema file not found: {schema_path}\"\n        raise FileNotFoundError(msg)\n\n    try:\n        schema_text = read_text(schema_path)\n        schema_obj: dict[str, JsonValue] = json.loads(schema_text)\n    except json.JSONDecodeError as exc:\n        msg = f\"Invalid JSON in schema file {schema_path}: {exc}\"\n        raise DeserializationError(msg) from exc\n\n    # Validate against JSON Schema 2020-12 meta-schema\n    try:\n        Draft202012Validator.check_schema(schema_obj)\n    except SchemaError as exc:\n        msg = f\"Invalid JSON Schema 2020-12 in {schema_path}: {exc}\"\n        raise DeserializationError(msg) from exc\n\n    return schema_obj\n</code></pre>"},{"location":"modules/kgfoundry_common.schema_helpers/#kgfoundry_commonschema_helpersvalidate_model_against_schema","title":"kgfoundry_common.schema_helpers.validate_model_against_schema","text":""},{"location":"modules/kgfoundry_common.schema_helpers/#kgfoundry_common.schema_helpers.validate_model_against_schema","title":"<code>kgfoundry_common.schema_helpers.validate_model_against_schema(model_instance, schema)</code>","text":"<p>Validate a Pydantic model instance against a JSON Schema.</p> <p>Converts the model instance to a dictionary and validates it against the provided JSON Schema 2020-12.</p>"},{"location":"modules/kgfoundry_common.schema_helpers/#kgfoundry_common.schema_helpers.validate_model_against_schema--parameters","title":"Parameters","text":"<p>model_instance : BaseModel     Pydantic model instance to validate. schema : dict[str, JsonValue]     JSON Schema 2020-12 dictionary.</p>"},{"location":"modules/kgfoundry_common.schema_helpers/#kgfoundry_common.schema_helpers.validate_model_against_schema--raises","title":"Raises","text":"<p>SerializationError     If validation fails or schema is invalid.</p>"},{"location":"modules/kgfoundry_common.schema_helpers/#kgfoundry_common.schema_helpers.validate_model_against_schema--examples","title":"Examples","text":"<p>from kgfoundry_common.models import Doc schema = {\"type\": \"object\", \"properties\": {\"id\": {\"type\": \"string\"}}} doc = Doc(id=\"urn:doc:test\") validate_model_against_schema(doc, schema)</p> Source code in <code>src/kgfoundry_common/schema_helpers.py</code> <pre><code>def validate_model_against_schema(\n    model_instance: BaseModel,\n    schema: dict[str, JsonValue],\n) -&gt; None:\n    \"\"\"Validate a Pydantic model instance against a JSON Schema.\n\n    Converts the model instance to a dictionary and validates it against\n    the provided JSON Schema 2020-12.\n\n    Parameters\n    ----------\n    model_instance : BaseModel\n        Pydantic model instance to validate.\n    schema : dict[str, JsonValue]\n        JSON Schema 2020-12 dictionary.\n\n    Raises\n    ------\n    SerializationError\n        If validation fails or schema is invalid.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from kgfoundry_common.models import Doc\n    &gt;&gt;&gt; schema = {\"type\": \"object\", \"properties\": {\"id\": {\"type\": \"string\"}}}\n    &gt;&gt;&gt; doc = Doc(id=\"urn:doc:test\")\n    &gt;&gt;&gt; validate_model_against_schema(doc, schema)\n    \"\"\"\n    try:\n        # Convert model to dict (using model_dump with mode='json' for JSON-compatible types)\n        # model_dump returns dict[str, object], cast to JsonValue since it's JSON-serializable\n        data: dict[str, JsonValue] = cast(\n            \"dict[str, JsonValue]\", model_instance.model_dump(mode=\"json\")\n        )\n        jsonschema_validate(instance=data, schema=schema)\n    except ValidationError as exc:\n        msg = f\"Model instance does not match schema: {exc}\"\n        raise SerializationError(msg) from exc\n    except SchemaError as exc:\n        msg = f\"Invalid schema: {exc}\"\n        raise SerializationError(msg) from exc\n</code></pre>"},{"location":"modules/kgfoundry_common.types/","title":"kgfoundry_common.types","text":""},{"location":"modules/kgfoundry_common.types/#kgfoundry_commontypes","title":"kgfoundry_common.types","text":"<p>Type aliases for kgfoundry_common.</p>"},{"location":"modules/kgfoundry_common.types/#relationships","title":"Relationships","text":"<p>Imports: future.annotations</p>"}]}