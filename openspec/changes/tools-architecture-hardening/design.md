## Context

Prior hardening phases resolved surface lint errors but left structural issues: tooling packages still rely on namespace bridges, public APIs are implicit, subprocess orchestration lacks correlation-aware telemetry, and many modules mix CLI parsing with domain logic. Ruff continues to flag architectural smells (private cross-package imports, excessive complexity, deprecated typing aliases), while pyrefly fails on missing modules because exports are not deterministic. Without a deeper architectural pass, typed automation and layering guarantees remain fragile.

## Goals

- Publish curated, documented public APIs with exports that match runtime and stubbed symbols.
- Enforce layered separation between domain logic, orchestrators, adapters, and CLI entry points via import-linter.
- Harden subprocess execution to propagate correlation IDs, enforce retries, and emit structured telemetry.
- Replace dictionary payloads with typed models capable of emitting and validating JSON Schemas while supporting legacy conversions.
- Reduce cyclomatic complexity by decomposing oversized functions into composable, dependency-injected strategies.

## Non-Goals

- Altering observable CLI behaviour beyond structured metadata enhancements.
- Introducing new documentation suites or test frameworks; verification relies on existing Ruff, pyrefly, and mypy gates.
- Replacing established third-party libraries (msgspec, Prometheus, OpenTelemetry).
- Modifying external services (agent catalog, search APIs) except to adopt new facades.

## Decisions

1. **Explicit package surfaces:** Build each package’s `__all__` from a `PUBLIC_EXPORTS` mapping and sync it with `stubs/tools/**`, ensuring pyrefly and mypy share a consistent public API.
2. **Controlled namespace bridging:** Limit legacy imports to wrappers provided by `kgfoundry/_namespace_proxy`, eliminating direct references to private names.
3. **Layered module layout:** Split monolithic modules into `domain`, `orchestrator`, `io`, and `cli` layers and enforce the dependency direction with import-linter contracts generated by `tools/make_importlinter.py`.
4. **Context-aware subprocess orchestration:** Centralise subprocess handling in `tools._shared.proc`, injecting operation IDs via `ContextVar`, standardising `raise ... from e`, and exposing retry helpers for idempotent flows.
5. **Typed payload models:** Represent docstring edits, navmap documents, analytics payloads, and CLI envelopes using msgspec or frozen dataclasses, with schema emission/validation managed by `tools._shared.schema`.
6. **Complexity budgets:** Decompose high-complexity functions into focused helpers backed by dependency injection and strategy objects.

## Detailed Plan

### Phase 0 — Package hygiene
**Objectives:** promote `tools` to a first-class distribution surface, eliminate private namespace bridging, and document public exports.

#### P0.1 Promote `tools` as an installable extra
- Amend `pyproject.toml`:
  - Add `[project.optional-dependencies.tools]` listing runtime-only requirements for tooling (Prometheus, OpenTelemetry extras, msgspec, yaml, etc.).
  - Extend `tool.hatch.build.targets.wheel.packages` (or add if absent) so the `tools` package and its subpackages are shipped with the wheel; include a `tool.hatch.build.targets.wheel.force-include` entry for `tools/py.typed` to advertise typing support.
  - Ensure `tool.hatch.build.targets.sdist.include` mirrors the wheel selection so source tarballs include tooling assets (plugins, templates, schema files).
- Drop ad-hoc `sys.path` manipulation: confirm no scripts append the repository root; rely on the packaging metadata for resolution.
- Provide a `tools/py.typed` marker if not already present so tooling remains type-visible when installed via the optional extra.

#### P0.2 Tighten public exports
- Review `tools/__init__.py`, `tools/docs/__init__.py`, and other package initialisers:
  - Use a single `PUBLIC_EXPORTS` mapping per module to define the exposed API, limiting runtime imports to the orchestrator/adapter pairs we intend to support.
  - Annotate re-exported callables and classes with precise types (e.g., `Callable[[DocstringBuildRequest], DocstringBuildResult]`) and update docstrings to follow the NumPy style, referencing the shared exception taxonomy and Problem Details sample.
- Synchronise `stubs/tools/__init__.pyi` (and `stubs/tools/docs/__init__.pyi`) with the curated export sets; remove unused imports, add explicit `ModuleType` annotations for lazily-loaded modules, and keep `__all__` sorted.
- Add module-level summaries for each `__init__` describing stability guarantees and pointing to RFC 9457 payload examples under `schema/examples/tools/problem_details/`.

#### P0.3 Replace private namespace bridging
- Create a public adapter module, e.g., `src/kgfoundry/tooling_bridge.py`, that wraps helpers from `kgfoundry._namespace_proxy` with exported functions (`attach_namespace`, `list_namespace`, etc.).
- Update `src/kgfoundry/namespace_bridge.py`, `src/kgfoundry/search_client/client.py`, and `src/kgfoundry/vectorstore_faiss/__init__.py` to depend on the new public adapter instead of importing `_namespace_proxy` directly; adjust their docstrings to state the compatibility contract.
- Refine `kgfoundry/_namespace_proxy.py`:
  - Document each helper with NumPy-style docstrings and tighten parameter/return typing (e.g., `Iterable[str]` → `Sequence[str]`).
  - Restrict `__all__` to private use and mark the module internal in the docstring.
- Add regression checks in `pyrefly` and Ruff (`PLC2701`) to confirm no remaining imports reference `_namespace_proxy` outside the new adapter module.

#### P0.4 Validate packaging
- Add a packaging smoke test target (make recipe or script) that runs:
  1. `uv run python -m build --wheel` to produce artifacts.
  2. `uv run python -m pip install dist/kgfoundry-*.whl[tools] --force-reinstall` inside a clean virtualenv.
  3. `python -c "import tools; tools.run_tool(['python','--version'])"` to ensure exports load without path hacks.
- Document the verification steps in the PR checklist for Phase 0 and require the optional extra to succeed in CI packaging jobs.

### Phase 1 — Static checker guardrails
**Objectives:** institutionalise lint/type guardrails for tooling modules and provide helpers that make Ruff/pyrefly compliance frictionless.

#### P1.1 Shared lint defaults module
- Create `tools/_shared/linting.py` (or similar) exposing:
  - `enforce_union_order()` or a decorator that normalises `typing.Optional`/`| None` ordering to satisfy `RUF036` when constructing annotations programmatically.
  - Constants/utilities flagging deprecated typing aliases (`typing.Dict`, `typing.List`, `TypeAlias`, etc.) so modules can import guardrails rather than re-implementing checks.
  - Decorators `as_staticmethod` / `as_classmethod` that wrap plain functions to emulate the semantics Ruff expects when auto-converting low-cohesion instance methods, keeping call sites explicit.
- Update modules frequently triggering `PLR6301` (docstring builder orchestrator, metrics helpers, navmap utilities) to use these decorators or refactor to module-level functions via the helper API.
- Add NumPy-style docstrings and full typing to the new module, and reference it from `tools/__init__` if the helpers should be public.

#### P1.2 Ruff configuration & rule enforcement
- Adjust `pyproject.toml` `[tool.ruff.lint]` or `per-file-ignores`:
  - Remove ad-hoc ignores once the new helper module is in place.
  - If necessary, add a `flake8-tidy-imports` forbiddance or custom plugin to detect stray `_namespace_proxy` imports as part of linting (complementing Phase 0).
- Add targeted Ruff configuration (e.g., `unfixable = []`) if certain rules need to auto-fix with the new decorators; document any rule adjustments in `openspec/AGENTS.md`.

#### P1.3 Pre-commit and developer workflow
- Update `.pre-commit-config.yaml`:
  - Ensure `ruff-format` and `ruff` run sequentially with `--fix` across `tools/**` (they already run repo-wide; confirm no excludes prevent tooling modules).
  - Add/confirm a `pyrefly-check` hook limited to `tools/**` to shorten feedback loops when editing tooling.
  - Optionally add a wrapper hook that imports the new lint defaults module and runs a quick smoke script to ensure decorators behave as expected (e.g., `python -m tools._shared.linting --self-test`).
- Extend local tooling scripts (`tools/hooks/docformatter.py`, `tools/check_imports.py`) to reference the shared lint defaults where applicable.

#### P1.4 Documentation & guidance
- Update `openspec/AGENTS.md` (or a focused section in `docs/contributing/quality.md`) describing:
  - The expectation to run `uv run ruff format && uv run ruff check --fix && uv run pyrefly check` before submitting tooling changes.
  - How to use the new helper decorators/utilities to satisfy lint recommendations without sacrificing readability.
  - The location of the new lint defaults module and examples of migrating away from deprecated typing aliases.
- Capture the pre-commit changes and lint workflow in the PR template’s “Test Plan” guidance for tooling-related work.

### Phase 2 — Module boundaries
- Split `tools/docstring_builder/cli.py` and analogous docs builders into CLI shells, orchestrators, and IO helpers; annotate all public entry points with PEP 257 docstrings referencing exception taxonomy and Problem Details examples.
- Re-export orchestrator entry points through package initialisers to keep CLI adapters thin and testable.

### Phase 3 — Reliability & context propagation
- Add `tools._shared.context` with a `ContextVar[str]` for operation IDs and helper context managers.
- Update `tools._shared.proc.run_tool` to log structured metadata, enforce `raise ... from e`, and accept optional streaming callbacks.
- Introduce `run_tool_with_retry` for idempotent operations and promote `tools._shared.settings` to namespaced `BaseSettings` derivatives that validate configuration eagerly.

### Phase 4 — Modularity & complexity reduction
- Decompose BM25/FAISS adapters, agent catalog search, and navmap builders into strategy modules with injected dependencies, reducing Ruff `C901`/`PLR091x` violations.
- Regenerate import-linter contracts to encode the dependency direction (`domain -> orchestrator -> adapters -> cli`) and add a CI-invoked `--check` mode.

### Phase 5 — Data contracts & validation
- Define typed models for docstring edits, navmap documents, analytics envelopes, and CLI payloads; remove `dict[str, Any]` from public APIs.
- Implement legacy conversion helpers and mandate validation via `tools._shared.schema.validate_struct_payload` before processing inputs.
- Provide `render_schema` and `write_schema` helpers plus Problem Details builders that attach correlation metadata and retry hints consistently.

## Risks & Mitigations

- **Breaking downstream tooling:** Mitigated by sequencing phases, running Ruff/pyrefly/mypy after each tranche, and keeping shim facades until consumers migrate.
- **Import-linter false positives:** Mitigated by delivering transitional wrappers and adjusting contracts only after bridges adopt public APIs.
- **Incomplete context propagation:** Mitigated by wrapping every orchestrator entry point with context managers and defaulting `run_tool` to generate new IDs when absent.
- **Legacy payload drift:** Mitigated by adding conversion helpers that fail closed with Problem Details when encountering unknown schema versions.

## Migration

1. Complete Phase 0 to stabilise exports and stubs.
2. Enable guardrails in Phase 1 and confirm pre-commit parity.
3. Restructure modules per Phase 2 and regenerate import-linter contracts.
4. Apply reliability and settings improvements in Phase 3.
5. Execute complexity reductions and enforce contracts in Phase 4.
6. Replace payloads and integrate schema helpers in Phase 5.
7. After each phase, run `uv run ruff check --fix`, `uv run pyrefly check`, `uv run mypy --config-file mypy.ini`, and once contracts exist, run `python tools/make_importlinter.py --check`.

